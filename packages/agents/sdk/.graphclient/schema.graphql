schema {
  query: Query
  subscription: Subscription
}

type Query {
  mumbai_systemInfo(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mumbai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mumbai_SystemInfo
  mumbai_systemInfos(
    skip: Int = 0
    first: Int = 100
    orderBy: mumbai_SystemInfo_orderBy
    orderDirection: mumbai_OrderDirection
    where: mumbai_SystemInfo_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mumbai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mumbai_SystemInfo!]!
  mumbai_pooledToken(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mumbai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mumbai_PooledToken
  mumbai_pooledTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: mumbai_PooledToken_orderBy
    orderDirection: mumbai_OrderDirection
    where: mumbai_PooledToken_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mumbai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mumbai_PooledToken!]!
  mumbai_stableSwap(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mumbai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mumbai_StableSwap
  mumbai_stableSwaps(
    skip: Int = 0
    first: Int = 100
    orderBy: mumbai_StableSwap_orderBy
    orderDirection: mumbai_OrderDirection
    where: mumbai_StableSwap_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mumbai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mumbai_StableSwap!]!
  mumbai_stableSwapAddLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mumbai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mumbai_StableSwapAddLiquidityEvent
  mumbai_stableSwapAddLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: mumbai_StableSwapAddLiquidityEvent_orderBy
    orderDirection: mumbai_OrderDirection
    where: mumbai_StableSwapAddLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mumbai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mumbai_StableSwapAddLiquidityEvent!]!
  mumbai_stableSwapRemoveLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mumbai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mumbai_StableSwapRemoveLiquidityEvent
  mumbai_stableSwapRemoveLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: mumbai_StableSwapRemoveLiquidityEvent_orderBy
    orderDirection: mumbai_OrderDirection
    where: mumbai_StableSwapRemoveLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mumbai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mumbai_StableSwapRemoveLiquidityEvent!]!
  mumbai_stableSwapExchange(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mumbai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mumbai_StableSwapExchange
  mumbai_stableSwapExchanges(
    skip: Int = 0
    first: Int = 100
    orderBy: mumbai_StableSwapExchange_orderBy
    orderDirection: mumbai_OrderDirection
    where: mumbai_StableSwapExchange_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mumbai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mumbai_StableSwapExchange!]!
  mumbai_swapDailyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mumbai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mumbai_SwapDailyVolume
  mumbai_swapDailyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: mumbai_SwapDailyVolume_orderBy
    orderDirection: mumbai_OrderDirection
    where: mumbai_SwapDailyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mumbai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mumbai_SwapDailyVolume!]!
  mumbai_swapHourlyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mumbai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mumbai_SwapHourlyVolume
  mumbai_swapHourlyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: mumbai_SwapHourlyVolume_orderBy
    orderDirection: mumbai_OrderDirection
    where: mumbai_SwapHourlyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mumbai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mumbai_SwapHourlyVolume!]!
  mumbai_swapWeeklyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mumbai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mumbai_SwapWeeklyVolume
  mumbai_swapWeeklyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: mumbai_SwapWeeklyVolume_orderBy
    orderDirection: mumbai_OrderDirection
    where: mumbai_SwapWeeklyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mumbai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mumbai_SwapWeeklyVolume!]!
  mumbai_stableSwapEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mumbai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mumbai_StableSwapEvent
  mumbai_stableSwapEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: mumbai_StableSwapEvent_orderBy
    orderDirection: mumbai_OrderDirection
    where: mumbai_StableSwapEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mumbai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mumbai_StableSwapEvent!]!
  mumbai_swapTradeVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mumbai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mumbai_SwapTradeVolume
  mumbai_swapTradeVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: mumbai_SwapTradeVolume_orderBy
    orderDirection: mumbai_OrderDirection
    where: mumbai_SwapTradeVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mumbai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mumbai_SwapTradeVolume!]!
  """Access to subgraph metadata"""
  mumbai__meta(block: mumbai_Block_height): mumbai__Meta_
  xdai_systemInfo(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xdai_SystemInfo
  xdai_systemInfos(
    skip: Int = 0
    first: Int = 100
    orderBy: xdai_SystemInfo_orderBy
    orderDirection: xdai_OrderDirection
    where: xdai_SystemInfo_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xdai_SystemInfo!]!
  xdai_pooledToken(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xdai_PooledToken
  xdai_pooledTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: xdai_PooledToken_orderBy
    orderDirection: xdai_OrderDirection
    where: xdai_PooledToken_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xdai_PooledToken!]!
  xdai_stableSwap(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xdai_StableSwap
  xdai_stableSwaps(
    skip: Int = 0
    first: Int = 100
    orderBy: xdai_StableSwap_orderBy
    orderDirection: xdai_OrderDirection
    where: xdai_StableSwap_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xdai_StableSwap!]!
  xdai_stableSwapAddLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xdai_StableSwapAddLiquidityEvent
  xdai_stableSwapAddLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: xdai_StableSwapAddLiquidityEvent_orderBy
    orderDirection: xdai_OrderDirection
    where: xdai_StableSwapAddLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xdai_StableSwapAddLiquidityEvent!]!
  xdai_stableSwapRemoveLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xdai_StableSwapRemoveLiquidityEvent
  xdai_stableSwapRemoveLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: xdai_StableSwapRemoveLiquidityEvent_orderBy
    orderDirection: xdai_OrderDirection
    where: xdai_StableSwapRemoveLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xdai_StableSwapRemoveLiquidityEvent!]!
  xdai_stableSwapExchange(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xdai_StableSwapExchange
  xdai_stableSwapExchanges(
    skip: Int = 0
    first: Int = 100
    orderBy: xdai_StableSwapExchange_orderBy
    orderDirection: xdai_OrderDirection
    where: xdai_StableSwapExchange_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xdai_StableSwapExchange!]!
  xdai_swapDailyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xdai_SwapDailyVolume
  xdai_swapDailyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: xdai_SwapDailyVolume_orderBy
    orderDirection: xdai_OrderDirection
    where: xdai_SwapDailyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xdai_SwapDailyVolume!]!
  xdai_swapHourlyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xdai_SwapHourlyVolume
  xdai_swapHourlyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: xdai_SwapHourlyVolume_orderBy
    orderDirection: xdai_OrderDirection
    where: xdai_SwapHourlyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xdai_SwapHourlyVolume!]!
  xdai_swapWeeklyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xdai_SwapWeeklyVolume
  xdai_swapWeeklyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: xdai_SwapWeeklyVolume_orderBy
    orderDirection: xdai_OrderDirection
    where: xdai_SwapWeeklyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xdai_SwapWeeklyVolume!]!
  xdai_stableSwapEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xdai_StableSwapEvent
  xdai_stableSwapEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: xdai_StableSwapEvent_orderBy
    orderDirection: xdai_OrderDirection
    where: xdai_StableSwapEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xdai_StableSwapEvent!]!
  xdai_swapTradeVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xdai_SwapTradeVolume
  xdai_swapTradeVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: xdai_SwapTradeVolume_orderBy
    orderDirection: xdai_OrderDirection
    where: xdai_SwapTradeVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xdai_SwapTradeVolume!]!
  """Access to subgraph metadata"""
  xdai__meta(block: xdai_Block_height): xdai__Meta_
  arbitrumone_systemInfo(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): arbitrumone_SystemInfo
  arbitrumone_systemInfos(
    skip: Int = 0
    first: Int = 100
    orderBy: arbitrumone_SystemInfo_orderBy
    orderDirection: arbitrumone_OrderDirection
    where: arbitrumone_SystemInfo_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [arbitrumone_SystemInfo!]!
  arbitrumone_pooledToken(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): arbitrumone_PooledToken
  arbitrumone_pooledTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: arbitrumone_PooledToken_orderBy
    orderDirection: arbitrumone_OrderDirection
    where: arbitrumone_PooledToken_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [arbitrumone_PooledToken!]!
  arbitrumone_stableSwap(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): arbitrumone_StableSwap
  arbitrumone_stableSwaps(
    skip: Int = 0
    first: Int = 100
    orderBy: arbitrumone_StableSwap_orderBy
    orderDirection: arbitrumone_OrderDirection
    where: arbitrumone_StableSwap_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [arbitrumone_StableSwap!]!
  arbitrumone_stableSwapAddLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): arbitrumone_StableSwapAddLiquidityEvent
  arbitrumone_stableSwapAddLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: arbitrumone_StableSwapAddLiquidityEvent_orderBy
    orderDirection: arbitrumone_OrderDirection
    where: arbitrumone_StableSwapAddLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [arbitrumone_StableSwapAddLiquidityEvent!]!
  arbitrumone_stableSwapRemoveLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): arbitrumone_StableSwapRemoveLiquidityEvent
  arbitrumone_stableSwapRemoveLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: arbitrumone_StableSwapRemoveLiquidityEvent_orderBy
    orderDirection: arbitrumone_OrderDirection
    where: arbitrumone_StableSwapRemoveLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [arbitrumone_StableSwapRemoveLiquidityEvent!]!
  arbitrumone_stableSwapExchange(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): arbitrumone_StableSwapExchange
  arbitrumone_stableSwapExchanges(
    skip: Int = 0
    first: Int = 100
    orderBy: arbitrumone_StableSwapExchange_orderBy
    orderDirection: arbitrumone_OrderDirection
    where: arbitrumone_StableSwapExchange_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [arbitrumone_StableSwapExchange!]!
  arbitrumone_swapDailyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): arbitrumone_SwapDailyVolume
  arbitrumone_swapDailyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: arbitrumone_SwapDailyVolume_orderBy
    orderDirection: arbitrumone_OrderDirection
    where: arbitrumone_SwapDailyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [arbitrumone_SwapDailyVolume!]!
  arbitrumone_swapHourlyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): arbitrumone_SwapHourlyVolume
  arbitrumone_swapHourlyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: arbitrumone_SwapHourlyVolume_orderBy
    orderDirection: arbitrumone_OrderDirection
    where: arbitrumone_SwapHourlyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [arbitrumone_SwapHourlyVolume!]!
  arbitrumone_swapWeeklyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): arbitrumone_SwapWeeklyVolume
  arbitrumone_swapWeeklyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: arbitrumone_SwapWeeklyVolume_orderBy
    orderDirection: arbitrumone_OrderDirection
    where: arbitrumone_SwapWeeklyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [arbitrumone_SwapWeeklyVolume!]!
  arbitrumone_stableSwapEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): arbitrumone_StableSwapEvent
  arbitrumone_stableSwapEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: arbitrumone_StableSwapEvent_orderBy
    orderDirection: arbitrumone_OrderDirection
    where: arbitrumone_StableSwapEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [arbitrumone_StableSwapEvent!]!
  arbitrumone_swapTradeVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): arbitrumone_SwapTradeVolume
  arbitrumone_swapTradeVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: arbitrumone_SwapTradeVolume_orderBy
    orderDirection: arbitrumone_OrderDirection
    where: arbitrumone_SwapTradeVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [arbitrumone_SwapTradeVolume!]!
  """Access to subgraph metadata"""
  arbitrumone__meta(block: arbitrumone_Block_height): arbitrumone__Meta_
  bnb_systemInfo(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): bnb_SystemInfo
  bnb_systemInfos(
    skip: Int = 0
    first: Int = 100
    orderBy: bnb_SystemInfo_orderBy
    orderDirection: bnb_OrderDirection
    where: bnb_SystemInfo_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [bnb_SystemInfo!]!
  bnb_pooledToken(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): bnb_PooledToken
  bnb_pooledTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: bnb_PooledToken_orderBy
    orderDirection: bnb_OrderDirection
    where: bnb_PooledToken_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [bnb_PooledToken!]!
  bnb_stableSwap(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): bnb_StableSwap
  bnb_stableSwaps(
    skip: Int = 0
    first: Int = 100
    orderBy: bnb_StableSwap_orderBy
    orderDirection: bnb_OrderDirection
    where: bnb_StableSwap_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [bnb_StableSwap!]!
  bnb_stableSwapAddLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): bnb_StableSwapAddLiquidityEvent
  bnb_stableSwapAddLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: bnb_StableSwapAddLiquidityEvent_orderBy
    orderDirection: bnb_OrderDirection
    where: bnb_StableSwapAddLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [bnb_StableSwapAddLiquidityEvent!]!
  bnb_stableSwapRemoveLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): bnb_StableSwapRemoveLiquidityEvent
  bnb_stableSwapRemoveLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: bnb_StableSwapRemoveLiquidityEvent_orderBy
    orderDirection: bnb_OrderDirection
    where: bnb_StableSwapRemoveLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [bnb_StableSwapRemoveLiquidityEvent!]!
  bnb_stableSwapExchange(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): bnb_StableSwapExchange
  bnb_stableSwapExchanges(
    skip: Int = 0
    first: Int = 100
    orderBy: bnb_StableSwapExchange_orderBy
    orderDirection: bnb_OrderDirection
    where: bnb_StableSwapExchange_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [bnb_StableSwapExchange!]!
  bnb_swapDailyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): bnb_SwapDailyVolume
  bnb_swapDailyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: bnb_SwapDailyVolume_orderBy
    orderDirection: bnb_OrderDirection
    where: bnb_SwapDailyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [bnb_SwapDailyVolume!]!
  bnb_swapHourlyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): bnb_SwapHourlyVolume
  bnb_swapHourlyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: bnb_SwapHourlyVolume_orderBy
    orderDirection: bnb_OrderDirection
    where: bnb_SwapHourlyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [bnb_SwapHourlyVolume!]!
  bnb_swapWeeklyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): bnb_SwapWeeklyVolume
  bnb_swapWeeklyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: bnb_SwapWeeklyVolume_orderBy
    orderDirection: bnb_OrderDirection
    where: bnb_SwapWeeklyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [bnb_SwapWeeklyVolume!]!
  bnb_stableSwapEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): bnb_StableSwapEvent
  bnb_stableSwapEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: bnb_StableSwapEvent_orderBy
    orderDirection: bnb_OrderDirection
    where: bnb_StableSwapEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [bnb_StableSwapEvent!]!
  bnb_swapTradeVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): bnb_SwapTradeVolume
  bnb_swapTradeVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: bnb_SwapTradeVolume_orderBy
    orderDirection: bnb_OrderDirection
    where: bnb_SwapTradeVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [bnb_SwapTradeVolume!]!
  """Access to subgraph metadata"""
  bnb__meta(block: bnb_Block_height): bnb__Meta_
  goerli_systemInfo(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: goerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): goerli_SystemInfo
  goerli_systemInfos(
    skip: Int = 0
    first: Int = 100
    orderBy: goerli_SystemInfo_orderBy
    orderDirection: goerli_OrderDirection
    where: goerli_SystemInfo_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: goerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [goerli_SystemInfo!]!
  goerli_pooledToken(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: goerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): goerli_PooledToken
  goerli_pooledTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: goerli_PooledToken_orderBy
    orderDirection: goerli_OrderDirection
    where: goerli_PooledToken_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: goerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [goerli_PooledToken!]!
  goerli_stableSwap(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: goerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): goerli_StableSwap
  goerli_stableSwaps(
    skip: Int = 0
    first: Int = 100
    orderBy: goerli_StableSwap_orderBy
    orderDirection: goerli_OrderDirection
    where: goerli_StableSwap_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: goerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [goerli_StableSwap!]!
  goerli_stableSwapAddLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: goerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): goerli_StableSwapAddLiquidityEvent
  goerli_stableSwapAddLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: goerli_StableSwapAddLiquidityEvent_orderBy
    orderDirection: goerli_OrderDirection
    where: goerli_StableSwapAddLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: goerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [goerli_StableSwapAddLiquidityEvent!]!
  goerli_stableSwapRemoveLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: goerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): goerli_StableSwapRemoveLiquidityEvent
  goerli_stableSwapRemoveLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: goerli_StableSwapRemoveLiquidityEvent_orderBy
    orderDirection: goerli_OrderDirection
    where: goerli_StableSwapRemoveLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: goerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [goerli_StableSwapRemoveLiquidityEvent!]!
  goerli_stableSwapExchange(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: goerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): goerli_StableSwapExchange
  goerli_stableSwapExchanges(
    skip: Int = 0
    first: Int = 100
    orderBy: goerli_StableSwapExchange_orderBy
    orderDirection: goerli_OrderDirection
    where: goerli_StableSwapExchange_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: goerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [goerli_StableSwapExchange!]!
  goerli_swapDailyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: goerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): goerli_SwapDailyVolume
  goerli_swapDailyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: goerli_SwapDailyVolume_orderBy
    orderDirection: goerli_OrderDirection
    where: goerli_SwapDailyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: goerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [goerli_SwapDailyVolume!]!
  goerli_swapHourlyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: goerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): goerli_SwapHourlyVolume
  goerli_swapHourlyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: goerli_SwapHourlyVolume_orderBy
    orderDirection: goerli_OrderDirection
    where: goerli_SwapHourlyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: goerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [goerli_SwapHourlyVolume!]!
  goerli_swapWeeklyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: goerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): goerli_SwapWeeklyVolume
  goerli_swapWeeklyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: goerli_SwapWeeklyVolume_orderBy
    orderDirection: goerli_OrderDirection
    where: goerli_SwapWeeklyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: goerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [goerli_SwapWeeklyVolume!]!
  goerli_stableSwapEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: goerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): goerli_StableSwapEvent
  goerli_stableSwapEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: goerli_StableSwapEvent_orderBy
    orderDirection: goerli_OrderDirection
    where: goerli_StableSwapEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: goerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [goerli_StableSwapEvent!]!
  goerli_swapTradeVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: goerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): goerli_SwapTradeVolume
  goerli_swapTradeVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: goerli_SwapTradeVolume_orderBy
    orderDirection: goerli_OrderDirection
    where: goerli_SwapTradeVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: goerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [goerli_SwapTradeVolume!]!
  """Access to subgraph metadata"""
  goerli__meta(block: goerli_Block_height): goerli__Meta_
  stagingoptimismgoerli_systemInfo(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingoptimismgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): stagingoptimismgoerli_SystemInfo
  stagingoptimismgoerli_systemInfos(
    skip: Int = 0
    first: Int = 100
    orderBy: stagingoptimismgoerli_SystemInfo_orderBy
    orderDirection: stagingoptimismgoerli_OrderDirection
    where: stagingoptimismgoerli_SystemInfo_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingoptimismgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [stagingoptimismgoerli_SystemInfo!]!
  stagingoptimismgoerli_pooledToken(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingoptimismgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): stagingoptimismgoerli_PooledToken
  stagingoptimismgoerli_pooledTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: stagingoptimismgoerli_PooledToken_orderBy
    orderDirection: stagingoptimismgoerli_OrderDirection
    where: stagingoptimismgoerli_PooledToken_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingoptimismgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [stagingoptimismgoerli_PooledToken!]!
  stagingoptimismgoerli_stableSwap(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingoptimismgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): stagingoptimismgoerli_StableSwap
  stagingoptimismgoerli_stableSwaps(
    skip: Int = 0
    first: Int = 100
    orderBy: stagingoptimismgoerli_StableSwap_orderBy
    orderDirection: stagingoptimismgoerli_OrderDirection
    where: stagingoptimismgoerli_StableSwap_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingoptimismgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [stagingoptimismgoerli_StableSwap!]!
  stagingoptimismgoerli_stableSwapAddLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingoptimismgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): stagingoptimismgoerli_StableSwapAddLiquidityEvent
  stagingoptimismgoerli_stableSwapAddLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: stagingoptimismgoerli_StableSwapAddLiquidityEvent_orderBy
    orderDirection: stagingoptimismgoerli_OrderDirection
    where: stagingoptimismgoerli_StableSwapAddLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingoptimismgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [stagingoptimismgoerli_StableSwapAddLiquidityEvent!]!
  stagingoptimismgoerli_stableSwapRemoveLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingoptimismgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): stagingoptimismgoerli_StableSwapRemoveLiquidityEvent
  stagingoptimismgoerli_stableSwapRemoveLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: stagingoptimismgoerli_StableSwapRemoveLiquidityEvent_orderBy
    orderDirection: stagingoptimismgoerli_OrderDirection
    where: stagingoptimismgoerli_StableSwapRemoveLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingoptimismgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [stagingoptimismgoerli_StableSwapRemoveLiquidityEvent!]!
  stagingoptimismgoerli_stableSwapExchange(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingoptimismgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): stagingoptimismgoerli_StableSwapExchange
  stagingoptimismgoerli_stableSwapExchanges(
    skip: Int = 0
    first: Int = 100
    orderBy: stagingoptimismgoerli_StableSwapExchange_orderBy
    orderDirection: stagingoptimismgoerli_OrderDirection
    where: stagingoptimismgoerli_StableSwapExchange_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingoptimismgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [stagingoptimismgoerli_StableSwapExchange!]!
  stagingoptimismgoerli_swapDailyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingoptimismgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): stagingoptimismgoerli_SwapDailyVolume
  stagingoptimismgoerli_swapDailyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: stagingoptimismgoerli_SwapDailyVolume_orderBy
    orderDirection: stagingoptimismgoerli_OrderDirection
    where: stagingoptimismgoerli_SwapDailyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingoptimismgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [stagingoptimismgoerli_SwapDailyVolume!]!
  stagingoptimismgoerli_swapHourlyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingoptimismgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): stagingoptimismgoerli_SwapHourlyVolume
  stagingoptimismgoerli_swapHourlyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: stagingoptimismgoerli_SwapHourlyVolume_orderBy
    orderDirection: stagingoptimismgoerli_OrderDirection
    where: stagingoptimismgoerli_SwapHourlyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingoptimismgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [stagingoptimismgoerli_SwapHourlyVolume!]!
  stagingoptimismgoerli_swapWeeklyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingoptimismgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): stagingoptimismgoerli_SwapWeeklyVolume
  stagingoptimismgoerli_swapWeeklyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: stagingoptimismgoerli_SwapWeeklyVolume_orderBy
    orderDirection: stagingoptimismgoerli_OrderDirection
    where: stagingoptimismgoerli_SwapWeeklyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingoptimismgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [stagingoptimismgoerli_SwapWeeklyVolume!]!
  stagingoptimismgoerli_stableSwapEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingoptimismgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): stagingoptimismgoerli_StableSwapEvent
  stagingoptimismgoerli_stableSwapEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: stagingoptimismgoerli_StableSwapEvent_orderBy
    orderDirection: stagingoptimismgoerli_OrderDirection
    where: stagingoptimismgoerli_StableSwapEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingoptimismgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [stagingoptimismgoerli_StableSwapEvent!]!
  stagingoptimismgoerli_swapTradeVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingoptimismgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): stagingoptimismgoerli_SwapTradeVolume
  stagingoptimismgoerli_swapTradeVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: stagingoptimismgoerli_SwapTradeVolume_orderBy
    orderDirection: stagingoptimismgoerli_OrderDirection
    where: stagingoptimismgoerli_SwapTradeVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingoptimismgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [stagingoptimismgoerli_SwapTradeVolume!]!
  """Access to subgraph metadata"""
  stagingoptimismgoerli__meta(block: stagingoptimismgoerli_Block_height): stagingoptimismgoerli__Meta_
  optimism_systemInfo(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): optimism_SystemInfo
  optimism_systemInfos(
    skip: Int = 0
    first: Int = 100
    orderBy: optimism_SystemInfo_orderBy
    orderDirection: optimism_OrderDirection
    where: optimism_SystemInfo_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [optimism_SystemInfo!]!
  optimism_pooledToken(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): optimism_PooledToken
  optimism_pooledTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: optimism_PooledToken_orderBy
    orderDirection: optimism_OrderDirection
    where: optimism_PooledToken_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [optimism_PooledToken!]!
  optimism_stableSwap(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): optimism_StableSwap
  optimism_stableSwaps(
    skip: Int = 0
    first: Int = 100
    orderBy: optimism_StableSwap_orderBy
    orderDirection: optimism_OrderDirection
    where: optimism_StableSwap_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [optimism_StableSwap!]!
  optimism_stableSwapAddLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): optimism_StableSwapAddLiquidityEvent
  optimism_stableSwapAddLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: optimism_StableSwapAddLiquidityEvent_orderBy
    orderDirection: optimism_OrderDirection
    where: optimism_StableSwapAddLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [optimism_StableSwapAddLiquidityEvent!]!
  optimism_stableSwapRemoveLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): optimism_StableSwapRemoveLiquidityEvent
  optimism_stableSwapRemoveLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: optimism_StableSwapRemoveLiquidityEvent_orderBy
    orderDirection: optimism_OrderDirection
    where: optimism_StableSwapRemoveLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [optimism_StableSwapRemoveLiquidityEvent!]!
  optimism_stableSwapExchange(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): optimism_StableSwapExchange
  optimism_stableSwapExchanges(
    skip: Int = 0
    first: Int = 100
    orderBy: optimism_StableSwapExchange_orderBy
    orderDirection: optimism_OrderDirection
    where: optimism_StableSwapExchange_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [optimism_StableSwapExchange!]!
  optimism_swapDailyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): optimism_SwapDailyVolume
  optimism_swapDailyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: optimism_SwapDailyVolume_orderBy
    orderDirection: optimism_OrderDirection
    where: optimism_SwapDailyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [optimism_SwapDailyVolume!]!
  optimism_swapHourlyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): optimism_SwapHourlyVolume
  optimism_swapHourlyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: optimism_SwapHourlyVolume_orderBy
    orderDirection: optimism_OrderDirection
    where: optimism_SwapHourlyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [optimism_SwapHourlyVolume!]!
  optimism_swapWeeklyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): optimism_SwapWeeklyVolume
  optimism_swapWeeklyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: optimism_SwapWeeklyVolume_orderBy
    orderDirection: optimism_OrderDirection
    where: optimism_SwapWeeklyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [optimism_SwapWeeklyVolume!]!
  optimism_stableSwapEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): optimism_StableSwapEvent
  optimism_stableSwapEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: optimism_StableSwapEvent_orderBy
    orderDirection: optimism_OrderDirection
    where: optimism_StableSwapEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [optimism_StableSwapEvent!]!
  optimism_swapTradeVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): optimism_SwapTradeVolume
  optimism_swapTradeVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: optimism_SwapTradeVolume_orderBy
    orderDirection: optimism_OrderDirection
    where: optimism_SwapTradeVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [optimism_SwapTradeVolume!]!
  """Access to subgraph metadata"""
  optimism__meta(block: optimism_Block_height): optimism__Meta_
  polygon_systemInfo(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygon_SystemInfo
  polygon_systemInfos(
    skip: Int = 0
    first: Int = 100
    orderBy: polygon_SystemInfo_orderBy
    orderDirection: polygon_OrderDirection
    where: polygon_SystemInfo_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygon_SystemInfo!]!
  polygon_pooledToken(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygon_PooledToken
  polygon_pooledTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: polygon_PooledToken_orderBy
    orderDirection: polygon_OrderDirection
    where: polygon_PooledToken_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygon_PooledToken!]!
  polygon_stableSwap(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygon_StableSwap
  polygon_stableSwaps(
    skip: Int = 0
    first: Int = 100
    orderBy: polygon_StableSwap_orderBy
    orderDirection: polygon_OrderDirection
    where: polygon_StableSwap_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygon_StableSwap!]!
  polygon_stableSwapAddLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygon_StableSwapAddLiquidityEvent
  polygon_stableSwapAddLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: polygon_StableSwapAddLiquidityEvent_orderBy
    orderDirection: polygon_OrderDirection
    where: polygon_StableSwapAddLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygon_StableSwapAddLiquidityEvent!]!
  polygon_stableSwapRemoveLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygon_StableSwapRemoveLiquidityEvent
  polygon_stableSwapRemoveLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: polygon_StableSwapRemoveLiquidityEvent_orderBy
    orderDirection: polygon_OrderDirection
    where: polygon_StableSwapRemoveLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygon_StableSwapRemoveLiquidityEvent!]!
  polygon_stableSwapExchange(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygon_StableSwapExchange
  polygon_stableSwapExchanges(
    skip: Int = 0
    first: Int = 100
    orderBy: polygon_StableSwapExchange_orderBy
    orderDirection: polygon_OrderDirection
    where: polygon_StableSwapExchange_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygon_StableSwapExchange!]!
  polygon_swapDailyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygon_SwapDailyVolume
  polygon_swapDailyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: polygon_SwapDailyVolume_orderBy
    orderDirection: polygon_OrderDirection
    where: polygon_SwapDailyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygon_SwapDailyVolume!]!
  polygon_swapHourlyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygon_SwapHourlyVolume
  polygon_swapHourlyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: polygon_SwapHourlyVolume_orderBy
    orderDirection: polygon_OrderDirection
    where: polygon_SwapHourlyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygon_SwapHourlyVolume!]!
  polygon_swapWeeklyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygon_SwapWeeklyVolume
  polygon_swapWeeklyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: polygon_SwapWeeklyVolume_orderBy
    orderDirection: polygon_OrderDirection
    where: polygon_SwapWeeklyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygon_SwapWeeklyVolume!]!
  polygon_stableSwapEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygon_StableSwapEvent
  polygon_stableSwapEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: polygon_StableSwapEvent_orderBy
    orderDirection: polygon_OrderDirection
    where: polygon_StableSwapEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygon_StableSwapEvent!]!
  polygon_swapTradeVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygon_SwapTradeVolume
  polygon_swapTradeVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: polygon_SwapTradeVolume_orderBy
    orderDirection: polygon_OrderDirection
    where: polygon_SwapTradeVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygon_SwapTradeVolume!]!
  """Access to subgraph metadata"""
  polygon__meta(block: polygon_Block_height): polygon__Meta_
  staginggoerli_systemInfo(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: staginggoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): staginggoerli_SystemInfo
  staginggoerli_systemInfos(
    skip: Int = 0
    first: Int = 100
    orderBy: staginggoerli_SystemInfo_orderBy
    orderDirection: staginggoerli_OrderDirection
    where: staginggoerli_SystemInfo_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: staginggoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [staginggoerli_SystemInfo!]!
  staginggoerli_pooledToken(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: staginggoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): staginggoerli_PooledToken
  staginggoerli_pooledTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: staginggoerli_PooledToken_orderBy
    orderDirection: staginggoerli_OrderDirection
    where: staginggoerli_PooledToken_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: staginggoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [staginggoerli_PooledToken!]!
  staginggoerli_stableSwap(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: staginggoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): staginggoerli_StableSwap
  staginggoerli_stableSwaps(
    skip: Int = 0
    first: Int = 100
    orderBy: staginggoerli_StableSwap_orderBy
    orderDirection: staginggoerli_OrderDirection
    where: staginggoerli_StableSwap_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: staginggoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [staginggoerli_StableSwap!]!
  staginggoerli_stableSwapAddLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: staginggoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): staginggoerli_StableSwapAddLiquidityEvent
  staginggoerli_stableSwapAddLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: staginggoerli_StableSwapAddLiquidityEvent_orderBy
    orderDirection: staginggoerli_OrderDirection
    where: staginggoerli_StableSwapAddLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: staginggoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [staginggoerli_StableSwapAddLiquidityEvent!]!
  staginggoerli_stableSwapRemoveLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: staginggoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): staginggoerli_StableSwapRemoveLiquidityEvent
  staginggoerli_stableSwapRemoveLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: staginggoerli_StableSwapRemoveLiquidityEvent_orderBy
    orderDirection: staginggoerli_OrderDirection
    where: staginggoerli_StableSwapRemoveLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: staginggoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [staginggoerli_StableSwapRemoveLiquidityEvent!]!
  staginggoerli_stableSwapExchange(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: staginggoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): staginggoerli_StableSwapExchange
  staginggoerli_stableSwapExchanges(
    skip: Int = 0
    first: Int = 100
    orderBy: staginggoerli_StableSwapExchange_orderBy
    orderDirection: staginggoerli_OrderDirection
    where: staginggoerli_StableSwapExchange_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: staginggoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [staginggoerli_StableSwapExchange!]!
  staginggoerli_swapDailyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: staginggoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): staginggoerli_SwapDailyVolume
  staginggoerli_swapDailyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: staginggoerli_SwapDailyVolume_orderBy
    orderDirection: staginggoerli_OrderDirection
    where: staginggoerli_SwapDailyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: staginggoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [staginggoerli_SwapDailyVolume!]!
  staginggoerli_swapHourlyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: staginggoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): staginggoerli_SwapHourlyVolume
  staginggoerli_swapHourlyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: staginggoerli_SwapHourlyVolume_orderBy
    orderDirection: staginggoerli_OrderDirection
    where: staginggoerli_SwapHourlyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: staginggoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [staginggoerli_SwapHourlyVolume!]!
  staginggoerli_swapWeeklyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: staginggoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): staginggoerli_SwapWeeklyVolume
  staginggoerli_swapWeeklyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: staginggoerli_SwapWeeklyVolume_orderBy
    orderDirection: staginggoerli_OrderDirection
    where: staginggoerli_SwapWeeklyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: staginggoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [staginggoerli_SwapWeeklyVolume!]!
  staginggoerli_stableSwapEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: staginggoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): staginggoerli_StableSwapEvent
  staginggoerli_stableSwapEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: staginggoerli_StableSwapEvent_orderBy
    orderDirection: staginggoerli_OrderDirection
    where: staginggoerli_StableSwapEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: staginggoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [staginggoerli_StableSwapEvent!]!
  staginggoerli_swapTradeVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: staginggoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): staginggoerli_SwapTradeVolume
  staginggoerli_swapTradeVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: staginggoerli_SwapTradeVolume_orderBy
    orderDirection: staginggoerli_OrderDirection
    where: staginggoerli_SwapTradeVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: staginggoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [staginggoerli_SwapTradeVolume!]!
  """Access to subgraph metadata"""
  staginggoerli__meta(block: staginggoerli_Block_height): staginggoerli__Meta_
  arbitrumgoerli_systemInfo(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): arbitrumgoerli_SystemInfo
  arbitrumgoerli_systemInfos(
    skip: Int = 0
    first: Int = 100
    orderBy: arbitrumgoerli_SystemInfo_orderBy
    orderDirection: arbitrumgoerli_OrderDirection
    where: arbitrumgoerli_SystemInfo_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [arbitrumgoerli_SystemInfo!]!
  arbitrumgoerli_pooledToken(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): arbitrumgoerli_PooledToken
  arbitrumgoerli_pooledTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: arbitrumgoerli_PooledToken_orderBy
    orderDirection: arbitrumgoerli_OrderDirection
    where: arbitrumgoerli_PooledToken_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [arbitrumgoerli_PooledToken!]!
  arbitrumgoerli_stableSwap(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): arbitrumgoerli_StableSwap
  arbitrumgoerli_stableSwaps(
    skip: Int = 0
    first: Int = 100
    orderBy: arbitrumgoerli_StableSwap_orderBy
    orderDirection: arbitrumgoerli_OrderDirection
    where: arbitrumgoerli_StableSwap_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [arbitrumgoerli_StableSwap!]!
  arbitrumgoerli_stableSwapAddLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): arbitrumgoerli_StableSwapAddLiquidityEvent
  arbitrumgoerli_stableSwapAddLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: arbitrumgoerli_StableSwapAddLiquidityEvent_orderBy
    orderDirection: arbitrumgoerli_OrderDirection
    where: arbitrumgoerli_StableSwapAddLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [arbitrumgoerli_StableSwapAddLiquidityEvent!]!
  arbitrumgoerli_stableSwapRemoveLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): arbitrumgoerli_StableSwapRemoveLiquidityEvent
  arbitrumgoerli_stableSwapRemoveLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: arbitrumgoerli_StableSwapRemoveLiquidityEvent_orderBy
    orderDirection: arbitrumgoerli_OrderDirection
    where: arbitrumgoerli_StableSwapRemoveLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [arbitrumgoerli_StableSwapRemoveLiquidityEvent!]!
  arbitrumgoerli_stableSwapExchange(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): arbitrumgoerli_StableSwapExchange
  arbitrumgoerli_stableSwapExchanges(
    skip: Int = 0
    first: Int = 100
    orderBy: arbitrumgoerli_StableSwapExchange_orderBy
    orderDirection: arbitrumgoerli_OrderDirection
    where: arbitrumgoerli_StableSwapExchange_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [arbitrumgoerli_StableSwapExchange!]!
  arbitrumgoerli_swapDailyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): arbitrumgoerli_SwapDailyVolume
  arbitrumgoerli_swapDailyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: arbitrumgoerli_SwapDailyVolume_orderBy
    orderDirection: arbitrumgoerli_OrderDirection
    where: arbitrumgoerli_SwapDailyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [arbitrumgoerli_SwapDailyVolume!]!
  arbitrumgoerli_swapHourlyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): arbitrumgoerli_SwapHourlyVolume
  arbitrumgoerli_swapHourlyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: arbitrumgoerli_SwapHourlyVolume_orderBy
    orderDirection: arbitrumgoerli_OrderDirection
    where: arbitrumgoerli_SwapHourlyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [arbitrumgoerli_SwapHourlyVolume!]!
  arbitrumgoerli_swapWeeklyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): arbitrumgoerli_SwapWeeklyVolume
  arbitrumgoerli_swapWeeklyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: arbitrumgoerli_SwapWeeklyVolume_orderBy
    orderDirection: arbitrumgoerli_OrderDirection
    where: arbitrumgoerli_SwapWeeklyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [arbitrumgoerli_SwapWeeklyVolume!]!
  arbitrumgoerli_stableSwapEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): arbitrumgoerli_StableSwapEvent
  arbitrumgoerli_stableSwapEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: arbitrumgoerli_StableSwapEvent_orderBy
    orderDirection: arbitrumgoerli_OrderDirection
    where: arbitrumgoerli_StableSwapEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [arbitrumgoerli_StableSwapEvent!]!
  arbitrumgoerli_swapTradeVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): arbitrumgoerli_SwapTradeVolume
  arbitrumgoerli_swapTradeVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: arbitrumgoerli_SwapTradeVolume_orderBy
    orderDirection: arbitrumgoerli_OrderDirection
    where: arbitrumgoerli_SwapTradeVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [arbitrumgoerli_SwapTradeVolume!]!
  """Access to subgraph metadata"""
  arbitrumgoerli__meta(block: arbitrumgoerli_Block_height): arbitrumgoerli__Meta_
  optimismgoerli_systemInfo(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimismgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): optimismgoerli_SystemInfo
  optimismgoerli_systemInfos(
    skip: Int = 0
    first: Int = 100
    orderBy: optimismgoerli_SystemInfo_orderBy
    orderDirection: optimismgoerli_OrderDirection
    where: optimismgoerli_SystemInfo_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimismgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [optimismgoerli_SystemInfo!]!
  optimismgoerli_pooledToken(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimismgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): optimismgoerli_PooledToken
  optimismgoerli_pooledTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: optimismgoerli_PooledToken_orderBy
    orderDirection: optimismgoerli_OrderDirection
    where: optimismgoerli_PooledToken_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimismgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [optimismgoerli_PooledToken!]!
  optimismgoerli_stableSwap(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimismgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): optimismgoerli_StableSwap
  optimismgoerli_stableSwaps(
    skip: Int = 0
    first: Int = 100
    orderBy: optimismgoerli_StableSwap_orderBy
    orderDirection: optimismgoerli_OrderDirection
    where: optimismgoerli_StableSwap_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimismgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [optimismgoerli_StableSwap!]!
  optimismgoerli_stableSwapAddLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimismgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): optimismgoerli_StableSwapAddLiquidityEvent
  optimismgoerli_stableSwapAddLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: optimismgoerli_StableSwapAddLiquidityEvent_orderBy
    orderDirection: optimismgoerli_OrderDirection
    where: optimismgoerli_StableSwapAddLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimismgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [optimismgoerli_StableSwapAddLiquidityEvent!]!
  optimismgoerli_stableSwapRemoveLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimismgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): optimismgoerli_StableSwapRemoveLiquidityEvent
  optimismgoerli_stableSwapRemoveLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: optimismgoerli_StableSwapRemoveLiquidityEvent_orderBy
    orderDirection: optimismgoerli_OrderDirection
    where: optimismgoerli_StableSwapRemoveLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimismgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [optimismgoerli_StableSwapRemoveLiquidityEvent!]!
  optimismgoerli_stableSwapExchange(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimismgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): optimismgoerli_StableSwapExchange
  optimismgoerli_stableSwapExchanges(
    skip: Int = 0
    first: Int = 100
    orderBy: optimismgoerli_StableSwapExchange_orderBy
    orderDirection: optimismgoerli_OrderDirection
    where: optimismgoerli_StableSwapExchange_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimismgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [optimismgoerli_StableSwapExchange!]!
  optimismgoerli_swapDailyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimismgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): optimismgoerli_SwapDailyVolume
  optimismgoerli_swapDailyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: optimismgoerli_SwapDailyVolume_orderBy
    orderDirection: optimismgoerli_OrderDirection
    where: optimismgoerli_SwapDailyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimismgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [optimismgoerli_SwapDailyVolume!]!
  optimismgoerli_swapHourlyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimismgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): optimismgoerli_SwapHourlyVolume
  optimismgoerli_swapHourlyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: optimismgoerli_SwapHourlyVolume_orderBy
    orderDirection: optimismgoerli_OrderDirection
    where: optimismgoerli_SwapHourlyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimismgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [optimismgoerli_SwapHourlyVolume!]!
  optimismgoerli_swapWeeklyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimismgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): optimismgoerli_SwapWeeklyVolume
  optimismgoerli_swapWeeklyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: optimismgoerli_SwapWeeklyVolume_orderBy
    orderDirection: optimismgoerli_OrderDirection
    where: optimismgoerli_SwapWeeklyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimismgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [optimismgoerli_SwapWeeklyVolume!]!
  optimismgoerli_stableSwapEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimismgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): optimismgoerli_StableSwapEvent
  optimismgoerli_stableSwapEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: optimismgoerli_StableSwapEvent_orderBy
    orderDirection: optimismgoerli_OrderDirection
    where: optimismgoerli_StableSwapEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimismgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [optimismgoerli_StableSwapEvent!]!
  optimismgoerli_swapTradeVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimismgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): optimismgoerli_SwapTradeVolume
  optimismgoerli_swapTradeVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: optimismgoerli_SwapTradeVolume_orderBy
    orderDirection: optimismgoerli_OrderDirection
    where: optimismgoerli_SwapTradeVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimismgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [optimismgoerli_SwapTradeVolume!]!
  """Access to subgraph metadata"""
  optimismgoerli__meta(block: optimismgoerli_Block_height): optimismgoerli__Meta_
  stagingmumbai_systemInfo(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingmumbai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): stagingmumbai_SystemInfo
  stagingmumbai_systemInfos(
    skip: Int = 0
    first: Int = 100
    orderBy: stagingmumbai_SystemInfo_orderBy
    orderDirection: stagingmumbai_OrderDirection
    where: stagingmumbai_SystemInfo_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingmumbai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [stagingmumbai_SystemInfo!]!
  stagingmumbai_pooledToken(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingmumbai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): stagingmumbai_PooledToken
  stagingmumbai_pooledTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: stagingmumbai_PooledToken_orderBy
    orderDirection: stagingmumbai_OrderDirection
    where: stagingmumbai_PooledToken_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingmumbai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [stagingmumbai_PooledToken!]!
  stagingmumbai_stableSwap(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingmumbai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): stagingmumbai_StableSwap
  stagingmumbai_stableSwaps(
    skip: Int = 0
    first: Int = 100
    orderBy: stagingmumbai_StableSwap_orderBy
    orderDirection: stagingmumbai_OrderDirection
    where: stagingmumbai_StableSwap_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingmumbai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [stagingmumbai_StableSwap!]!
  stagingmumbai_stableSwapAddLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingmumbai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): stagingmumbai_StableSwapAddLiquidityEvent
  stagingmumbai_stableSwapAddLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: stagingmumbai_StableSwapAddLiquidityEvent_orderBy
    orderDirection: stagingmumbai_OrderDirection
    where: stagingmumbai_StableSwapAddLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingmumbai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [stagingmumbai_StableSwapAddLiquidityEvent!]!
  stagingmumbai_stableSwapRemoveLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingmumbai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): stagingmumbai_StableSwapRemoveLiquidityEvent
  stagingmumbai_stableSwapRemoveLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: stagingmumbai_StableSwapRemoveLiquidityEvent_orderBy
    orderDirection: stagingmumbai_OrderDirection
    where: stagingmumbai_StableSwapRemoveLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingmumbai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [stagingmumbai_StableSwapRemoveLiquidityEvent!]!
  stagingmumbai_stableSwapExchange(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingmumbai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): stagingmumbai_StableSwapExchange
  stagingmumbai_stableSwapExchanges(
    skip: Int = 0
    first: Int = 100
    orderBy: stagingmumbai_StableSwapExchange_orderBy
    orderDirection: stagingmumbai_OrderDirection
    where: stagingmumbai_StableSwapExchange_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingmumbai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [stagingmumbai_StableSwapExchange!]!
  stagingmumbai_swapDailyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingmumbai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): stagingmumbai_SwapDailyVolume
  stagingmumbai_swapDailyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: stagingmumbai_SwapDailyVolume_orderBy
    orderDirection: stagingmumbai_OrderDirection
    where: stagingmumbai_SwapDailyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingmumbai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [stagingmumbai_SwapDailyVolume!]!
  stagingmumbai_swapHourlyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingmumbai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): stagingmumbai_SwapHourlyVolume
  stagingmumbai_swapHourlyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: stagingmumbai_SwapHourlyVolume_orderBy
    orderDirection: stagingmumbai_OrderDirection
    where: stagingmumbai_SwapHourlyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingmumbai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [stagingmumbai_SwapHourlyVolume!]!
  stagingmumbai_swapWeeklyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingmumbai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): stagingmumbai_SwapWeeklyVolume
  stagingmumbai_swapWeeklyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: stagingmumbai_SwapWeeklyVolume_orderBy
    orderDirection: stagingmumbai_OrderDirection
    where: stagingmumbai_SwapWeeklyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingmumbai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [stagingmumbai_SwapWeeklyVolume!]!
  stagingmumbai_stableSwapEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingmumbai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): stagingmumbai_StableSwapEvent
  stagingmumbai_stableSwapEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: stagingmumbai_StableSwapEvent_orderBy
    orderDirection: stagingmumbai_OrderDirection
    where: stagingmumbai_StableSwapEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingmumbai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [stagingmumbai_StableSwapEvent!]!
  stagingmumbai_swapTradeVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingmumbai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): stagingmumbai_SwapTradeVolume
  stagingmumbai_swapTradeVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: stagingmumbai_SwapTradeVolume_orderBy
    orderDirection: stagingmumbai_OrderDirection
    where: stagingmumbai_SwapTradeVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingmumbai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [stagingmumbai_SwapTradeVolume!]!
  """Access to subgraph metadata"""
  stagingmumbai__meta(block: stagingmumbai_Block_height): stagingmumbai__Meta_
  stagingarbitrumgoerli_systemInfo(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingarbitrumgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): stagingarbitrumgoerli_SystemInfo
  stagingarbitrumgoerli_systemInfos(
    skip: Int = 0
    first: Int = 100
    orderBy: stagingarbitrumgoerli_SystemInfo_orderBy
    orderDirection: stagingarbitrumgoerli_OrderDirection
    where: stagingarbitrumgoerli_SystemInfo_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingarbitrumgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [stagingarbitrumgoerli_SystemInfo!]!
  stagingarbitrumgoerli_pooledToken(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingarbitrumgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): stagingarbitrumgoerli_PooledToken
  stagingarbitrumgoerli_pooledTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: stagingarbitrumgoerli_PooledToken_orderBy
    orderDirection: stagingarbitrumgoerli_OrderDirection
    where: stagingarbitrumgoerli_PooledToken_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingarbitrumgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [stagingarbitrumgoerli_PooledToken!]!
  stagingarbitrumgoerli_stableSwap(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingarbitrumgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): stagingarbitrumgoerli_StableSwap
  stagingarbitrumgoerli_stableSwaps(
    skip: Int = 0
    first: Int = 100
    orderBy: stagingarbitrumgoerli_StableSwap_orderBy
    orderDirection: stagingarbitrumgoerli_OrderDirection
    where: stagingarbitrumgoerli_StableSwap_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingarbitrumgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [stagingarbitrumgoerli_StableSwap!]!
  stagingarbitrumgoerli_stableSwapAddLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingarbitrumgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): stagingarbitrumgoerli_StableSwapAddLiquidityEvent
  stagingarbitrumgoerli_stableSwapAddLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: stagingarbitrumgoerli_StableSwapAddLiquidityEvent_orderBy
    orderDirection: stagingarbitrumgoerli_OrderDirection
    where: stagingarbitrumgoerli_StableSwapAddLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingarbitrumgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [stagingarbitrumgoerli_StableSwapAddLiquidityEvent!]!
  stagingarbitrumgoerli_stableSwapRemoveLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingarbitrumgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): stagingarbitrumgoerli_StableSwapRemoveLiquidityEvent
  stagingarbitrumgoerli_stableSwapRemoveLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: stagingarbitrumgoerli_StableSwapRemoveLiquidityEvent_orderBy
    orderDirection: stagingarbitrumgoerli_OrderDirection
    where: stagingarbitrumgoerli_StableSwapRemoveLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingarbitrumgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [stagingarbitrumgoerli_StableSwapRemoveLiquidityEvent!]!
  stagingarbitrumgoerli_stableSwapExchange(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingarbitrumgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): stagingarbitrumgoerli_StableSwapExchange
  stagingarbitrumgoerli_stableSwapExchanges(
    skip: Int = 0
    first: Int = 100
    orderBy: stagingarbitrumgoerli_StableSwapExchange_orderBy
    orderDirection: stagingarbitrumgoerli_OrderDirection
    where: stagingarbitrumgoerli_StableSwapExchange_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingarbitrumgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [stagingarbitrumgoerli_StableSwapExchange!]!
  stagingarbitrumgoerli_swapDailyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingarbitrumgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): stagingarbitrumgoerli_SwapDailyVolume
  stagingarbitrumgoerli_swapDailyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: stagingarbitrumgoerli_SwapDailyVolume_orderBy
    orderDirection: stagingarbitrumgoerli_OrderDirection
    where: stagingarbitrumgoerli_SwapDailyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingarbitrumgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [stagingarbitrumgoerli_SwapDailyVolume!]!
  stagingarbitrumgoerli_swapHourlyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingarbitrumgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): stagingarbitrumgoerli_SwapHourlyVolume
  stagingarbitrumgoerli_swapHourlyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: stagingarbitrumgoerli_SwapHourlyVolume_orderBy
    orderDirection: stagingarbitrumgoerli_OrderDirection
    where: stagingarbitrumgoerli_SwapHourlyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingarbitrumgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [stagingarbitrumgoerli_SwapHourlyVolume!]!
  stagingarbitrumgoerli_swapWeeklyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingarbitrumgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): stagingarbitrumgoerli_SwapWeeklyVolume
  stagingarbitrumgoerli_swapWeeklyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: stagingarbitrumgoerli_SwapWeeklyVolume_orderBy
    orderDirection: stagingarbitrumgoerli_OrderDirection
    where: stagingarbitrumgoerli_SwapWeeklyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingarbitrumgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [stagingarbitrumgoerli_SwapWeeklyVolume!]!
  stagingarbitrumgoerli_stableSwapEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingarbitrumgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): stagingarbitrumgoerli_StableSwapEvent
  stagingarbitrumgoerli_stableSwapEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: stagingarbitrumgoerli_StableSwapEvent_orderBy
    orderDirection: stagingarbitrumgoerli_OrderDirection
    where: stagingarbitrumgoerli_StableSwapEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingarbitrumgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [stagingarbitrumgoerli_StableSwapEvent!]!
  stagingarbitrumgoerli_swapTradeVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingarbitrumgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): stagingarbitrumgoerli_SwapTradeVolume
  stagingarbitrumgoerli_swapTradeVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: stagingarbitrumgoerli_SwapTradeVolume_orderBy
    orderDirection: stagingarbitrumgoerli_OrderDirection
    where: stagingarbitrumgoerli_SwapTradeVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingarbitrumgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [stagingarbitrumgoerli_SwapTradeVolume!]!
  """Access to subgraph metadata"""
  stagingarbitrumgoerli__meta(block: stagingarbitrumgoerli_Block_height): stagingarbitrumgoerli__Meta_
}

type Subscription {
  mumbai_systemInfo(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mumbai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mumbai_SystemInfo
  mumbai_systemInfos(
    skip: Int = 0
    first: Int = 100
    orderBy: mumbai_SystemInfo_orderBy
    orderDirection: mumbai_OrderDirection
    where: mumbai_SystemInfo_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mumbai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mumbai_SystemInfo!]!
  mumbai_pooledToken(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mumbai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mumbai_PooledToken
  mumbai_pooledTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: mumbai_PooledToken_orderBy
    orderDirection: mumbai_OrderDirection
    where: mumbai_PooledToken_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mumbai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mumbai_PooledToken!]!
  mumbai_stableSwap(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mumbai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mumbai_StableSwap
  mumbai_stableSwaps(
    skip: Int = 0
    first: Int = 100
    orderBy: mumbai_StableSwap_orderBy
    orderDirection: mumbai_OrderDirection
    where: mumbai_StableSwap_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mumbai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mumbai_StableSwap!]!
  mumbai_stableSwapAddLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mumbai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mumbai_StableSwapAddLiquidityEvent
  mumbai_stableSwapAddLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: mumbai_StableSwapAddLiquidityEvent_orderBy
    orderDirection: mumbai_OrderDirection
    where: mumbai_StableSwapAddLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mumbai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mumbai_StableSwapAddLiquidityEvent!]!
  mumbai_stableSwapRemoveLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mumbai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mumbai_StableSwapRemoveLiquidityEvent
  mumbai_stableSwapRemoveLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: mumbai_StableSwapRemoveLiquidityEvent_orderBy
    orderDirection: mumbai_OrderDirection
    where: mumbai_StableSwapRemoveLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mumbai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mumbai_StableSwapRemoveLiquidityEvent!]!
  mumbai_stableSwapExchange(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mumbai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mumbai_StableSwapExchange
  mumbai_stableSwapExchanges(
    skip: Int = 0
    first: Int = 100
    orderBy: mumbai_StableSwapExchange_orderBy
    orderDirection: mumbai_OrderDirection
    where: mumbai_StableSwapExchange_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mumbai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mumbai_StableSwapExchange!]!
  mumbai_swapDailyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mumbai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mumbai_SwapDailyVolume
  mumbai_swapDailyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: mumbai_SwapDailyVolume_orderBy
    orderDirection: mumbai_OrderDirection
    where: mumbai_SwapDailyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mumbai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mumbai_SwapDailyVolume!]!
  mumbai_swapHourlyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mumbai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mumbai_SwapHourlyVolume
  mumbai_swapHourlyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: mumbai_SwapHourlyVolume_orderBy
    orderDirection: mumbai_OrderDirection
    where: mumbai_SwapHourlyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mumbai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mumbai_SwapHourlyVolume!]!
  mumbai_swapWeeklyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mumbai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mumbai_SwapWeeklyVolume
  mumbai_swapWeeklyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: mumbai_SwapWeeklyVolume_orderBy
    orderDirection: mumbai_OrderDirection
    where: mumbai_SwapWeeklyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mumbai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mumbai_SwapWeeklyVolume!]!
  mumbai_stableSwapEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mumbai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mumbai_StableSwapEvent
  mumbai_stableSwapEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: mumbai_StableSwapEvent_orderBy
    orderDirection: mumbai_OrderDirection
    where: mumbai_StableSwapEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mumbai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mumbai_StableSwapEvent!]!
  mumbai_swapTradeVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mumbai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mumbai_SwapTradeVolume
  mumbai_swapTradeVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: mumbai_SwapTradeVolume_orderBy
    orderDirection: mumbai_OrderDirection
    where: mumbai_SwapTradeVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mumbai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mumbai_SwapTradeVolume!]!
  """Access to subgraph metadata"""
  mumbai__meta(block: mumbai_Block_height): mumbai__Meta_
  xdai_systemInfo(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xdai_SystemInfo
  xdai_systemInfos(
    skip: Int = 0
    first: Int = 100
    orderBy: xdai_SystemInfo_orderBy
    orderDirection: xdai_OrderDirection
    where: xdai_SystemInfo_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xdai_SystemInfo!]!
  xdai_pooledToken(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xdai_PooledToken
  xdai_pooledTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: xdai_PooledToken_orderBy
    orderDirection: xdai_OrderDirection
    where: xdai_PooledToken_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xdai_PooledToken!]!
  xdai_stableSwap(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xdai_StableSwap
  xdai_stableSwaps(
    skip: Int = 0
    first: Int = 100
    orderBy: xdai_StableSwap_orderBy
    orderDirection: xdai_OrderDirection
    where: xdai_StableSwap_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xdai_StableSwap!]!
  xdai_stableSwapAddLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xdai_StableSwapAddLiquidityEvent
  xdai_stableSwapAddLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: xdai_StableSwapAddLiquidityEvent_orderBy
    orderDirection: xdai_OrderDirection
    where: xdai_StableSwapAddLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xdai_StableSwapAddLiquidityEvent!]!
  xdai_stableSwapRemoveLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xdai_StableSwapRemoveLiquidityEvent
  xdai_stableSwapRemoveLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: xdai_StableSwapRemoveLiquidityEvent_orderBy
    orderDirection: xdai_OrderDirection
    where: xdai_StableSwapRemoveLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xdai_StableSwapRemoveLiquidityEvent!]!
  xdai_stableSwapExchange(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xdai_StableSwapExchange
  xdai_stableSwapExchanges(
    skip: Int = 0
    first: Int = 100
    orderBy: xdai_StableSwapExchange_orderBy
    orderDirection: xdai_OrderDirection
    where: xdai_StableSwapExchange_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xdai_StableSwapExchange!]!
  xdai_swapDailyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xdai_SwapDailyVolume
  xdai_swapDailyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: xdai_SwapDailyVolume_orderBy
    orderDirection: xdai_OrderDirection
    where: xdai_SwapDailyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xdai_SwapDailyVolume!]!
  xdai_swapHourlyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xdai_SwapHourlyVolume
  xdai_swapHourlyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: xdai_SwapHourlyVolume_orderBy
    orderDirection: xdai_OrderDirection
    where: xdai_SwapHourlyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xdai_SwapHourlyVolume!]!
  xdai_swapWeeklyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xdai_SwapWeeklyVolume
  xdai_swapWeeklyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: xdai_SwapWeeklyVolume_orderBy
    orderDirection: xdai_OrderDirection
    where: xdai_SwapWeeklyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xdai_SwapWeeklyVolume!]!
  xdai_stableSwapEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xdai_StableSwapEvent
  xdai_stableSwapEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: xdai_StableSwapEvent_orderBy
    orderDirection: xdai_OrderDirection
    where: xdai_StableSwapEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xdai_StableSwapEvent!]!
  xdai_swapTradeVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xdai_SwapTradeVolume
  xdai_swapTradeVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: xdai_SwapTradeVolume_orderBy
    orderDirection: xdai_OrderDirection
    where: xdai_SwapTradeVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xdai_SwapTradeVolume!]!
  """Access to subgraph metadata"""
  xdai__meta(block: xdai_Block_height): xdai__Meta_
  arbitrumone_systemInfo(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): arbitrumone_SystemInfo
  arbitrumone_systemInfos(
    skip: Int = 0
    first: Int = 100
    orderBy: arbitrumone_SystemInfo_orderBy
    orderDirection: arbitrumone_OrderDirection
    where: arbitrumone_SystemInfo_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [arbitrumone_SystemInfo!]!
  arbitrumone_pooledToken(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): arbitrumone_PooledToken
  arbitrumone_pooledTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: arbitrumone_PooledToken_orderBy
    orderDirection: arbitrumone_OrderDirection
    where: arbitrumone_PooledToken_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [arbitrumone_PooledToken!]!
  arbitrumone_stableSwap(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): arbitrumone_StableSwap
  arbitrumone_stableSwaps(
    skip: Int = 0
    first: Int = 100
    orderBy: arbitrumone_StableSwap_orderBy
    orderDirection: arbitrumone_OrderDirection
    where: arbitrumone_StableSwap_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [arbitrumone_StableSwap!]!
  arbitrumone_stableSwapAddLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): arbitrumone_StableSwapAddLiquidityEvent
  arbitrumone_stableSwapAddLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: arbitrumone_StableSwapAddLiquidityEvent_orderBy
    orderDirection: arbitrumone_OrderDirection
    where: arbitrumone_StableSwapAddLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [arbitrumone_StableSwapAddLiquidityEvent!]!
  arbitrumone_stableSwapRemoveLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): arbitrumone_StableSwapRemoveLiquidityEvent
  arbitrumone_stableSwapRemoveLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: arbitrumone_StableSwapRemoveLiquidityEvent_orderBy
    orderDirection: arbitrumone_OrderDirection
    where: arbitrumone_StableSwapRemoveLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [arbitrumone_StableSwapRemoveLiquidityEvent!]!
  arbitrumone_stableSwapExchange(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): arbitrumone_StableSwapExchange
  arbitrumone_stableSwapExchanges(
    skip: Int = 0
    first: Int = 100
    orderBy: arbitrumone_StableSwapExchange_orderBy
    orderDirection: arbitrumone_OrderDirection
    where: arbitrumone_StableSwapExchange_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [arbitrumone_StableSwapExchange!]!
  arbitrumone_swapDailyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): arbitrumone_SwapDailyVolume
  arbitrumone_swapDailyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: arbitrumone_SwapDailyVolume_orderBy
    orderDirection: arbitrumone_OrderDirection
    where: arbitrumone_SwapDailyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [arbitrumone_SwapDailyVolume!]!
  arbitrumone_swapHourlyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): arbitrumone_SwapHourlyVolume
  arbitrumone_swapHourlyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: arbitrumone_SwapHourlyVolume_orderBy
    orderDirection: arbitrumone_OrderDirection
    where: arbitrumone_SwapHourlyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [arbitrumone_SwapHourlyVolume!]!
  arbitrumone_swapWeeklyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): arbitrumone_SwapWeeklyVolume
  arbitrumone_swapWeeklyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: arbitrumone_SwapWeeklyVolume_orderBy
    orderDirection: arbitrumone_OrderDirection
    where: arbitrumone_SwapWeeklyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [arbitrumone_SwapWeeklyVolume!]!
  arbitrumone_stableSwapEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): arbitrumone_StableSwapEvent
  arbitrumone_stableSwapEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: arbitrumone_StableSwapEvent_orderBy
    orderDirection: arbitrumone_OrderDirection
    where: arbitrumone_StableSwapEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [arbitrumone_StableSwapEvent!]!
  arbitrumone_swapTradeVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): arbitrumone_SwapTradeVolume
  arbitrumone_swapTradeVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: arbitrumone_SwapTradeVolume_orderBy
    orderDirection: arbitrumone_OrderDirection
    where: arbitrumone_SwapTradeVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [arbitrumone_SwapTradeVolume!]!
  """Access to subgraph metadata"""
  arbitrumone__meta(block: arbitrumone_Block_height): arbitrumone__Meta_
  bnb_systemInfo(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): bnb_SystemInfo
  bnb_systemInfos(
    skip: Int = 0
    first: Int = 100
    orderBy: bnb_SystemInfo_orderBy
    orderDirection: bnb_OrderDirection
    where: bnb_SystemInfo_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [bnb_SystemInfo!]!
  bnb_pooledToken(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): bnb_PooledToken
  bnb_pooledTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: bnb_PooledToken_orderBy
    orderDirection: bnb_OrderDirection
    where: bnb_PooledToken_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [bnb_PooledToken!]!
  bnb_stableSwap(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): bnb_StableSwap
  bnb_stableSwaps(
    skip: Int = 0
    first: Int = 100
    orderBy: bnb_StableSwap_orderBy
    orderDirection: bnb_OrderDirection
    where: bnb_StableSwap_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [bnb_StableSwap!]!
  bnb_stableSwapAddLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): bnb_StableSwapAddLiquidityEvent
  bnb_stableSwapAddLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: bnb_StableSwapAddLiquidityEvent_orderBy
    orderDirection: bnb_OrderDirection
    where: bnb_StableSwapAddLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [bnb_StableSwapAddLiquidityEvent!]!
  bnb_stableSwapRemoveLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): bnb_StableSwapRemoveLiquidityEvent
  bnb_stableSwapRemoveLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: bnb_StableSwapRemoveLiquidityEvent_orderBy
    orderDirection: bnb_OrderDirection
    where: bnb_StableSwapRemoveLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [bnb_StableSwapRemoveLiquidityEvent!]!
  bnb_stableSwapExchange(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): bnb_StableSwapExchange
  bnb_stableSwapExchanges(
    skip: Int = 0
    first: Int = 100
    orderBy: bnb_StableSwapExchange_orderBy
    orderDirection: bnb_OrderDirection
    where: bnb_StableSwapExchange_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [bnb_StableSwapExchange!]!
  bnb_swapDailyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): bnb_SwapDailyVolume
  bnb_swapDailyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: bnb_SwapDailyVolume_orderBy
    orderDirection: bnb_OrderDirection
    where: bnb_SwapDailyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [bnb_SwapDailyVolume!]!
  bnb_swapHourlyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): bnb_SwapHourlyVolume
  bnb_swapHourlyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: bnb_SwapHourlyVolume_orderBy
    orderDirection: bnb_OrderDirection
    where: bnb_SwapHourlyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [bnb_SwapHourlyVolume!]!
  bnb_swapWeeklyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): bnb_SwapWeeklyVolume
  bnb_swapWeeklyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: bnb_SwapWeeklyVolume_orderBy
    orderDirection: bnb_OrderDirection
    where: bnb_SwapWeeklyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [bnb_SwapWeeklyVolume!]!
  bnb_stableSwapEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): bnb_StableSwapEvent
  bnb_stableSwapEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: bnb_StableSwapEvent_orderBy
    orderDirection: bnb_OrderDirection
    where: bnb_StableSwapEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [bnb_StableSwapEvent!]!
  bnb_swapTradeVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): bnb_SwapTradeVolume
  bnb_swapTradeVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: bnb_SwapTradeVolume_orderBy
    orderDirection: bnb_OrderDirection
    where: bnb_SwapTradeVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [bnb_SwapTradeVolume!]!
  """Access to subgraph metadata"""
  bnb__meta(block: bnb_Block_height): bnb__Meta_
  goerli_systemInfo(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: goerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): goerli_SystemInfo
  goerli_systemInfos(
    skip: Int = 0
    first: Int = 100
    orderBy: goerli_SystemInfo_orderBy
    orderDirection: goerli_OrderDirection
    where: goerli_SystemInfo_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: goerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [goerli_SystemInfo!]!
  goerli_pooledToken(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: goerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): goerli_PooledToken
  goerli_pooledTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: goerli_PooledToken_orderBy
    orderDirection: goerli_OrderDirection
    where: goerli_PooledToken_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: goerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [goerli_PooledToken!]!
  goerli_stableSwap(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: goerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): goerli_StableSwap
  goerli_stableSwaps(
    skip: Int = 0
    first: Int = 100
    orderBy: goerli_StableSwap_orderBy
    orderDirection: goerli_OrderDirection
    where: goerli_StableSwap_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: goerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [goerli_StableSwap!]!
  goerli_stableSwapAddLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: goerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): goerli_StableSwapAddLiquidityEvent
  goerli_stableSwapAddLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: goerli_StableSwapAddLiquidityEvent_orderBy
    orderDirection: goerli_OrderDirection
    where: goerli_StableSwapAddLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: goerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [goerli_StableSwapAddLiquidityEvent!]!
  goerli_stableSwapRemoveLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: goerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): goerli_StableSwapRemoveLiquidityEvent
  goerli_stableSwapRemoveLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: goerli_StableSwapRemoveLiquidityEvent_orderBy
    orderDirection: goerli_OrderDirection
    where: goerli_StableSwapRemoveLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: goerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [goerli_StableSwapRemoveLiquidityEvent!]!
  goerli_stableSwapExchange(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: goerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): goerli_StableSwapExchange
  goerli_stableSwapExchanges(
    skip: Int = 0
    first: Int = 100
    orderBy: goerli_StableSwapExchange_orderBy
    orderDirection: goerli_OrderDirection
    where: goerli_StableSwapExchange_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: goerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [goerli_StableSwapExchange!]!
  goerli_swapDailyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: goerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): goerli_SwapDailyVolume
  goerli_swapDailyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: goerli_SwapDailyVolume_orderBy
    orderDirection: goerli_OrderDirection
    where: goerli_SwapDailyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: goerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [goerli_SwapDailyVolume!]!
  goerli_swapHourlyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: goerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): goerli_SwapHourlyVolume
  goerli_swapHourlyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: goerli_SwapHourlyVolume_orderBy
    orderDirection: goerli_OrderDirection
    where: goerli_SwapHourlyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: goerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [goerli_SwapHourlyVolume!]!
  goerli_swapWeeklyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: goerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): goerli_SwapWeeklyVolume
  goerli_swapWeeklyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: goerli_SwapWeeklyVolume_orderBy
    orderDirection: goerli_OrderDirection
    where: goerli_SwapWeeklyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: goerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [goerli_SwapWeeklyVolume!]!
  goerli_stableSwapEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: goerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): goerli_StableSwapEvent
  goerli_stableSwapEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: goerli_StableSwapEvent_orderBy
    orderDirection: goerli_OrderDirection
    where: goerli_StableSwapEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: goerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [goerli_StableSwapEvent!]!
  goerli_swapTradeVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: goerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): goerli_SwapTradeVolume
  goerli_swapTradeVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: goerli_SwapTradeVolume_orderBy
    orderDirection: goerli_OrderDirection
    where: goerli_SwapTradeVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: goerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [goerli_SwapTradeVolume!]!
  """Access to subgraph metadata"""
  goerli__meta(block: goerli_Block_height): goerli__Meta_
  stagingoptimismgoerli_systemInfo(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingoptimismgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): stagingoptimismgoerli_SystemInfo
  stagingoptimismgoerli_systemInfos(
    skip: Int = 0
    first: Int = 100
    orderBy: stagingoptimismgoerli_SystemInfo_orderBy
    orderDirection: stagingoptimismgoerli_OrderDirection
    where: stagingoptimismgoerli_SystemInfo_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingoptimismgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [stagingoptimismgoerli_SystemInfo!]!
  stagingoptimismgoerli_pooledToken(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingoptimismgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): stagingoptimismgoerli_PooledToken
  stagingoptimismgoerli_pooledTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: stagingoptimismgoerli_PooledToken_orderBy
    orderDirection: stagingoptimismgoerli_OrderDirection
    where: stagingoptimismgoerli_PooledToken_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingoptimismgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [stagingoptimismgoerli_PooledToken!]!
  stagingoptimismgoerli_stableSwap(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingoptimismgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): stagingoptimismgoerli_StableSwap
  stagingoptimismgoerli_stableSwaps(
    skip: Int = 0
    first: Int = 100
    orderBy: stagingoptimismgoerli_StableSwap_orderBy
    orderDirection: stagingoptimismgoerli_OrderDirection
    where: stagingoptimismgoerli_StableSwap_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingoptimismgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [stagingoptimismgoerli_StableSwap!]!
  stagingoptimismgoerli_stableSwapAddLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingoptimismgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): stagingoptimismgoerli_StableSwapAddLiquidityEvent
  stagingoptimismgoerli_stableSwapAddLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: stagingoptimismgoerli_StableSwapAddLiquidityEvent_orderBy
    orderDirection: stagingoptimismgoerli_OrderDirection
    where: stagingoptimismgoerli_StableSwapAddLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingoptimismgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [stagingoptimismgoerli_StableSwapAddLiquidityEvent!]!
  stagingoptimismgoerli_stableSwapRemoveLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingoptimismgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): stagingoptimismgoerli_StableSwapRemoveLiquidityEvent
  stagingoptimismgoerli_stableSwapRemoveLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: stagingoptimismgoerli_StableSwapRemoveLiquidityEvent_orderBy
    orderDirection: stagingoptimismgoerli_OrderDirection
    where: stagingoptimismgoerli_StableSwapRemoveLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingoptimismgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [stagingoptimismgoerli_StableSwapRemoveLiquidityEvent!]!
  stagingoptimismgoerli_stableSwapExchange(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingoptimismgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): stagingoptimismgoerli_StableSwapExchange
  stagingoptimismgoerli_stableSwapExchanges(
    skip: Int = 0
    first: Int = 100
    orderBy: stagingoptimismgoerli_StableSwapExchange_orderBy
    orderDirection: stagingoptimismgoerli_OrderDirection
    where: stagingoptimismgoerli_StableSwapExchange_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingoptimismgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [stagingoptimismgoerli_StableSwapExchange!]!
  stagingoptimismgoerli_swapDailyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingoptimismgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): stagingoptimismgoerli_SwapDailyVolume
  stagingoptimismgoerli_swapDailyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: stagingoptimismgoerli_SwapDailyVolume_orderBy
    orderDirection: stagingoptimismgoerli_OrderDirection
    where: stagingoptimismgoerli_SwapDailyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingoptimismgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [stagingoptimismgoerli_SwapDailyVolume!]!
  stagingoptimismgoerli_swapHourlyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingoptimismgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): stagingoptimismgoerli_SwapHourlyVolume
  stagingoptimismgoerli_swapHourlyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: stagingoptimismgoerli_SwapHourlyVolume_orderBy
    orderDirection: stagingoptimismgoerli_OrderDirection
    where: stagingoptimismgoerli_SwapHourlyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingoptimismgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [stagingoptimismgoerli_SwapHourlyVolume!]!
  stagingoptimismgoerli_swapWeeklyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingoptimismgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): stagingoptimismgoerli_SwapWeeklyVolume
  stagingoptimismgoerli_swapWeeklyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: stagingoptimismgoerli_SwapWeeklyVolume_orderBy
    orderDirection: stagingoptimismgoerli_OrderDirection
    where: stagingoptimismgoerli_SwapWeeklyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingoptimismgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [stagingoptimismgoerli_SwapWeeklyVolume!]!
  stagingoptimismgoerli_stableSwapEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingoptimismgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): stagingoptimismgoerli_StableSwapEvent
  stagingoptimismgoerli_stableSwapEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: stagingoptimismgoerli_StableSwapEvent_orderBy
    orderDirection: stagingoptimismgoerli_OrderDirection
    where: stagingoptimismgoerli_StableSwapEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingoptimismgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [stagingoptimismgoerli_StableSwapEvent!]!
  stagingoptimismgoerli_swapTradeVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingoptimismgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): stagingoptimismgoerli_SwapTradeVolume
  stagingoptimismgoerli_swapTradeVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: stagingoptimismgoerli_SwapTradeVolume_orderBy
    orderDirection: stagingoptimismgoerli_OrderDirection
    where: stagingoptimismgoerli_SwapTradeVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingoptimismgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [stagingoptimismgoerli_SwapTradeVolume!]!
  """Access to subgraph metadata"""
  stagingoptimismgoerli__meta(block: stagingoptimismgoerli_Block_height): stagingoptimismgoerli__Meta_
  optimism_systemInfo(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): optimism_SystemInfo
  optimism_systemInfos(
    skip: Int = 0
    first: Int = 100
    orderBy: optimism_SystemInfo_orderBy
    orderDirection: optimism_OrderDirection
    where: optimism_SystemInfo_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [optimism_SystemInfo!]!
  optimism_pooledToken(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): optimism_PooledToken
  optimism_pooledTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: optimism_PooledToken_orderBy
    orderDirection: optimism_OrderDirection
    where: optimism_PooledToken_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [optimism_PooledToken!]!
  optimism_stableSwap(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): optimism_StableSwap
  optimism_stableSwaps(
    skip: Int = 0
    first: Int = 100
    orderBy: optimism_StableSwap_orderBy
    orderDirection: optimism_OrderDirection
    where: optimism_StableSwap_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [optimism_StableSwap!]!
  optimism_stableSwapAddLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): optimism_StableSwapAddLiquidityEvent
  optimism_stableSwapAddLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: optimism_StableSwapAddLiquidityEvent_orderBy
    orderDirection: optimism_OrderDirection
    where: optimism_StableSwapAddLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [optimism_StableSwapAddLiquidityEvent!]!
  optimism_stableSwapRemoveLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): optimism_StableSwapRemoveLiquidityEvent
  optimism_stableSwapRemoveLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: optimism_StableSwapRemoveLiquidityEvent_orderBy
    orderDirection: optimism_OrderDirection
    where: optimism_StableSwapRemoveLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [optimism_StableSwapRemoveLiquidityEvent!]!
  optimism_stableSwapExchange(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): optimism_StableSwapExchange
  optimism_stableSwapExchanges(
    skip: Int = 0
    first: Int = 100
    orderBy: optimism_StableSwapExchange_orderBy
    orderDirection: optimism_OrderDirection
    where: optimism_StableSwapExchange_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [optimism_StableSwapExchange!]!
  optimism_swapDailyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): optimism_SwapDailyVolume
  optimism_swapDailyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: optimism_SwapDailyVolume_orderBy
    orderDirection: optimism_OrderDirection
    where: optimism_SwapDailyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [optimism_SwapDailyVolume!]!
  optimism_swapHourlyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): optimism_SwapHourlyVolume
  optimism_swapHourlyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: optimism_SwapHourlyVolume_orderBy
    orderDirection: optimism_OrderDirection
    where: optimism_SwapHourlyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [optimism_SwapHourlyVolume!]!
  optimism_swapWeeklyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): optimism_SwapWeeklyVolume
  optimism_swapWeeklyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: optimism_SwapWeeklyVolume_orderBy
    orderDirection: optimism_OrderDirection
    where: optimism_SwapWeeklyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [optimism_SwapWeeklyVolume!]!
  optimism_stableSwapEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): optimism_StableSwapEvent
  optimism_stableSwapEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: optimism_StableSwapEvent_orderBy
    orderDirection: optimism_OrderDirection
    where: optimism_StableSwapEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [optimism_StableSwapEvent!]!
  optimism_swapTradeVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): optimism_SwapTradeVolume
  optimism_swapTradeVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: optimism_SwapTradeVolume_orderBy
    orderDirection: optimism_OrderDirection
    where: optimism_SwapTradeVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [optimism_SwapTradeVolume!]!
  """Access to subgraph metadata"""
  optimism__meta(block: optimism_Block_height): optimism__Meta_
  polygon_systemInfo(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygon_SystemInfo
  polygon_systemInfos(
    skip: Int = 0
    first: Int = 100
    orderBy: polygon_SystemInfo_orderBy
    orderDirection: polygon_OrderDirection
    where: polygon_SystemInfo_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygon_SystemInfo!]!
  polygon_pooledToken(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygon_PooledToken
  polygon_pooledTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: polygon_PooledToken_orderBy
    orderDirection: polygon_OrderDirection
    where: polygon_PooledToken_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygon_PooledToken!]!
  polygon_stableSwap(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygon_StableSwap
  polygon_stableSwaps(
    skip: Int = 0
    first: Int = 100
    orderBy: polygon_StableSwap_orderBy
    orderDirection: polygon_OrderDirection
    where: polygon_StableSwap_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygon_StableSwap!]!
  polygon_stableSwapAddLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygon_StableSwapAddLiquidityEvent
  polygon_stableSwapAddLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: polygon_StableSwapAddLiquidityEvent_orderBy
    orderDirection: polygon_OrderDirection
    where: polygon_StableSwapAddLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygon_StableSwapAddLiquidityEvent!]!
  polygon_stableSwapRemoveLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygon_StableSwapRemoveLiquidityEvent
  polygon_stableSwapRemoveLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: polygon_StableSwapRemoveLiquidityEvent_orderBy
    orderDirection: polygon_OrderDirection
    where: polygon_StableSwapRemoveLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygon_StableSwapRemoveLiquidityEvent!]!
  polygon_stableSwapExchange(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygon_StableSwapExchange
  polygon_stableSwapExchanges(
    skip: Int = 0
    first: Int = 100
    orderBy: polygon_StableSwapExchange_orderBy
    orderDirection: polygon_OrderDirection
    where: polygon_StableSwapExchange_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygon_StableSwapExchange!]!
  polygon_swapDailyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygon_SwapDailyVolume
  polygon_swapDailyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: polygon_SwapDailyVolume_orderBy
    orderDirection: polygon_OrderDirection
    where: polygon_SwapDailyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygon_SwapDailyVolume!]!
  polygon_swapHourlyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygon_SwapHourlyVolume
  polygon_swapHourlyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: polygon_SwapHourlyVolume_orderBy
    orderDirection: polygon_OrderDirection
    where: polygon_SwapHourlyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygon_SwapHourlyVolume!]!
  polygon_swapWeeklyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygon_SwapWeeklyVolume
  polygon_swapWeeklyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: polygon_SwapWeeklyVolume_orderBy
    orderDirection: polygon_OrderDirection
    where: polygon_SwapWeeklyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygon_SwapWeeklyVolume!]!
  polygon_stableSwapEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygon_StableSwapEvent
  polygon_stableSwapEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: polygon_StableSwapEvent_orderBy
    orderDirection: polygon_OrderDirection
    where: polygon_StableSwapEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygon_StableSwapEvent!]!
  polygon_swapTradeVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygon_SwapTradeVolume
  polygon_swapTradeVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: polygon_SwapTradeVolume_orderBy
    orderDirection: polygon_OrderDirection
    where: polygon_SwapTradeVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygon_SwapTradeVolume!]!
  """Access to subgraph metadata"""
  polygon__meta(block: polygon_Block_height): polygon__Meta_
  staginggoerli_systemInfo(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: staginggoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): staginggoerli_SystemInfo
  staginggoerli_systemInfos(
    skip: Int = 0
    first: Int = 100
    orderBy: staginggoerli_SystemInfo_orderBy
    orderDirection: staginggoerli_OrderDirection
    where: staginggoerli_SystemInfo_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: staginggoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [staginggoerli_SystemInfo!]!
  staginggoerli_pooledToken(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: staginggoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): staginggoerli_PooledToken
  staginggoerli_pooledTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: staginggoerli_PooledToken_orderBy
    orderDirection: staginggoerli_OrderDirection
    where: staginggoerli_PooledToken_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: staginggoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [staginggoerli_PooledToken!]!
  staginggoerli_stableSwap(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: staginggoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): staginggoerli_StableSwap
  staginggoerli_stableSwaps(
    skip: Int = 0
    first: Int = 100
    orderBy: staginggoerli_StableSwap_orderBy
    orderDirection: staginggoerli_OrderDirection
    where: staginggoerli_StableSwap_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: staginggoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [staginggoerli_StableSwap!]!
  staginggoerli_stableSwapAddLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: staginggoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): staginggoerli_StableSwapAddLiquidityEvent
  staginggoerli_stableSwapAddLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: staginggoerli_StableSwapAddLiquidityEvent_orderBy
    orderDirection: staginggoerli_OrderDirection
    where: staginggoerli_StableSwapAddLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: staginggoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [staginggoerli_StableSwapAddLiquidityEvent!]!
  staginggoerli_stableSwapRemoveLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: staginggoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): staginggoerli_StableSwapRemoveLiquidityEvent
  staginggoerli_stableSwapRemoveLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: staginggoerli_StableSwapRemoveLiquidityEvent_orderBy
    orderDirection: staginggoerli_OrderDirection
    where: staginggoerli_StableSwapRemoveLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: staginggoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [staginggoerli_StableSwapRemoveLiquidityEvent!]!
  staginggoerli_stableSwapExchange(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: staginggoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): staginggoerli_StableSwapExchange
  staginggoerli_stableSwapExchanges(
    skip: Int = 0
    first: Int = 100
    orderBy: staginggoerli_StableSwapExchange_orderBy
    orderDirection: staginggoerli_OrderDirection
    where: staginggoerli_StableSwapExchange_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: staginggoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [staginggoerli_StableSwapExchange!]!
  staginggoerli_swapDailyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: staginggoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): staginggoerli_SwapDailyVolume
  staginggoerli_swapDailyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: staginggoerli_SwapDailyVolume_orderBy
    orderDirection: staginggoerli_OrderDirection
    where: staginggoerli_SwapDailyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: staginggoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [staginggoerli_SwapDailyVolume!]!
  staginggoerli_swapHourlyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: staginggoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): staginggoerli_SwapHourlyVolume
  staginggoerli_swapHourlyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: staginggoerli_SwapHourlyVolume_orderBy
    orderDirection: staginggoerli_OrderDirection
    where: staginggoerli_SwapHourlyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: staginggoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [staginggoerli_SwapHourlyVolume!]!
  staginggoerli_swapWeeklyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: staginggoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): staginggoerli_SwapWeeklyVolume
  staginggoerli_swapWeeklyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: staginggoerli_SwapWeeklyVolume_orderBy
    orderDirection: staginggoerli_OrderDirection
    where: staginggoerli_SwapWeeklyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: staginggoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [staginggoerli_SwapWeeklyVolume!]!
  staginggoerli_stableSwapEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: staginggoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): staginggoerli_StableSwapEvent
  staginggoerli_stableSwapEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: staginggoerli_StableSwapEvent_orderBy
    orderDirection: staginggoerli_OrderDirection
    where: staginggoerli_StableSwapEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: staginggoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [staginggoerli_StableSwapEvent!]!
  staginggoerli_swapTradeVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: staginggoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): staginggoerli_SwapTradeVolume
  staginggoerli_swapTradeVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: staginggoerli_SwapTradeVolume_orderBy
    orderDirection: staginggoerli_OrderDirection
    where: staginggoerli_SwapTradeVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: staginggoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [staginggoerli_SwapTradeVolume!]!
  """Access to subgraph metadata"""
  staginggoerli__meta(block: staginggoerli_Block_height): staginggoerli__Meta_
  arbitrumgoerli_systemInfo(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): arbitrumgoerli_SystemInfo
  arbitrumgoerli_systemInfos(
    skip: Int = 0
    first: Int = 100
    orderBy: arbitrumgoerli_SystemInfo_orderBy
    orderDirection: arbitrumgoerli_OrderDirection
    where: arbitrumgoerli_SystemInfo_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [arbitrumgoerli_SystemInfo!]!
  arbitrumgoerli_pooledToken(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): arbitrumgoerli_PooledToken
  arbitrumgoerli_pooledTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: arbitrumgoerli_PooledToken_orderBy
    orderDirection: arbitrumgoerli_OrderDirection
    where: arbitrumgoerli_PooledToken_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [arbitrumgoerli_PooledToken!]!
  arbitrumgoerli_stableSwap(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): arbitrumgoerli_StableSwap
  arbitrumgoerli_stableSwaps(
    skip: Int = 0
    first: Int = 100
    orderBy: arbitrumgoerli_StableSwap_orderBy
    orderDirection: arbitrumgoerli_OrderDirection
    where: arbitrumgoerli_StableSwap_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [arbitrumgoerli_StableSwap!]!
  arbitrumgoerli_stableSwapAddLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): arbitrumgoerli_StableSwapAddLiquidityEvent
  arbitrumgoerli_stableSwapAddLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: arbitrumgoerli_StableSwapAddLiquidityEvent_orderBy
    orderDirection: arbitrumgoerli_OrderDirection
    where: arbitrumgoerli_StableSwapAddLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [arbitrumgoerli_StableSwapAddLiquidityEvent!]!
  arbitrumgoerli_stableSwapRemoveLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): arbitrumgoerli_StableSwapRemoveLiquidityEvent
  arbitrumgoerli_stableSwapRemoveLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: arbitrumgoerli_StableSwapRemoveLiquidityEvent_orderBy
    orderDirection: arbitrumgoerli_OrderDirection
    where: arbitrumgoerli_StableSwapRemoveLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [arbitrumgoerli_StableSwapRemoveLiquidityEvent!]!
  arbitrumgoerli_stableSwapExchange(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): arbitrumgoerli_StableSwapExchange
  arbitrumgoerli_stableSwapExchanges(
    skip: Int = 0
    first: Int = 100
    orderBy: arbitrumgoerli_StableSwapExchange_orderBy
    orderDirection: arbitrumgoerli_OrderDirection
    where: arbitrumgoerli_StableSwapExchange_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [arbitrumgoerli_StableSwapExchange!]!
  arbitrumgoerli_swapDailyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): arbitrumgoerli_SwapDailyVolume
  arbitrumgoerli_swapDailyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: arbitrumgoerli_SwapDailyVolume_orderBy
    orderDirection: arbitrumgoerli_OrderDirection
    where: arbitrumgoerli_SwapDailyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [arbitrumgoerli_SwapDailyVolume!]!
  arbitrumgoerli_swapHourlyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): arbitrumgoerli_SwapHourlyVolume
  arbitrumgoerli_swapHourlyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: arbitrumgoerli_SwapHourlyVolume_orderBy
    orderDirection: arbitrumgoerli_OrderDirection
    where: arbitrumgoerli_SwapHourlyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [arbitrumgoerli_SwapHourlyVolume!]!
  arbitrumgoerli_swapWeeklyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): arbitrumgoerli_SwapWeeklyVolume
  arbitrumgoerli_swapWeeklyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: arbitrumgoerli_SwapWeeklyVolume_orderBy
    orderDirection: arbitrumgoerli_OrderDirection
    where: arbitrumgoerli_SwapWeeklyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [arbitrumgoerli_SwapWeeklyVolume!]!
  arbitrumgoerli_stableSwapEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): arbitrumgoerli_StableSwapEvent
  arbitrumgoerli_stableSwapEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: arbitrumgoerli_StableSwapEvent_orderBy
    orderDirection: arbitrumgoerli_OrderDirection
    where: arbitrumgoerli_StableSwapEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [arbitrumgoerli_StableSwapEvent!]!
  arbitrumgoerli_swapTradeVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): arbitrumgoerli_SwapTradeVolume
  arbitrumgoerli_swapTradeVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: arbitrumgoerli_SwapTradeVolume_orderBy
    orderDirection: arbitrumgoerli_OrderDirection
    where: arbitrumgoerli_SwapTradeVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [arbitrumgoerli_SwapTradeVolume!]!
  """Access to subgraph metadata"""
  arbitrumgoerli__meta(block: arbitrumgoerli_Block_height): arbitrumgoerli__Meta_
  optimismgoerli_systemInfo(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimismgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): optimismgoerli_SystemInfo
  optimismgoerli_systemInfos(
    skip: Int = 0
    first: Int = 100
    orderBy: optimismgoerli_SystemInfo_orderBy
    orderDirection: optimismgoerli_OrderDirection
    where: optimismgoerli_SystemInfo_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimismgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [optimismgoerli_SystemInfo!]!
  optimismgoerli_pooledToken(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimismgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): optimismgoerli_PooledToken
  optimismgoerli_pooledTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: optimismgoerli_PooledToken_orderBy
    orderDirection: optimismgoerli_OrderDirection
    where: optimismgoerli_PooledToken_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimismgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [optimismgoerli_PooledToken!]!
  optimismgoerli_stableSwap(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimismgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): optimismgoerli_StableSwap
  optimismgoerli_stableSwaps(
    skip: Int = 0
    first: Int = 100
    orderBy: optimismgoerli_StableSwap_orderBy
    orderDirection: optimismgoerli_OrderDirection
    where: optimismgoerli_StableSwap_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimismgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [optimismgoerli_StableSwap!]!
  optimismgoerli_stableSwapAddLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimismgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): optimismgoerli_StableSwapAddLiquidityEvent
  optimismgoerli_stableSwapAddLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: optimismgoerli_StableSwapAddLiquidityEvent_orderBy
    orderDirection: optimismgoerli_OrderDirection
    where: optimismgoerli_StableSwapAddLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimismgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [optimismgoerli_StableSwapAddLiquidityEvent!]!
  optimismgoerli_stableSwapRemoveLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimismgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): optimismgoerli_StableSwapRemoveLiquidityEvent
  optimismgoerli_stableSwapRemoveLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: optimismgoerli_StableSwapRemoveLiquidityEvent_orderBy
    orderDirection: optimismgoerli_OrderDirection
    where: optimismgoerli_StableSwapRemoveLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimismgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [optimismgoerli_StableSwapRemoveLiquidityEvent!]!
  optimismgoerli_stableSwapExchange(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimismgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): optimismgoerli_StableSwapExchange
  optimismgoerli_stableSwapExchanges(
    skip: Int = 0
    first: Int = 100
    orderBy: optimismgoerli_StableSwapExchange_orderBy
    orderDirection: optimismgoerli_OrderDirection
    where: optimismgoerli_StableSwapExchange_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimismgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [optimismgoerli_StableSwapExchange!]!
  optimismgoerli_swapDailyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimismgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): optimismgoerli_SwapDailyVolume
  optimismgoerli_swapDailyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: optimismgoerli_SwapDailyVolume_orderBy
    orderDirection: optimismgoerli_OrderDirection
    where: optimismgoerli_SwapDailyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimismgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [optimismgoerli_SwapDailyVolume!]!
  optimismgoerli_swapHourlyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimismgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): optimismgoerli_SwapHourlyVolume
  optimismgoerli_swapHourlyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: optimismgoerli_SwapHourlyVolume_orderBy
    orderDirection: optimismgoerli_OrderDirection
    where: optimismgoerli_SwapHourlyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimismgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [optimismgoerli_SwapHourlyVolume!]!
  optimismgoerli_swapWeeklyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimismgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): optimismgoerli_SwapWeeklyVolume
  optimismgoerli_swapWeeklyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: optimismgoerli_SwapWeeklyVolume_orderBy
    orderDirection: optimismgoerli_OrderDirection
    where: optimismgoerli_SwapWeeklyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimismgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [optimismgoerli_SwapWeeklyVolume!]!
  optimismgoerli_stableSwapEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimismgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): optimismgoerli_StableSwapEvent
  optimismgoerli_stableSwapEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: optimismgoerli_StableSwapEvent_orderBy
    orderDirection: optimismgoerli_OrderDirection
    where: optimismgoerli_StableSwapEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimismgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [optimismgoerli_StableSwapEvent!]!
  optimismgoerli_swapTradeVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimismgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): optimismgoerli_SwapTradeVolume
  optimismgoerli_swapTradeVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: optimismgoerli_SwapTradeVolume_orderBy
    orderDirection: optimismgoerli_OrderDirection
    where: optimismgoerli_SwapTradeVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimismgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [optimismgoerli_SwapTradeVolume!]!
  """Access to subgraph metadata"""
  optimismgoerli__meta(block: optimismgoerli_Block_height): optimismgoerli__Meta_
  stagingmumbai_systemInfo(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingmumbai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): stagingmumbai_SystemInfo
  stagingmumbai_systemInfos(
    skip: Int = 0
    first: Int = 100
    orderBy: stagingmumbai_SystemInfo_orderBy
    orderDirection: stagingmumbai_OrderDirection
    where: stagingmumbai_SystemInfo_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingmumbai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [stagingmumbai_SystemInfo!]!
  stagingmumbai_pooledToken(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingmumbai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): stagingmumbai_PooledToken
  stagingmumbai_pooledTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: stagingmumbai_PooledToken_orderBy
    orderDirection: stagingmumbai_OrderDirection
    where: stagingmumbai_PooledToken_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingmumbai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [stagingmumbai_PooledToken!]!
  stagingmumbai_stableSwap(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingmumbai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): stagingmumbai_StableSwap
  stagingmumbai_stableSwaps(
    skip: Int = 0
    first: Int = 100
    orderBy: stagingmumbai_StableSwap_orderBy
    orderDirection: stagingmumbai_OrderDirection
    where: stagingmumbai_StableSwap_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingmumbai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [stagingmumbai_StableSwap!]!
  stagingmumbai_stableSwapAddLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingmumbai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): stagingmumbai_StableSwapAddLiquidityEvent
  stagingmumbai_stableSwapAddLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: stagingmumbai_StableSwapAddLiquidityEvent_orderBy
    orderDirection: stagingmumbai_OrderDirection
    where: stagingmumbai_StableSwapAddLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingmumbai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [stagingmumbai_StableSwapAddLiquidityEvent!]!
  stagingmumbai_stableSwapRemoveLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingmumbai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): stagingmumbai_StableSwapRemoveLiquidityEvent
  stagingmumbai_stableSwapRemoveLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: stagingmumbai_StableSwapRemoveLiquidityEvent_orderBy
    orderDirection: stagingmumbai_OrderDirection
    where: stagingmumbai_StableSwapRemoveLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingmumbai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [stagingmumbai_StableSwapRemoveLiquidityEvent!]!
  stagingmumbai_stableSwapExchange(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingmumbai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): stagingmumbai_StableSwapExchange
  stagingmumbai_stableSwapExchanges(
    skip: Int = 0
    first: Int = 100
    orderBy: stagingmumbai_StableSwapExchange_orderBy
    orderDirection: stagingmumbai_OrderDirection
    where: stagingmumbai_StableSwapExchange_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingmumbai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [stagingmumbai_StableSwapExchange!]!
  stagingmumbai_swapDailyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingmumbai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): stagingmumbai_SwapDailyVolume
  stagingmumbai_swapDailyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: stagingmumbai_SwapDailyVolume_orderBy
    orderDirection: stagingmumbai_OrderDirection
    where: stagingmumbai_SwapDailyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingmumbai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [stagingmumbai_SwapDailyVolume!]!
  stagingmumbai_swapHourlyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingmumbai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): stagingmumbai_SwapHourlyVolume
  stagingmumbai_swapHourlyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: stagingmumbai_SwapHourlyVolume_orderBy
    orderDirection: stagingmumbai_OrderDirection
    where: stagingmumbai_SwapHourlyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingmumbai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [stagingmumbai_SwapHourlyVolume!]!
  stagingmumbai_swapWeeklyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingmumbai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): stagingmumbai_SwapWeeklyVolume
  stagingmumbai_swapWeeklyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: stagingmumbai_SwapWeeklyVolume_orderBy
    orderDirection: stagingmumbai_OrderDirection
    where: stagingmumbai_SwapWeeklyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingmumbai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [stagingmumbai_SwapWeeklyVolume!]!
  stagingmumbai_stableSwapEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingmumbai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): stagingmumbai_StableSwapEvent
  stagingmumbai_stableSwapEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: stagingmumbai_StableSwapEvent_orderBy
    orderDirection: stagingmumbai_OrderDirection
    where: stagingmumbai_StableSwapEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingmumbai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [stagingmumbai_StableSwapEvent!]!
  stagingmumbai_swapTradeVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingmumbai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): stagingmumbai_SwapTradeVolume
  stagingmumbai_swapTradeVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: stagingmumbai_SwapTradeVolume_orderBy
    orderDirection: stagingmumbai_OrderDirection
    where: stagingmumbai_SwapTradeVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingmumbai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [stagingmumbai_SwapTradeVolume!]!
  """Access to subgraph metadata"""
  stagingmumbai__meta(block: stagingmumbai_Block_height): stagingmumbai__Meta_
  stagingarbitrumgoerli_systemInfo(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingarbitrumgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): stagingarbitrumgoerli_SystemInfo
  stagingarbitrumgoerli_systemInfos(
    skip: Int = 0
    first: Int = 100
    orderBy: stagingarbitrumgoerli_SystemInfo_orderBy
    orderDirection: stagingarbitrumgoerli_OrderDirection
    where: stagingarbitrumgoerli_SystemInfo_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingarbitrumgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [stagingarbitrumgoerli_SystemInfo!]!
  stagingarbitrumgoerli_pooledToken(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingarbitrumgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): stagingarbitrumgoerli_PooledToken
  stagingarbitrumgoerli_pooledTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: stagingarbitrumgoerli_PooledToken_orderBy
    orderDirection: stagingarbitrumgoerli_OrderDirection
    where: stagingarbitrumgoerli_PooledToken_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingarbitrumgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [stagingarbitrumgoerli_PooledToken!]!
  stagingarbitrumgoerli_stableSwap(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingarbitrumgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): stagingarbitrumgoerli_StableSwap
  stagingarbitrumgoerli_stableSwaps(
    skip: Int = 0
    first: Int = 100
    orderBy: stagingarbitrumgoerli_StableSwap_orderBy
    orderDirection: stagingarbitrumgoerli_OrderDirection
    where: stagingarbitrumgoerli_StableSwap_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingarbitrumgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [stagingarbitrumgoerli_StableSwap!]!
  stagingarbitrumgoerli_stableSwapAddLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingarbitrumgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): stagingarbitrumgoerli_StableSwapAddLiquidityEvent
  stagingarbitrumgoerli_stableSwapAddLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: stagingarbitrumgoerli_StableSwapAddLiquidityEvent_orderBy
    orderDirection: stagingarbitrumgoerli_OrderDirection
    where: stagingarbitrumgoerli_StableSwapAddLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingarbitrumgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [stagingarbitrumgoerli_StableSwapAddLiquidityEvent!]!
  stagingarbitrumgoerli_stableSwapRemoveLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingarbitrumgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): stagingarbitrumgoerli_StableSwapRemoveLiquidityEvent
  stagingarbitrumgoerli_stableSwapRemoveLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: stagingarbitrumgoerli_StableSwapRemoveLiquidityEvent_orderBy
    orderDirection: stagingarbitrumgoerli_OrderDirection
    where: stagingarbitrumgoerli_StableSwapRemoveLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingarbitrumgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [stagingarbitrumgoerli_StableSwapRemoveLiquidityEvent!]!
  stagingarbitrumgoerli_stableSwapExchange(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingarbitrumgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): stagingarbitrumgoerli_StableSwapExchange
  stagingarbitrumgoerli_stableSwapExchanges(
    skip: Int = 0
    first: Int = 100
    orderBy: stagingarbitrumgoerli_StableSwapExchange_orderBy
    orderDirection: stagingarbitrumgoerli_OrderDirection
    where: stagingarbitrumgoerli_StableSwapExchange_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingarbitrumgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [stagingarbitrumgoerli_StableSwapExchange!]!
  stagingarbitrumgoerli_swapDailyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingarbitrumgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): stagingarbitrumgoerli_SwapDailyVolume
  stagingarbitrumgoerli_swapDailyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: stagingarbitrumgoerli_SwapDailyVolume_orderBy
    orderDirection: stagingarbitrumgoerli_OrderDirection
    where: stagingarbitrumgoerli_SwapDailyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingarbitrumgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [stagingarbitrumgoerli_SwapDailyVolume!]!
  stagingarbitrumgoerli_swapHourlyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingarbitrumgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): stagingarbitrumgoerli_SwapHourlyVolume
  stagingarbitrumgoerli_swapHourlyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: stagingarbitrumgoerli_SwapHourlyVolume_orderBy
    orderDirection: stagingarbitrumgoerli_OrderDirection
    where: stagingarbitrumgoerli_SwapHourlyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingarbitrumgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [stagingarbitrumgoerli_SwapHourlyVolume!]!
  stagingarbitrumgoerli_swapWeeklyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingarbitrumgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): stagingarbitrumgoerli_SwapWeeklyVolume
  stagingarbitrumgoerli_swapWeeklyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: stagingarbitrumgoerli_SwapWeeklyVolume_orderBy
    orderDirection: stagingarbitrumgoerli_OrderDirection
    where: stagingarbitrumgoerli_SwapWeeklyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingarbitrumgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [stagingarbitrumgoerli_SwapWeeklyVolume!]!
  stagingarbitrumgoerli_stableSwapEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingarbitrumgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): stagingarbitrumgoerli_StableSwapEvent
  stagingarbitrumgoerli_stableSwapEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: stagingarbitrumgoerli_StableSwapEvent_orderBy
    orderDirection: stagingarbitrumgoerli_OrderDirection
    where: stagingarbitrumgoerli_StableSwapEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingarbitrumgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [stagingarbitrumgoerli_StableSwapEvent!]!
  stagingarbitrumgoerli_swapTradeVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingarbitrumgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): stagingarbitrumgoerli_SwapTradeVolume
  stagingarbitrumgoerli_swapTradeVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: stagingarbitrumgoerli_SwapTradeVolume_orderBy
    orderDirection: stagingarbitrumgoerli_OrderDirection
    where: stagingarbitrumgoerli_SwapTradeVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: stagingarbitrumgoerli_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [stagingarbitrumgoerli_SwapTradeVolume!]!
  """Access to subgraph metadata"""
  stagingarbitrumgoerli__meta(block: stagingarbitrumgoerli_Block_height): stagingarbitrumgoerli__Meta_
}

scalar mumbai_BigDecimal

scalar BigInt

input mumbai_BlockChangedFilter {
  number_gte: Int!
}

input mumbai_Block_height {
  hash: mumbai_Bytes
  number: Int
  number_gte: Int
}

scalar mumbai_Bytes

"""Defines the order direction, either ascending or descending"""
enum mumbai_OrderDirection {
  asc
  desc
}

type mumbai_PooledToken {
  id: ID!
  asset: mumbai_Bytes!
}

input mumbai_PooledToken_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  asset: mumbai_Bytes
  asset_not: mumbai_Bytes
  asset_gt: mumbai_Bytes
  asset_lt: mumbai_Bytes
  asset_gte: mumbai_Bytes
  asset_lte: mumbai_Bytes
  asset_in: [mumbai_Bytes!]
  asset_not_in: [mumbai_Bytes!]
  asset_contains: mumbai_Bytes
  asset_not_contains: mumbai_Bytes
  """Filter for the block changed event."""
  _change_block: mumbai_BlockChangedFilter
}

enum mumbai_PooledToken_orderBy {
  id
  asset
}

type mumbai_StableSwap {
  id: ID!
  isActive: Boolean
  key: mumbai_Bytes!
  canonicalId: mumbai_Bytes
  domain: BigInt
  swapPool: mumbai_Bytes
  lpToken: mumbai_Bytes
  initialA: BigInt
  futureA: BigInt
  initialATime: BigInt
  futureATime: BigInt
  swapFee: BigInt
  adminFee: BigInt
  pooledTokens(skip: Int = 0, first: Int = 100, orderBy: mumbai_PooledToken_orderBy, orderDirection: mumbai_OrderDirection, where: mumbai_PooledToken_filter): [mumbai_PooledToken!]!
  tokenPrecisionMultipliers: [BigInt!]!
  balances: [BigInt!]!
  adminFees: [BigInt!]!
  virtualPrice: BigInt!
  invariant: BigInt!
  lpTokenSupply: BigInt!
  events(skip: Int = 0, first: Int = 100, orderBy: mumbai_StableSwapEvent_orderBy, orderDirection: mumbai_OrderDirection, where: mumbai_StableSwapEvent_filter): [mumbai_StableSwapEvent!]
  exchanges(skip: Int = 0, first: Int = 100, orderBy: mumbai_StableSwapExchange_orderBy, orderDirection: mumbai_OrderDirection, where: mumbai_StableSwapExchange_filter): [mumbai_StableSwapExchange!]
  hourlyVolumes(skip: Int = 0, first: Int = 100, orderBy: mumbai_SwapHourlyVolume_orderBy, orderDirection: mumbai_OrderDirection, where: mumbai_SwapHourlyVolume_filter): [mumbai_SwapHourlyVolume!]
  dailyVolumes(skip: Int = 0, first: Int = 100, orderBy: mumbai_SwapDailyVolume_orderBy, orderDirection: mumbai_OrderDirection, where: mumbai_SwapDailyVolume_filter): [mumbai_SwapDailyVolume!]
  weeklyVolumes(skip: Int = 0, first: Int = 100, orderBy: mumbai_SwapWeeklyVolume_orderBy, orderDirection: mumbai_OrderDirection, where: mumbai_SwapWeeklyVolume_filter): [mumbai_SwapWeeklyVolume!]
}

type mumbai_StableSwapAddLiquidityEvent implements mumbai_StableSwapEvent {
  id: ID!
  stableSwap: mumbai_StableSwap!
  provider: mumbai_Bytes!
  tokenAmounts: [BigInt!]!
  fees: [BigInt!]!
  invariant: BigInt
  lpTokenSupply: BigInt!
  block: BigInt!
  timestamp: BigInt!
  transaction: mumbai_Bytes!
}

input mumbai_StableSwapAddLiquidityEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: mumbai_StableSwap_filter
  provider: mumbai_Bytes
  provider_not: mumbai_Bytes
  provider_gt: mumbai_Bytes
  provider_lt: mumbai_Bytes
  provider_gte: mumbai_Bytes
  provider_lte: mumbai_Bytes
  provider_in: [mumbai_Bytes!]
  provider_not_in: [mumbai_Bytes!]
  provider_contains: mumbai_Bytes
  provider_not_contains: mumbai_Bytes
  tokenAmounts: [BigInt!]
  tokenAmounts_not: [BigInt!]
  tokenAmounts_contains: [BigInt!]
  tokenAmounts_contains_nocase: [BigInt!]
  tokenAmounts_not_contains: [BigInt!]
  tokenAmounts_not_contains_nocase: [BigInt!]
  fees: [BigInt!]
  fees_not: [BigInt!]
  fees_contains: [BigInt!]
  fees_contains_nocase: [BigInt!]
  fees_not_contains: [BigInt!]
  fees_not_contains_nocase: [BigInt!]
  invariant: BigInt
  invariant_not: BigInt
  invariant_gt: BigInt
  invariant_lt: BigInt
  invariant_gte: BigInt
  invariant_lte: BigInt
  invariant_in: [BigInt!]
  invariant_not_in: [BigInt!]
  lpTokenSupply: BigInt
  lpTokenSupply_not: BigInt
  lpTokenSupply_gt: BigInt
  lpTokenSupply_lt: BigInt
  lpTokenSupply_gte: BigInt
  lpTokenSupply_lte: BigInt
  lpTokenSupply_in: [BigInt!]
  lpTokenSupply_not_in: [BigInt!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: mumbai_Bytes
  transaction_not: mumbai_Bytes
  transaction_gt: mumbai_Bytes
  transaction_lt: mumbai_Bytes
  transaction_gte: mumbai_Bytes
  transaction_lte: mumbai_Bytes
  transaction_in: [mumbai_Bytes!]
  transaction_not_in: [mumbai_Bytes!]
  transaction_contains: mumbai_Bytes
  transaction_not_contains: mumbai_Bytes
  """Filter for the block changed event."""
  _change_block: mumbai_BlockChangedFilter
}

enum mumbai_StableSwapAddLiquidityEvent_orderBy {
  id
  stableSwap
  provider
  tokenAmounts
  fees
  invariant
  lpTokenSupply
  block
  timestamp
  transaction
}

interface mumbai_StableSwapEvent {
  id: ID!
  stableSwap: mumbai_StableSwap!
  block: BigInt!
  timestamp: BigInt!
  transaction: mumbai_Bytes!
}

input mumbai_StableSwapEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: mumbai_StableSwap_filter
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: mumbai_Bytes
  transaction_not: mumbai_Bytes
  transaction_gt: mumbai_Bytes
  transaction_lt: mumbai_Bytes
  transaction_gte: mumbai_Bytes
  transaction_lte: mumbai_Bytes
  transaction_in: [mumbai_Bytes!]
  transaction_not_in: [mumbai_Bytes!]
  transaction_contains: mumbai_Bytes
  transaction_not_contains: mumbai_Bytes
  """Filter for the block changed event."""
  _change_block: mumbai_BlockChangedFilter
}

enum mumbai_StableSwapEvent_orderBy {
  id
  stableSwap
  block
  timestamp
  transaction
}

type mumbai_StableSwapExchange {
  id: ID!
  stableSwap: mumbai_StableSwap!
  buyer: mumbai_Bytes!
  boughtId: BigInt!
  tokensBought: BigInt!
  soldId: BigInt!
  tokensSold: BigInt!
  block: BigInt!
  timestamp: BigInt!
  transaction: mumbai_Bytes!
}

input mumbai_StableSwapExchange_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: mumbai_StableSwap_filter
  buyer: mumbai_Bytes
  buyer_not: mumbai_Bytes
  buyer_gt: mumbai_Bytes
  buyer_lt: mumbai_Bytes
  buyer_gte: mumbai_Bytes
  buyer_lte: mumbai_Bytes
  buyer_in: [mumbai_Bytes!]
  buyer_not_in: [mumbai_Bytes!]
  buyer_contains: mumbai_Bytes
  buyer_not_contains: mumbai_Bytes
  boughtId: BigInt
  boughtId_not: BigInt
  boughtId_gt: BigInt
  boughtId_lt: BigInt
  boughtId_gte: BigInt
  boughtId_lte: BigInt
  boughtId_in: [BigInt!]
  boughtId_not_in: [BigInt!]
  tokensBought: BigInt
  tokensBought_not: BigInt
  tokensBought_gt: BigInt
  tokensBought_lt: BigInt
  tokensBought_gte: BigInt
  tokensBought_lte: BigInt
  tokensBought_in: [BigInt!]
  tokensBought_not_in: [BigInt!]
  soldId: BigInt
  soldId_not: BigInt
  soldId_gt: BigInt
  soldId_lt: BigInt
  soldId_gte: BigInt
  soldId_lte: BigInt
  soldId_in: [BigInt!]
  soldId_not_in: [BigInt!]
  tokensSold: BigInt
  tokensSold_not: BigInt
  tokensSold_gt: BigInt
  tokensSold_lt: BigInt
  tokensSold_gte: BigInt
  tokensSold_lte: BigInt
  tokensSold_in: [BigInt!]
  tokensSold_not_in: [BigInt!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: mumbai_Bytes
  transaction_not: mumbai_Bytes
  transaction_gt: mumbai_Bytes
  transaction_lt: mumbai_Bytes
  transaction_gte: mumbai_Bytes
  transaction_lte: mumbai_Bytes
  transaction_in: [mumbai_Bytes!]
  transaction_not_in: [mumbai_Bytes!]
  transaction_contains: mumbai_Bytes
  transaction_not_contains: mumbai_Bytes
  """Filter for the block changed event."""
  _change_block: mumbai_BlockChangedFilter
}

enum mumbai_StableSwapExchange_orderBy {
  id
  stableSwap
  buyer
  boughtId
  tokensBought
  soldId
  tokensSold
  block
  timestamp
  transaction
}

type mumbai_StableSwapRemoveLiquidityEvent implements mumbai_StableSwapEvent {
  id: ID!
  stableSwap: mumbai_StableSwap!
  provider: mumbai_Bytes!
  tokenAmounts: [BigInt!]!
  fees: [BigInt!]
  invariant: BigInt
  lpTokenSupply: BigInt!
  block: BigInt!
  timestamp: BigInt!
  transaction: mumbai_Bytes!
}

input mumbai_StableSwapRemoveLiquidityEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: mumbai_StableSwap_filter
  provider: mumbai_Bytes
  provider_not: mumbai_Bytes
  provider_gt: mumbai_Bytes
  provider_lt: mumbai_Bytes
  provider_gte: mumbai_Bytes
  provider_lte: mumbai_Bytes
  provider_in: [mumbai_Bytes!]
  provider_not_in: [mumbai_Bytes!]
  provider_contains: mumbai_Bytes
  provider_not_contains: mumbai_Bytes
  tokenAmounts: [BigInt!]
  tokenAmounts_not: [BigInt!]
  tokenAmounts_contains: [BigInt!]
  tokenAmounts_contains_nocase: [BigInt!]
  tokenAmounts_not_contains: [BigInt!]
  tokenAmounts_not_contains_nocase: [BigInt!]
  fees: [BigInt!]
  fees_not: [BigInt!]
  fees_contains: [BigInt!]
  fees_contains_nocase: [BigInt!]
  fees_not_contains: [BigInt!]
  fees_not_contains_nocase: [BigInt!]
  invariant: BigInt
  invariant_not: BigInt
  invariant_gt: BigInt
  invariant_lt: BigInt
  invariant_gte: BigInt
  invariant_lte: BigInt
  invariant_in: [BigInt!]
  invariant_not_in: [BigInt!]
  lpTokenSupply: BigInt
  lpTokenSupply_not: BigInt
  lpTokenSupply_gt: BigInt
  lpTokenSupply_lt: BigInt
  lpTokenSupply_gte: BigInt
  lpTokenSupply_lte: BigInt
  lpTokenSupply_in: [BigInt!]
  lpTokenSupply_not_in: [BigInt!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: mumbai_Bytes
  transaction_not: mumbai_Bytes
  transaction_gt: mumbai_Bytes
  transaction_lt: mumbai_Bytes
  transaction_gte: mumbai_Bytes
  transaction_lte: mumbai_Bytes
  transaction_in: [mumbai_Bytes!]
  transaction_not_in: [mumbai_Bytes!]
  transaction_contains: mumbai_Bytes
  transaction_not_contains: mumbai_Bytes
  """Filter for the block changed event."""
  _change_block: mumbai_BlockChangedFilter
}

enum mumbai_StableSwapRemoveLiquidityEvent_orderBy {
  id
  stableSwap
  provider
  tokenAmounts
  fees
  invariant
  lpTokenSupply
  block
  timestamp
  transaction
}

input mumbai_StableSwap_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  isActive: Boolean
  isActive_not: Boolean
  isActive_in: [Boolean!]
  isActive_not_in: [Boolean!]
  key: mumbai_Bytes
  key_not: mumbai_Bytes
  key_gt: mumbai_Bytes
  key_lt: mumbai_Bytes
  key_gte: mumbai_Bytes
  key_lte: mumbai_Bytes
  key_in: [mumbai_Bytes!]
  key_not_in: [mumbai_Bytes!]
  key_contains: mumbai_Bytes
  key_not_contains: mumbai_Bytes
  canonicalId: mumbai_Bytes
  canonicalId_not: mumbai_Bytes
  canonicalId_gt: mumbai_Bytes
  canonicalId_lt: mumbai_Bytes
  canonicalId_gte: mumbai_Bytes
  canonicalId_lte: mumbai_Bytes
  canonicalId_in: [mumbai_Bytes!]
  canonicalId_not_in: [mumbai_Bytes!]
  canonicalId_contains: mumbai_Bytes
  canonicalId_not_contains: mumbai_Bytes
  domain: BigInt
  domain_not: BigInt
  domain_gt: BigInt
  domain_lt: BigInt
  domain_gte: BigInt
  domain_lte: BigInt
  domain_in: [BigInt!]
  domain_not_in: [BigInt!]
  swapPool: mumbai_Bytes
  swapPool_not: mumbai_Bytes
  swapPool_gt: mumbai_Bytes
  swapPool_lt: mumbai_Bytes
  swapPool_gte: mumbai_Bytes
  swapPool_lte: mumbai_Bytes
  swapPool_in: [mumbai_Bytes!]
  swapPool_not_in: [mumbai_Bytes!]
  swapPool_contains: mumbai_Bytes
  swapPool_not_contains: mumbai_Bytes
  lpToken: mumbai_Bytes
  lpToken_not: mumbai_Bytes
  lpToken_gt: mumbai_Bytes
  lpToken_lt: mumbai_Bytes
  lpToken_gte: mumbai_Bytes
  lpToken_lte: mumbai_Bytes
  lpToken_in: [mumbai_Bytes!]
  lpToken_not_in: [mumbai_Bytes!]
  lpToken_contains: mumbai_Bytes
  lpToken_not_contains: mumbai_Bytes
  initialA: BigInt
  initialA_not: BigInt
  initialA_gt: BigInt
  initialA_lt: BigInt
  initialA_gte: BigInt
  initialA_lte: BigInt
  initialA_in: [BigInt!]
  initialA_not_in: [BigInt!]
  futureA: BigInt
  futureA_not: BigInt
  futureA_gt: BigInt
  futureA_lt: BigInt
  futureA_gte: BigInt
  futureA_lte: BigInt
  futureA_in: [BigInt!]
  futureA_not_in: [BigInt!]
  initialATime: BigInt
  initialATime_not: BigInt
  initialATime_gt: BigInt
  initialATime_lt: BigInt
  initialATime_gte: BigInt
  initialATime_lte: BigInt
  initialATime_in: [BigInt!]
  initialATime_not_in: [BigInt!]
  futureATime: BigInt
  futureATime_not: BigInt
  futureATime_gt: BigInt
  futureATime_lt: BigInt
  futureATime_gte: BigInt
  futureATime_lte: BigInt
  futureATime_in: [BigInt!]
  futureATime_not_in: [BigInt!]
  swapFee: BigInt
  swapFee_not: BigInt
  swapFee_gt: BigInt
  swapFee_lt: BigInt
  swapFee_gte: BigInt
  swapFee_lte: BigInt
  swapFee_in: [BigInt!]
  swapFee_not_in: [BigInt!]
  adminFee: BigInt
  adminFee_not: BigInt
  adminFee_gt: BigInt
  adminFee_lt: BigInt
  adminFee_gte: BigInt
  adminFee_lte: BigInt
  adminFee_in: [BigInt!]
  adminFee_not_in: [BigInt!]
  pooledTokens: [String!]
  pooledTokens_not: [String!]
  pooledTokens_contains: [String!]
  pooledTokens_contains_nocase: [String!]
  pooledTokens_not_contains: [String!]
  pooledTokens_not_contains_nocase: [String!]
  pooledTokens_: mumbai_PooledToken_filter
  tokenPrecisionMultipliers: [BigInt!]
  tokenPrecisionMultipliers_not: [BigInt!]
  tokenPrecisionMultipliers_contains: [BigInt!]
  tokenPrecisionMultipliers_contains_nocase: [BigInt!]
  tokenPrecisionMultipliers_not_contains: [BigInt!]
  tokenPrecisionMultipliers_not_contains_nocase: [BigInt!]
  balances: [BigInt!]
  balances_not: [BigInt!]
  balances_contains: [BigInt!]
  balances_contains_nocase: [BigInt!]
  balances_not_contains: [BigInt!]
  balances_not_contains_nocase: [BigInt!]
  adminFees: [BigInt!]
  adminFees_not: [BigInt!]
  adminFees_contains: [BigInt!]
  adminFees_contains_nocase: [BigInt!]
  adminFees_not_contains: [BigInt!]
  adminFees_not_contains_nocase: [BigInt!]
  virtualPrice: BigInt
  virtualPrice_not: BigInt
  virtualPrice_gt: BigInt
  virtualPrice_lt: BigInt
  virtualPrice_gte: BigInt
  virtualPrice_lte: BigInt
  virtualPrice_in: [BigInt!]
  virtualPrice_not_in: [BigInt!]
  invariant: BigInt
  invariant_not: BigInt
  invariant_gt: BigInt
  invariant_lt: BigInt
  invariant_gte: BigInt
  invariant_lte: BigInt
  invariant_in: [BigInt!]
  invariant_not_in: [BigInt!]
  lpTokenSupply: BigInt
  lpTokenSupply_not: BigInt
  lpTokenSupply_gt: BigInt
  lpTokenSupply_lt: BigInt
  lpTokenSupply_gte: BigInt
  lpTokenSupply_lte: BigInt
  lpTokenSupply_in: [BigInt!]
  lpTokenSupply_not_in: [BigInt!]
  events_: mumbai_StableSwapEvent_filter
  exchanges_: mumbai_StableSwapExchange_filter
  hourlyVolumes_: mumbai_SwapHourlyVolume_filter
  dailyVolumes_: mumbai_SwapDailyVolume_filter
  weeklyVolumes_: mumbai_SwapWeeklyVolume_filter
  """Filter for the block changed event."""
  _change_block: mumbai_BlockChangedFilter
}

enum mumbai_StableSwap_orderBy {
  id
  isActive
  key
  canonicalId
  domain
  swapPool
  lpToken
  initialA
  futureA
  initialATime
  futureATime
  swapFee
  adminFee
  pooledTokens
  tokenPrecisionMultipliers
  balances
  adminFees
  virtualPrice
  invariant
  lpTokenSupply
  events
  exchanges
  hourlyVolumes
  dailyVolumes
  weeklyVolumes
}

type mumbai_SwapDailyVolume implements mumbai_SwapTradeVolume {
  id: ID!
  stableSwap: mumbai_StableSwap!
  timestamp: BigInt!
  volume: mumbai_BigDecimal!
}

input mumbai_SwapDailyVolume_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: mumbai_StableSwap_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  volume: mumbai_BigDecimal
  volume_not: mumbai_BigDecimal
  volume_gt: mumbai_BigDecimal
  volume_lt: mumbai_BigDecimal
  volume_gte: mumbai_BigDecimal
  volume_lte: mumbai_BigDecimal
  volume_in: [mumbai_BigDecimal!]
  volume_not_in: [mumbai_BigDecimal!]
  """Filter for the block changed event."""
  _change_block: mumbai_BlockChangedFilter
}

enum mumbai_SwapDailyVolume_orderBy {
  id
  stableSwap
  timestamp
  volume
}

type mumbai_SwapHourlyVolume implements mumbai_SwapTradeVolume {
  id: ID!
  stableSwap: mumbai_StableSwap!
  timestamp: BigInt!
  volume: mumbai_BigDecimal!
}

input mumbai_SwapHourlyVolume_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: mumbai_StableSwap_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  volume: mumbai_BigDecimal
  volume_not: mumbai_BigDecimal
  volume_gt: mumbai_BigDecimal
  volume_lt: mumbai_BigDecimal
  volume_gte: mumbai_BigDecimal
  volume_lte: mumbai_BigDecimal
  volume_in: [mumbai_BigDecimal!]
  volume_not_in: [mumbai_BigDecimal!]
  """Filter for the block changed event."""
  _change_block: mumbai_BlockChangedFilter
}

enum mumbai_SwapHourlyVolume_orderBy {
  id
  stableSwap
  timestamp
  volume
}

interface mumbai_SwapTradeVolume {
  stableSwap: mumbai_StableSwap!
  timestamp: BigInt!
  volume: mumbai_BigDecimal!
}

input mumbai_SwapTradeVolume_filter {
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: mumbai_StableSwap_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  volume: mumbai_BigDecimal
  volume_not: mumbai_BigDecimal
  volume_gt: mumbai_BigDecimal
  volume_lt: mumbai_BigDecimal
  volume_gte: mumbai_BigDecimal
  volume_lte: mumbai_BigDecimal
  volume_in: [mumbai_BigDecimal!]
  volume_not_in: [mumbai_BigDecimal!]
  """Filter for the block changed event."""
  _change_block: mumbai_BlockChangedFilter
}

enum mumbai_SwapTradeVolume_orderBy {
  stableSwap
  timestamp
  volume
}

type mumbai_SwapWeeklyVolume implements mumbai_SwapTradeVolume {
  id: ID!
  stableSwap: mumbai_StableSwap!
  timestamp: BigInt!
  volume: mumbai_BigDecimal!
}

input mumbai_SwapWeeklyVolume_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: mumbai_StableSwap_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  volume: mumbai_BigDecimal
  volume_not: mumbai_BigDecimal
  volume_gt: mumbai_BigDecimal
  volume_lt: mumbai_BigDecimal
  volume_gte: mumbai_BigDecimal
  volume_lte: mumbai_BigDecimal
  volume_in: [mumbai_BigDecimal!]
  volume_not_in: [mumbai_BigDecimal!]
  """Filter for the block changed event."""
  _change_block: mumbai_BlockChangedFilter
}

enum mumbai_SwapWeeklyVolume_orderBy {
  id
  stableSwap
  timestamp
  volume
}

type mumbai_SystemInfo {
  id: ID!
  exchangeCount: BigInt!
  swapCount: BigInt!
}

input mumbai_SystemInfo_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  exchangeCount: BigInt
  exchangeCount_not: BigInt
  exchangeCount_gt: BigInt
  exchangeCount_lt: BigInt
  exchangeCount_gte: BigInt
  exchangeCount_lte: BigInt
  exchangeCount_in: [BigInt!]
  exchangeCount_not_in: [BigInt!]
  swapCount: BigInt
  swapCount_not: BigInt
  swapCount_gt: BigInt
  swapCount_lt: BigInt
  swapCount_gte: BigInt
  swapCount_lte: BigInt
  swapCount_in: [BigInt!]
  swapCount_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: mumbai_BlockChangedFilter
}

enum mumbai_SystemInfo_orderBy {
  id
  exchangeCount
  swapCount
}

type mumbai__Block_ {
  """The hash of the block"""
  hash: mumbai_Bytes
  """The block number"""
  number: Int!
  """Integer representation of the timestamp stored in blocks for the chain"""
  timestamp: Int
}

"""The type for the top-level _meta field"""
type mumbai__Meta_ {
  """
  Information about a specific subgraph block. The hash of the block
  will be null if the _meta field has a block constraint that asks for
  a block number. It will be filled if the _meta field has no block constraint
  and therefore asks for the latest  block
  
  """
  block: mumbai__Block_!
  """The deployment ID"""
  deployment: String!
  """If `true`, the subgraph encountered indexing errors at some past block"""
  hasIndexingErrors: Boolean!
}

enum _SubgraphErrorPolicy_ {
  """Data will be returned even if the subgraph has indexing errors"""
  allow
  """
  If the subgraph has indexing errors, data will be omitted. The default.
  """
  deny
}

scalar xdai_BigDecimal

input xdai_BlockChangedFilter {
  number_gte: Int!
}

input xdai_Block_height {
  hash: xdai_Bytes
  number: Int
  number_gte: Int
}

scalar xdai_Bytes

"""Defines the order direction, either ascending or descending"""
enum xdai_OrderDirection {
  asc
  desc
}

type xdai_PooledToken {
  id: ID!
  asset: xdai_Bytes!
}

input xdai_PooledToken_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  asset: xdai_Bytes
  asset_not: xdai_Bytes
  asset_gt: xdai_Bytes
  asset_lt: xdai_Bytes
  asset_gte: xdai_Bytes
  asset_lte: xdai_Bytes
  asset_in: [xdai_Bytes!]
  asset_not_in: [xdai_Bytes!]
  asset_contains: xdai_Bytes
  asset_not_contains: xdai_Bytes
  """Filter for the block changed event."""
  _change_block: xdai_BlockChangedFilter
}

enum xdai_PooledToken_orderBy {
  id
  asset
}

type xdai_StableSwap {
  id: ID!
  isActive: Boolean
  key: xdai_Bytes!
  canonicalId: xdai_Bytes
  domain: BigInt
  swapPool: xdai_Bytes
  lpToken: xdai_Bytes
  initialA: BigInt
  futureA: BigInt
  initialATime: BigInt
  futureATime: BigInt
  swapFee: BigInt
  adminFee: BigInt
  pooledTokens(skip: Int = 0, first: Int = 100, orderBy: xdai_PooledToken_orderBy, orderDirection: xdai_OrderDirection, where: xdai_PooledToken_filter): [xdai_PooledToken!]!
  tokenPrecisionMultipliers: [BigInt!]!
  balances: [BigInt!]!
  adminFees: [BigInt!]!
  virtualPrice: BigInt!
  invariant: BigInt!
  lpTokenSupply: BigInt!
  events(skip: Int = 0, first: Int = 100, orderBy: xdai_StableSwapEvent_orderBy, orderDirection: xdai_OrderDirection, where: xdai_StableSwapEvent_filter): [xdai_StableSwapEvent!]
  exchanges(skip: Int = 0, first: Int = 100, orderBy: xdai_StableSwapExchange_orderBy, orderDirection: xdai_OrderDirection, where: xdai_StableSwapExchange_filter): [xdai_StableSwapExchange!]
  hourlyVolumes(skip: Int = 0, first: Int = 100, orderBy: xdai_SwapHourlyVolume_orderBy, orderDirection: xdai_OrderDirection, where: xdai_SwapHourlyVolume_filter): [xdai_SwapHourlyVolume!]
  dailyVolumes(skip: Int = 0, first: Int = 100, orderBy: xdai_SwapDailyVolume_orderBy, orderDirection: xdai_OrderDirection, where: xdai_SwapDailyVolume_filter): [xdai_SwapDailyVolume!]
  weeklyVolumes(skip: Int = 0, first: Int = 100, orderBy: xdai_SwapWeeklyVolume_orderBy, orderDirection: xdai_OrderDirection, where: xdai_SwapWeeklyVolume_filter): [xdai_SwapWeeklyVolume!]
}

type xdai_StableSwapAddLiquidityEvent implements xdai_StableSwapEvent {
  id: ID!
  stableSwap: xdai_StableSwap!
  provider: xdai_Bytes!
  tokenAmounts: [BigInt!]!
  fees: [BigInt!]!
  invariant: BigInt
  lpTokenSupply: BigInt!
  block: BigInt!
  timestamp: BigInt!
  transaction: xdai_Bytes!
}

input xdai_StableSwapAddLiquidityEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: xdai_StableSwap_filter
  provider: xdai_Bytes
  provider_not: xdai_Bytes
  provider_gt: xdai_Bytes
  provider_lt: xdai_Bytes
  provider_gte: xdai_Bytes
  provider_lte: xdai_Bytes
  provider_in: [xdai_Bytes!]
  provider_not_in: [xdai_Bytes!]
  provider_contains: xdai_Bytes
  provider_not_contains: xdai_Bytes
  tokenAmounts: [BigInt!]
  tokenAmounts_not: [BigInt!]
  tokenAmounts_contains: [BigInt!]
  tokenAmounts_contains_nocase: [BigInt!]
  tokenAmounts_not_contains: [BigInt!]
  tokenAmounts_not_contains_nocase: [BigInt!]
  fees: [BigInt!]
  fees_not: [BigInt!]
  fees_contains: [BigInt!]
  fees_contains_nocase: [BigInt!]
  fees_not_contains: [BigInt!]
  fees_not_contains_nocase: [BigInt!]
  invariant: BigInt
  invariant_not: BigInt
  invariant_gt: BigInt
  invariant_lt: BigInt
  invariant_gte: BigInt
  invariant_lte: BigInt
  invariant_in: [BigInt!]
  invariant_not_in: [BigInt!]
  lpTokenSupply: BigInt
  lpTokenSupply_not: BigInt
  lpTokenSupply_gt: BigInt
  lpTokenSupply_lt: BigInt
  lpTokenSupply_gte: BigInt
  lpTokenSupply_lte: BigInt
  lpTokenSupply_in: [BigInt!]
  lpTokenSupply_not_in: [BigInt!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: xdai_Bytes
  transaction_not: xdai_Bytes
  transaction_gt: xdai_Bytes
  transaction_lt: xdai_Bytes
  transaction_gte: xdai_Bytes
  transaction_lte: xdai_Bytes
  transaction_in: [xdai_Bytes!]
  transaction_not_in: [xdai_Bytes!]
  transaction_contains: xdai_Bytes
  transaction_not_contains: xdai_Bytes
  """Filter for the block changed event."""
  _change_block: xdai_BlockChangedFilter
}

enum xdai_StableSwapAddLiquidityEvent_orderBy {
  id
  stableSwap
  provider
  tokenAmounts
  fees
  invariant
  lpTokenSupply
  block
  timestamp
  transaction
}

interface xdai_StableSwapEvent {
  id: ID!
  stableSwap: xdai_StableSwap!
  block: BigInt!
  timestamp: BigInt!
  transaction: xdai_Bytes!
}

input xdai_StableSwapEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: xdai_StableSwap_filter
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: xdai_Bytes
  transaction_not: xdai_Bytes
  transaction_gt: xdai_Bytes
  transaction_lt: xdai_Bytes
  transaction_gte: xdai_Bytes
  transaction_lte: xdai_Bytes
  transaction_in: [xdai_Bytes!]
  transaction_not_in: [xdai_Bytes!]
  transaction_contains: xdai_Bytes
  transaction_not_contains: xdai_Bytes
  """Filter for the block changed event."""
  _change_block: xdai_BlockChangedFilter
}

enum xdai_StableSwapEvent_orderBy {
  id
  stableSwap
  block
  timestamp
  transaction
}

type xdai_StableSwapExchange {
  id: ID!
  stableSwap: xdai_StableSwap!
  buyer: xdai_Bytes!
  boughtId: BigInt!
  tokensBought: BigInt!
  soldId: BigInt!
  tokensSold: BigInt!
  block: BigInt!
  timestamp: BigInt!
  transaction: xdai_Bytes!
}

input xdai_StableSwapExchange_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: xdai_StableSwap_filter
  buyer: xdai_Bytes
  buyer_not: xdai_Bytes
  buyer_gt: xdai_Bytes
  buyer_lt: xdai_Bytes
  buyer_gte: xdai_Bytes
  buyer_lte: xdai_Bytes
  buyer_in: [xdai_Bytes!]
  buyer_not_in: [xdai_Bytes!]
  buyer_contains: xdai_Bytes
  buyer_not_contains: xdai_Bytes
  boughtId: BigInt
  boughtId_not: BigInt
  boughtId_gt: BigInt
  boughtId_lt: BigInt
  boughtId_gte: BigInt
  boughtId_lte: BigInt
  boughtId_in: [BigInt!]
  boughtId_not_in: [BigInt!]
  tokensBought: BigInt
  tokensBought_not: BigInt
  tokensBought_gt: BigInt
  tokensBought_lt: BigInt
  tokensBought_gte: BigInt
  tokensBought_lte: BigInt
  tokensBought_in: [BigInt!]
  tokensBought_not_in: [BigInt!]
  soldId: BigInt
  soldId_not: BigInt
  soldId_gt: BigInt
  soldId_lt: BigInt
  soldId_gte: BigInt
  soldId_lte: BigInt
  soldId_in: [BigInt!]
  soldId_not_in: [BigInt!]
  tokensSold: BigInt
  tokensSold_not: BigInt
  tokensSold_gt: BigInt
  tokensSold_lt: BigInt
  tokensSold_gte: BigInt
  tokensSold_lte: BigInt
  tokensSold_in: [BigInt!]
  tokensSold_not_in: [BigInt!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: xdai_Bytes
  transaction_not: xdai_Bytes
  transaction_gt: xdai_Bytes
  transaction_lt: xdai_Bytes
  transaction_gte: xdai_Bytes
  transaction_lte: xdai_Bytes
  transaction_in: [xdai_Bytes!]
  transaction_not_in: [xdai_Bytes!]
  transaction_contains: xdai_Bytes
  transaction_not_contains: xdai_Bytes
  """Filter for the block changed event."""
  _change_block: xdai_BlockChangedFilter
}

enum xdai_StableSwapExchange_orderBy {
  id
  stableSwap
  buyer
  boughtId
  tokensBought
  soldId
  tokensSold
  block
  timestamp
  transaction
}

type xdai_StableSwapRemoveLiquidityEvent implements xdai_StableSwapEvent {
  id: ID!
  stableSwap: xdai_StableSwap!
  provider: xdai_Bytes!
  tokenAmounts: [BigInt!]!
  fees: [BigInt!]
  invariant: BigInt
  lpTokenSupply: BigInt!
  block: BigInt!
  timestamp: BigInt!
  transaction: xdai_Bytes!
}

input xdai_StableSwapRemoveLiquidityEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: xdai_StableSwap_filter
  provider: xdai_Bytes
  provider_not: xdai_Bytes
  provider_gt: xdai_Bytes
  provider_lt: xdai_Bytes
  provider_gte: xdai_Bytes
  provider_lte: xdai_Bytes
  provider_in: [xdai_Bytes!]
  provider_not_in: [xdai_Bytes!]
  provider_contains: xdai_Bytes
  provider_not_contains: xdai_Bytes
  tokenAmounts: [BigInt!]
  tokenAmounts_not: [BigInt!]
  tokenAmounts_contains: [BigInt!]
  tokenAmounts_contains_nocase: [BigInt!]
  tokenAmounts_not_contains: [BigInt!]
  tokenAmounts_not_contains_nocase: [BigInt!]
  fees: [BigInt!]
  fees_not: [BigInt!]
  fees_contains: [BigInt!]
  fees_contains_nocase: [BigInt!]
  fees_not_contains: [BigInt!]
  fees_not_contains_nocase: [BigInt!]
  invariant: BigInt
  invariant_not: BigInt
  invariant_gt: BigInt
  invariant_lt: BigInt
  invariant_gte: BigInt
  invariant_lte: BigInt
  invariant_in: [BigInt!]
  invariant_not_in: [BigInt!]
  lpTokenSupply: BigInt
  lpTokenSupply_not: BigInt
  lpTokenSupply_gt: BigInt
  lpTokenSupply_lt: BigInt
  lpTokenSupply_gte: BigInt
  lpTokenSupply_lte: BigInt
  lpTokenSupply_in: [BigInt!]
  lpTokenSupply_not_in: [BigInt!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: xdai_Bytes
  transaction_not: xdai_Bytes
  transaction_gt: xdai_Bytes
  transaction_lt: xdai_Bytes
  transaction_gte: xdai_Bytes
  transaction_lte: xdai_Bytes
  transaction_in: [xdai_Bytes!]
  transaction_not_in: [xdai_Bytes!]
  transaction_contains: xdai_Bytes
  transaction_not_contains: xdai_Bytes
  """Filter for the block changed event."""
  _change_block: xdai_BlockChangedFilter
}

enum xdai_StableSwapRemoveLiquidityEvent_orderBy {
  id
  stableSwap
  provider
  tokenAmounts
  fees
  invariant
  lpTokenSupply
  block
  timestamp
  transaction
}

input xdai_StableSwap_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  isActive: Boolean
  isActive_not: Boolean
  isActive_in: [Boolean!]
  isActive_not_in: [Boolean!]
  key: xdai_Bytes
  key_not: xdai_Bytes
  key_gt: xdai_Bytes
  key_lt: xdai_Bytes
  key_gte: xdai_Bytes
  key_lte: xdai_Bytes
  key_in: [xdai_Bytes!]
  key_not_in: [xdai_Bytes!]
  key_contains: xdai_Bytes
  key_not_contains: xdai_Bytes
  canonicalId: xdai_Bytes
  canonicalId_not: xdai_Bytes
  canonicalId_gt: xdai_Bytes
  canonicalId_lt: xdai_Bytes
  canonicalId_gte: xdai_Bytes
  canonicalId_lte: xdai_Bytes
  canonicalId_in: [xdai_Bytes!]
  canonicalId_not_in: [xdai_Bytes!]
  canonicalId_contains: xdai_Bytes
  canonicalId_not_contains: xdai_Bytes
  domain: BigInt
  domain_not: BigInt
  domain_gt: BigInt
  domain_lt: BigInt
  domain_gte: BigInt
  domain_lte: BigInt
  domain_in: [BigInt!]
  domain_not_in: [BigInt!]
  swapPool: xdai_Bytes
  swapPool_not: xdai_Bytes
  swapPool_gt: xdai_Bytes
  swapPool_lt: xdai_Bytes
  swapPool_gte: xdai_Bytes
  swapPool_lte: xdai_Bytes
  swapPool_in: [xdai_Bytes!]
  swapPool_not_in: [xdai_Bytes!]
  swapPool_contains: xdai_Bytes
  swapPool_not_contains: xdai_Bytes
  lpToken: xdai_Bytes
  lpToken_not: xdai_Bytes
  lpToken_gt: xdai_Bytes
  lpToken_lt: xdai_Bytes
  lpToken_gte: xdai_Bytes
  lpToken_lte: xdai_Bytes
  lpToken_in: [xdai_Bytes!]
  lpToken_not_in: [xdai_Bytes!]
  lpToken_contains: xdai_Bytes
  lpToken_not_contains: xdai_Bytes
  initialA: BigInt
  initialA_not: BigInt
  initialA_gt: BigInt
  initialA_lt: BigInt
  initialA_gte: BigInt
  initialA_lte: BigInt
  initialA_in: [BigInt!]
  initialA_not_in: [BigInt!]
  futureA: BigInt
  futureA_not: BigInt
  futureA_gt: BigInt
  futureA_lt: BigInt
  futureA_gte: BigInt
  futureA_lte: BigInt
  futureA_in: [BigInt!]
  futureA_not_in: [BigInt!]
  initialATime: BigInt
  initialATime_not: BigInt
  initialATime_gt: BigInt
  initialATime_lt: BigInt
  initialATime_gte: BigInt
  initialATime_lte: BigInt
  initialATime_in: [BigInt!]
  initialATime_not_in: [BigInt!]
  futureATime: BigInt
  futureATime_not: BigInt
  futureATime_gt: BigInt
  futureATime_lt: BigInt
  futureATime_gte: BigInt
  futureATime_lte: BigInt
  futureATime_in: [BigInt!]
  futureATime_not_in: [BigInt!]
  swapFee: BigInt
  swapFee_not: BigInt
  swapFee_gt: BigInt
  swapFee_lt: BigInt
  swapFee_gte: BigInt
  swapFee_lte: BigInt
  swapFee_in: [BigInt!]
  swapFee_not_in: [BigInt!]
  adminFee: BigInt
  adminFee_not: BigInt
  adminFee_gt: BigInt
  adminFee_lt: BigInt
  adminFee_gte: BigInt
  adminFee_lte: BigInt
  adminFee_in: [BigInt!]
  adminFee_not_in: [BigInt!]
  pooledTokens: [String!]
  pooledTokens_not: [String!]
  pooledTokens_contains: [String!]
  pooledTokens_contains_nocase: [String!]
  pooledTokens_not_contains: [String!]
  pooledTokens_not_contains_nocase: [String!]
  pooledTokens_: xdai_PooledToken_filter
  tokenPrecisionMultipliers: [BigInt!]
  tokenPrecisionMultipliers_not: [BigInt!]
  tokenPrecisionMultipliers_contains: [BigInt!]
  tokenPrecisionMultipliers_contains_nocase: [BigInt!]
  tokenPrecisionMultipliers_not_contains: [BigInt!]
  tokenPrecisionMultipliers_not_contains_nocase: [BigInt!]
  balances: [BigInt!]
  balances_not: [BigInt!]
  balances_contains: [BigInt!]
  balances_contains_nocase: [BigInt!]
  balances_not_contains: [BigInt!]
  balances_not_contains_nocase: [BigInt!]
  adminFees: [BigInt!]
  adminFees_not: [BigInt!]
  adminFees_contains: [BigInt!]
  adminFees_contains_nocase: [BigInt!]
  adminFees_not_contains: [BigInt!]
  adminFees_not_contains_nocase: [BigInt!]
  virtualPrice: BigInt
  virtualPrice_not: BigInt
  virtualPrice_gt: BigInt
  virtualPrice_lt: BigInt
  virtualPrice_gte: BigInt
  virtualPrice_lte: BigInt
  virtualPrice_in: [BigInt!]
  virtualPrice_not_in: [BigInt!]
  invariant: BigInt
  invariant_not: BigInt
  invariant_gt: BigInt
  invariant_lt: BigInt
  invariant_gte: BigInt
  invariant_lte: BigInt
  invariant_in: [BigInt!]
  invariant_not_in: [BigInt!]
  lpTokenSupply: BigInt
  lpTokenSupply_not: BigInt
  lpTokenSupply_gt: BigInt
  lpTokenSupply_lt: BigInt
  lpTokenSupply_gte: BigInt
  lpTokenSupply_lte: BigInt
  lpTokenSupply_in: [BigInt!]
  lpTokenSupply_not_in: [BigInt!]
  events_: xdai_StableSwapEvent_filter
  exchanges_: xdai_StableSwapExchange_filter
  hourlyVolumes_: xdai_SwapHourlyVolume_filter
  dailyVolumes_: xdai_SwapDailyVolume_filter
  weeklyVolumes_: xdai_SwapWeeklyVolume_filter
  """Filter for the block changed event."""
  _change_block: xdai_BlockChangedFilter
}

enum xdai_StableSwap_orderBy {
  id
  isActive
  key
  canonicalId
  domain
  swapPool
  lpToken
  initialA
  futureA
  initialATime
  futureATime
  swapFee
  adminFee
  pooledTokens
  tokenPrecisionMultipliers
  balances
  adminFees
  virtualPrice
  invariant
  lpTokenSupply
  events
  exchanges
  hourlyVolumes
  dailyVolumes
  weeklyVolumes
}

type xdai_SwapDailyVolume implements xdai_SwapTradeVolume {
  id: ID!
  stableSwap: xdai_StableSwap!
  timestamp: BigInt!
  volume: xdai_BigDecimal!
}

input xdai_SwapDailyVolume_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: xdai_StableSwap_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  volume: xdai_BigDecimal
  volume_not: xdai_BigDecimal
  volume_gt: xdai_BigDecimal
  volume_lt: xdai_BigDecimal
  volume_gte: xdai_BigDecimal
  volume_lte: xdai_BigDecimal
  volume_in: [xdai_BigDecimal!]
  volume_not_in: [xdai_BigDecimal!]
  """Filter for the block changed event."""
  _change_block: xdai_BlockChangedFilter
}

enum xdai_SwapDailyVolume_orderBy {
  id
  stableSwap
  timestamp
  volume
}

type xdai_SwapHourlyVolume implements xdai_SwapTradeVolume {
  id: ID!
  stableSwap: xdai_StableSwap!
  timestamp: BigInt!
  volume: xdai_BigDecimal!
}

input xdai_SwapHourlyVolume_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: xdai_StableSwap_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  volume: xdai_BigDecimal
  volume_not: xdai_BigDecimal
  volume_gt: xdai_BigDecimal
  volume_lt: xdai_BigDecimal
  volume_gte: xdai_BigDecimal
  volume_lte: xdai_BigDecimal
  volume_in: [xdai_BigDecimal!]
  volume_not_in: [xdai_BigDecimal!]
  """Filter for the block changed event."""
  _change_block: xdai_BlockChangedFilter
}

enum xdai_SwapHourlyVolume_orderBy {
  id
  stableSwap
  timestamp
  volume
}

interface xdai_SwapTradeVolume {
  stableSwap: xdai_StableSwap!
  timestamp: BigInt!
  volume: xdai_BigDecimal!
}

input xdai_SwapTradeVolume_filter {
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: xdai_StableSwap_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  volume: xdai_BigDecimal
  volume_not: xdai_BigDecimal
  volume_gt: xdai_BigDecimal
  volume_lt: xdai_BigDecimal
  volume_gte: xdai_BigDecimal
  volume_lte: xdai_BigDecimal
  volume_in: [xdai_BigDecimal!]
  volume_not_in: [xdai_BigDecimal!]
  """Filter for the block changed event."""
  _change_block: xdai_BlockChangedFilter
}

enum xdai_SwapTradeVolume_orderBy {
  stableSwap
  timestamp
  volume
}

type xdai_SwapWeeklyVolume implements xdai_SwapTradeVolume {
  id: ID!
  stableSwap: xdai_StableSwap!
  timestamp: BigInt!
  volume: xdai_BigDecimal!
}

input xdai_SwapWeeklyVolume_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: xdai_StableSwap_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  volume: xdai_BigDecimal
  volume_not: xdai_BigDecimal
  volume_gt: xdai_BigDecimal
  volume_lt: xdai_BigDecimal
  volume_gte: xdai_BigDecimal
  volume_lte: xdai_BigDecimal
  volume_in: [xdai_BigDecimal!]
  volume_not_in: [xdai_BigDecimal!]
  """Filter for the block changed event."""
  _change_block: xdai_BlockChangedFilter
}

enum xdai_SwapWeeklyVolume_orderBy {
  id
  stableSwap
  timestamp
  volume
}

type xdai_SystemInfo {
  id: ID!
  exchangeCount: BigInt!
  swapCount: BigInt!
}

input xdai_SystemInfo_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  exchangeCount: BigInt
  exchangeCount_not: BigInt
  exchangeCount_gt: BigInt
  exchangeCount_lt: BigInt
  exchangeCount_gte: BigInt
  exchangeCount_lte: BigInt
  exchangeCount_in: [BigInt!]
  exchangeCount_not_in: [BigInt!]
  swapCount: BigInt
  swapCount_not: BigInt
  swapCount_gt: BigInt
  swapCount_lt: BigInt
  swapCount_gte: BigInt
  swapCount_lte: BigInt
  swapCount_in: [BigInt!]
  swapCount_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: xdai_BlockChangedFilter
}

enum xdai_SystemInfo_orderBy {
  id
  exchangeCount
  swapCount
}

type xdai__Block_ {
  """The hash of the block"""
  hash: xdai_Bytes
  """The block number"""
  number: Int!
  """Integer representation of the timestamp stored in blocks for the chain"""
  timestamp: Int
}

"""The type for the top-level _meta field"""
type xdai__Meta_ {
  """
  Information about a specific subgraph block. The hash of the block
  will be null if the _meta field has a block constraint that asks for
  a block number. It will be filled if the _meta field has no block constraint
  and therefore asks for the latest  block
  
  """
  block: xdai__Block_!
  """The deployment ID"""
  deployment: String!
  """If `true`, the subgraph encountered indexing errors at some past block"""
  hasIndexingErrors: Boolean!
}

scalar arbitrumone_BigDecimal

input arbitrumone_BlockChangedFilter {
  number_gte: Int!
}

input arbitrumone_Block_height {
  hash: arbitrumone_Bytes
  number: Int
  number_gte: Int
}

scalar arbitrumone_Bytes

"""Defines the order direction, either ascending or descending"""
enum arbitrumone_OrderDirection {
  asc
  desc
}

type arbitrumone_PooledToken {
  id: ID!
  asset: arbitrumone_Bytes!
}

input arbitrumone_PooledToken_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  asset: arbitrumone_Bytes
  asset_not: arbitrumone_Bytes
  asset_gt: arbitrumone_Bytes
  asset_lt: arbitrumone_Bytes
  asset_gte: arbitrumone_Bytes
  asset_lte: arbitrumone_Bytes
  asset_in: [arbitrumone_Bytes!]
  asset_not_in: [arbitrumone_Bytes!]
  asset_contains: arbitrumone_Bytes
  asset_not_contains: arbitrumone_Bytes
  """Filter for the block changed event."""
  _change_block: arbitrumone_BlockChangedFilter
}

enum arbitrumone_PooledToken_orderBy {
  id
  asset
}

type arbitrumone_StableSwap {
  id: ID!
  isActive: Boolean
  key: arbitrumone_Bytes!
  canonicalId: arbitrumone_Bytes
  domain: BigInt
  swapPool: arbitrumone_Bytes
  lpToken: arbitrumone_Bytes
  initialA: BigInt
  futureA: BigInt
  initialATime: BigInt
  futureATime: BigInt
  swapFee: BigInt
  adminFee: BigInt
  pooledTokens(skip: Int = 0, first: Int = 100, orderBy: arbitrumone_PooledToken_orderBy, orderDirection: arbitrumone_OrderDirection, where: arbitrumone_PooledToken_filter): [arbitrumone_PooledToken!]!
  tokenPrecisionMultipliers: [BigInt!]!
  balances: [BigInt!]!
  adminFees: [BigInt!]!
  virtualPrice: BigInt!
  invariant: BigInt!
  lpTokenSupply: BigInt!
  events(skip: Int = 0, first: Int = 100, orderBy: arbitrumone_StableSwapEvent_orderBy, orderDirection: arbitrumone_OrderDirection, where: arbitrumone_StableSwapEvent_filter): [arbitrumone_StableSwapEvent!]
  exchanges(skip: Int = 0, first: Int = 100, orderBy: arbitrumone_StableSwapExchange_orderBy, orderDirection: arbitrumone_OrderDirection, where: arbitrumone_StableSwapExchange_filter): [arbitrumone_StableSwapExchange!]
  hourlyVolumes(skip: Int = 0, first: Int = 100, orderBy: arbitrumone_SwapHourlyVolume_orderBy, orderDirection: arbitrumone_OrderDirection, where: arbitrumone_SwapHourlyVolume_filter): [arbitrumone_SwapHourlyVolume!]
  dailyVolumes(skip: Int = 0, first: Int = 100, orderBy: arbitrumone_SwapDailyVolume_orderBy, orderDirection: arbitrumone_OrderDirection, where: arbitrumone_SwapDailyVolume_filter): [arbitrumone_SwapDailyVolume!]
  weeklyVolumes(skip: Int = 0, first: Int = 100, orderBy: arbitrumone_SwapWeeklyVolume_orderBy, orderDirection: arbitrumone_OrderDirection, where: arbitrumone_SwapWeeklyVolume_filter): [arbitrumone_SwapWeeklyVolume!]
}

type arbitrumone_StableSwapAddLiquidityEvent implements arbitrumone_StableSwapEvent {
  id: ID!
  stableSwap: arbitrumone_StableSwap!
  provider: arbitrumone_Bytes!
  tokenAmounts: [BigInt!]!
  fees: [BigInt!]!
  invariant: BigInt
  lpTokenSupply: BigInt!
  block: BigInt!
  timestamp: BigInt!
  transaction: arbitrumone_Bytes!
}

input arbitrumone_StableSwapAddLiquidityEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: arbitrumone_StableSwap_filter
  provider: arbitrumone_Bytes
  provider_not: arbitrumone_Bytes
  provider_gt: arbitrumone_Bytes
  provider_lt: arbitrumone_Bytes
  provider_gte: arbitrumone_Bytes
  provider_lte: arbitrumone_Bytes
  provider_in: [arbitrumone_Bytes!]
  provider_not_in: [arbitrumone_Bytes!]
  provider_contains: arbitrumone_Bytes
  provider_not_contains: arbitrumone_Bytes
  tokenAmounts: [BigInt!]
  tokenAmounts_not: [BigInt!]
  tokenAmounts_contains: [BigInt!]
  tokenAmounts_contains_nocase: [BigInt!]
  tokenAmounts_not_contains: [BigInt!]
  tokenAmounts_not_contains_nocase: [BigInt!]
  fees: [BigInt!]
  fees_not: [BigInt!]
  fees_contains: [BigInt!]
  fees_contains_nocase: [BigInt!]
  fees_not_contains: [BigInt!]
  fees_not_contains_nocase: [BigInt!]
  invariant: BigInt
  invariant_not: BigInt
  invariant_gt: BigInt
  invariant_lt: BigInt
  invariant_gte: BigInt
  invariant_lte: BigInt
  invariant_in: [BigInt!]
  invariant_not_in: [BigInt!]
  lpTokenSupply: BigInt
  lpTokenSupply_not: BigInt
  lpTokenSupply_gt: BigInt
  lpTokenSupply_lt: BigInt
  lpTokenSupply_gte: BigInt
  lpTokenSupply_lte: BigInt
  lpTokenSupply_in: [BigInt!]
  lpTokenSupply_not_in: [BigInt!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: arbitrumone_Bytes
  transaction_not: arbitrumone_Bytes
  transaction_gt: arbitrumone_Bytes
  transaction_lt: arbitrumone_Bytes
  transaction_gte: arbitrumone_Bytes
  transaction_lte: arbitrumone_Bytes
  transaction_in: [arbitrumone_Bytes!]
  transaction_not_in: [arbitrumone_Bytes!]
  transaction_contains: arbitrumone_Bytes
  transaction_not_contains: arbitrumone_Bytes
  """Filter for the block changed event."""
  _change_block: arbitrumone_BlockChangedFilter
}

enum arbitrumone_StableSwapAddLiquidityEvent_orderBy {
  id
  stableSwap
  provider
  tokenAmounts
  fees
  invariant
  lpTokenSupply
  block
  timestamp
  transaction
}

interface arbitrumone_StableSwapEvent {
  id: ID!
  stableSwap: arbitrumone_StableSwap!
  block: BigInt!
  timestamp: BigInt!
  transaction: arbitrumone_Bytes!
}

input arbitrumone_StableSwapEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: arbitrumone_StableSwap_filter
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: arbitrumone_Bytes
  transaction_not: arbitrumone_Bytes
  transaction_gt: arbitrumone_Bytes
  transaction_lt: arbitrumone_Bytes
  transaction_gte: arbitrumone_Bytes
  transaction_lte: arbitrumone_Bytes
  transaction_in: [arbitrumone_Bytes!]
  transaction_not_in: [arbitrumone_Bytes!]
  transaction_contains: arbitrumone_Bytes
  transaction_not_contains: arbitrumone_Bytes
  """Filter for the block changed event."""
  _change_block: arbitrumone_BlockChangedFilter
}

enum arbitrumone_StableSwapEvent_orderBy {
  id
  stableSwap
  block
  timestamp
  transaction
}

type arbitrumone_StableSwapExchange {
  id: ID!
  stableSwap: arbitrumone_StableSwap!
  buyer: arbitrumone_Bytes!
  boughtId: BigInt!
  tokensBought: BigInt!
  soldId: BigInt!
  tokensSold: BigInt!
  block: BigInt!
  timestamp: BigInt!
  transaction: arbitrumone_Bytes!
}

input arbitrumone_StableSwapExchange_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: arbitrumone_StableSwap_filter
  buyer: arbitrumone_Bytes
  buyer_not: arbitrumone_Bytes
  buyer_gt: arbitrumone_Bytes
  buyer_lt: arbitrumone_Bytes
  buyer_gte: arbitrumone_Bytes
  buyer_lte: arbitrumone_Bytes
  buyer_in: [arbitrumone_Bytes!]
  buyer_not_in: [arbitrumone_Bytes!]
  buyer_contains: arbitrumone_Bytes
  buyer_not_contains: arbitrumone_Bytes
  boughtId: BigInt
  boughtId_not: BigInt
  boughtId_gt: BigInt
  boughtId_lt: BigInt
  boughtId_gte: BigInt
  boughtId_lte: BigInt
  boughtId_in: [BigInt!]
  boughtId_not_in: [BigInt!]
  tokensBought: BigInt
  tokensBought_not: BigInt
  tokensBought_gt: BigInt
  tokensBought_lt: BigInt
  tokensBought_gte: BigInt
  tokensBought_lte: BigInt
  tokensBought_in: [BigInt!]
  tokensBought_not_in: [BigInt!]
  soldId: BigInt
  soldId_not: BigInt
  soldId_gt: BigInt
  soldId_lt: BigInt
  soldId_gte: BigInt
  soldId_lte: BigInt
  soldId_in: [BigInt!]
  soldId_not_in: [BigInt!]
  tokensSold: BigInt
  tokensSold_not: BigInt
  tokensSold_gt: BigInt
  tokensSold_lt: BigInt
  tokensSold_gte: BigInt
  tokensSold_lte: BigInt
  tokensSold_in: [BigInt!]
  tokensSold_not_in: [BigInt!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: arbitrumone_Bytes
  transaction_not: arbitrumone_Bytes
  transaction_gt: arbitrumone_Bytes
  transaction_lt: arbitrumone_Bytes
  transaction_gte: arbitrumone_Bytes
  transaction_lte: arbitrumone_Bytes
  transaction_in: [arbitrumone_Bytes!]
  transaction_not_in: [arbitrumone_Bytes!]
  transaction_contains: arbitrumone_Bytes
  transaction_not_contains: arbitrumone_Bytes
  """Filter for the block changed event."""
  _change_block: arbitrumone_BlockChangedFilter
}

enum arbitrumone_StableSwapExchange_orderBy {
  id
  stableSwap
  buyer
  boughtId
  tokensBought
  soldId
  tokensSold
  block
  timestamp
  transaction
}

type arbitrumone_StableSwapRemoveLiquidityEvent implements arbitrumone_StableSwapEvent {
  id: ID!
  stableSwap: arbitrumone_StableSwap!
  provider: arbitrumone_Bytes!
  tokenAmounts: [BigInt!]!
  fees: [BigInt!]
  invariant: BigInt
  lpTokenSupply: BigInt!
  block: BigInt!
  timestamp: BigInt!
  transaction: arbitrumone_Bytes!
}

input arbitrumone_StableSwapRemoveLiquidityEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: arbitrumone_StableSwap_filter
  provider: arbitrumone_Bytes
  provider_not: arbitrumone_Bytes
  provider_gt: arbitrumone_Bytes
  provider_lt: arbitrumone_Bytes
  provider_gte: arbitrumone_Bytes
  provider_lte: arbitrumone_Bytes
  provider_in: [arbitrumone_Bytes!]
  provider_not_in: [arbitrumone_Bytes!]
  provider_contains: arbitrumone_Bytes
  provider_not_contains: arbitrumone_Bytes
  tokenAmounts: [BigInt!]
  tokenAmounts_not: [BigInt!]
  tokenAmounts_contains: [BigInt!]
  tokenAmounts_contains_nocase: [BigInt!]
  tokenAmounts_not_contains: [BigInt!]
  tokenAmounts_not_contains_nocase: [BigInt!]
  fees: [BigInt!]
  fees_not: [BigInt!]
  fees_contains: [BigInt!]
  fees_contains_nocase: [BigInt!]
  fees_not_contains: [BigInt!]
  fees_not_contains_nocase: [BigInt!]
  invariant: BigInt
  invariant_not: BigInt
  invariant_gt: BigInt
  invariant_lt: BigInt
  invariant_gte: BigInt
  invariant_lte: BigInt
  invariant_in: [BigInt!]
  invariant_not_in: [BigInt!]
  lpTokenSupply: BigInt
  lpTokenSupply_not: BigInt
  lpTokenSupply_gt: BigInt
  lpTokenSupply_lt: BigInt
  lpTokenSupply_gte: BigInt
  lpTokenSupply_lte: BigInt
  lpTokenSupply_in: [BigInt!]
  lpTokenSupply_not_in: [BigInt!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: arbitrumone_Bytes
  transaction_not: arbitrumone_Bytes
  transaction_gt: arbitrumone_Bytes
  transaction_lt: arbitrumone_Bytes
  transaction_gte: arbitrumone_Bytes
  transaction_lte: arbitrumone_Bytes
  transaction_in: [arbitrumone_Bytes!]
  transaction_not_in: [arbitrumone_Bytes!]
  transaction_contains: arbitrumone_Bytes
  transaction_not_contains: arbitrumone_Bytes
  """Filter for the block changed event."""
  _change_block: arbitrumone_BlockChangedFilter
}

enum arbitrumone_StableSwapRemoveLiquidityEvent_orderBy {
  id
  stableSwap
  provider
  tokenAmounts
  fees
  invariant
  lpTokenSupply
  block
  timestamp
  transaction
}

input arbitrumone_StableSwap_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  isActive: Boolean
  isActive_not: Boolean
  isActive_in: [Boolean!]
  isActive_not_in: [Boolean!]
  key: arbitrumone_Bytes
  key_not: arbitrumone_Bytes
  key_gt: arbitrumone_Bytes
  key_lt: arbitrumone_Bytes
  key_gte: arbitrumone_Bytes
  key_lte: arbitrumone_Bytes
  key_in: [arbitrumone_Bytes!]
  key_not_in: [arbitrumone_Bytes!]
  key_contains: arbitrumone_Bytes
  key_not_contains: arbitrumone_Bytes
  canonicalId: arbitrumone_Bytes
  canonicalId_not: arbitrumone_Bytes
  canonicalId_gt: arbitrumone_Bytes
  canonicalId_lt: arbitrumone_Bytes
  canonicalId_gte: arbitrumone_Bytes
  canonicalId_lte: arbitrumone_Bytes
  canonicalId_in: [arbitrumone_Bytes!]
  canonicalId_not_in: [arbitrumone_Bytes!]
  canonicalId_contains: arbitrumone_Bytes
  canonicalId_not_contains: arbitrumone_Bytes
  domain: BigInt
  domain_not: BigInt
  domain_gt: BigInt
  domain_lt: BigInt
  domain_gte: BigInt
  domain_lte: BigInt
  domain_in: [BigInt!]
  domain_not_in: [BigInt!]
  swapPool: arbitrumone_Bytes
  swapPool_not: arbitrumone_Bytes
  swapPool_gt: arbitrumone_Bytes
  swapPool_lt: arbitrumone_Bytes
  swapPool_gte: arbitrumone_Bytes
  swapPool_lte: arbitrumone_Bytes
  swapPool_in: [arbitrumone_Bytes!]
  swapPool_not_in: [arbitrumone_Bytes!]
  swapPool_contains: arbitrumone_Bytes
  swapPool_not_contains: arbitrumone_Bytes
  lpToken: arbitrumone_Bytes
  lpToken_not: arbitrumone_Bytes
  lpToken_gt: arbitrumone_Bytes
  lpToken_lt: arbitrumone_Bytes
  lpToken_gte: arbitrumone_Bytes
  lpToken_lte: arbitrumone_Bytes
  lpToken_in: [arbitrumone_Bytes!]
  lpToken_not_in: [arbitrumone_Bytes!]
  lpToken_contains: arbitrumone_Bytes
  lpToken_not_contains: arbitrumone_Bytes
  initialA: BigInt
  initialA_not: BigInt
  initialA_gt: BigInt
  initialA_lt: BigInt
  initialA_gte: BigInt
  initialA_lte: BigInt
  initialA_in: [BigInt!]
  initialA_not_in: [BigInt!]
  futureA: BigInt
  futureA_not: BigInt
  futureA_gt: BigInt
  futureA_lt: BigInt
  futureA_gte: BigInt
  futureA_lte: BigInt
  futureA_in: [BigInt!]
  futureA_not_in: [BigInt!]
  initialATime: BigInt
  initialATime_not: BigInt
  initialATime_gt: BigInt
  initialATime_lt: BigInt
  initialATime_gte: BigInt
  initialATime_lte: BigInt
  initialATime_in: [BigInt!]
  initialATime_not_in: [BigInt!]
  futureATime: BigInt
  futureATime_not: BigInt
  futureATime_gt: BigInt
  futureATime_lt: BigInt
  futureATime_gte: BigInt
  futureATime_lte: BigInt
  futureATime_in: [BigInt!]
  futureATime_not_in: [BigInt!]
  swapFee: BigInt
  swapFee_not: BigInt
  swapFee_gt: BigInt
  swapFee_lt: BigInt
  swapFee_gte: BigInt
  swapFee_lte: BigInt
  swapFee_in: [BigInt!]
  swapFee_not_in: [BigInt!]
  adminFee: BigInt
  adminFee_not: BigInt
  adminFee_gt: BigInt
  adminFee_lt: BigInt
  adminFee_gte: BigInt
  adminFee_lte: BigInt
  adminFee_in: [BigInt!]
  adminFee_not_in: [BigInt!]
  pooledTokens: [String!]
  pooledTokens_not: [String!]
  pooledTokens_contains: [String!]
  pooledTokens_contains_nocase: [String!]
  pooledTokens_not_contains: [String!]
  pooledTokens_not_contains_nocase: [String!]
  pooledTokens_: arbitrumone_PooledToken_filter
  tokenPrecisionMultipliers: [BigInt!]
  tokenPrecisionMultipliers_not: [BigInt!]
  tokenPrecisionMultipliers_contains: [BigInt!]
  tokenPrecisionMultipliers_contains_nocase: [BigInt!]
  tokenPrecisionMultipliers_not_contains: [BigInt!]
  tokenPrecisionMultipliers_not_contains_nocase: [BigInt!]
  balances: [BigInt!]
  balances_not: [BigInt!]
  balances_contains: [BigInt!]
  balances_contains_nocase: [BigInt!]
  balances_not_contains: [BigInt!]
  balances_not_contains_nocase: [BigInt!]
  adminFees: [BigInt!]
  adminFees_not: [BigInt!]
  adminFees_contains: [BigInt!]
  adminFees_contains_nocase: [BigInt!]
  adminFees_not_contains: [BigInt!]
  adminFees_not_contains_nocase: [BigInt!]
  virtualPrice: BigInt
  virtualPrice_not: BigInt
  virtualPrice_gt: BigInt
  virtualPrice_lt: BigInt
  virtualPrice_gte: BigInt
  virtualPrice_lte: BigInt
  virtualPrice_in: [BigInt!]
  virtualPrice_not_in: [BigInt!]
  invariant: BigInt
  invariant_not: BigInt
  invariant_gt: BigInt
  invariant_lt: BigInt
  invariant_gte: BigInt
  invariant_lte: BigInt
  invariant_in: [BigInt!]
  invariant_not_in: [BigInt!]
  lpTokenSupply: BigInt
  lpTokenSupply_not: BigInt
  lpTokenSupply_gt: BigInt
  lpTokenSupply_lt: BigInt
  lpTokenSupply_gte: BigInt
  lpTokenSupply_lte: BigInt
  lpTokenSupply_in: [BigInt!]
  lpTokenSupply_not_in: [BigInt!]
  events_: arbitrumone_StableSwapEvent_filter
  exchanges_: arbitrumone_StableSwapExchange_filter
  hourlyVolumes_: arbitrumone_SwapHourlyVolume_filter
  dailyVolumes_: arbitrumone_SwapDailyVolume_filter
  weeklyVolumes_: arbitrumone_SwapWeeklyVolume_filter
  """Filter for the block changed event."""
  _change_block: arbitrumone_BlockChangedFilter
}

enum arbitrumone_StableSwap_orderBy {
  id
  isActive
  key
  canonicalId
  domain
  swapPool
  lpToken
  initialA
  futureA
  initialATime
  futureATime
  swapFee
  adminFee
  pooledTokens
  tokenPrecisionMultipliers
  balances
  adminFees
  virtualPrice
  invariant
  lpTokenSupply
  events
  exchanges
  hourlyVolumes
  dailyVolumes
  weeklyVolumes
}

type arbitrumone_SwapDailyVolume implements arbitrumone_SwapTradeVolume {
  id: ID!
  stableSwap: arbitrumone_StableSwap!
  timestamp: BigInt!
  volume: arbitrumone_BigDecimal!
}

input arbitrumone_SwapDailyVolume_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: arbitrumone_StableSwap_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  volume: arbitrumone_BigDecimal
  volume_not: arbitrumone_BigDecimal
  volume_gt: arbitrumone_BigDecimal
  volume_lt: arbitrumone_BigDecimal
  volume_gte: arbitrumone_BigDecimal
  volume_lte: arbitrumone_BigDecimal
  volume_in: [arbitrumone_BigDecimal!]
  volume_not_in: [arbitrumone_BigDecimal!]
  """Filter for the block changed event."""
  _change_block: arbitrumone_BlockChangedFilter
}

enum arbitrumone_SwapDailyVolume_orderBy {
  id
  stableSwap
  timestamp
  volume
}

type arbitrumone_SwapHourlyVolume implements arbitrumone_SwapTradeVolume {
  id: ID!
  stableSwap: arbitrumone_StableSwap!
  timestamp: BigInt!
  volume: arbitrumone_BigDecimal!
}

input arbitrumone_SwapHourlyVolume_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: arbitrumone_StableSwap_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  volume: arbitrumone_BigDecimal
  volume_not: arbitrumone_BigDecimal
  volume_gt: arbitrumone_BigDecimal
  volume_lt: arbitrumone_BigDecimal
  volume_gte: arbitrumone_BigDecimal
  volume_lte: arbitrumone_BigDecimal
  volume_in: [arbitrumone_BigDecimal!]
  volume_not_in: [arbitrumone_BigDecimal!]
  """Filter for the block changed event."""
  _change_block: arbitrumone_BlockChangedFilter
}

enum arbitrumone_SwapHourlyVolume_orderBy {
  id
  stableSwap
  timestamp
  volume
}

interface arbitrumone_SwapTradeVolume {
  stableSwap: arbitrumone_StableSwap!
  timestamp: BigInt!
  volume: arbitrumone_BigDecimal!
}

input arbitrumone_SwapTradeVolume_filter {
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: arbitrumone_StableSwap_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  volume: arbitrumone_BigDecimal
  volume_not: arbitrumone_BigDecimal
  volume_gt: arbitrumone_BigDecimal
  volume_lt: arbitrumone_BigDecimal
  volume_gte: arbitrumone_BigDecimal
  volume_lte: arbitrumone_BigDecimal
  volume_in: [arbitrumone_BigDecimal!]
  volume_not_in: [arbitrumone_BigDecimal!]
  """Filter for the block changed event."""
  _change_block: arbitrumone_BlockChangedFilter
}

enum arbitrumone_SwapTradeVolume_orderBy {
  stableSwap
  timestamp
  volume
}

type arbitrumone_SwapWeeklyVolume implements arbitrumone_SwapTradeVolume {
  id: ID!
  stableSwap: arbitrumone_StableSwap!
  timestamp: BigInt!
  volume: arbitrumone_BigDecimal!
}

input arbitrumone_SwapWeeklyVolume_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: arbitrumone_StableSwap_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  volume: arbitrumone_BigDecimal
  volume_not: arbitrumone_BigDecimal
  volume_gt: arbitrumone_BigDecimal
  volume_lt: arbitrumone_BigDecimal
  volume_gte: arbitrumone_BigDecimal
  volume_lte: arbitrumone_BigDecimal
  volume_in: [arbitrumone_BigDecimal!]
  volume_not_in: [arbitrumone_BigDecimal!]
  """Filter for the block changed event."""
  _change_block: arbitrumone_BlockChangedFilter
}

enum arbitrumone_SwapWeeklyVolume_orderBy {
  id
  stableSwap
  timestamp
  volume
}

type arbitrumone_SystemInfo {
  id: ID!
  exchangeCount: BigInt!
  swapCount: BigInt!
}

input arbitrumone_SystemInfo_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  exchangeCount: BigInt
  exchangeCount_not: BigInt
  exchangeCount_gt: BigInt
  exchangeCount_lt: BigInt
  exchangeCount_gte: BigInt
  exchangeCount_lte: BigInt
  exchangeCount_in: [BigInt!]
  exchangeCount_not_in: [BigInt!]
  swapCount: BigInt
  swapCount_not: BigInt
  swapCount_gt: BigInt
  swapCount_lt: BigInt
  swapCount_gte: BigInt
  swapCount_lte: BigInt
  swapCount_in: [BigInt!]
  swapCount_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: arbitrumone_BlockChangedFilter
}

enum arbitrumone_SystemInfo_orderBy {
  id
  exchangeCount
  swapCount
}

type arbitrumone__Block_ {
  """The hash of the block"""
  hash: arbitrumone_Bytes
  """The block number"""
  number: Int!
  """Integer representation of the timestamp stored in blocks for the chain"""
  timestamp: Int
}

"""The type for the top-level _meta field"""
type arbitrumone__Meta_ {
  """
  Information about a specific subgraph block. The hash of the block
  will be null if the _meta field has a block constraint that asks for
  a block number. It will be filled if the _meta field has no block constraint
  and therefore asks for the latest  block
  
  """
  block: arbitrumone__Block_!
  """The deployment ID"""
  deployment: String!
  """If `true`, the subgraph encountered indexing errors at some past block"""
  hasIndexingErrors: Boolean!
}

scalar bnb_BigDecimal

input bnb_BlockChangedFilter {
  number_gte: Int!
}

input bnb_Block_height {
  hash: bnb_Bytes
  number: Int
  number_gte: Int
}

scalar bnb_Bytes

"""Defines the order direction, either ascending or descending"""
enum bnb_OrderDirection {
  asc
  desc
}

type bnb_PooledToken {
  id: ID!
  asset: bnb_Bytes!
}

input bnb_PooledToken_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  asset: bnb_Bytes
  asset_not: bnb_Bytes
  asset_gt: bnb_Bytes
  asset_lt: bnb_Bytes
  asset_gte: bnb_Bytes
  asset_lte: bnb_Bytes
  asset_in: [bnb_Bytes!]
  asset_not_in: [bnb_Bytes!]
  asset_contains: bnb_Bytes
  asset_not_contains: bnb_Bytes
  """Filter for the block changed event."""
  _change_block: bnb_BlockChangedFilter
}

enum bnb_PooledToken_orderBy {
  id
  asset
}

type bnb_StableSwap {
  id: ID!
  isActive: Boolean
  key: bnb_Bytes!
  canonicalId: bnb_Bytes
  domain: BigInt
  swapPool: bnb_Bytes
  lpToken: bnb_Bytes
  initialA: BigInt
  futureA: BigInt
  initialATime: BigInt
  futureATime: BigInt
  swapFee: BigInt
  adminFee: BigInt
  pooledTokens(skip: Int = 0, first: Int = 100, orderBy: bnb_PooledToken_orderBy, orderDirection: bnb_OrderDirection, where: bnb_PooledToken_filter): [bnb_PooledToken!]!
  tokenPrecisionMultipliers: [BigInt!]!
  balances: [BigInt!]!
  adminFees: [BigInt!]!
  virtualPrice: BigInt!
  invariant: BigInt!
  lpTokenSupply: BigInt!
  events(skip: Int = 0, first: Int = 100, orderBy: bnb_StableSwapEvent_orderBy, orderDirection: bnb_OrderDirection, where: bnb_StableSwapEvent_filter): [bnb_StableSwapEvent!]
  exchanges(skip: Int = 0, first: Int = 100, orderBy: bnb_StableSwapExchange_orderBy, orderDirection: bnb_OrderDirection, where: bnb_StableSwapExchange_filter): [bnb_StableSwapExchange!]
  hourlyVolumes(skip: Int = 0, first: Int = 100, orderBy: bnb_SwapHourlyVolume_orderBy, orderDirection: bnb_OrderDirection, where: bnb_SwapHourlyVolume_filter): [bnb_SwapHourlyVolume!]
  dailyVolumes(skip: Int = 0, first: Int = 100, orderBy: bnb_SwapDailyVolume_orderBy, orderDirection: bnb_OrderDirection, where: bnb_SwapDailyVolume_filter): [bnb_SwapDailyVolume!]
  weeklyVolumes(skip: Int = 0, first: Int = 100, orderBy: bnb_SwapWeeklyVolume_orderBy, orderDirection: bnb_OrderDirection, where: bnb_SwapWeeklyVolume_filter): [bnb_SwapWeeklyVolume!]
}

type bnb_StableSwapAddLiquidityEvent implements bnb_StableSwapEvent {
  id: ID!
  stableSwap: bnb_StableSwap!
  provider: bnb_Bytes!
  tokenAmounts: [BigInt!]!
  fees: [BigInt!]!
  invariant: BigInt
  lpTokenSupply: BigInt!
  block: BigInt!
  timestamp: BigInt!
  transaction: bnb_Bytes!
}

input bnb_StableSwapAddLiquidityEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: bnb_StableSwap_filter
  provider: bnb_Bytes
  provider_not: bnb_Bytes
  provider_gt: bnb_Bytes
  provider_lt: bnb_Bytes
  provider_gte: bnb_Bytes
  provider_lte: bnb_Bytes
  provider_in: [bnb_Bytes!]
  provider_not_in: [bnb_Bytes!]
  provider_contains: bnb_Bytes
  provider_not_contains: bnb_Bytes
  tokenAmounts: [BigInt!]
  tokenAmounts_not: [BigInt!]
  tokenAmounts_contains: [BigInt!]
  tokenAmounts_contains_nocase: [BigInt!]
  tokenAmounts_not_contains: [BigInt!]
  tokenAmounts_not_contains_nocase: [BigInt!]
  fees: [BigInt!]
  fees_not: [BigInt!]
  fees_contains: [BigInt!]
  fees_contains_nocase: [BigInt!]
  fees_not_contains: [BigInt!]
  fees_not_contains_nocase: [BigInt!]
  invariant: BigInt
  invariant_not: BigInt
  invariant_gt: BigInt
  invariant_lt: BigInt
  invariant_gte: BigInt
  invariant_lte: BigInt
  invariant_in: [BigInt!]
  invariant_not_in: [BigInt!]
  lpTokenSupply: BigInt
  lpTokenSupply_not: BigInt
  lpTokenSupply_gt: BigInt
  lpTokenSupply_lt: BigInt
  lpTokenSupply_gte: BigInt
  lpTokenSupply_lte: BigInt
  lpTokenSupply_in: [BigInt!]
  lpTokenSupply_not_in: [BigInt!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: bnb_Bytes
  transaction_not: bnb_Bytes
  transaction_gt: bnb_Bytes
  transaction_lt: bnb_Bytes
  transaction_gte: bnb_Bytes
  transaction_lte: bnb_Bytes
  transaction_in: [bnb_Bytes!]
  transaction_not_in: [bnb_Bytes!]
  transaction_contains: bnb_Bytes
  transaction_not_contains: bnb_Bytes
  """Filter for the block changed event."""
  _change_block: bnb_BlockChangedFilter
}

enum bnb_StableSwapAddLiquidityEvent_orderBy {
  id
  stableSwap
  provider
  tokenAmounts
  fees
  invariant
  lpTokenSupply
  block
  timestamp
  transaction
}

interface bnb_StableSwapEvent {
  id: ID!
  stableSwap: bnb_StableSwap!
  block: BigInt!
  timestamp: BigInt!
  transaction: bnb_Bytes!
}

input bnb_StableSwapEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: bnb_StableSwap_filter
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: bnb_Bytes
  transaction_not: bnb_Bytes
  transaction_gt: bnb_Bytes
  transaction_lt: bnb_Bytes
  transaction_gte: bnb_Bytes
  transaction_lte: bnb_Bytes
  transaction_in: [bnb_Bytes!]
  transaction_not_in: [bnb_Bytes!]
  transaction_contains: bnb_Bytes
  transaction_not_contains: bnb_Bytes
  """Filter for the block changed event."""
  _change_block: bnb_BlockChangedFilter
}

enum bnb_StableSwapEvent_orderBy {
  id
  stableSwap
  block
  timestamp
  transaction
}

type bnb_StableSwapExchange {
  id: ID!
  stableSwap: bnb_StableSwap!
  buyer: bnb_Bytes!
  boughtId: BigInt!
  tokensBought: BigInt!
  soldId: BigInt!
  tokensSold: BigInt!
  block: BigInt!
  timestamp: BigInt!
  transaction: bnb_Bytes!
}

input bnb_StableSwapExchange_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: bnb_StableSwap_filter
  buyer: bnb_Bytes
  buyer_not: bnb_Bytes
  buyer_gt: bnb_Bytes
  buyer_lt: bnb_Bytes
  buyer_gte: bnb_Bytes
  buyer_lte: bnb_Bytes
  buyer_in: [bnb_Bytes!]
  buyer_not_in: [bnb_Bytes!]
  buyer_contains: bnb_Bytes
  buyer_not_contains: bnb_Bytes
  boughtId: BigInt
  boughtId_not: BigInt
  boughtId_gt: BigInt
  boughtId_lt: BigInt
  boughtId_gte: BigInt
  boughtId_lte: BigInt
  boughtId_in: [BigInt!]
  boughtId_not_in: [BigInt!]
  tokensBought: BigInt
  tokensBought_not: BigInt
  tokensBought_gt: BigInt
  tokensBought_lt: BigInt
  tokensBought_gte: BigInt
  tokensBought_lte: BigInt
  tokensBought_in: [BigInt!]
  tokensBought_not_in: [BigInt!]
  soldId: BigInt
  soldId_not: BigInt
  soldId_gt: BigInt
  soldId_lt: BigInt
  soldId_gte: BigInt
  soldId_lte: BigInt
  soldId_in: [BigInt!]
  soldId_not_in: [BigInt!]
  tokensSold: BigInt
  tokensSold_not: BigInt
  tokensSold_gt: BigInt
  tokensSold_lt: BigInt
  tokensSold_gte: BigInt
  tokensSold_lte: BigInt
  tokensSold_in: [BigInt!]
  tokensSold_not_in: [BigInt!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: bnb_Bytes
  transaction_not: bnb_Bytes
  transaction_gt: bnb_Bytes
  transaction_lt: bnb_Bytes
  transaction_gte: bnb_Bytes
  transaction_lte: bnb_Bytes
  transaction_in: [bnb_Bytes!]
  transaction_not_in: [bnb_Bytes!]
  transaction_contains: bnb_Bytes
  transaction_not_contains: bnb_Bytes
  """Filter for the block changed event."""
  _change_block: bnb_BlockChangedFilter
}

enum bnb_StableSwapExchange_orderBy {
  id
  stableSwap
  buyer
  boughtId
  tokensBought
  soldId
  tokensSold
  block
  timestamp
  transaction
}

type bnb_StableSwapRemoveLiquidityEvent implements bnb_StableSwapEvent {
  id: ID!
  stableSwap: bnb_StableSwap!
  provider: bnb_Bytes!
  tokenAmounts: [BigInt!]!
  fees: [BigInt!]
  invariant: BigInt
  lpTokenSupply: BigInt!
  block: BigInt!
  timestamp: BigInt!
  transaction: bnb_Bytes!
}

input bnb_StableSwapRemoveLiquidityEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: bnb_StableSwap_filter
  provider: bnb_Bytes
  provider_not: bnb_Bytes
  provider_gt: bnb_Bytes
  provider_lt: bnb_Bytes
  provider_gte: bnb_Bytes
  provider_lte: bnb_Bytes
  provider_in: [bnb_Bytes!]
  provider_not_in: [bnb_Bytes!]
  provider_contains: bnb_Bytes
  provider_not_contains: bnb_Bytes
  tokenAmounts: [BigInt!]
  tokenAmounts_not: [BigInt!]
  tokenAmounts_contains: [BigInt!]
  tokenAmounts_contains_nocase: [BigInt!]
  tokenAmounts_not_contains: [BigInt!]
  tokenAmounts_not_contains_nocase: [BigInt!]
  fees: [BigInt!]
  fees_not: [BigInt!]
  fees_contains: [BigInt!]
  fees_contains_nocase: [BigInt!]
  fees_not_contains: [BigInt!]
  fees_not_contains_nocase: [BigInt!]
  invariant: BigInt
  invariant_not: BigInt
  invariant_gt: BigInt
  invariant_lt: BigInt
  invariant_gte: BigInt
  invariant_lte: BigInt
  invariant_in: [BigInt!]
  invariant_not_in: [BigInt!]
  lpTokenSupply: BigInt
  lpTokenSupply_not: BigInt
  lpTokenSupply_gt: BigInt
  lpTokenSupply_lt: BigInt
  lpTokenSupply_gte: BigInt
  lpTokenSupply_lte: BigInt
  lpTokenSupply_in: [BigInt!]
  lpTokenSupply_not_in: [BigInt!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: bnb_Bytes
  transaction_not: bnb_Bytes
  transaction_gt: bnb_Bytes
  transaction_lt: bnb_Bytes
  transaction_gte: bnb_Bytes
  transaction_lte: bnb_Bytes
  transaction_in: [bnb_Bytes!]
  transaction_not_in: [bnb_Bytes!]
  transaction_contains: bnb_Bytes
  transaction_not_contains: bnb_Bytes
  """Filter for the block changed event."""
  _change_block: bnb_BlockChangedFilter
}

enum bnb_StableSwapRemoveLiquidityEvent_orderBy {
  id
  stableSwap
  provider
  tokenAmounts
  fees
  invariant
  lpTokenSupply
  block
  timestamp
  transaction
}

input bnb_StableSwap_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  isActive: Boolean
  isActive_not: Boolean
  isActive_in: [Boolean!]
  isActive_not_in: [Boolean!]
  key: bnb_Bytes
  key_not: bnb_Bytes
  key_gt: bnb_Bytes
  key_lt: bnb_Bytes
  key_gte: bnb_Bytes
  key_lte: bnb_Bytes
  key_in: [bnb_Bytes!]
  key_not_in: [bnb_Bytes!]
  key_contains: bnb_Bytes
  key_not_contains: bnb_Bytes
  canonicalId: bnb_Bytes
  canonicalId_not: bnb_Bytes
  canonicalId_gt: bnb_Bytes
  canonicalId_lt: bnb_Bytes
  canonicalId_gte: bnb_Bytes
  canonicalId_lte: bnb_Bytes
  canonicalId_in: [bnb_Bytes!]
  canonicalId_not_in: [bnb_Bytes!]
  canonicalId_contains: bnb_Bytes
  canonicalId_not_contains: bnb_Bytes
  domain: BigInt
  domain_not: BigInt
  domain_gt: BigInt
  domain_lt: BigInt
  domain_gte: BigInt
  domain_lte: BigInt
  domain_in: [BigInt!]
  domain_not_in: [BigInt!]
  swapPool: bnb_Bytes
  swapPool_not: bnb_Bytes
  swapPool_gt: bnb_Bytes
  swapPool_lt: bnb_Bytes
  swapPool_gte: bnb_Bytes
  swapPool_lte: bnb_Bytes
  swapPool_in: [bnb_Bytes!]
  swapPool_not_in: [bnb_Bytes!]
  swapPool_contains: bnb_Bytes
  swapPool_not_contains: bnb_Bytes
  lpToken: bnb_Bytes
  lpToken_not: bnb_Bytes
  lpToken_gt: bnb_Bytes
  lpToken_lt: bnb_Bytes
  lpToken_gte: bnb_Bytes
  lpToken_lte: bnb_Bytes
  lpToken_in: [bnb_Bytes!]
  lpToken_not_in: [bnb_Bytes!]
  lpToken_contains: bnb_Bytes
  lpToken_not_contains: bnb_Bytes
  initialA: BigInt
  initialA_not: BigInt
  initialA_gt: BigInt
  initialA_lt: BigInt
  initialA_gte: BigInt
  initialA_lte: BigInt
  initialA_in: [BigInt!]
  initialA_not_in: [BigInt!]
  futureA: BigInt
  futureA_not: BigInt
  futureA_gt: BigInt
  futureA_lt: BigInt
  futureA_gte: BigInt
  futureA_lte: BigInt
  futureA_in: [BigInt!]
  futureA_not_in: [BigInt!]
  initialATime: BigInt
  initialATime_not: BigInt
  initialATime_gt: BigInt
  initialATime_lt: BigInt
  initialATime_gte: BigInt
  initialATime_lte: BigInt
  initialATime_in: [BigInt!]
  initialATime_not_in: [BigInt!]
  futureATime: BigInt
  futureATime_not: BigInt
  futureATime_gt: BigInt
  futureATime_lt: BigInt
  futureATime_gte: BigInt
  futureATime_lte: BigInt
  futureATime_in: [BigInt!]
  futureATime_not_in: [BigInt!]
  swapFee: BigInt
  swapFee_not: BigInt
  swapFee_gt: BigInt
  swapFee_lt: BigInt
  swapFee_gte: BigInt
  swapFee_lte: BigInt
  swapFee_in: [BigInt!]
  swapFee_not_in: [BigInt!]
  adminFee: BigInt
  adminFee_not: BigInt
  adminFee_gt: BigInt
  adminFee_lt: BigInt
  adminFee_gte: BigInt
  adminFee_lte: BigInt
  adminFee_in: [BigInt!]
  adminFee_not_in: [BigInt!]
  pooledTokens: [String!]
  pooledTokens_not: [String!]
  pooledTokens_contains: [String!]
  pooledTokens_contains_nocase: [String!]
  pooledTokens_not_contains: [String!]
  pooledTokens_not_contains_nocase: [String!]
  pooledTokens_: bnb_PooledToken_filter
  tokenPrecisionMultipliers: [BigInt!]
  tokenPrecisionMultipliers_not: [BigInt!]
  tokenPrecisionMultipliers_contains: [BigInt!]
  tokenPrecisionMultipliers_contains_nocase: [BigInt!]
  tokenPrecisionMultipliers_not_contains: [BigInt!]
  tokenPrecisionMultipliers_not_contains_nocase: [BigInt!]
  balances: [BigInt!]
  balances_not: [BigInt!]
  balances_contains: [BigInt!]
  balances_contains_nocase: [BigInt!]
  balances_not_contains: [BigInt!]
  balances_not_contains_nocase: [BigInt!]
  adminFees: [BigInt!]
  adminFees_not: [BigInt!]
  adminFees_contains: [BigInt!]
  adminFees_contains_nocase: [BigInt!]
  adminFees_not_contains: [BigInt!]
  adminFees_not_contains_nocase: [BigInt!]
  virtualPrice: BigInt
  virtualPrice_not: BigInt
  virtualPrice_gt: BigInt
  virtualPrice_lt: BigInt
  virtualPrice_gte: BigInt
  virtualPrice_lte: BigInt
  virtualPrice_in: [BigInt!]
  virtualPrice_not_in: [BigInt!]
  invariant: BigInt
  invariant_not: BigInt
  invariant_gt: BigInt
  invariant_lt: BigInt
  invariant_gte: BigInt
  invariant_lte: BigInt
  invariant_in: [BigInt!]
  invariant_not_in: [BigInt!]
  lpTokenSupply: BigInt
  lpTokenSupply_not: BigInt
  lpTokenSupply_gt: BigInt
  lpTokenSupply_lt: BigInt
  lpTokenSupply_gte: BigInt
  lpTokenSupply_lte: BigInt
  lpTokenSupply_in: [BigInt!]
  lpTokenSupply_not_in: [BigInt!]
  events_: bnb_StableSwapEvent_filter
  exchanges_: bnb_StableSwapExchange_filter
  hourlyVolumes_: bnb_SwapHourlyVolume_filter
  dailyVolumes_: bnb_SwapDailyVolume_filter
  weeklyVolumes_: bnb_SwapWeeklyVolume_filter
  """Filter for the block changed event."""
  _change_block: bnb_BlockChangedFilter
}

enum bnb_StableSwap_orderBy {
  id
  isActive
  key
  canonicalId
  domain
  swapPool
  lpToken
  initialA
  futureA
  initialATime
  futureATime
  swapFee
  adminFee
  pooledTokens
  tokenPrecisionMultipliers
  balances
  adminFees
  virtualPrice
  invariant
  lpTokenSupply
  events
  exchanges
  hourlyVolumes
  dailyVolumes
  weeklyVolumes
}

type bnb_SwapDailyVolume implements bnb_SwapTradeVolume {
  id: ID!
  stableSwap: bnb_StableSwap!
  timestamp: BigInt!
  volume: bnb_BigDecimal!
}

input bnb_SwapDailyVolume_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: bnb_StableSwap_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  volume: bnb_BigDecimal
  volume_not: bnb_BigDecimal
  volume_gt: bnb_BigDecimal
  volume_lt: bnb_BigDecimal
  volume_gte: bnb_BigDecimal
  volume_lte: bnb_BigDecimal
  volume_in: [bnb_BigDecimal!]
  volume_not_in: [bnb_BigDecimal!]
  """Filter for the block changed event."""
  _change_block: bnb_BlockChangedFilter
}

enum bnb_SwapDailyVolume_orderBy {
  id
  stableSwap
  timestamp
  volume
}

type bnb_SwapHourlyVolume implements bnb_SwapTradeVolume {
  id: ID!
  stableSwap: bnb_StableSwap!
  timestamp: BigInt!
  volume: bnb_BigDecimal!
}

input bnb_SwapHourlyVolume_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: bnb_StableSwap_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  volume: bnb_BigDecimal
  volume_not: bnb_BigDecimal
  volume_gt: bnb_BigDecimal
  volume_lt: bnb_BigDecimal
  volume_gte: bnb_BigDecimal
  volume_lte: bnb_BigDecimal
  volume_in: [bnb_BigDecimal!]
  volume_not_in: [bnb_BigDecimal!]
  """Filter for the block changed event."""
  _change_block: bnb_BlockChangedFilter
}

enum bnb_SwapHourlyVolume_orderBy {
  id
  stableSwap
  timestamp
  volume
}

interface bnb_SwapTradeVolume {
  stableSwap: bnb_StableSwap!
  timestamp: BigInt!
  volume: bnb_BigDecimal!
}

input bnb_SwapTradeVolume_filter {
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: bnb_StableSwap_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  volume: bnb_BigDecimal
  volume_not: bnb_BigDecimal
  volume_gt: bnb_BigDecimal
  volume_lt: bnb_BigDecimal
  volume_gte: bnb_BigDecimal
  volume_lte: bnb_BigDecimal
  volume_in: [bnb_BigDecimal!]
  volume_not_in: [bnb_BigDecimal!]
  """Filter for the block changed event."""
  _change_block: bnb_BlockChangedFilter
}

enum bnb_SwapTradeVolume_orderBy {
  stableSwap
  timestamp
  volume
}

type bnb_SwapWeeklyVolume implements bnb_SwapTradeVolume {
  id: ID!
  stableSwap: bnb_StableSwap!
  timestamp: BigInt!
  volume: bnb_BigDecimal!
}

input bnb_SwapWeeklyVolume_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: bnb_StableSwap_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  volume: bnb_BigDecimal
  volume_not: bnb_BigDecimal
  volume_gt: bnb_BigDecimal
  volume_lt: bnb_BigDecimal
  volume_gte: bnb_BigDecimal
  volume_lte: bnb_BigDecimal
  volume_in: [bnb_BigDecimal!]
  volume_not_in: [bnb_BigDecimal!]
  """Filter for the block changed event."""
  _change_block: bnb_BlockChangedFilter
}

enum bnb_SwapWeeklyVolume_orderBy {
  id
  stableSwap
  timestamp
  volume
}

type bnb_SystemInfo {
  id: ID!
  exchangeCount: BigInt!
  swapCount: BigInt!
}

input bnb_SystemInfo_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  exchangeCount: BigInt
  exchangeCount_not: BigInt
  exchangeCount_gt: BigInt
  exchangeCount_lt: BigInt
  exchangeCount_gte: BigInt
  exchangeCount_lte: BigInt
  exchangeCount_in: [BigInt!]
  exchangeCount_not_in: [BigInt!]
  swapCount: BigInt
  swapCount_not: BigInt
  swapCount_gt: BigInt
  swapCount_lt: BigInt
  swapCount_gte: BigInt
  swapCount_lte: BigInt
  swapCount_in: [BigInt!]
  swapCount_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: bnb_BlockChangedFilter
}

enum bnb_SystemInfo_orderBy {
  id
  exchangeCount
  swapCount
}

type bnb__Block_ {
  """The hash of the block"""
  hash: bnb_Bytes
  """The block number"""
  number: Int!
  """Integer representation of the timestamp stored in blocks for the chain"""
  timestamp: Int
}

"""The type for the top-level _meta field"""
type bnb__Meta_ {
  """
  Information about a specific subgraph block. The hash of the block
  will be null if the _meta field has a block constraint that asks for
  a block number. It will be filled if the _meta field has no block constraint
  and therefore asks for the latest  block
  
  """
  block: bnb__Block_!
  """The deployment ID"""
  deployment: String!
  """If `true`, the subgraph encountered indexing errors at some past block"""
  hasIndexingErrors: Boolean!
}

scalar goerli_BigDecimal

input goerli_BlockChangedFilter {
  number_gte: Int!
}

input goerli_Block_height {
  hash: goerli_Bytes
  number: Int
  number_gte: Int
}

scalar goerli_Bytes

"""Defines the order direction, either ascending or descending"""
enum goerli_OrderDirection {
  asc
  desc
}

type goerli_PooledToken {
  id: ID!
  asset: goerli_Bytes!
}

input goerli_PooledToken_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  asset: goerli_Bytes
  asset_not: goerli_Bytes
  asset_gt: goerli_Bytes
  asset_lt: goerli_Bytes
  asset_gte: goerli_Bytes
  asset_lte: goerli_Bytes
  asset_in: [goerli_Bytes!]
  asset_not_in: [goerli_Bytes!]
  asset_contains: goerli_Bytes
  asset_not_contains: goerli_Bytes
  """Filter for the block changed event."""
  _change_block: goerli_BlockChangedFilter
}

enum goerli_PooledToken_orderBy {
  id
  asset
}

type goerli_StableSwap {
  id: ID!
  isActive: Boolean
  key: goerli_Bytes!
  canonicalId: goerli_Bytes
  domain: BigInt
  swapPool: goerli_Bytes
  lpToken: goerli_Bytes
  initialA: BigInt
  futureA: BigInt
  initialATime: BigInt
  futureATime: BigInt
  swapFee: BigInt
  adminFee: BigInt
  pooledTokens(skip: Int = 0, first: Int = 100, orderBy: goerli_PooledToken_orderBy, orderDirection: goerli_OrderDirection, where: goerli_PooledToken_filter): [goerli_PooledToken!]!
  tokenPrecisionMultipliers: [BigInt!]!
  balances: [BigInt!]!
  adminFees: [BigInt!]!
  virtualPrice: BigInt!
  invariant: BigInt!
  lpTokenSupply: BigInt!
  events(skip: Int = 0, first: Int = 100, orderBy: goerli_StableSwapEvent_orderBy, orderDirection: goerli_OrderDirection, where: goerli_StableSwapEvent_filter): [goerli_StableSwapEvent!]
  exchanges(skip: Int = 0, first: Int = 100, orderBy: goerli_StableSwapExchange_orderBy, orderDirection: goerli_OrderDirection, where: goerli_StableSwapExchange_filter): [goerli_StableSwapExchange!]
  hourlyVolumes(skip: Int = 0, first: Int = 100, orderBy: goerli_SwapHourlyVolume_orderBy, orderDirection: goerli_OrderDirection, where: goerli_SwapHourlyVolume_filter): [goerli_SwapHourlyVolume!]
  dailyVolumes(skip: Int = 0, first: Int = 100, orderBy: goerli_SwapDailyVolume_orderBy, orderDirection: goerli_OrderDirection, where: goerli_SwapDailyVolume_filter): [goerli_SwapDailyVolume!]
  weeklyVolumes(skip: Int = 0, first: Int = 100, orderBy: goerli_SwapWeeklyVolume_orderBy, orderDirection: goerli_OrderDirection, where: goerli_SwapWeeklyVolume_filter): [goerli_SwapWeeklyVolume!]
}

type goerli_StableSwapAddLiquidityEvent implements goerli_StableSwapEvent {
  id: ID!
  stableSwap: goerli_StableSwap!
  provider: goerli_Bytes!
  tokenAmounts: [BigInt!]!
  fees: [BigInt!]!
  invariant: BigInt
  lpTokenSupply: BigInt!
  block: BigInt!
  timestamp: BigInt!
  transaction: goerli_Bytes!
}

input goerli_StableSwapAddLiquidityEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: goerli_StableSwap_filter
  provider: goerli_Bytes
  provider_not: goerli_Bytes
  provider_gt: goerli_Bytes
  provider_lt: goerli_Bytes
  provider_gte: goerli_Bytes
  provider_lte: goerli_Bytes
  provider_in: [goerli_Bytes!]
  provider_not_in: [goerli_Bytes!]
  provider_contains: goerli_Bytes
  provider_not_contains: goerli_Bytes
  tokenAmounts: [BigInt!]
  tokenAmounts_not: [BigInt!]
  tokenAmounts_contains: [BigInt!]
  tokenAmounts_contains_nocase: [BigInt!]
  tokenAmounts_not_contains: [BigInt!]
  tokenAmounts_not_contains_nocase: [BigInt!]
  fees: [BigInt!]
  fees_not: [BigInt!]
  fees_contains: [BigInt!]
  fees_contains_nocase: [BigInt!]
  fees_not_contains: [BigInt!]
  fees_not_contains_nocase: [BigInt!]
  invariant: BigInt
  invariant_not: BigInt
  invariant_gt: BigInt
  invariant_lt: BigInt
  invariant_gte: BigInt
  invariant_lte: BigInt
  invariant_in: [BigInt!]
  invariant_not_in: [BigInt!]
  lpTokenSupply: BigInt
  lpTokenSupply_not: BigInt
  lpTokenSupply_gt: BigInt
  lpTokenSupply_lt: BigInt
  lpTokenSupply_gte: BigInt
  lpTokenSupply_lte: BigInt
  lpTokenSupply_in: [BigInt!]
  lpTokenSupply_not_in: [BigInt!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: goerli_Bytes
  transaction_not: goerli_Bytes
  transaction_gt: goerli_Bytes
  transaction_lt: goerli_Bytes
  transaction_gte: goerli_Bytes
  transaction_lte: goerli_Bytes
  transaction_in: [goerli_Bytes!]
  transaction_not_in: [goerli_Bytes!]
  transaction_contains: goerli_Bytes
  transaction_not_contains: goerli_Bytes
  """Filter for the block changed event."""
  _change_block: goerli_BlockChangedFilter
}

enum goerli_StableSwapAddLiquidityEvent_orderBy {
  id
  stableSwap
  provider
  tokenAmounts
  fees
  invariant
  lpTokenSupply
  block
  timestamp
  transaction
}

interface goerli_StableSwapEvent {
  id: ID!
  stableSwap: goerli_StableSwap!
  block: BigInt!
  timestamp: BigInt!
  transaction: goerli_Bytes!
}

input goerli_StableSwapEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: goerli_StableSwap_filter
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: goerli_Bytes
  transaction_not: goerli_Bytes
  transaction_gt: goerli_Bytes
  transaction_lt: goerli_Bytes
  transaction_gte: goerli_Bytes
  transaction_lte: goerli_Bytes
  transaction_in: [goerli_Bytes!]
  transaction_not_in: [goerli_Bytes!]
  transaction_contains: goerli_Bytes
  transaction_not_contains: goerli_Bytes
  """Filter for the block changed event."""
  _change_block: goerli_BlockChangedFilter
}

enum goerli_StableSwapEvent_orderBy {
  id
  stableSwap
  block
  timestamp
  transaction
}

type goerli_StableSwapExchange {
  id: ID!
  stableSwap: goerli_StableSwap!
  buyer: goerli_Bytes!
  boughtId: BigInt!
  tokensBought: BigInt!
  soldId: BigInt!
  tokensSold: BigInt!
  block: BigInt!
  timestamp: BigInt!
  transaction: goerli_Bytes!
}

input goerli_StableSwapExchange_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: goerli_StableSwap_filter
  buyer: goerli_Bytes
  buyer_not: goerli_Bytes
  buyer_gt: goerli_Bytes
  buyer_lt: goerli_Bytes
  buyer_gte: goerli_Bytes
  buyer_lte: goerli_Bytes
  buyer_in: [goerli_Bytes!]
  buyer_not_in: [goerli_Bytes!]
  buyer_contains: goerli_Bytes
  buyer_not_contains: goerli_Bytes
  boughtId: BigInt
  boughtId_not: BigInt
  boughtId_gt: BigInt
  boughtId_lt: BigInt
  boughtId_gte: BigInt
  boughtId_lte: BigInt
  boughtId_in: [BigInt!]
  boughtId_not_in: [BigInt!]
  tokensBought: BigInt
  tokensBought_not: BigInt
  tokensBought_gt: BigInt
  tokensBought_lt: BigInt
  tokensBought_gte: BigInt
  tokensBought_lte: BigInt
  tokensBought_in: [BigInt!]
  tokensBought_not_in: [BigInt!]
  soldId: BigInt
  soldId_not: BigInt
  soldId_gt: BigInt
  soldId_lt: BigInt
  soldId_gte: BigInt
  soldId_lte: BigInt
  soldId_in: [BigInt!]
  soldId_not_in: [BigInt!]
  tokensSold: BigInt
  tokensSold_not: BigInt
  tokensSold_gt: BigInt
  tokensSold_lt: BigInt
  tokensSold_gte: BigInt
  tokensSold_lte: BigInt
  tokensSold_in: [BigInt!]
  tokensSold_not_in: [BigInt!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: goerli_Bytes
  transaction_not: goerli_Bytes
  transaction_gt: goerli_Bytes
  transaction_lt: goerli_Bytes
  transaction_gte: goerli_Bytes
  transaction_lte: goerli_Bytes
  transaction_in: [goerli_Bytes!]
  transaction_not_in: [goerli_Bytes!]
  transaction_contains: goerli_Bytes
  transaction_not_contains: goerli_Bytes
  """Filter for the block changed event."""
  _change_block: goerli_BlockChangedFilter
}

enum goerli_StableSwapExchange_orderBy {
  id
  stableSwap
  buyer
  boughtId
  tokensBought
  soldId
  tokensSold
  block
  timestamp
  transaction
}

type goerli_StableSwapRemoveLiquidityEvent implements goerli_StableSwapEvent {
  id: ID!
  stableSwap: goerli_StableSwap!
  provider: goerli_Bytes!
  tokenAmounts: [BigInt!]!
  fees: [BigInt!]
  invariant: BigInt
  lpTokenSupply: BigInt!
  block: BigInt!
  timestamp: BigInt!
  transaction: goerli_Bytes!
}

input goerli_StableSwapRemoveLiquidityEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: goerli_StableSwap_filter
  provider: goerli_Bytes
  provider_not: goerli_Bytes
  provider_gt: goerli_Bytes
  provider_lt: goerli_Bytes
  provider_gte: goerli_Bytes
  provider_lte: goerli_Bytes
  provider_in: [goerli_Bytes!]
  provider_not_in: [goerli_Bytes!]
  provider_contains: goerli_Bytes
  provider_not_contains: goerli_Bytes
  tokenAmounts: [BigInt!]
  tokenAmounts_not: [BigInt!]
  tokenAmounts_contains: [BigInt!]
  tokenAmounts_contains_nocase: [BigInt!]
  tokenAmounts_not_contains: [BigInt!]
  tokenAmounts_not_contains_nocase: [BigInt!]
  fees: [BigInt!]
  fees_not: [BigInt!]
  fees_contains: [BigInt!]
  fees_contains_nocase: [BigInt!]
  fees_not_contains: [BigInt!]
  fees_not_contains_nocase: [BigInt!]
  invariant: BigInt
  invariant_not: BigInt
  invariant_gt: BigInt
  invariant_lt: BigInt
  invariant_gte: BigInt
  invariant_lte: BigInt
  invariant_in: [BigInt!]
  invariant_not_in: [BigInt!]
  lpTokenSupply: BigInt
  lpTokenSupply_not: BigInt
  lpTokenSupply_gt: BigInt
  lpTokenSupply_lt: BigInt
  lpTokenSupply_gte: BigInt
  lpTokenSupply_lte: BigInt
  lpTokenSupply_in: [BigInt!]
  lpTokenSupply_not_in: [BigInt!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: goerli_Bytes
  transaction_not: goerli_Bytes
  transaction_gt: goerli_Bytes
  transaction_lt: goerli_Bytes
  transaction_gte: goerli_Bytes
  transaction_lte: goerli_Bytes
  transaction_in: [goerli_Bytes!]
  transaction_not_in: [goerli_Bytes!]
  transaction_contains: goerli_Bytes
  transaction_not_contains: goerli_Bytes
  """Filter for the block changed event."""
  _change_block: goerli_BlockChangedFilter
}

enum goerli_StableSwapRemoveLiquidityEvent_orderBy {
  id
  stableSwap
  provider
  tokenAmounts
  fees
  invariant
  lpTokenSupply
  block
  timestamp
  transaction
}

input goerli_StableSwap_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  isActive: Boolean
  isActive_not: Boolean
  isActive_in: [Boolean!]
  isActive_not_in: [Boolean!]
  key: goerli_Bytes
  key_not: goerli_Bytes
  key_gt: goerli_Bytes
  key_lt: goerli_Bytes
  key_gte: goerli_Bytes
  key_lte: goerli_Bytes
  key_in: [goerli_Bytes!]
  key_not_in: [goerli_Bytes!]
  key_contains: goerli_Bytes
  key_not_contains: goerli_Bytes
  canonicalId: goerli_Bytes
  canonicalId_not: goerli_Bytes
  canonicalId_gt: goerli_Bytes
  canonicalId_lt: goerli_Bytes
  canonicalId_gte: goerli_Bytes
  canonicalId_lte: goerli_Bytes
  canonicalId_in: [goerli_Bytes!]
  canonicalId_not_in: [goerli_Bytes!]
  canonicalId_contains: goerli_Bytes
  canonicalId_not_contains: goerli_Bytes
  domain: BigInt
  domain_not: BigInt
  domain_gt: BigInt
  domain_lt: BigInt
  domain_gte: BigInt
  domain_lte: BigInt
  domain_in: [BigInt!]
  domain_not_in: [BigInt!]
  swapPool: goerli_Bytes
  swapPool_not: goerli_Bytes
  swapPool_gt: goerli_Bytes
  swapPool_lt: goerli_Bytes
  swapPool_gte: goerli_Bytes
  swapPool_lte: goerli_Bytes
  swapPool_in: [goerli_Bytes!]
  swapPool_not_in: [goerli_Bytes!]
  swapPool_contains: goerli_Bytes
  swapPool_not_contains: goerli_Bytes
  lpToken: goerli_Bytes
  lpToken_not: goerli_Bytes
  lpToken_gt: goerli_Bytes
  lpToken_lt: goerli_Bytes
  lpToken_gte: goerli_Bytes
  lpToken_lte: goerli_Bytes
  lpToken_in: [goerli_Bytes!]
  lpToken_not_in: [goerli_Bytes!]
  lpToken_contains: goerli_Bytes
  lpToken_not_contains: goerli_Bytes
  initialA: BigInt
  initialA_not: BigInt
  initialA_gt: BigInt
  initialA_lt: BigInt
  initialA_gte: BigInt
  initialA_lte: BigInt
  initialA_in: [BigInt!]
  initialA_not_in: [BigInt!]
  futureA: BigInt
  futureA_not: BigInt
  futureA_gt: BigInt
  futureA_lt: BigInt
  futureA_gte: BigInt
  futureA_lte: BigInt
  futureA_in: [BigInt!]
  futureA_not_in: [BigInt!]
  initialATime: BigInt
  initialATime_not: BigInt
  initialATime_gt: BigInt
  initialATime_lt: BigInt
  initialATime_gte: BigInt
  initialATime_lte: BigInt
  initialATime_in: [BigInt!]
  initialATime_not_in: [BigInt!]
  futureATime: BigInt
  futureATime_not: BigInt
  futureATime_gt: BigInt
  futureATime_lt: BigInt
  futureATime_gte: BigInt
  futureATime_lte: BigInt
  futureATime_in: [BigInt!]
  futureATime_not_in: [BigInt!]
  swapFee: BigInt
  swapFee_not: BigInt
  swapFee_gt: BigInt
  swapFee_lt: BigInt
  swapFee_gte: BigInt
  swapFee_lte: BigInt
  swapFee_in: [BigInt!]
  swapFee_not_in: [BigInt!]
  adminFee: BigInt
  adminFee_not: BigInt
  adminFee_gt: BigInt
  adminFee_lt: BigInt
  adminFee_gte: BigInt
  adminFee_lte: BigInt
  adminFee_in: [BigInt!]
  adminFee_not_in: [BigInt!]
  pooledTokens: [String!]
  pooledTokens_not: [String!]
  pooledTokens_contains: [String!]
  pooledTokens_contains_nocase: [String!]
  pooledTokens_not_contains: [String!]
  pooledTokens_not_contains_nocase: [String!]
  pooledTokens_: goerli_PooledToken_filter
  tokenPrecisionMultipliers: [BigInt!]
  tokenPrecisionMultipliers_not: [BigInt!]
  tokenPrecisionMultipliers_contains: [BigInt!]
  tokenPrecisionMultipliers_contains_nocase: [BigInt!]
  tokenPrecisionMultipliers_not_contains: [BigInt!]
  tokenPrecisionMultipliers_not_contains_nocase: [BigInt!]
  balances: [BigInt!]
  balances_not: [BigInt!]
  balances_contains: [BigInt!]
  balances_contains_nocase: [BigInt!]
  balances_not_contains: [BigInt!]
  balances_not_contains_nocase: [BigInt!]
  adminFees: [BigInt!]
  adminFees_not: [BigInt!]
  adminFees_contains: [BigInt!]
  adminFees_contains_nocase: [BigInt!]
  adminFees_not_contains: [BigInt!]
  adminFees_not_contains_nocase: [BigInt!]
  virtualPrice: BigInt
  virtualPrice_not: BigInt
  virtualPrice_gt: BigInt
  virtualPrice_lt: BigInt
  virtualPrice_gte: BigInt
  virtualPrice_lte: BigInt
  virtualPrice_in: [BigInt!]
  virtualPrice_not_in: [BigInt!]
  invariant: BigInt
  invariant_not: BigInt
  invariant_gt: BigInt
  invariant_lt: BigInt
  invariant_gte: BigInt
  invariant_lte: BigInt
  invariant_in: [BigInt!]
  invariant_not_in: [BigInt!]
  lpTokenSupply: BigInt
  lpTokenSupply_not: BigInt
  lpTokenSupply_gt: BigInt
  lpTokenSupply_lt: BigInt
  lpTokenSupply_gte: BigInt
  lpTokenSupply_lte: BigInt
  lpTokenSupply_in: [BigInt!]
  lpTokenSupply_not_in: [BigInt!]
  events_: goerli_StableSwapEvent_filter
  exchanges_: goerli_StableSwapExchange_filter
  hourlyVolumes_: goerli_SwapHourlyVolume_filter
  dailyVolumes_: goerli_SwapDailyVolume_filter
  weeklyVolumes_: goerli_SwapWeeklyVolume_filter
  """Filter for the block changed event."""
  _change_block: goerli_BlockChangedFilter
}

enum goerli_StableSwap_orderBy {
  id
  isActive
  key
  canonicalId
  domain
  swapPool
  lpToken
  initialA
  futureA
  initialATime
  futureATime
  swapFee
  adminFee
  pooledTokens
  tokenPrecisionMultipliers
  balances
  adminFees
  virtualPrice
  invariant
  lpTokenSupply
  events
  exchanges
  hourlyVolumes
  dailyVolumes
  weeklyVolumes
}

type goerli_SwapDailyVolume implements goerli_SwapTradeVolume {
  id: ID!
  stableSwap: goerli_StableSwap!
  timestamp: BigInt!
  volume: goerli_BigDecimal!
}

input goerli_SwapDailyVolume_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: goerli_StableSwap_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  volume: goerli_BigDecimal
  volume_not: goerli_BigDecimal
  volume_gt: goerli_BigDecimal
  volume_lt: goerli_BigDecimal
  volume_gte: goerli_BigDecimal
  volume_lte: goerli_BigDecimal
  volume_in: [goerli_BigDecimal!]
  volume_not_in: [goerli_BigDecimal!]
  """Filter for the block changed event."""
  _change_block: goerli_BlockChangedFilter
}

enum goerli_SwapDailyVolume_orderBy {
  id
  stableSwap
  timestamp
  volume
}

type goerli_SwapHourlyVolume implements goerli_SwapTradeVolume {
  id: ID!
  stableSwap: goerli_StableSwap!
  timestamp: BigInt!
  volume: goerli_BigDecimal!
}

input goerli_SwapHourlyVolume_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: goerli_StableSwap_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  volume: goerli_BigDecimal
  volume_not: goerli_BigDecimal
  volume_gt: goerli_BigDecimal
  volume_lt: goerli_BigDecimal
  volume_gte: goerli_BigDecimal
  volume_lte: goerli_BigDecimal
  volume_in: [goerli_BigDecimal!]
  volume_not_in: [goerli_BigDecimal!]
  """Filter for the block changed event."""
  _change_block: goerli_BlockChangedFilter
}

enum goerli_SwapHourlyVolume_orderBy {
  id
  stableSwap
  timestamp
  volume
}

interface goerli_SwapTradeVolume {
  stableSwap: goerli_StableSwap!
  timestamp: BigInt!
  volume: goerli_BigDecimal!
}

input goerli_SwapTradeVolume_filter {
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: goerli_StableSwap_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  volume: goerli_BigDecimal
  volume_not: goerli_BigDecimal
  volume_gt: goerli_BigDecimal
  volume_lt: goerli_BigDecimal
  volume_gte: goerli_BigDecimal
  volume_lte: goerli_BigDecimal
  volume_in: [goerli_BigDecimal!]
  volume_not_in: [goerli_BigDecimal!]
  """Filter for the block changed event."""
  _change_block: goerli_BlockChangedFilter
}

enum goerli_SwapTradeVolume_orderBy {
  stableSwap
  timestamp
  volume
}

type goerli_SwapWeeklyVolume implements goerli_SwapTradeVolume {
  id: ID!
  stableSwap: goerli_StableSwap!
  timestamp: BigInt!
  volume: goerli_BigDecimal!
}

input goerli_SwapWeeklyVolume_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: goerli_StableSwap_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  volume: goerli_BigDecimal
  volume_not: goerli_BigDecimal
  volume_gt: goerli_BigDecimal
  volume_lt: goerli_BigDecimal
  volume_gte: goerli_BigDecimal
  volume_lte: goerli_BigDecimal
  volume_in: [goerli_BigDecimal!]
  volume_not_in: [goerli_BigDecimal!]
  """Filter for the block changed event."""
  _change_block: goerli_BlockChangedFilter
}

enum goerli_SwapWeeklyVolume_orderBy {
  id
  stableSwap
  timestamp
  volume
}

type goerli_SystemInfo {
  id: ID!
  exchangeCount: BigInt!
  swapCount: BigInt!
}

input goerli_SystemInfo_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  exchangeCount: BigInt
  exchangeCount_not: BigInt
  exchangeCount_gt: BigInt
  exchangeCount_lt: BigInt
  exchangeCount_gte: BigInt
  exchangeCount_lte: BigInt
  exchangeCount_in: [BigInt!]
  exchangeCount_not_in: [BigInt!]
  swapCount: BigInt
  swapCount_not: BigInt
  swapCount_gt: BigInt
  swapCount_lt: BigInt
  swapCount_gte: BigInt
  swapCount_lte: BigInt
  swapCount_in: [BigInt!]
  swapCount_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: goerli_BlockChangedFilter
}

enum goerli_SystemInfo_orderBy {
  id
  exchangeCount
  swapCount
}

type goerli__Block_ {
  """The hash of the block"""
  hash: goerli_Bytes
  """The block number"""
  number: Int!
  """Integer representation of the timestamp stored in blocks for the chain"""
  timestamp: Int
}

"""The type for the top-level _meta field"""
type goerli__Meta_ {
  """
  Information about a specific subgraph block. The hash of the block
  will be null if the _meta field has a block constraint that asks for
  a block number. It will be filled if the _meta field has no block constraint
  and therefore asks for the latest  block
  
  """
  block: goerli__Block_!
  """The deployment ID"""
  deployment: String!
  """If `true`, the subgraph encountered indexing errors at some past block"""
  hasIndexingErrors: Boolean!
}

scalar stagingoptimismgoerli_BigDecimal

input stagingoptimismgoerli_BlockChangedFilter {
  number_gte: Int!
}

input stagingoptimismgoerli_Block_height {
  hash: stagingoptimismgoerli_Bytes
  number: Int
  number_gte: Int
}

scalar stagingoptimismgoerli_Bytes

"""Defines the order direction, either ascending or descending"""
enum stagingoptimismgoerli_OrderDirection {
  asc
  desc
}

type stagingoptimismgoerli_PooledToken {
  id: ID!
  asset: stagingoptimismgoerli_Bytes!
}

input stagingoptimismgoerli_PooledToken_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  asset: stagingoptimismgoerli_Bytes
  asset_not: stagingoptimismgoerli_Bytes
  asset_gt: stagingoptimismgoerli_Bytes
  asset_lt: stagingoptimismgoerli_Bytes
  asset_gte: stagingoptimismgoerli_Bytes
  asset_lte: stagingoptimismgoerli_Bytes
  asset_in: [stagingoptimismgoerli_Bytes!]
  asset_not_in: [stagingoptimismgoerli_Bytes!]
  asset_contains: stagingoptimismgoerli_Bytes
  asset_not_contains: stagingoptimismgoerli_Bytes
  """Filter for the block changed event."""
  _change_block: stagingoptimismgoerli_BlockChangedFilter
}

enum stagingoptimismgoerli_PooledToken_orderBy {
  id
  asset
}

type stagingoptimismgoerli_StableSwap {
  id: ID!
  isActive: Boolean
  key: stagingoptimismgoerli_Bytes!
  canonicalId: stagingoptimismgoerli_Bytes
  domain: BigInt
  swapPool: stagingoptimismgoerli_Bytes
  lpToken: stagingoptimismgoerli_Bytes
  initialA: BigInt
  futureA: BigInt
  initialATime: BigInt
  futureATime: BigInt
  swapFee: BigInt
  adminFee: BigInt
  pooledTokens(skip: Int = 0, first: Int = 100, orderBy: stagingoptimismgoerli_PooledToken_orderBy, orderDirection: stagingoptimismgoerli_OrderDirection, where: stagingoptimismgoerli_PooledToken_filter): [stagingoptimismgoerli_PooledToken!]!
  tokenPrecisionMultipliers: [BigInt!]!
  balances: [BigInt!]!
  adminFees: [BigInt!]!
  virtualPrice: BigInt!
  invariant: BigInt!
  lpTokenSupply: BigInt!
  events(skip: Int = 0, first: Int = 100, orderBy: stagingoptimismgoerli_StableSwapEvent_orderBy, orderDirection: stagingoptimismgoerli_OrderDirection, where: stagingoptimismgoerli_StableSwapEvent_filter): [stagingoptimismgoerli_StableSwapEvent!]
  exchanges(skip: Int = 0, first: Int = 100, orderBy: stagingoptimismgoerli_StableSwapExchange_orderBy, orderDirection: stagingoptimismgoerli_OrderDirection, where: stagingoptimismgoerli_StableSwapExchange_filter): [stagingoptimismgoerli_StableSwapExchange!]
  hourlyVolumes(skip: Int = 0, first: Int = 100, orderBy: stagingoptimismgoerli_SwapHourlyVolume_orderBy, orderDirection: stagingoptimismgoerli_OrderDirection, where: stagingoptimismgoerli_SwapHourlyVolume_filter): [stagingoptimismgoerli_SwapHourlyVolume!]
  dailyVolumes(skip: Int = 0, first: Int = 100, orderBy: stagingoptimismgoerli_SwapDailyVolume_orderBy, orderDirection: stagingoptimismgoerli_OrderDirection, where: stagingoptimismgoerli_SwapDailyVolume_filter): [stagingoptimismgoerli_SwapDailyVolume!]
  weeklyVolumes(skip: Int = 0, first: Int = 100, orderBy: stagingoptimismgoerli_SwapWeeklyVolume_orderBy, orderDirection: stagingoptimismgoerli_OrderDirection, where: stagingoptimismgoerli_SwapWeeklyVolume_filter): [stagingoptimismgoerli_SwapWeeklyVolume!]
}

type stagingoptimismgoerli_StableSwapAddLiquidityEvent implements stagingoptimismgoerli_StableSwapEvent {
  id: ID!
  stableSwap: stagingoptimismgoerli_StableSwap!
  provider: stagingoptimismgoerli_Bytes!
  tokenAmounts: [BigInt!]!
  fees: [BigInt!]!
  invariant: BigInt
  lpTokenSupply: BigInt!
  block: BigInt!
  timestamp: BigInt!
  transaction: stagingoptimismgoerli_Bytes!
}

input stagingoptimismgoerli_StableSwapAddLiquidityEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: stagingoptimismgoerli_StableSwap_filter
  provider: stagingoptimismgoerli_Bytes
  provider_not: stagingoptimismgoerli_Bytes
  provider_gt: stagingoptimismgoerli_Bytes
  provider_lt: stagingoptimismgoerli_Bytes
  provider_gte: stagingoptimismgoerli_Bytes
  provider_lte: stagingoptimismgoerli_Bytes
  provider_in: [stagingoptimismgoerli_Bytes!]
  provider_not_in: [stagingoptimismgoerli_Bytes!]
  provider_contains: stagingoptimismgoerli_Bytes
  provider_not_contains: stagingoptimismgoerli_Bytes
  tokenAmounts: [BigInt!]
  tokenAmounts_not: [BigInt!]
  tokenAmounts_contains: [BigInt!]
  tokenAmounts_contains_nocase: [BigInt!]
  tokenAmounts_not_contains: [BigInt!]
  tokenAmounts_not_contains_nocase: [BigInt!]
  fees: [BigInt!]
  fees_not: [BigInt!]
  fees_contains: [BigInt!]
  fees_contains_nocase: [BigInt!]
  fees_not_contains: [BigInt!]
  fees_not_contains_nocase: [BigInt!]
  invariant: BigInt
  invariant_not: BigInt
  invariant_gt: BigInt
  invariant_lt: BigInt
  invariant_gte: BigInt
  invariant_lte: BigInt
  invariant_in: [BigInt!]
  invariant_not_in: [BigInt!]
  lpTokenSupply: BigInt
  lpTokenSupply_not: BigInt
  lpTokenSupply_gt: BigInt
  lpTokenSupply_lt: BigInt
  lpTokenSupply_gte: BigInt
  lpTokenSupply_lte: BigInt
  lpTokenSupply_in: [BigInt!]
  lpTokenSupply_not_in: [BigInt!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: stagingoptimismgoerli_Bytes
  transaction_not: stagingoptimismgoerli_Bytes
  transaction_gt: stagingoptimismgoerli_Bytes
  transaction_lt: stagingoptimismgoerli_Bytes
  transaction_gte: stagingoptimismgoerli_Bytes
  transaction_lte: stagingoptimismgoerli_Bytes
  transaction_in: [stagingoptimismgoerli_Bytes!]
  transaction_not_in: [stagingoptimismgoerli_Bytes!]
  transaction_contains: stagingoptimismgoerli_Bytes
  transaction_not_contains: stagingoptimismgoerli_Bytes
  """Filter for the block changed event."""
  _change_block: stagingoptimismgoerli_BlockChangedFilter
}

enum stagingoptimismgoerli_StableSwapAddLiquidityEvent_orderBy {
  id
  stableSwap
  provider
  tokenAmounts
  fees
  invariant
  lpTokenSupply
  block
  timestamp
  transaction
}

interface stagingoptimismgoerli_StableSwapEvent {
  id: ID!
  stableSwap: stagingoptimismgoerli_StableSwap!
  block: BigInt!
  timestamp: BigInt!
  transaction: stagingoptimismgoerli_Bytes!
}

input stagingoptimismgoerli_StableSwapEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: stagingoptimismgoerli_StableSwap_filter
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: stagingoptimismgoerli_Bytes
  transaction_not: stagingoptimismgoerli_Bytes
  transaction_gt: stagingoptimismgoerli_Bytes
  transaction_lt: stagingoptimismgoerli_Bytes
  transaction_gte: stagingoptimismgoerli_Bytes
  transaction_lte: stagingoptimismgoerli_Bytes
  transaction_in: [stagingoptimismgoerli_Bytes!]
  transaction_not_in: [stagingoptimismgoerli_Bytes!]
  transaction_contains: stagingoptimismgoerli_Bytes
  transaction_not_contains: stagingoptimismgoerli_Bytes
  """Filter for the block changed event."""
  _change_block: stagingoptimismgoerli_BlockChangedFilter
}

enum stagingoptimismgoerli_StableSwapEvent_orderBy {
  id
  stableSwap
  block
  timestamp
  transaction
}

type stagingoptimismgoerli_StableSwapExchange {
  id: ID!
  stableSwap: stagingoptimismgoerli_StableSwap!
  buyer: stagingoptimismgoerli_Bytes!
  boughtId: BigInt!
  tokensBought: BigInt!
  soldId: BigInt!
  tokensSold: BigInt!
  block: BigInt!
  timestamp: BigInt!
  transaction: stagingoptimismgoerli_Bytes!
}

input stagingoptimismgoerli_StableSwapExchange_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: stagingoptimismgoerli_StableSwap_filter
  buyer: stagingoptimismgoerli_Bytes
  buyer_not: stagingoptimismgoerli_Bytes
  buyer_gt: stagingoptimismgoerli_Bytes
  buyer_lt: stagingoptimismgoerli_Bytes
  buyer_gte: stagingoptimismgoerli_Bytes
  buyer_lte: stagingoptimismgoerli_Bytes
  buyer_in: [stagingoptimismgoerli_Bytes!]
  buyer_not_in: [stagingoptimismgoerli_Bytes!]
  buyer_contains: stagingoptimismgoerli_Bytes
  buyer_not_contains: stagingoptimismgoerli_Bytes
  boughtId: BigInt
  boughtId_not: BigInt
  boughtId_gt: BigInt
  boughtId_lt: BigInt
  boughtId_gte: BigInt
  boughtId_lte: BigInt
  boughtId_in: [BigInt!]
  boughtId_not_in: [BigInt!]
  tokensBought: BigInt
  tokensBought_not: BigInt
  tokensBought_gt: BigInt
  tokensBought_lt: BigInt
  tokensBought_gte: BigInt
  tokensBought_lte: BigInt
  tokensBought_in: [BigInt!]
  tokensBought_not_in: [BigInt!]
  soldId: BigInt
  soldId_not: BigInt
  soldId_gt: BigInt
  soldId_lt: BigInt
  soldId_gte: BigInt
  soldId_lte: BigInt
  soldId_in: [BigInt!]
  soldId_not_in: [BigInt!]
  tokensSold: BigInt
  tokensSold_not: BigInt
  tokensSold_gt: BigInt
  tokensSold_lt: BigInt
  tokensSold_gte: BigInt
  tokensSold_lte: BigInt
  tokensSold_in: [BigInt!]
  tokensSold_not_in: [BigInt!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: stagingoptimismgoerli_Bytes
  transaction_not: stagingoptimismgoerli_Bytes
  transaction_gt: stagingoptimismgoerli_Bytes
  transaction_lt: stagingoptimismgoerli_Bytes
  transaction_gte: stagingoptimismgoerli_Bytes
  transaction_lte: stagingoptimismgoerli_Bytes
  transaction_in: [stagingoptimismgoerli_Bytes!]
  transaction_not_in: [stagingoptimismgoerli_Bytes!]
  transaction_contains: stagingoptimismgoerli_Bytes
  transaction_not_contains: stagingoptimismgoerli_Bytes
  """Filter for the block changed event."""
  _change_block: stagingoptimismgoerli_BlockChangedFilter
}

enum stagingoptimismgoerli_StableSwapExchange_orderBy {
  id
  stableSwap
  buyer
  boughtId
  tokensBought
  soldId
  tokensSold
  block
  timestamp
  transaction
}

type stagingoptimismgoerli_StableSwapRemoveLiquidityEvent implements stagingoptimismgoerli_StableSwapEvent {
  id: ID!
  stableSwap: stagingoptimismgoerli_StableSwap!
  provider: stagingoptimismgoerli_Bytes!
  tokenAmounts: [BigInt!]!
  fees: [BigInt!]
  invariant: BigInt
  lpTokenSupply: BigInt!
  block: BigInt!
  timestamp: BigInt!
  transaction: stagingoptimismgoerli_Bytes!
}

input stagingoptimismgoerli_StableSwapRemoveLiquidityEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: stagingoptimismgoerli_StableSwap_filter
  provider: stagingoptimismgoerli_Bytes
  provider_not: stagingoptimismgoerli_Bytes
  provider_gt: stagingoptimismgoerli_Bytes
  provider_lt: stagingoptimismgoerli_Bytes
  provider_gte: stagingoptimismgoerli_Bytes
  provider_lte: stagingoptimismgoerli_Bytes
  provider_in: [stagingoptimismgoerli_Bytes!]
  provider_not_in: [stagingoptimismgoerli_Bytes!]
  provider_contains: stagingoptimismgoerli_Bytes
  provider_not_contains: stagingoptimismgoerli_Bytes
  tokenAmounts: [BigInt!]
  tokenAmounts_not: [BigInt!]
  tokenAmounts_contains: [BigInt!]
  tokenAmounts_contains_nocase: [BigInt!]
  tokenAmounts_not_contains: [BigInt!]
  tokenAmounts_not_contains_nocase: [BigInt!]
  fees: [BigInt!]
  fees_not: [BigInt!]
  fees_contains: [BigInt!]
  fees_contains_nocase: [BigInt!]
  fees_not_contains: [BigInt!]
  fees_not_contains_nocase: [BigInt!]
  invariant: BigInt
  invariant_not: BigInt
  invariant_gt: BigInt
  invariant_lt: BigInt
  invariant_gte: BigInt
  invariant_lte: BigInt
  invariant_in: [BigInt!]
  invariant_not_in: [BigInt!]
  lpTokenSupply: BigInt
  lpTokenSupply_not: BigInt
  lpTokenSupply_gt: BigInt
  lpTokenSupply_lt: BigInt
  lpTokenSupply_gte: BigInt
  lpTokenSupply_lte: BigInt
  lpTokenSupply_in: [BigInt!]
  lpTokenSupply_not_in: [BigInt!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: stagingoptimismgoerli_Bytes
  transaction_not: stagingoptimismgoerli_Bytes
  transaction_gt: stagingoptimismgoerli_Bytes
  transaction_lt: stagingoptimismgoerli_Bytes
  transaction_gte: stagingoptimismgoerli_Bytes
  transaction_lte: stagingoptimismgoerli_Bytes
  transaction_in: [stagingoptimismgoerli_Bytes!]
  transaction_not_in: [stagingoptimismgoerli_Bytes!]
  transaction_contains: stagingoptimismgoerli_Bytes
  transaction_not_contains: stagingoptimismgoerli_Bytes
  """Filter for the block changed event."""
  _change_block: stagingoptimismgoerli_BlockChangedFilter
}

enum stagingoptimismgoerli_StableSwapRemoveLiquidityEvent_orderBy {
  id
  stableSwap
  provider
  tokenAmounts
  fees
  invariant
  lpTokenSupply
  block
  timestamp
  transaction
}

input stagingoptimismgoerli_StableSwap_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  isActive: Boolean
  isActive_not: Boolean
  isActive_in: [Boolean!]
  isActive_not_in: [Boolean!]
  key: stagingoptimismgoerli_Bytes
  key_not: stagingoptimismgoerli_Bytes
  key_gt: stagingoptimismgoerli_Bytes
  key_lt: stagingoptimismgoerli_Bytes
  key_gte: stagingoptimismgoerli_Bytes
  key_lte: stagingoptimismgoerli_Bytes
  key_in: [stagingoptimismgoerli_Bytes!]
  key_not_in: [stagingoptimismgoerli_Bytes!]
  key_contains: stagingoptimismgoerli_Bytes
  key_not_contains: stagingoptimismgoerli_Bytes
  canonicalId: stagingoptimismgoerli_Bytes
  canonicalId_not: stagingoptimismgoerli_Bytes
  canonicalId_gt: stagingoptimismgoerli_Bytes
  canonicalId_lt: stagingoptimismgoerli_Bytes
  canonicalId_gte: stagingoptimismgoerli_Bytes
  canonicalId_lte: stagingoptimismgoerli_Bytes
  canonicalId_in: [stagingoptimismgoerli_Bytes!]
  canonicalId_not_in: [stagingoptimismgoerli_Bytes!]
  canonicalId_contains: stagingoptimismgoerli_Bytes
  canonicalId_not_contains: stagingoptimismgoerli_Bytes
  domain: BigInt
  domain_not: BigInt
  domain_gt: BigInt
  domain_lt: BigInt
  domain_gte: BigInt
  domain_lte: BigInt
  domain_in: [BigInt!]
  domain_not_in: [BigInt!]
  swapPool: stagingoptimismgoerli_Bytes
  swapPool_not: stagingoptimismgoerli_Bytes
  swapPool_gt: stagingoptimismgoerli_Bytes
  swapPool_lt: stagingoptimismgoerli_Bytes
  swapPool_gte: stagingoptimismgoerli_Bytes
  swapPool_lte: stagingoptimismgoerli_Bytes
  swapPool_in: [stagingoptimismgoerli_Bytes!]
  swapPool_not_in: [stagingoptimismgoerli_Bytes!]
  swapPool_contains: stagingoptimismgoerli_Bytes
  swapPool_not_contains: stagingoptimismgoerli_Bytes
  lpToken: stagingoptimismgoerli_Bytes
  lpToken_not: stagingoptimismgoerli_Bytes
  lpToken_gt: stagingoptimismgoerli_Bytes
  lpToken_lt: stagingoptimismgoerli_Bytes
  lpToken_gte: stagingoptimismgoerli_Bytes
  lpToken_lte: stagingoptimismgoerli_Bytes
  lpToken_in: [stagingoptimismgoerli_Bytes!]
  lpToken_not_in: [stagingoptimismgoerli_Bytes!]
  lpToken_contains: stagingoptimismgoerli_Bytes
  lpToken_not_contains: stagingoptimismgoerli_Bytes
  initialA: BigInt
  initialA_not: BigInt
  initialA_gt: BigInt
  initialA_lt: BigInt
  initialA_gte: BigInt
  initialA_lte: BigInt
  initialA_in: [BigInt!]
  initialA_not_in: [BigInt!]
  futureA: BigInt
  futureA_not: BigInt
  futureA_gt: BigInt
  futureA_lt: BigInt
  futureA_gte: BigInt
  futureA_lte: BigInt
  futureA_in: [BigInt!]
  futureA_not_in: [BigInt!]
  initialATime: BigInt
  initialATime_not: BigInt
  initialATime_gt: BigInt
  initialATime_lt: BigInt
  initialATime_gte: BigInt
  initialATime_lte: BigInt
  initialATime_in: [BigInt!]
  initialATime_not_in: [BigInt!]
  futureATime: BigInt
  futureATime_not: BigInt
  futureATime_gt: BigInt
  futureATime_lt: BigInt
  futureATime_gte: BigInt
  futureATime_lte: BigInt
  futureATime_in: [BigInt!]
  futureATime_not_in: [BigInt!]
  swapFee: BigInt
  swapFee_not: BigInt
  swapFee_gt: BigInt
  swapFee_lt: BigInt
  swapFee_gte: BigInt
  swapFee_lte: BigInt
  swapFee_in: [BigInt!]
  swapFee_not_in: [BigInt!]
  adminFee: BigInt
  adminFee_not: BigInt
  adminFee_gt: BigInt
  adminFee_lt: BigInt
  adminFee_gte: BigInt
  adminFee_lte: BigInt
  adminFee_in: [BigInt!]
  adminFee_not_in: [BigInt!]
  pooledTokens: [String!]
  pooledTokens_not: [String!]
  pooledTokens_contains: [String!]
  pooledTokens_contains_nocase: [String!]
  pooledTokens_not_contains: [String!]
  pooledTokens_not_contains_nocase: [String!]
  pooledTokens_: stagingoptimismgoerli_PooledToken_filter
  tokenPrecisionMultipliers: [BigInt!]
  tokenPrecisionMultipliers_not: [BigInt!]
  tokenPrecisionMultipliers_contains: [BigInt!]
  tokenPrecisionMultipliers_contains_nocase: [BigInt!]
  tokenPrecisionMultipliers_not_contains: [BigInt!]
  tokenPrecisionMultipliers_not_contains_nocase: [BigInt!]
  balances: [BigInt!]
  balances_not: [BigInt!]
  balances_contains: [BigInt!]
  balances_contains_nocase: [BigInt!]
  balances_not_contains: [BigInt!]
  balances_not_contains_nocase: [BigInt!]
  adminFees: [BigInt!]
  adminFees_not: [BigInt!]
  adminFees_contains: [BigInt!]
  adminFees_contains_nocase: [BigInt!]
  adminFees_not_contains: [BigInt!]
  adminFees_not_contains_nocase: [BigInt!]
  virtualPrice: BigInt
  virtualPrice_not: BigInt
  virtualPrice_gt: BigInt
  virtualPrice_lt: BigInt
  virtualPrice_gte: BigInt
  virtualPrice_lte: BigInt
  virtualPrice_in: [BigInt!]
  virtualPrice_not_in: [BigInt!]
  invariant: BigInt
  invariant_not: BigInt
  invariant_gt: BigInt
  invariant_lt: BigInt
  invariant_gte: BigInt
  invariant_lte: BigInt
  invariant_in: [BigInt!]
  invariant_not_in: [BigInt!]
  lpTokenSupply: BigInt
  lpTokenSupply_not: BigInt
  lpTokenSupply_gt: BigInt
  lpTokenSupply_lt: BigInt
  lpTokenSupply_gte: BigInt
  lpTokenSupply_lte: BigInt
  lpTokenSupply_in: [BigInt!]
  lpTokenSupply_not_in: [BigInt!]
  events_: stagingoptimismgoerli_StableSwapEvent_filter
  exchanges_: stagingoptimismgoerli_StableSwapExchange_filter
  hourlyVolumes_: stagingoptimismgoerli_SwapHourlyVolume_filter
  dailyVolumes_: stagingoptimismgoerli_SwapDailyVolume_filter
  weeklyVolumes_: stagingoptimismgoerli_SwapWeeklyVolume_filter
  """Filter for the block changed event."""
  _change_block: stagingoptimismgoerli_BlockChangedFilter
}

enum stagingoptimismgoerli_StableSwap_orderBy {
  id
  isActive
  key
  canonicalId
  domain
  swapPool
  lpToken
  initialA
  futureA
  initialATime
  futureATime
  swapFee
  adminFee
  pooledTokens
  tokenPrecisionMultipliers
  balances
  adminFees
  virtualPrice
  invariant
  lpTokenSupply
  events
  exchanges
  hourlyVolumes
  dailyVolumes
  weeklyVolumes
}

type stagingoptimismgoerli_SwapDailyVolume implements stagingoptimismgoerli_SwapTradeVolume {
  id: ID!
  stableSwap: stagingoptimismgoerli_StableSwap!
  timestamp: BigInt!
  volume: stagingoptimismgoerli_BigDecimal!
}

input stagingoptimismgoerli_SwapDailyVolume_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: stagingoptimismgoerli_StableSwap_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  volume: stagingoptimismgoerli_BigDecimal
  volume_not: stagingoptimismgoerli_BigDecimal
  volume_gt: stagingoptimismgoerli_BigDecimal
  volume_lt: stagingoptimismgoerli_BigDecimal
  volume_gte: stagingoptimismgoerli_BigDecimal
  volume_lte: stagingoptimismgoerli_BigDecimal
  volume_in: [stagingoptimismgoerli_BigDecimal!]
  volume_not_in: [stagingoptimismgoerli_BigDecimal!]
  """Filter for the block changed event."""
  _change_block: stagingoptimismgoerli_BlockChangedFilter
}

enum stagingoptimismgoerli_SwapDailyVolume_orderBy {
  id
  stableSwap
  timestamp
  volume
}

type stagingoptimismgoerli_SwapHourlyVolume implements stagingoptimismgoerli_SwapTradeVolume {
  id: ID!
  stableSwap: stagingoptimismgoerli_StableSwap!
  timestamp: BigInt!
  volume: stagingoptimismgoerli_BigDecimal!
}

input stagingoptimismgoerli_SwapHourlyVolume_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: stagingoptimismgoerli_StableSwap_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  volume: stagingoptimismgoerli_BigDecimal
  volume_not: stagingoptimismgoerli_BigDecimal
  volume_gt: stagingoptimismgoerli_BigDecimal
  volume_lt: stagingoptimismgoerli_BigDecimal
  volume_gte: stagingoptimismgoerli_BigDecimal
  volume_lte: stagingoptimismgoerli_BigDecimal
  volume_in: [stagingoptimismgoerli_BigDecimal!]
  volume_not_in: [stagingoptimismgoerli_BigDecimal!]
  """Filter for the block changed event."""
  _change_block: stagingoptimismgoerli_BlockChangedFilter
}

enum stagingoptimismgoerli_SwapHourlyVolume_orderBy {
  id
  stableSwap
  timestamp
  volume
}

interface stagingoptimismgoerli_SwapTradeVolume {
  stableSwap: stagingoptimismgoerli_StableSwap!
  timestamp: BigInt!
  volume: stagingoptimismgoerli_BigDecimal!
}

input stagingoptimismgoerli_SwapTradeVolume_filter {
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: stagingoptimismgoerli_StableSwap_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  volume: stagingoptimismgoerli_BigDecimal
  volume_not: stagingoptimismgoerli_BigDecimal
  volume_gt: stagingoptimismgoerli_BigDecimal
  volume_lt: stagingoptimismgoerli_BigDecimal
  volume_gte: stagingoptimismgoerli_BigDecimal
  volume_lte: stagingoptimismgoerli_BigDecimal
  volume_in: [stagingoptimismgoerli_BigDecimal!]
  volume_not_in: [stagingoptimismgoerli_BigDecimal!]
  """Filter for the block changed event."""
  _change_block: stagingoptimismgoerli_BlockChangedFilter
}

enum stagingoptimismgoerli_SwapTradeVolume_orderBy {
  stableSwap
  timestamp
  volume
}

type stagingoptimismgoerli_SwapWeeklyVolume implements stagingoptimismgoerli_SwapTradeVolume {
  id: ID!
  stableSwap: stagingoptimismgoerli_StableSwap!
  timestamp: BigInt!
  volume: stagingoptimismgoerli_BigDecimal!
}

input stagingoptimismgoerli_SwapWeeklyVolume_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: stagingoptimismgoerli_StableSwap_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  volume: stagingoptimismgoerli_BigDecimal
  volume_not: stagingoptimismgoerli_BigDecimal
  volume_gt: stagingoptimismgoerli_BigDecimal
  volume_lt: stagingoptimismgoerli_BigDecimal
  volume_gte: stagingoptimismgoerli_BigDecimal
  volume_lte: stagingoptimismgoerli_BigDecimal
  volume_in: [stagingoptimismgoerli_BigDecimal!]
  volume_not_in: [stagingoptimismgoerli_BigDecimal!]
  """Filter for the block changed event."""
  _change_block: stagingoptimismgoerli_BlockChangedFilter
}

enum stagingoptimismgoerli_SwapWeeklyVolume_orderBy {
  id
  stableSwap
  timestamp
  volume
}

type stagingoptimismgoerli_SystemInfo {
  id: ID!
  exchangeCount: BigInt!
  swapCount: BigInt!
}

input stagingoptimismgoerli_SystemInfo_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  exchangeCount: BigInt
  exchangeCount_not: BigInt
  exchangeCount_gt: BigInt
  exchangeCount_lt: BigInt
  exchangeCount_gte: BigInt
  exchangeCount_lte: BigInt
  exchangeCount_in: [BigInt!]
  exchangeCount_not_in: [BigInt!]
  swapCount: BigInt
  swapCount_not: BigInt
  swapCount_gt: BigInt
  swapCount_lt: BigInt
  swapCount_gte: BigInt
  swapCount_lte: BigInt
  swapCount_in: [BigInt!]
  swapCount_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: stagingoptimismgoerli_BlockChangedFilter
}

enum stagingoptimismgoerli_SystemInfo_orderBy {
  id
  exchangeCount
  swapCount
}

type stagingoptimismgoerli__Block_ {
  """The hash of the block"""
  hash: stagingoptimismgoerli_Bytes
  """The block number"""
  number: Int!
  """Integer representation of the timestamp stored in blocks for the chain"""
  timestamp: Int
}

"""The type for the top-level _meta field"""
type stagingoptimismgoerli__Meta_ {
  """
  Information about a specific subgraph block. The hash of the block
  will be null if the _meta field has a block constraint that asks for
  a block number. It will be filled if the _meta field has no block constraint
  and therefore asks for the latest  block
  
  """
  block: stagingoptimismgoerli__Block_!
  """The deployment ID"""
  deployment: String!
  """If `true`, the subgraph encountered indexing errors at some past block"""
  hasIndexingErrors: Boolean!
}

scalar optimism_BigDecimal

input optimism_BlockChangedFilter {
  number_gte: Int!
}

input optimism_Block_height {
  hash: optimism_Bytes
  number: Int
  number_gte: Int
}

scalar optimism_Bytes

"""Defines the order direction, either ascending or descending"""
enum optimism_OrderDirection {
  asc
  desc
}

type optimism_PooledToken {
  id: ID!
  asset: optimism_Bytes!
}

input optimism_PooledToken_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  asset: optimism_Bytes
  asset_not: optimism_Bytes
  asset_gt: optimism_Bytes
  asset_lt: optimism_Bytes
  asset_gte: optimism_Bytes
  asset_lte: optimism_Bytes
  asset_in: [optimism_Bytes!]
  asset_not_in: [optimism_Bytes!]
  asset_contains: optimism_Bytes
  asset_not_contains: optimism_Bytes
  """Filter for the block changed event."""
  _change_block: optimism_BlockChangedFilter
}

enum optimism_PooledToken_orderBy {
  id
  asset
}

type optimism_StableSwap {
  id: ID!
  isActive: Boolean
  key: optimism_Bytes!
  canonicalId: optimism_Bytes
  domain: BigInt
  swapPool: optimism_Bytes
  lpToken: optimism_Bytes
  initialA: BigInt
  futureA: BigInt
  initialATime: BigInt
  futureATime: BigInt
  swapFee: BigInt
  adminFee: BigInt
  pooledTokens(skip: Int = 0, first: Int = 100, orderBy: optimism_PooledToken_orderBy, orderDirection: optimism_OrderDirection, where: optimism_PooledToken_filter): [optimism_PooledToken!]!
  tokenPrecisionMultipliers: [BigInt!]!
  balances: [BigInt!]!
  adminFees: [BigInt!]!
  virtualPrice: BigInt!
  invariant: BigInt!
  lpTokenSupply: BigInt!
  events(skip: Int = 0, first: Int = 100, orderBy: optimism_StableSwapEvent_orderBy, orderDirection: optimism_OrderDirection, where: optimism_StableSwapEvent_filter): [optimism_StableSwapEvent!]
  exchanges(skip: Int = 0, first: Int = 100, orderBy: optimism_StableSwapExchange_orderBy, orderDirection: optimism_OrderDirection, where: optimism_StableSwapExchange_filter): [optimism_StableSwapExchange!]
  hourlyVolumes(skip: Int = 0, first: Int = 100, orderBy: optimism_SwapHourlyVolume_orderBy, orderDirection: optimism_OrderDirection, where: optimism_SwapHourlyVolume_filter): [optimism_SwapHourlyVolume!]
  dailyVolumes(skip: Int = 0, first: Int = 100, orderBy: optimism_SwapDailyVolume_orderBy, orderDirection: optimism_OrderDirection, where: optimism_SwapDailyVolume_filter): [optimism_SwapDailyVolume!]
  weeklyVolumes(skip: Int = 0, first: Int = 100, orderBy: optimism_SwapWeeklyVolume_orderBy, orderDirection: optimism_OrderDirection, where: optimism_SwapWeeklyVolume_filter): [optimism_SwapWeeklyVolume!]
}

type optimism_StableSwapAddLiquidityEvent implements optimism_StableSwapEvent {
  id: ID!
  stableSwap: optimism_StableSwap!
  provider: optimism_Bytes!
  tokenAmounts: [BigInt!]!
  fees: [BigInt!]!
  invariant: BigInt
  lpTokenSupply: BigInt!
  block: BigInt!
  timestamp: BigInt!
  transaction: optimism_Bytes!
}

input optimism_StableSwapAddLiquidityEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: optimism_StableSwap_filter
  provider: optimism_Bytes
  provider_not: optimism_Bytes
  provider_gt: optimism_Bytes
  provider_lt: optimism_Bytes
  provider_gte: optimism_Bytes
  provider_lte: optimism_Bytes
  provider_in: [optimism_Bytes!]
  provider_not_in: [optimism_Bytes!]
  provider_contains: optimism_Bytes
  provider_not_contains: optimism_Bytes
  tokenAmounts: [BigInt!]
  tokenAmounts_not: [BigInt!]
  tokenAmounts_contains: [BigInt!]
  tokenAmounts_contains_nocase: [BigInt!]
  tokenAmounts_not_contains: [BigInt!]
  tokenAmounts_not_contains_nocase: [BigInt!]
  fees: [BigInt!]
  fees_not: [BigInt!]
  fees_contains: [BigInt!]
  fees_contains_nocase: [BigInt!]
  fees_not_contains: [BigInt!]
  fees_not_contains_nocase: [BigInt!]
  invariant: BigInt
  invariant_not: BigInt
  invariant_gt: BigInt
  invariant_lt: BigInt
  invariant_gte: BigInt
  invariant_lte: BigInt
  invariant_in: [BigInt!]
  invariant_not_in: [BigInt!]
  lpTokenSupply: BigInt
  lpTokenSupply_not: BigInt
  lpTokenSupply_gt: BigInt
  lpTokenSupply_lt: BigInt
  lpTokenSupply_gte: BigInt
  lpTokenSupply_lte: BigInt
  lpTokenSupply_in: [BigInt!]
  lpTokenSupply_not_in: [BigInt!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: optimism_Bytes
  transaction_not: optimism_Bytes
  transaction_gt: optimism_Bytes
  transaction_lt: optimism_Bytes
  transaction_gte: optimism_Bytes
  transaction_lte: optimism_Bytes
  transaction_in: [optimism_Bytes!]
  transaction_not_in: [optimism_Bytes!]
  transaction_contains: optimism_Bytes
  transaction_not_contains: optimism_Bytes
  """Filter for the block changed event."""
  _change_block: optimism_BlockChangedFilter
}

enum optimism_StableSwapAddLiquidityEvent_orderBy {
  id
  stableSwap
  provider
  tokenAmounts
  fees
  invariant
  lpTokenSupply
  block
  timestamp
  transaction
}

interface optimism_StableSwapEvent {
  id: ID!
  stableSwap: optimism_StableSwap!
  block: BigInt!
  timestamp: BigInt!
  transaction: optimism_Bytes!
}

input optimism_StableSwapEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: optimism_StableSwap_filter
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: optimism_Bytes
  transaction_not: optimism_Bytes
  transaction_gt: optimism_Bytes
  transaction_lt: optimism_Bytes
  transaction_gte: optimism_Bytes
  transaction_lte: optimism_Bytes
  transaction_in: [optimism_Bytes!]
  transaction_not_in: [optimism_Bytes!]
  transaction_contains: optimism_Bytes
  transaction_not_contains: optimism_Bytes
  """Filter for the block changed event."""
  _change_block: optimism_BlockChangedFilter
}

enum optimism_StableSwapEvent_orderBy {
  id
  stableSwap
  block
  timestamp
  transaction
}

type optimism_StableSwapExchange {
  id: ID!
  stableSwap: optimism_StableSwap!
  buyer: optimism_Bytes!
  boughtId: BigInt!
  tokensBought: BigInt!
  soldId: BigInt!
  tokensSold: BigInt!
  block: BigInt!
  timestamp: BigInt!
  transaction: optimism_Bytes!
}

input optimism_StableSwapExchange_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: optimism_StableSwap_filter
  buyer: optimism_Bytes
  buyer_not: optimism_Bytes
  buyer_gt: optimism_Bytes
  buyer_lt: optimism_Bytes
  buyer_gte: optimism_Bytes
  buyer_lte: optimism_Bytes
  buyer_in: [optimism_Bytes!]
  buyer_not_in: [optimism_Bytes!]
  buyer_contains: optimism_Bytes
  buyer_not_contains: optimism_Bytes
  boughtId: BigInt
  boughtId_not: BigInt
  boughtId_gt: BigInt
  boughtId_lt: BigInt
  boughtId_gte: BigInt
  boughtId_lte: BigInt
  boughtId_in: [BigInt!]
  boughtId_not_in: [BigInt!]
  tokensBought: BigInt
  tokensBought_not: BigInt
  tokensBought_gt: BigInt
  tokensBought_lt: BigInt
  tokensBought_gte: BigInt
  tokensBought_lte: BigInt
  tokensBought_in: [BigInt!]
  tokensBought_not_in: [BigInt!]
  soldId: BigInt
  soldId_not: BigInt
  soldId_gt: BigInt
  soldId_lt: BigInt
  soldId_gte: BigInt
  soldId_lte: BigInt
  soldId_in: [BigInt!]
  soldId_not_in: [BigInt!]
  tokensSold: BigInt
  tokensSold_not: BigInt
  tokensSold_gt: BigInt
  tokensSold_lt: BigInt
  tokensSold_gte: BigInt
  tokensSold_lte: BigInt
  tokensSold_in: [BigInt!]
  tokensSold_not_in: [BigInt!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: optimism_Bytes
  transaction_not: optimism_Bytes
  transaction_gt: optimism_Bytes
  transaction_lt: optimism_Bytes
  transaction_gte: optimism_Bytes
  transaction_lte: optimism_Bytes
  transaction_in: [optimism_Bytes!]
  transaction_not_in: [optimism_Bytes!]
  transaction_contains: optimism_Bytes
  transaction_not_contains: optimism_Bytes
  """Filter for the block changed event."""
  _change_block: optimism_BlockChangedFilter
}

enum optimism_StableSwapExchange_orderBy {
  id
  stableSwap
  buyer
  boughtId
  tokensBought
  soldId
  tokensSold
  block
  timestamp
  transaction
}

type optimism_StableSwapRemoveLiquidityEvent implements optimism_StableSwapEvent {
  id: ID!
  stableSwap: optimism_StableSwap!
  provider: optimism_Bytes!
  tokenAmounts: [BigInt!]!
  fees: [BigInt!]
  invariant: BigInt
  lpTokenSupply: BigInt!
  block: BigInt!
  timestamp: BigInt!
  transaction: optimism_Bytes!
}

input optimism_StableSwapRemoveLiquidityEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: optimism_StableSwap_filter
  provider: optimism_Bytes
  provider_not: optimism_Bytes
  provider_gt: optimism_Bytes
  provider_lt: optimism_Bytes
  provider_gte: optimism_Bytes
  provider_lte: optimism_Bytes
  provider_in: [optimism_Bytes!]
  provider_not_in: [optimism_Bytes!]
  provider_contains: optimism_Bytes
  provider_not_contains: optimism_Bytes
  tokenAmounts: [BigInt!]
  tokenAmounts_not: [BigInt!]
  tokenAmounts_contains: [BigInt!]
  tokenAmounts_contains_nocase: [BigInt!]
  tokenAmounts_not_contains: [BigInt!]
  tokenAmounts_not_contains_nocase: [BigInt!]
  fees: [BigInt!]
  fees_not: [BigInt!]
  fees_contains: [BigInt!]
  fees_contains_nocase: [BigInt!]
  fees_not_contains: [BigInt!]
  fees_not_contains_nocase: [BigInt!]
  invariant: BigInt
  invariant_not: BigInt
  invariant_gt: BigInt
  invariant_lt: BigInt
  invariant_gte: BigInt
  invariant_lte: BigInt
  invariant_in: [BigInt!]
  invariant_not_in: [BigInt!]
  lpTokenSupply: BigInt
  lpTokenSupply_not: BigInt
  lpTokenSupply_gt: BigInt
  lpTokenSupply_lt: BigInt
  lpTokenSupply_gte: BigInt
  lpTokenSupply_lte: BigInt
  lpTokenSupply_in: [BigInt!]
  lpTokenSupply_not_in: [BigInt!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: optimism_Bytes
  transaction_not: optimism_Bytes
  transaction_gt: optimism_Bytes
  transaction_lt: optimism_Bytes
  transaction_gte: optimism_Bytes
  transaction_lte: optimism_Bytes
  transaction_in: [optimism_Bytes!]
  transaction_not_in: [optimism_Bytes!]
  transaction_contains: optimism_Bytes
  transaction_not_contains: optimism_Bytes
  """Filter for the block changed event."""
  _change_block: optimism_BlockChangedFilter
}

enum optimism_StableSwapRemoveLiquidityEvent_orderBy {
  id
  stableSwap
  provider
  tokenAmounts
  fees
  invariant
  lpTokenSupply
  block
  timestamp
  transaction
}

input optimism_StableSwap_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  isActive: Boolean
  isActive_not: Boolean
  isActive_in: [Boolean!]
  isActive_not_in: [Boolean!]
  key: optimism_Bytes
  key_not: optimism_Bytes
  key_gt: optimism_Bytes
  key_lt: optimism_Bytes
  key_gte: optimism_Bytes
  key_lte: optimism_Bytes
  key_in: [optimism_Bytes!]
  key_not_in: [optimism_Bytes!]
  key_contains: optimism_Bytes
  key_not_contains: optimism_Bytes
  canonicalId: optimism_Bytes
  canonicalId_not: optimism_Bytes
  canonicalId_gt: optimism_Bytes
  canonicalId_lt: optimism_Bytes
  canonicalId_gte: optimism_Bytes
  canonicalId_lte: optimism_Bytes
  canonicalId_in: [optimism_Bytes!]
  canonicalId_not_in: [optimism_Bytes!]
  canonicalId_contains: optimism_Bytes
  canonicalId_not_contains: optimism_Bytes
  domain: BigInt
  domain_not: BigInt
  domain_gt: BigInt
  domain_lt: BigInt
  domain_gte: BigInt
  domain_lte: BigInt
  domain_in: [BigInt!]
  domain_not_in: [BigInt!]
  swapPool: optimism_Bytes
  swapPool_not: optimism_Bytes
  swapPool_gt: optimism_Bytes
  swapPool_lt: optimism_Bytes
  swapPool_gte: optimism_Bytes
  swapPool_lte: optimism_Bytes
  swapPool_in: [optimism_Bytes!]
  swapPool_not_in: [optimism_Bytes!]
  swapPool_contains: optimism_Bytes
  swapPool_not_contains: optimism_Bytes
  lpToken: optimism_Bytes
  lpToken_not: optimism_Bytes
  lpToken_gt: optimism_Bytes
  lpToken_lt: optimism_Bytes
  lpToken_gte: optimism_Bytes
  lpToken_lte: optimism_Bytes
  lpToken_in: [optimism_Bytes!]
  lpToken_not_in: [optimism_Bytes!]
  lpToken_contains: optimism_Bytes
  lpToken_not_contains: optimism_Bytes
  initialA: BigInt
  initialA_not: BigInt
  initialA_gt: BigInt
  initialA_lt: BigInt
  initialA_gte: BigInt
  initialA_lte: BigInt
  initialA_in: [BigInt!]
  initialA_not_in: [BigInt!]
  futureA: BigInt
  futureA_not: BigInt
  futureA_gt: BigInt
  futureA_lt: BigInt
  futureA_gte: BigInt
  futureA_lte: BigInt
  futureA_in: [BigInt!]
  futureA_not_in: [BigInt!]
  initialATime: BigInt
  initialATime_not: BigInt
  initialATime_gt: BigInt
  initialATime_lt: BigInt
  initialATime_gte: BigInt
  initialATime_lte: BigInt
  initialATime_in: [BigInt!]
  initialATime_not_in: [BigInt!]
  futureATime: BigInt
  futureATime_not: BigInt
  futureATime_gt: BigInt
  futureATime_lt: BigInt
  futureATime_gte: BigInt
  futureATime_lte: BigInt
  futureATime_in: [BigInt!]
  futureATime_not_in: [BigInt!]
  swapFee: BigInt
  swapFee_not: BigInt
  swapFee_gt: BigInt
  swapFee_lt: BigInt
  swapFee_gte: BigInt
  swapFee_lte: BigInt
  swapFee_in: [BigInt!]
  swapFee_not_in: [BigInt!]
  adminFee: BigInt
  adminFee_not: BigInt
  adminFee_gt: BigInt
  adminFee_lt: BigInt
  adminFee_gte: BigInt
  adminFee_lte: BigInt
  adminFee_in: [BigInt!]
  adminFee_not_in: [BigInt!]
  pooledTokens: [String!]
  pooledTokens_not: [String!]
  pooledTokens_contains: [String!]
  pooledTokens_contains_nocase: [String!]
  pooledTokens_not_contains: [String!]
  pooledTokens_not_contains_nocase: [String!]
  pooledTokens_: optimism_PooledToken_filter
  tokenPrecisionMultipliers: [BigInt!]
  tokenPrecisionMultipliers_not: [BigInt!]
  tokenPrecisionMultipliers_contains: [BigInt!]
  tokenPrecisionMultipliers_contains_nocase: [BigInt!]
  tokenPrecisionMultipliers_not_contains: [BigInt!]
  tokenPrecisionMultipliers_not_contains_nocase: [BigInt!]
  balances: [BigInt!]
  balances_not: [BigInt!]
  balances_contains: [BigInt!]
  balances_contains_nocase: [BigInt!]
  balances_not_contains: [BigInt!]
  balances_not_contains_nocase: [BigInt!]
  adminFees: [BigInt!]
  adminFees_not: [BigInt!]
  adminFees_contains: [BigInt!]
  adminFees_contains_nocase: [BigInt!]
  adminFees_not_contains: [BigInt!]
  adminFees_not_contains_nocase: [BigInt!]
  virtualPrice: BigInt
  virtualPrice_not: BigInt
  virtualPrice_gt: BigInt
  virtualPrice_lt: BigInt
  virtualPrice_gte: BigInt
  virtualPrice_lte: BigInt
  virtualPrice_in: [BigInt!]
  virtualPrice_not_in: [BigInt!]
  invariant: BigInt
  invariant_not: BigInt
  invariant_gt: BigInt
  invariant_lt: BigInt
  invariant_gte: BigInt
  invariant_lte: BigInt
  invariant_in: [BigInt!]
  invariant_not_in: [BigInt!]
  lpTokenSupply: BigInt
  lpTokenSupply_not: BigInt
  lpTokenSupply_gt: BigInt
  lpTokenSupply_lt: BigInt
  lpTokenSupply_gte: BigInt
  lpTokenSupply_lte: BigInt
  lpTokenSupply_in: [BigInt!]
  lpTokenSupply_not_in: [BigInt!]
  events_: optimism_StableSwapEvent_filter
  exchanges_: optimism_StableSwapExchange_filter
  hourlyVolumes_: optimism_SwapHourlyVolume_filter
  dailyVolumes_: optimism_SwapDailyVolume_filter
  weeklyVolumes_: optimism_SwapWeeklyVolume_filter
  """Filter for the block changed event."""
  _change_block: optimism_BlockChangedFilter
}

enum optimism_StableSwap_orderBy {
  id
  isActive
  key
  canonicalId
  domain
  swapPool
  lpToken
  initialA
  futureA
  initialATime
  futureATime
  swapFee
  adminFee
  pooledTokens
  tokenPrecisionMultipliers
  balances
  adminFees
  virtualPrice
  invariant
  lpTokenSupply
  events
  exchanges
  hourlyVolumes
  dailyVolumes
  weeklyVolumes
}

type optimism_SwapDailyVolume implements optimism_SwapTradeVolume {
  id: ID!
  stableSwap: optimism_StableSwap!
  timestamp: BigInt!
  volume: optimism_BigDecimal!
}

input optimism_SwapDailyVolume_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: optimism_StableSwap_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  volume: optimism_BigDecimal
  volume_not: optimism_BigDecimal
  volume_gt: optimism_BigDecimal
  volume_lt: optimism_BigDecimal
  volume_gte: optimism_BigDecimal
  volume_lte: optimism_BigDecimal
  volume_in: [optimism_BigDecimal!]
  volume_not_in: [optimism_BigDecimal!]
  """Filter for the block changed event."""
  _change_block: optimism_BlockChangedFilter
}

enum optimism_SwapDailyVolume_orderBy {
  id
  stableSwap
  timestamp
  volume
}

type optimism_SwapHourlyVolume implements optimism_SwapTradeVolume {
  id: ID!
  stableSwap: optimism_StableSwap!
  timestamp: BigInt!
  volume: optimism_BigDecimal!
}

input optimism_SwapHourlyVolume_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: optimism_StableSwap_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  volume: optimism_BigDecimal
  volume_not: optimism_BigDecimal
  volume_gt: optimism_BigDecimal
  volume_lt: optimism_BigDecimal
  volume_gte: optimism_BigDecimal
  volume_lte: optimism_BigDecimal
  volume_in: [optimism_BigDecimal!]
  volume_not_in: [optimism_BigDecimal!]
  """Filter for the block changed event."""
  _change_block: optimism_BlockChangedFilter
}

enum optimism_SwapHourlyVolume_orderBy {
  id
  stableSwap
  timestamp
  volume
}

interface optimism_SwapTradeVolume {
  stableSwap: optimism_StableSwap!
  timestamp: BigInt!
  volume: optimism_BigDecimal!
}

input optimism_SwapTradeVolume_filter {
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: optimism_StableSwap_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  volume: optimism_BigDecimal
  volume_not: optimism_BigDecimal
  volume_gt: optimism_BigDecimal
  volume_lt: optimism_BigDecimal
  volume_gte: optimism_BigDecimal
  volume_lte: optimism_BigDecimal
  volume_in: [optimism_BigDecimal!]
  volume_not_in: [optimism_BigDecimal!]
  """Filter for the block changed event."""
  _change_block: optimism_BlockChangedFilter
}

enum optimism_SwapTradeVolume_orderBy {
  stableSwap
  timestamp
  volume
}

type optimism_SwapWeeklyVolume implements optimism_SwapTradeVolume {
  id: ID!
  stableSwap: optimism_StableSwap!
  timestamp: BigInt!
  volume: optimism_BigDecimal!
}

input optimism_SwapWeeklyVolume_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: optimism_StableSwap_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  volume: optimism_BigDecimal
  volume_not: optimism_BigDecimal
  volume_gt: optimism_BigDecimal
  volume_lt: optimism_BigDecimal
  volume_gte: optimism_BigDecimal
  volume_lte: optimism_BigDecimal
  volume_in: [optimism_BigDecimal!]
  volume_not_in: [optimism_BigDecimal!]
  """Filter for the block changed event."""
  _change_block: optimism_BlockChangedFilter
}

enum optimism_SwapWeeklyVolume_orderBy {
  id
  stableSwap
  timestamp
  volume
}

type optimism_SystemInfo {
  id: ID!
  exchangeCount: BigInt!
  swapCount: BigInt!
}

input optimism_SystemInfo_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  exchangeCount: BigInt
  exchangeCount_not: BigInt
  exchangeCount_gt: BigInt
  exchangeCount_lt: BigInt
  exchangeCount_gte: BigInt
  exchangeCount_lte: BigInt
  exchangeCount_in: [BigInt!]
  exchangeCount_not_in: [BigInt!]
  swapCount: BigInt
  swapCount_not: BigInt
  swapCount_gt: BigInt
  swapCount_lt: BigInt
  swapCount_gte: BigInt
  swapCount_lte: BigInt
  swapCount_in: [BigInt!]
  swapCount_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: optimism_BlockChangedFilter
}

enum optimism_SystemInfo_orderBy {
  id
  exchangeCount
  swapCount
}

type optimism__Block_ {
  """The hash of the block"""
  hash: optimism_Bytes
  """The block number"""
  number: Int!
  """Integer representation of the timestamp stored in blocks for the chain"""
  timestamp: Int
}

"""The type for the top-level _meta field"""
type optimism__Meta_ {
  """
  Information about a specific subgraph block. The hash of the block
  will be null if the _meta field has a block constraint that asks for
  a block number. It will be filled if the _meta field has no block constraint
  and therefore asks for the latest  block
  
  """
  block: optimism__Block_!
  """The deployment ID"""
  deployment: String!
  """If `true`, the subgraph encountered indexing errors at some past block"""
  hasIndexingErrors: Boolean!
}

scalar polygon_BigDecimal

input polygon_BlockChangedFilter {
  number_gte: Int!
}

input polygon_Block_height {
  hash: polygon_Bytes
  number: Int
  number_gte: Int
}

scalar polygon_Bytes

"""Defines the order direction, either ascending or descending"""
enum polygon_OrderDirection {
  asc
  desc
}

type polygon_PooledToken {
  id: ID!
  asset: polygon_Bytes!
}

input polygon_PooledToken_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  asset: polygon_Bytes
  asset_not: polygon_Bytes
  asset_gt: polygon_Bytes
  asset_lt: polygon_Bytes
  asset_gte: polygon_Bytes
  asset_lte: polygon_Bytes
  asset_in: [polygon_Bytes!]
  asset_not_in: [polygon_Bytes!]
  asset_contains: polygon_Bytes
  asset_not_contains: polygon_Bytes
  """Filter for the block changed event."""
  _change_block: polygon_BlockChangedFilter
}

enum polygon_PooledToken_orderBy {
  id
  asset
}

type polygon_StableSwap {
  id: ID!
  isActive: Boolean
  key: polygon_Bytes!
  canonicalId: polygon_Bytes
  domain: BigInt
  swapPool: polygon_Bytes
  lpToken: polygon_Bytes
  initialA: BigInt
  futureA: BigInt
  initialATime: BigInt
  futureATime: BigInt
  swapFee: BigInt
  adminFee: BigInt
  pooledTokens(skip: Int = 0, first: Int = 100, orderBy: polygon_PooledToken_orderBy, orderDirection: polygon_OrderDirection, where: polygon_PooledToken_filter): [polygon_PooledToken!]!
  tokenPrecisionMultipliers: [BigInt!]!
  balances: [BigInt!]!
  adminFees: [BigInt!]!
  virtualPrice: BigInt!
  invariant: BigInt!
  lpTokenSupply: BigInt!
  events(skip: Int = 0, first: Int = 100, orderBy: polygon_StableSwapEvent_orderBy, orderDirection: polygon_OrderDirection, where: polygon_StableSwapEvent_filter): [polygon_StableSwapEvent!]
  exchanges(skip: Int = 0, first: Int = 100, orderBy: polygon_StableSwapExchange_orderBy, orderDirection: polygon_OrderDirection, where: polygon_StableSwapExchange_filter): [polygon_StableSwapExchange!]
  hourlyVolumes(skip: Int = 0, first: Int = 100, orderBy: polygon_SwapHourlyVolume_orderBy, orderDirection: polygon_OrderDirection, where: polygon_SwapHourlyVolume_filter): [polygon_SwapHourlyVolume!]
  dailyVolumes(skip: Int = 0, first: Int = 100, orderBy: polygon_SwapDailyVolume_orderBy, orderDirection: polygon_OrderDirection, where: polygon_SwapDailyVolume_filter): [polygon_SwapDailyVolume!]
  weeklyVolumes(skip: Int = 0, first: Int = 100, orderBy: polygon_SwapWeeklyVolume_orderBy, orderDirection: polygon_OrderDirection, where: polygon_SwapWeeklyVolume_filter): [polygon_SwapWeeklyVolume!]
}

type polygon_StableSwapAddLiquidityEvent implements polygon_StableSwapEvent {
  id: ID!
  stableSwap: polygon_StableSwap!
  provider: polygon_Bytes!
  tokenAmounts: [BigInt!]!
  fees: [BigInt!]!
  invariant: BigInt
  lpTokenSupply: BigInt!
  block: BigInt!
  timestamp: BigInt!
  transaction: polygon_Bytes!
}

input polygon_StableSwapAddLiquidityEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: polygon_StableSwap_filter
  provider: polygon_Bytes
  provider_not: polygon_Bytes
  provider_gt: polygon_Bytes
  provider_lt: polygon_Bytes
  provider_gte: polygon_Bytes
  provider_lte: polygon_Bytes
  provider_in: [polygon_Bytes!]
  provider_not_in: [polygon_Bytes!]
  provider_contains: polygon_Bytes
  provider_not_contains: polygon_Bytes
  tokenAmounts: [BigInt!]
  tokenAmounts_not: [BigInt!]
  tokenAmounts_contains: [BigInt!]
  tokenAmounts_contains_nocase: [BigInt!]
  tokenAmounts_not_contains: [BigInt!]
  tokenAmounts_not_contains_nocase: [BigInt!]
  fees: [BigInt!]
  fees_not: [BigInt!]
  fees_contains: [BigInt!]
  fees_contains_nocase: [BigInt!]
  fees_not_contains: [BigInt!]
  fees_not_contains_nocase: [BigInt!]
  invariant: BigInt
  invariant_not: BigInt
  invariant_gt: BigInt
  invariant_lt: BigInt
  invariant_gte: BigInt
  invariant_lte: BigInt
  invariant_in: [BigInt!]
  invariant_not_in: [BigInt!]
  lpTokenSupply: BigInt
  lpTokenSupply_not: BigInt
  lpTokenSupply_gt: BigInt
  lpTokenSupply_lt: BigInt
  lpTokenSupply_gte: BigInt
  lpTokenSupply_lte: BigInt
  lpTokenSupply_in: [BigInt!]
  lpTokenSupply_not_in: [BigInt!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: polygon_Bytes
  transaction_not: polygon_Bytes
  transaction_gt: polygon_Bytes
  transaction_lt: polygon_Bytes
  transaction_gte: polygon_Bytes
  transaction_lte: polygon_Bytes
  transaction_in: [polygon_Bytes!]
  transaction_not_in: [polygon_Bytes!]
  transaction_contains: polygon_Bytes
  transaction_not_contains: polygon_Bytes
  """Filter for the block changed event."""
  _change_block: polygon_BlockChangedFilter
}

enum polygon_StableSwapAddLiquidityEvent_orderBy {
  id
  stableSwap
  provider
  tokenAmounts
  fees
  invariant
  lpTokenSupply
  block
  timestamp
  transaction
}

interface polygon_StableSwapEvent {
  id: ID!
  stableSwap: polygon_StableSwap!
  block: BigInt!
  timestamp: BigInt!
  transaction: polygon_Bytes!
}

input polygon_StableSwapEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: polygon_StableSwap_filter
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: polygon_Bytes
  transaction_not: polygon_Bytes
  transaction_gt: polygon_Bytes
  transaction_lt: polygon_Bytes
  transaction_gte: polygon_Bytes
  transaction_lte: polygon_Bytes
  transaction_in: [polygon_Bytes!]
  transaction_not_in: [polygon_Bytes!]
  transaction_contains: polygon_Bytes
  transaction_not_contains: polygon_Bytes
  """Filter for the block changed event."""
  _change_block: polygon_BlockChangedFilter
}

enum polygon_StableSwapEvent_orderBy {
  id
  stableSwap
  block
  timestamp
  transaction
}

type polygon_StableSwapExchange {
  id: ID!
  stableSwap: polygon_StableSwap!
  buyer: polygon_Bytes!
  boughtId: BigInt!
  tokensBought: BigInt!
  soldId: BigInt!
  tokensSold: BigInt!
  block: BigInt!
  timestamp: BigInt!
  transaction: polygon_Bytes!
}

input polygon_StableSwapExchange_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: polygon_StableSwap_filter
  buyer: polygon_Bytes
  buyer_not: polygon_Bytes
  buyer_gt: polygon_Bytes
  buyer_lt: polygon_Bytes
  buyer_gte: polygon_Bytes
  buyer_lte: polygon_Bytes
  buyer_in: [polygon_Bytes!]
  buyer_not_in: [polygon_Bytes!]
  buyer_contains: polygon_Bytes
  buyer_not_contains: polygon_Bytes
  boughtId: BigInt
  boughtId_not: BigInt
  boughtId_gt: BigInt
  boughtId_lt: BigInt
  boughtId_gte: BigInt
  boughtId_lte: BigInt
  boughtId_in: [BigInt!]
  boughtId_not_in: [BigInt!]
  tokensBought: BigInt
  tokensBought_not: BigInt
  tokensBought_gt: BigInt
  tokensBought_lt: BigInt
  tokensBought_gte: BigInt
  tokensBought_lte: BigInt
  tokensBought_in: [BigInt!]
  tokensBought_not_in: [BigInt!]
  soldId: BigInt
  soldId_not: BigInt
  soldId_gt: BigInt
  soldId_lt: BigInt
  soldId_gte: BigInt
  soldId_lte: BigInt
  soldId_in: [BigInt!]
  soldId_not_in: [BigInt!]
  tokensSold: BigInt
  tokensSold_not: BigInt
  tokensSold_gt: BigInt
  tokensSold_lt: BigInt
  tokensSold_gte: BigInt
  tokensSold_lte: BigInt
  tokensSold_in: [BigInt!]
  tokensSold_not_in: [BigInt!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: polygon_Bytes
  transaction_not: polygon_Bytes
  transaction_gt: polygon_Bytes
  transaction_lt: polygon_Bytes
  transaction_gte: polygon_Bytes
  transaction_lte: polygon_Bytes
  transaction_in: [polygon_Bytes!]
  transaction_not_in: [polygon_Bytes!]
  transaction_contains: polygon_Bytes
  transaction_not_contains: polygon_Bytes
  """Filter for the block changed event."""
  _change_block: polygon_BlockChangedFilter
}

enum polygon_StableSwapExchange_orderBy {
  id
  stableSwap
  buyer
  boughtId
  tokensBought
  soldId
  tokensSold
  block
  timestamp
  transaction
}

type polygon_StableSwapRemoveLiquidityEvent implements polygon_StableSwapEvent {
  id: ID!
  stableSwap: polygon_StableSwap!
  provider: polygon_Bytes!
  tokenAmounts: [BigInt!]!
  fees: [BigInt!]
  invariant: BigInt
  lpTokenSupply: BigInt!
  block: BigInt!
  timestamp: BigInt!
  transaction: polygon_Bytes!
}

input polygon_StableSwapRemoveLiquidityEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: polygon_StableSwap_filter
  provider: polygon_Bytes
  provider_not: polygon_Bytes
  provider_gt: polygon_Bytes
  provider_lt: polygon_Bytes
  provider_gte: polygon_Bytes
  provider_lte: polygon_Bytes
  provider_in: [polygon_Bytes!]
  provider_not_in: [polygon_Bytes!]
  provider_contains: polygon_Bytes
  provider_not_contains: polygon_Bytes
  tokenAmounts: [BigInt!]
  tokenAmounts_not: [BigInt!]
  tokenAmounts_contains: [BigInt!]
  tokenAmounts_contains_nocase: [BigInt!]
  tokenAmounts_not_contains: [BigInt!]
  tokenAmounts_not_contains_nocase: [BigInt!]
  fees: [BigInt!]
  fees_not: [BigInt!]
  fees_contains: [BigInt!]
  fees_contains_nocase: [BigInt!]
  fees_not_contains: [BigInt!]
  fees_not_contains_nocase: [BigInt!]
  invariant: BigInt
  invariant_not: BigInt
  invariant_gt: BigInt
  invariant_lt: BigInt
  invariant_gte: BigInt
  invariant_lte: BigInt
  invariant_in: [BigInt!]
  invariant_not_in: [BigInt!]
  lpTokenSupply: BigInt
  lpTokenSupply_not: BigInt
  lpTokenSupply_gt: BigInt
  lpTokenSupply_lt: BigInt
  lpTokenSupply_gte: BigInt
  lpTokenSupply_lte: BigInt
  lpTokenSupply_in: [BigInt!]
  lpTokenSupply_not_in: [BigInt!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: polygon_Bytes
  transaction_not: polygon_Bytes
  transaction_gt: polygon_Bytes
  transaction_lt: polygon_Bytes
  transaction_gte: polygon_Bytes
  transaction_lte: polygon_Bytes
  transaction_in: [polygon_Bytes!]
  transaction_not_in: [polygon_Bytes!]
  transaction_contains: polygon_Bytes
  transaction_not_contains: polygon_Bytes
  """Filter for the block changed event."""
  _change_block: polygon_BlockChangedFilter
}

enum polygon_StableSwapRemoveLiquidityEvent_orderBy {
  id
  stableSwap
  provider
  tokenAmounts
  fees
  invariant
  lpTokenSupply
  block
  timestamp
  transaction
}

input polygon_StableSwap_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  isActive: Boolean
  isActive_not: Boolean
  isActive_in: [Boolean!]
  isActive_not_in: [Boolean!]
  key: polygon_Bytes
  key_not: polygon_Bytes
  key_gt: polygon_Bytes
  key_lt: polygon_Bytes
  key_gte: polygon_Bytes
  key_lte: polygon_Bytes
  key_in: [polygon_Bytes!]
  key_not_in: [polygon_Bytes!]
  key_contains: polygon_Bytes
  key_not_contains: polygon_Bytes
  canonicalId: polygon_Bytes
  canonicalId_not: polygon_Bytes
  canonicalId_gt: polygon_Bytes
  canonicalId_lt: polygon_Bytes
  canonicalId_gte: polygon_Bytes
  canonicalId_lte: polygon_Bytes
  canonicalId_in: [polygon_Bytes!]
  canonicalId_not_in: [polygon_Bytes!]
  canonicalId_contains: polygon_Bytes
  canonicalId_not_contains: polygon_Bytes
  domain: BigInt
  domain_not: BigInt
  domain_gt: BigInt
  domain_lt: BigInt
  domain_gte: BigInt
  domain_lte: BigInt
  domain_in: [BigInt!]
  domain_not_in: [BigInt!]
  swapPool: polygon_Bytes
  swapPool_not: polygon_Bytes
  swapPool_gt: polygon_Bytes
  swapPool_lt: polygon_Bytes
  swapPool_gte: polygon_Bytes
  swapPool_lte: polygon_Bytes
  swapPool_in: [polygon_Bytes!]
  swapPool_not_in: [polygon_Bytes!]
  swapPool_contains: polygon_Bytes
  swapPool_not_contains: polygon_Bytes
  lpToken: polygon_Bytes
  lpToken_not: polygon_Bytes
  lpToken_gt: polygon_Bytes
  lpToken_lt: polygon_Bytes
  lpToken_gte: polygon_Bytes
  lpToken_lte: polygon_Bytes
  lpToken_in: [polygon_Bytes!]
  lpToken_not_in: [polygon_Bytes!]
  lpToken_contains: polygon_Bytes
  lpToken_not_contains: polygon_Bytes
  initialA: BigInt
  initialA_not: BigInt
  initialA_gt: BigInt
  initialA_lt: BigInt
  initialA_gte: BigInt
  initialA_lte: BigInt
  initialA_in: [BigInt!]
  initialA_not_in: [BigInt!]
  futureA: BigInt
  futureA_not: BigInt
  futureA_gt: BigInt
  futureA_lt: BigInt
  futureA_gte: BigInt
  futureA_lte: BigInt
  futureA_in: [BigInt!]
  futureA_not_in: [BigInt!]
  initialATime: BigInt
  initialATime_not: BigInt
  initialATime_gt: BigInt
  initialATime_lt: BigInt
  initialATime_gte: BigInt
  initialATime_lte: BigInt
  initialATime_in: [BigInt!]
  initialATime_not_in: [BigInt!]
  futureATime: BigInt
  futureATime_not: BigInt
  futureATime_gt: BigInt
  futureATime_lt: BigInt
  futureATime_gte: BigInt
  futureATime_lte: BigInt
  futureATime_in: [BigInt!]
  futureATime_not_in: [BigInt!]
  swapFee: BigInt
  swapFee_not: BigInt
  swapFee_gt: BigInt
  swapFee_lt: BigInt
  swapFee_gte: BigInt
  swapFee_lte: BigInt
  swapFee_in: [BigInt!]
  swapFee_not_in: [BigInt!]
  adminFee: BigInt
  adminFee_not: BigInt
  adminFee_gt: BigInt
  adminFee_lt: BigInt
  adminFee_gte: BigInt
  adminFee_lte: BigInt
  adminFee_in: [BigInt!]
  adminFee_not_in: [BigInt!]
  pooledTokens: [String!]
  pooledTokens_not: [String!]
  pooledTokens_contains: [String!]
  pooledTokens_contains_nocase: [String!]
  pooledTokens_not_contains: [String!]
  pooledTokens_not_contains_nocase: [String!]
  pooledTokens_: polygon_PooledToken_filter
  tokenPrecisionMultipliers: [BigInt!]
  tokenPrecisionMultipliers_not: [BigInt!]
  tokenPrecisionMultipliers_contains: [BigInt!]
  tokenPrecisionMultipliers_contains_nocase: [BigInt!]
  tokenPrecisionMultipliers_not_contains: [BigInt!]
  tokenPrecisionMultipliers_not_contains_nocase: [BigInt!]
  balances: [BigInt!]
  balances_not: [BigInt!]
  balances_contains: [BigInt!]
  balances_contains_nocase: [BigInt!]
  balances_not_contains: [BigInt!]
  balances_not_contains_nocase: [BigInt!]
  adminFees: [BigInt!]
  adminFees_not: [BigInt!]
  adminFees_contains: [BigInt!]
  adminFees_contains_nocase: [BigInt!]
  adminFees_not_contains: [BigInt!]
  adminFees_not_contains_nocase: [BigInt!]
  virtualPrice: BigInt
  virtualPrice_not: BigInt
  virtualPrice_gt: BigInt
  virtualPrice_lt: BigInt
  virtualPrice_gte: BigInt
  virtualPrice_lte: BigInt
  virtualPrice_in: [BigInt!]
  virtualPrice_not_in: [BigInt!]
  invariant: BigInt
  invariant_not: BigInt
  invariant_gt: BigInt
  invariant_lt: BigInt
  invariant_gte: BigInt
  invariant_lte: BigInt
  invariant_in: [BigInt!]
  invariant_not_in: [BigInt!]
  lpTokenSupply: BigInt
  lpTokenSupply_not: BigInt
  lpTokenSupply_gt: BigInt
  lpTokenSupply_lt: BigInt
  lpTokenSupply_gte: BigInt
  lpTokenSupply_lte: BigInt
  lpTokenSupply_in: [BigInt!]
  lpTokenSupply_not_in: [BigInt!]
  events_: polygon_StableSwapEvent_filter
  exchanges_: polygon_StableSwapExchange_filter
  hourlyVolumes_: polygon_SwapHourlyVolume_filter
  dailyVolumes_: polygon_SwapDailyVolume_filter
  weeklyVolumes_: polygon_SwapWeeklyVolume_filter
  """Filter for the block changed event."""
  _change_block: polygon_BlockChangedFilter
}

enum polygon_StableSwap_orderBy {
  id
  isActive
  key
  canonicalId
  domain
  swapPool
  lpToken
  initialA
  futureA
  initialATime
  futureATime
  swapFee
  adminFee
  pooledTokens
  tokenPrecisionMultipliers
  balances
  adminFees
  virtualPrice
  invariant
  lpTokenSupply
  events
  exchanges
  hourlyVolumes
  dailyVolumes
  weeklyVolumes
}

type polygon_SwapDailyVolume implements polygon_SwapTradeVolume {
  id: ID!
  stableSwap: polygon_StableSwap!
  timestamp: BigInt!
  volume: polygon_BigDecimal!
}

input polygon_SwapDailyVolume_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: polygon_StableSwap_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  volume: polygon_BigDecimal
  volume_not: polygon_BigDecimal
  volume_gt: polygon_BigDecimal
  volume_lt: polygon_BigDecimal
  volume_gte: polygon_BigDecimal
  volume_lte: polygon_BigDecimal
  volume_in: [polygon_BigDecimal!]
  volume_not_in: [polygon_BigDecimal!]
  """Filter for the block changed event."""
  _change_block: polygon_BlockChangedFilter
}

enum polygon_SwapDailyVolume_orderBy {
  id
  stableSwap
  timestamp
  volume
}

type polygon_SwapHourlyVolume implements polygon_SwapTradeVolume {
  id: ID!
  stableSwap: polygon_StableSwap!
  timestamp: BigInt!
  volume: polygon_BigDecimal!
}

input polygon_SwapHourlyVolume_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: polygon_StableSwap_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  volume: polygon_BigDecimal
  volume_not: polygon_BigDecimal
  volume_gt: polygon_BigDecimal
  volume_lt: polygon_BigDecimal
  volume_gte: polygon_BigDecimal
  volume_lte: polygon_BigDecimal
  volume_in: [polygon_BigDecimal!]
  volume_not_in: [polygon_BigDecimal!]
  """Filter for the block changed event."""
  _change_block: polygon_BlockChangedFilter
}

enum polygon_SwapHourlyVolume_orderBy {
  id
  stableSwap
  timestamp
  volume
}

interface polygon_SwapTradeVolume {
  stableSwap: polygon_StableSwap!
  timestamp: BigInt!
  volume: polygon_BigDecimal!
}

input polygon_SwapTradeVolume_filter {
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: polygon_StableSwap_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  volume: polygon_BigDecimal
  volume_not: polygon_BigDecimal
  volume_gt: polygon_BigDecimal
  volume_lt: polygon_BigDecimal
  volume_gte: polygon_BigDecimal
  volume_lte: polygon_BigDecimal
  volume_in: [polygon_BigDecimal!]
  volume_not_in: [polygon_BigDecimal!]
  """Filter for the block changed event."""
  _change_block: polygon_BlockChangedFilter
}

enum polygon_SwapTradeVolume_orderBy {
  stableSwap
  timestamp
  volume
}

type polygon_SwapWeeklyVolume implements polygon_SwapTradeVolume {
  id: ID!
  stableSwap: polygon_StableSwap!
  timestamp: BigInt!
  volume: polygon_BigDecimal!
}

input polygon_SwapWeeklyVolume_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: polygon_StableSwap_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  volume: polygon_BigDecimal
  volume_not: polygon_BigDecimal
  volume_gt: polygon_BigDecimal
  volume_lt: polygon_BigDecimal
  volume_gte: polygon_BigDecimal
  volume_lte: polygon_BigDecimal
  volume_in: [polygon_BigDecimal!]
  volume_not_in: [polygon_BigDecimal!]
  """Filter for the block changed event."""
  _change_block: polygon_BlockChangedFilter
}

enum polygon_SwapWeeklyVolume_orderBy {
  id
  stableSwap
  timestamp
  volume
}

type polygon_SystemInfo {
  id: ID!
  exchangeCount: BigInt!
  swapCount: BigInt!
}

input polygon_SystemInfo_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  exchangeCount: BigInt
  exchangeCount_not: BigInt
  exchangeCount_gt: BigInt
  exchangeCount_lt: BigInt
  exchangeCount_gte: BigInt
  exchangeCount_lte: BigInt
  exchangeCount_in: [BigInt!]
  exchangeCount_not_in: [BigInt!]
  swapCount: BigInt
  swapCount_not: BigInt
  swapCount_gt: BigInt
  swapCount_lt: BigInt
  swapCount_gte: BigInt
  swapCount_lte: BigInt
  swapCount_in: [BigInt!]
  swapCount_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: polygon_BlockChangedFilter
}

enum polygon_SystemInfo_orderBy {
  id
  exchangeCount
  swapCount
}

type polygon__Block_ {
  """The hash of the block"""
  hash: polygon_Bytes
  """The block number"""
  number: Int!
  """Integer representation of the timestamp stored in blocks for the chain"""
  timestamp: Int
}

"""The type for the top-level _meta field"""
type polygon__Meta_ {
  """
  Information about a specific subgraph block. The hash of the block
  will be null if the _meta field has a block constraint that asks for
  a block number. It will be filled if the _meta field has no block constraint
  and therefore asks for the latest  block
  
  """
  block: polygon__Block_!
  """The deployment ID"""
  deployment: String!
  """If `true`, the subgraph encountered indexing errors at some past block"""
  hasIndexingErrors: Boolean!
}

scalar staginggoerli_BigDecimal

input staginggoerli_BlockChangedFilter {
  number_gte: Int!
}

input staginggoerli_Block_height {
  hash: staginggoerli_Bytes
  number: Int
  number_gte: Int
}

scalar staginggoerli_Bytes

"""Defines the order direction, either ascending or descending"""
enum staginggoerli_OrderDirection {
  asc
  desc
}

type staginggoerli_PooledToken {
  id: ID!
  asset: staginggoerli_Bytes!
}

input staginggoerli_PooledToken_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  asset: staginggoerli_Bytes
  asset_not: staginggoerli_Bytes
  asset_gt: staginggoerli_Bytes
  asset_lt: staginggoerli_Bytes
  asset_gte: staginggoerli_Bytes
  asset_lte: staginggoerli_Bytes
  asset_in: [staginggoerli_Bytes!]
  asset_not_in: [staginggoerli_Bytes!]
  asset_contains: staginggoerli_Bytes
  asset_not_contains: staginggoerli_Bytes
  """Filter for the block changed event."""
  _change_block: staginggoerli_BlockChangedFilter
}

enum staginggoerli_PooledToken_orderBy {
  id
  asset
}

type staginggoerli_StableSwap {
  id: ID!
  isActive: Boolean
  key: staginggoerli_Bytes!
  canonicalId: staginggoerli_Bytes
  domain: BigInt
  swapPool: staginggoerli_Bytes
  lpToken: staginggoerli_Bytes
  initialA: BigInt
  futureA: BigInt
  initialATime: BigInt
  futureATime: BigInt
  swapFee: BigInt
  adminFee: BigInt
  pooledTokens(skip: Int = 0, first: Int = 100, orderBy: staginggoerli_PooledToken_orderBy, orderDirection: staginggoerli_OrderDirection, where: staginggoerli_PooledToken_filter): [staginggoerli_PooledToken!]!
  tokenPrecisionMultipliers: [BigInt!]!
  balances: [BigInt!]!
  adminFees: [BigInt!]!
  virtualPrice: BigInt!
  invariant: BigInt!
  lpTokenSupply: BigInt!
  events(skip: Int = 0, first: Int = 100, orderBy: staginggoerli_StableSwapEvent_orderBy, orderDirection: staginggoerli_OrderDirection, where: staginggoerli_StableSwapEvent_filter): [staginggoerli_StableSwapEvent!]
  exchanges(skip: Int = 0, first: Int = 100, orderBy: staginggoerli_StableSwapExchange_orderBy, orderDirection: staginggoerli_OrderDirection, where: staginggoerli_StableSwapExchange_filter): [staginggoerli_StableSwapExchange!]
  hourlyVolumes(skip: Int = 0, first: Int = 100, orderBy: staginggoerli_SwapHourlyVolume_orderBy, orderDirection: staginggoerli_OrderDirection, where: staginggoerli_SwapHourlyVolume_filter): [staginggoerli_SwapHourlyVolume!]
  dailyVolumes(skip: Int = 0, first: Int = 100, orderBy: staginggoerli_SwapDailyVolume_orderBy, orderDirection: staginggoerli_OrderDirection, where: staginggoerli_SwapDailyVolume_filter): [staginggoerli_SwapDailyVolume!]
  weeklyVolumes(skip: Int = 0, first: Int = 100, orderBy: staginggoerli_SwapWeeklyVolume_orderBy, orderDirection: staginggoerli_OrderDirection, where: staginggoerli_SwapWeeklyVolume_filter): [staginggoerli_SwapWeeklyVolume!]
}

type staginggoerli_StableSwapAddLiquidityEvent implements staginggoerli_StableSwapEvent {
  id: ID!
  stableSwap: staginggoerli_StableSwap!
  provider: staginggoerli_Bytes!
  tokenAmounts: [BigInt!]!
  fees: [BigInt!]!
  invariant: BigInt
  lpTokenSupply: BigInt!
  block: BigInt!
  timestamp: BigInt!
  transaction: staginggoerli_Bytes!
}

input staginggoerli_StableSwapAddLiquidityEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: staginggoerli_StableSwap_filter
  provider: staginggoerli_Bytes
  provider_not: staginggoerli_Bytes
  provider_gt: staginggoerli_Bytes
  provider_lt: staginggoerli_Bytes
  provider_gte: staginggoerli_Bytes
  provider_lte: staginggoerli_Bytes
  provider_in: [staginggoerli_Bytes!]
  provider_not_in: [staginggoerli_Bytes!]
  provider_contains: staginggoerli_Bytes
  provider_not_contains: staginggoerli_Bytes
  tokenAmounts: [BigInt!]
  tokenAmounts_not: [BigInt!]
  tokenAmounts_contains: [BigInt!]
  tokenAmounts_contains_nocase: [BigInt!]
  tokenAmounts_not_contains: [BigInt!]
  tokenAmounts_not_contains_nocase: [BigInt!]
  fees: [BigInt!]
  fees_not: [BigInt!]
  fees_contains: [BigInt!]
  fees_contains_nocase: [BigInt!]
  fees_not_contains: [BigInt!]
  fees_not_contains_nocase: [BigInt!]
  invariant: BigInt
  invariant_not: BigInt
  invariant_gt: BigInt
  invariant_lt: BigInt
  invariant_gte: BigInt
  invariant_lte: BigInt
  invariant_in: [BigInt!]
  invariant_not_in: [BigInt!]
  lpTokenSupply: BigInt
  lpTokenSupply_not: BigInt
  lpTokenSupply_gt: BigInt
  lpTokenSupply_lt: BigInt
  lpTokenSupply_gte: BigInt
  lpTokenSupply_lte: BigInt
  lpTokenSupply_in: [BigInt!]
  lpTokenSupply_not_in: [BigInt!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: staginggoerli_Bytes
  transaction_not: staginggoerli_Bytes
  transaction_gt: staginggoerli_Bytes
  transaction_lt: staginggoerli_Bytes
  transaction_gte: staginggoerli_Bytes
  transaction_lte: staginggoerli_Bytes
  transaction_in: [staginggoerli_Bytes!]
  transaction_not_in: [staginggoerli_Bytes!]
  transaction_contains: staginggoerli_Bytes
  transaction_not_contains: staginggoerli_Bytes
  """Filter for the block changed event."""
  _change_block: staginggoerli_BlockChangedFilter
}

enum staginggoerli_StableSwapAddLiquidityEvent_orderBy {
  id
  stableSwap
  provider
  tokenAmounts
  fees
  invariant
  lpTokenSupply
  block
  timestamp
  transaction
}

interface staginggoerli_StableSwapEvent {
  id: ID!
  stableSwap: staginggoerli_StableSwap!
  block: BigInt!
  timestamp: BigInt!
  transaction: staginggoerli_Bytes!
}

input staginggoerli_StableSwapEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: staginggoerli_StableSwap_filter
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: staginggoerli_Bytes
  transaction_not: staginggoerli_Bytes
  transaction_gt: staginggoerli_Bytes
  transaction_lt: staginggoerli_Bytes
  transaction_gte: staginggoerli_Bytes
  transaction_lte: staginggoerli_Bytes
  transaction_in: [staginggoerli_Bytes!]
  transaction_not_in: [staginggoerli_Bytes!]
  transaction_contains: staginggoerli_Bytes
  transaction_not_contains: staginggoerli_Bytes
  """Filter for the block changed event."""
  _change_block: staginggoerli_BlockChangedFilter
}

enum staginggoerli_StableSwapEvent_orderBy {
  id
  stableSwap
  block
  timestamp
  transaction
}

type staginggoerli_StableSwapExchange {
  id: ID!
  stableSwap: staginggoerli_StableSwap!
  buyer: staginggoerli_Bytes!
  boughtId: BigInt!
  tokensBought: BigInt!
  soldId: BigInt!
  tokensSold: BigInt!
  block: BigInt!
  timestamp: BigInt!
  transaction: staginggoerli_Bytes!
}

input staginggoerli_StableSwapExchange_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: staginggoerli_StableSwap_filter
  buyer: staginggoerli_Bytes
  buyer_not: staginggoerli_Bytes
  buyer_gt: staginggoerli_Bytes
  buyer_lt: staginggoerli_Bytes
  buyer_gte: staginggoerli_Bytes
  buyer_lte: staginggoerli_Bytes
  buyer_in: [staginggoerli_Bytes!]
  buyer_not_in: [staginggoerli_Bytes!]
  buyer_contains: staginggoerli_Bytes
  buyer_not_contains: staginggoerli_Bytes
  boughtId: BigInt
  boughtId_not: BigInt
  boughtId_gt: BigInt
  boughtId_lt: BigInt
  boughtId_gte: BigInt
  boughtId_lte: BigInt
  boughtId_in: [BigInt!]
  boughtId_not_in: [BigInt!]
  tokensBought: BigInt
  tokensBought_not: BigInt
  tokensBought_gt: BigInt
  tokensBought_lt: BigInt
  tokensBought_gte: BigInt
  tokensBought_lte: BigInt
  tokensBought_in: [BigInt!]
  tokensBought_not_in: [BigInt!]
  soldId: BigInt
  soldId_not: BigInt
  soldId_gt: BigInt
  soldId_lt: BigInt
  soldId_gte: BigInt
  soldId_lte: BigInt
  soldId_in: [BigInt!]
  soldId_not_in: [BigInt!]
  tokensSold: BigInt
  tokensSold_not: BigInt
  tokensSold_gt: BigInt
  tokensSold_lt: BigInt
  tokensSold_gte: BigInt
  tokensSold_lte: BigInt
  tokensSold_in: [BigInt!]
  tokensSold_not_in: [BigInt!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: staginggoerli_Bytes
  transaction_not: staginggoerli_Bytes
  transaction_gt: staginggoerli_Bytes
  transaction_lt: staginggoerli_Bytes
  transaction_gte: staginggoerli_Bytes
  transaction_lte: staginggoerli_Bytes
  transaction_in: [staginggoerli_Bytes!]
  transaction_not_in: [staginggoerli_Bytes!]
  transaction_contains: staginggoerli_Bytes
  transaction_not_contains: staginggoerli_Bytes
  """Filter for the block changed event."""
  _change_block: staginggoerli_BlockChangedFilter
}

enum staginggoerli_StableSwapExchange_orderBy {
  id
  stableSwap
  buyer
  boughtId
  tokensBought
  soldId
  tokensSold
  block
  timestamp
  transaction
}

type staginggoerli_StableSwapRemoveLiquidityEvent implements staginggoerli_StableSwapEvent {
  id: ID!
  stableSwap: staginggoerli_StableSwap!
  provider: staginggoerli_Bytes!
  tokenAmounts: [BigInt!]!
  fees: [BigInt!]
  invariant: BigInt
  lpTokenSupply: BigInt!
  block: BigInt!
  timestamp: BigInt!
  transaction: staginggoerli_Bytes!
}

input staginggoerli_StableSwapRemoveLiquidityEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: staginggoerli_StableSwap_filter
  provider: staginggoerli_Bytes
  provider_not: staginggoerli_Bytes
  provider_gt: staginggoerli_Bytes
  provider_lt: staginggoerli_Bytes
  provider_gte: staginggoerli_Bytes
  provider_lte: staginggoerli_Bytes
  provider_in: [staginggoerli_Bytes!]
  provider_not_in: [staginggoerli_Bytes!]
  provider_contains: staginggoerli_Bytes
  provider_not_contains: staginggoerli_Bytes
  tokenAmounts: [BigInt!]
  tokenAmounts_not: [BigInt!]
  tokenAmounts_contains: [BigInt!]
  tokenAmounts_contains_nocase: [BigInt!]
  tokenAmounts_not_contains: [BigInt!]
  tokenAmounts_not_contains_nocase: [BigInt!]
  fees: [BigInt!]
  fees_not: [BigInt!]
  fees_contains: [BigInt!]
  fees_contains_nocase: [BigInt!]
  fees_not_contains: [BigInt!]
  fees_not_contains_nocase: [BigInt!]
  invariant: BigInt
  invariant_not: BigInt
  invariant_gt: BigInt
  invariant_lt: BigInt
  invariant_gte: BigInt
  invariant_lte: BigInt
  invariant_in: [BigInt!]
  invariant_not_in: [BigInt!]
  lpTokenSupply: BigInt
  lpTokenSupply_not: BigInt
  lpTokenSupply_gt: BigInt
  lpTokenSupply_lt: BigInt
  lpTokenSupply_gte: BigInt
  lpTokenSupply_lte: BigInt
  lpTokenSupply_in: [BigInt!]
  lpTokenSupply_not_in: [BigInt!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: staginggoerli_Bytes
  transaction_not: staginggoerli_Bytes
  transaction_gt: staginggoerli_Bytes
  transaction_lt: staginggoerli_Bytes
  transaction_gte: staginggoerli_Bytes
  transaction_lte: staginggoerli_Bytes
  transaction_in: [staginggoerli_Bytes!]
  transaction_not_in: [staginggoerli_Bytes!]
  transaction_contains: staginggoerli_Bytes
  transaction_not_contains: staginggoerli_Bytes
  """Filter for the block changed event."""
  _change_block: staginggoerli_BlockChangedFilter
}

enum staginggoerli_StableSwapRemoveLiquidityEvent_orderBy {
  id
  stableSwap
  provider
  tokenAmounts
  fees
  invariant
  lpTokenSupply
  block
  timestamp
  transaction
}

input staginggoerli_StableSwap_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  isActive: Boolean
  isActive_not: Boolean
  isActive_in: [Boolean!]
  isActive_not_in: [Boolean!]
  key: staginggoerli_Bytes
  key_not: staginggoerli_Bytes
  key_gt: staginggoerli_Bytes
  key_lt: staginggoerli_Bytes
  key_gte: staginggoerli_Bytes
  key_lte: staginggoerli_Bytes
  key_in: [staginggoerli_Bytes!]
  key_not_in: [staginggoerli_Bytes!]
  key_contains: staginggoerli_Bytes
  key_not_contains: staginggoerli_Bytes
  canonicalId: staginggoerli_Bytes
  canonicalId_not: staginggoerli_Bytes
  canonicalId_gt: staginggoerli_Bytes
  canonicalId_lt: staginggoerli_Bytes
  canonicalId_gte: staginggoerli_Bytes
  canonicalId_lte: staginggoerli_Bytes
  canonicalId_in: [staginggoerli_Bytes!]
  canonicalId_not_in: [staginggoerli_Bytes!]
  canonicalId_contains: staginggoerli_Bytes
  canonicalId_not_contains: staginggoerli_Bytes
  domain: BigInt
  domain_not: BigInt
  domain_gt: BigInt
  domain_lt: BigInt
  domain_gte: BigInt
  domain_lte: BigInt
  domain_in: [BigInt!]
  domain_not_in: [BigInt!]
  swapPool: staginggoerli_Bytes
  swapPool_not: staginggoerli_Bytes
  swapPool_gt: staginggoerli_Bytes
  swapPool_lt: staginggoerli_Bytes
  swapPool_gte: staginggoerli_Bytes
  swapPool_lte: staginggoerli_Bytes
  swapPool_in: [staginggoerli_Bytes!]
  swapPool_not_in: [staginggoerli_Bytes!]
  swapPool_contains: staginggoerli_Bytes
  swapPool_not_contains: staginggoerli_Bytes
  lpToken: staginggoerli_Bytes
  lpToken_not: staginggoerli_Bytes
  lpToken_gt: staginggoerli_Bytes
  lpToken_lt: staginggoerli_Bytes
  lpToken_gte: staginggoerli_Bytes
  lpToken_lte: staginggoerli_Bytes
  lpToken_in: [staginggoerli_Bytes!]
  lpToken_not_in: [staginggoerli_Bytes!]
  lpToken_contains: staginggoerli_Bytes
  lpToken_not_contains: staginggoerli_Bytes
  initialA: BigInt
  initialA_not: BigInt
  initialA_gt: BigInt
  initialA_lt: BigInt
  initialA_gte: BigInt
  initialA_lte: BigInt
  initialA_in: [BigInt!]
  initialA_not_in: [BigInt!]
  futureA: BigInt
  futureA_not: BigInt
  futureA_gt: BigInt
  futureA_lt: BigInt
  futureA_gte: BigInt
  futureA_lte: BigInt
  futureA_in: [BigInt!]
  futureA_not_in: [BigInt!]
  initialATime: BigInt
  initialATime_not: BigInt
  initialATime_gt: BigInt
  initialATime_lt: BigInt
  initialATime_gte: BigInt
  initialATime_lte: BigInt
  initialATime_in: [BigInt!]
  initialATime_not_in: [BigInt!]
  futureATime: BigInt
  futureATime_not: BigInt
  futureATime_gt: BigInt
  futureATime_lt: BigInt
  futureATime_gte: BigInt
  futureATime_lte: BigInt
  futureATime_in: [BigInt!]
  futureATime_not_in: [BigInt!]
  swapFee: BigInt
  swapFee_not: BigInt
  swapFee_gt: BigInt
  swapFee_lt: BigInt
  swapFee_gte: BigInt
  swapFee_lte: BigInt
  swapFee_in: [BigInt!]
  swapFee_not_in: [BigInt!]
  adminFee: BigInt
  adminFee_not: BigInt
  adminFee_gt: BigInt
  adminFee_lt: BigInt
  adminFee_gte: BigInt
  adminFee_lte: BigInt
  adminFee_in: [BigInt!]
  adminFee_not_in: [BigInt!]
  pooledTokens: [String!]
  pooledTokens_not: [String!]
  pooledTokens_contains: [String!]
  pooledTokens_contains_nocase: [String!]
  pooledTokens_not_contains: [String!]
  pooledTokens_not_contains_nocase: [String!]
  pooledTokens_: staginggoerli_PooledToken_filter
  tokenPrecisionMultipliers: [BigInt!]
  tokenPrecisionMultipliers_not: [BigInt!]
  tokenPrecisionMultipliers_contains: [BigInt!]
  tokenPrecisionMultipliers_contains_nocase: [BigInt!]
  tokenPrecisionMultipliers_not_contains: [BigInt!]
  tokenPrecisionMultipliers_not_contains_nocase: [BigInt!]
  balances: [BigInt!]
  balances_not: [BigInt!]
  balances_contains: [BigInt!]
  balances_contains_nocase: [BigInt!]
  balances_not_contains: [BigInt!]
  balances_not_contains_nocase: [BigInt!]
  adminFees: [BigInt!]
  adminFees_not: [BigInt!]
  adminFees_contains: [BigInt!]
  adminFees_contains_nocase: [BigInt!]
  adminFees_not_contains: [BigInt!]
  adminFees_not_contains_nocase: [BigInt!]
  virtualPrice: BigInt
  virtualPrice_not: BigInt
  virtualPrice_gt: BigInt
  virtualPrice_lt: BigInt
  virtualPrice_gte: BigInt
  virtualPrice_lte: BigInt
  virtualPrice_in: [BigInt!]
  virtualPrice_not_in: [BigInt!]
  invariant: BigInt
  invariant_not: BigInt
  invariant_gt: BigInt
  invariant_lt: BigInt
  invariant_gte: BigInt
  invariant_lte: BigInt
  invariant_in: [BigInt!]
  invariant_not_in: [BigInt!]
  lpTokenSupply: BigInt
  lpTokenSupply_not: BigInt
  lpTokenSupply_gt: BigInt
  lpTokenSupply_lt: BigInt
  lpTokenSupply_gte: BigInt
  lpTokenSupply_lte: BigInt
  lpTokenSupply_in: [BigInt!]
  lpTokenSupply_not_in: [BigInt!]
  events_: staginggoerli_StableSwapEvent_filter
  exchanges_: staginggoerli_StableSwapExchange_filter
  hourlyVolumes_: staginggoerli_SwapHourlyVolume_filter
  dailyVolumes_: staginggoerli_SwapDailyVolume_filter
  weeklyVolumes_: staginggoerli_SwapWeeklyVolume_filter
  """Filter for the block changed event."""
  _change_block: staginggoerli_BlockChangedFilter
}

enum staginggoerli_StableSwap_orderBy {
  id
  isActive
  key
  canonicalId
  domain
  swapPool
  lpToken
  initialA
  futureA
  initialATime
  futureATime
  swapFee
  adminFee
  pooledTokens
  tokenPrecisionMultipliers
  balances
  adminFees
  virtualPrice
  invariant
  lpTokenSupply
  events
  exchanges
  hourlyVolumes
  dailyVolumes
  weeklyVolumes
}

type staginggoerli_SwapDailyVolume implements staginggoerli_SwapTradeVolume {
  id: ID!
  stableSwap: staginggoerli_StableSwap!
  timestamp: BigInt!
  volume: staginggoerli_BigDecimal!
}

input staginggoerli_SwapDailyVolume_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: staginggoerli_StableSwap_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  volume: staginggoerli_BigDecimal
  volume_not: staginggoerli_BigDecimal
  volume_gt: staginggoerli_BigDecimal
  volume_lt: staginggoerli_BigDecimal
  volume_gte: staginggoerli_BigDecimal
  volume_lte: staginggoerli_BigDecimal
  volume_in: [staginggoerli_BigDecimal!]
  volume_not_in: [staginggoerli_BigDecimal!]
  """Filter for the block changed event."""
  _change_block: staginggoerli_BlockChangedFilter
}

enum staginggoerli_SwapDailyVolume_orderBy {
  id
  stableSwap
  timestamp
  volume
}

type staginggoerli_SwapHourlyVolume implements staginggoerli_SwapTradeVolume {
  id: ID!
  stableSwap: staginggoerli_StableSwap!
  timestamp: BigInt!
  volume: staginggoerli_BigDecimal!
}

input staginggoerli_SwapHourlyVolume_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: staginggoerli_StableSwap_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  volume: staginggoerli_BigDecimal
  volume_not: staginggoerli_BigDecimal
  volume_gt: staginggoerli_BigDecimal
  volume_lt: staginggoerli_BigDecimal
  volume_gte: staginggoerli_BigDecimal
  volume_lte: staginggoerli_BigDecimal
  volume_in: [staginggoerli_BigDecimal!]
  volume_not_in: [staginggoerli_BigDecimal!]
  """Filter for the block changed event."""
  _change_block: staginggoerli_BlockChangedFilter
}

enum staginggoerli_SwapHourlyVolume_orderBy {
  id
  stableSwap
  timestamp
  volume
}

interface staginggoerli_SwapTradeVolume {
  stableSwap: staginggoerli_StableSwap!
  timestamp: BigInt!
  volume: staginggoerli_BigDecimal!
}

input staginggoerli_SwapTradeVolume_filter {
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: staginggoerli_StableSwap_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  volume: staginggoerli_BigDecimal
  volume_not: staginggoerli_BigDecimal
  volume_gt: staginggoerli_BigDecimal
  volume_lt: staginggoerli_BigDecimal
  volume_gte: staginggoerli_BigDecimal
  volume_lte: staginggoerli_BigDecimal
  volume_in: [staginggoerli_BigDecimal!]
  volume_not_in: [staginggoerli_BigDecimal!]
  """Filter for the block changed event."""
  _change_block: staginggoerli_BlockChangedFilter
}

enum staginggoerli_SwapTradeVolume_orderBy {
  stableSwap
  timestamp
  volume
}

type staginggoerli_SwapWeeklyVolume implements staginggoerli_SwapTradeVolume {
  id: ID!
  stableSwap: staginggoerli_StableSwap!
  timestamp: BigInt!
  volume: staginggoerli_BigDecimal!
}

input staginggoerli_SwapWeeklyVolume_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: staginggoerli_StableSwap_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  volume: staginggoerli_BigDecimal
  volume_not: staginggoerli_BigDecimal
  volume_gt: staginggoerli_BigDecimal
  volume_lt: staginggoerli_BigDecimal
  volume_gte: staginggoerli_BigDecimal
  volume_lte: staginggoerli_BigDecimal
  volume_in: [staginggoerli_BigDecimal!]
  volume_not_in: [staginggoerli_BigDecimal!]
  """Filter for the block changed event."""
  _change_block: staginggoerli_BlockChangedFilter
}

enum staginggoerli_SwapWeeklyVolume_orderBy {
  id
  stableSwap
  timestamp
  volume
}

type staginggoerli_SystemInfo {
  id: ID!
  exchangeCount: BigInt!
  swapCount: BigInt!
}

input staginggoerli_SystemInfo_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  exchangeCount: BigInt
  exchangeCount_not: BigInt
  exchangeCount_gt: BigInt
  exchangeCount_lt: BigInt
  exchangeCount_gte: BigInt
  exchangeCount_lte: BigInt
  exchangeCount_in: [BigInt!]
  exchangeCount_not_in: [BigInt!]
  swapCount: BigInt
  swapCount_not: BigInt
  swapCount_gt: BigInt
  swapCount_lt: BigInt
  swapCount_gte: BigInt
  swapCount_lte: BigInt
  swapCount_in: [BigInt!]
  swapCount_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: staginggoerli_BlockChangedFilter
}

enum staginggoerli_SystemInfo_orderBy {
  id
  exchangeCount
  swapCount
}

type staginggoerli__Block_ {
  """The hash of the block"""
  hash: staginggoerli_Bytes
  """The block number"""
  number: Int!
  """Integer representation of the timestamp stored in blocks for the chain"""
  timestamp: Int
}

"""The type for the top-level _meta field"""
type staginggoerli__Meta_ {
  """
  Information about a specific subgraph block. The hash of the block
  will be null if the _meta field has a block constraint that asks for
  a block number. It will be filled if the _meta field has no block constraint
  and therefore asks for the latest  block
  
  """
  block: staginggoerli__Block_!
  """The deployment ID"""
  deployment: String!
  """If `true`, the subgraph encountered indexing errors at some past block"""
  hasIndexingErrors: Boolean!
}

scalar arbitrumgoerli_BigDecimal

input arbitrumgoerli_BlockChangedFilter {
  number_gte: Int!
}

input arbitrumgoerli_Block_height {
  hash: arbitrumgoerli_Bytes
  number: Int
  number_gte: Int
}

scalar arbitrumgoerli_Bytes

"""Defines the order direction, either ascending or descending"""
enum arbitrumgoerli_OrderDirection {
  asc
  desc
}

type arbitrumgoerli_PooledToken {
  id: ID!
  asset: arbitrumgoerli_Bytes!
}

input arbitrumgoerli_PooledToken_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  asset: arbitrumgoerli_Bytes
  asset_not: arbitrumgoerli_Bytes
  asset_gt: arbitrumgoerli_Bytes
  asset_lt: arbitrumgoerli_Bytes
  asset_gte: arbitrumgoerli_Bytes
  asset_lte: arbitrumgoerli_Bytes
  asset_in: [arbitrumgoerli_Bytes!]
  asset_not_in: [arbitrumgoerli_Bytes!]
  asset_contains: arbitrumgoerli_Bytes
  asset_not_contains: arbitrumgoerli_Bytes
  """Filter for the block changed event."""
  _change_block: arbitrumgoerli_BlockChangedFilter
}

enum arbitrumgoerli_PooledToken_orderBy {
  id
  asset
}

type arbitrumgoerli_StableSwap {
  id: ID!
  isActive: Boolean
  key: arbitrumgoerli_Bytes!
  canonicalId: arbitrumgoerli_Bytes
  domain: BigInt
  swapPool: arbitrumgoerli_Bytes
  lpToken: arbitrumgoerli_Bytes
  initialA: BigInt
  futureA: BigInt
  initialATime: BigInt
  futureATime: BigInt
  swapFee: BigInt
  adminFee: BigInt
  pooledTokens(skip: Int = 0, first: Int = 100, orderBy: arbitrumgoerli_PooledToken_orderBy, orderDirection: arbitrumgoerli_OrderDirection, where: arbitrumgoerli_PooledToken_filter): [arbitrumgoerli_PooledToken!]!
  tokenPrecisionMultipliers: [BigInt!]!
  balances: [BigInt!]!
  adminFees: [BigInt!]!
  virtualPrice: BigInt!
  invariant: BigInt!
  lpTokenSupply: BigInt!
  events(skip: Int = 0, first: Int = 100, orderBy: arbitrumgoerli_StableSwapEvent_orderBy, orderDirection: arbitrumgoerli_OrderDirection, where: arbitrumgoerli_StableSwapEvent_filter): [arbitrumgoerli_StableSwapEvent!]
  exchanges(skip: Int = 0, first: Int = 100, orderBy: arbitrumgoerli_StableSwapExchange_orderBy, orderDirection: arbitrumgoerli_OrderDirection, where: arbitrumgoerli_StableSwapExchange_filter): [arbitrumgoerli_StableSwapExchange!]
  hourlyVolumes(skip: Int = 0, first: Int = 100, orderBy: arbitrumgoerli_SwapHourlyVolume_orderBy, orderDirection: arbitrumgoerli_OrderDirection, where: arbitrumgoerli_SwapHourlyVolume_filter): [arbitrumgoerli_SwapHourlyVolume!]
  dailyVolumes(skip: Int = 0, first: Int = 100, orderBy: arbitrumgoerli_SwapDailyVolume_orderBy, orderDirection: arbitrumgoerli_OrderDirection, where: arbitrumgoerli_SwapDailyVolume_filter): [arbitrumgoerli_SwapDailyVolume!]
  weeklyVolumes(skip: Int = 0, first: Int = 100, orderBy: arbitrumgoerli_SwapWeeklyVolume_orderBy, orderDirection: arbitrumgoerli_OrderDirection, where: arbitrumgoerli_SwapWeeklyVolume_filter): [arbitrumgoerli_SwapWeeklyVolume!]
}

type arbitrumgoerli_StableSwapAddLiquidityEvent implements arbitrumgoerli_StableSwapEvent {
  id: ID!
  stableSwap: arbitrumgoerli_StableSwap!
  provider: arbitrumgoerli_Bytes!
  tokenAmounts: [BigInt!]!
  fees: [BigInt!]!
  invariant: BigInt
  lpTokenSupply: BigInt!
  block: BigInt!
  timestamp: BigInt!
  transaction: arbitrumgoerli_Bytes!
}

input arbitrumgoerli_StableSwapAddLiquidityEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: arbitrumgoerli_StableSwap_filter
  provider: arbitrumgoerli_Bytes
  provider_not: arbitrumgoerli_Bytes
  provider_gt: arbitrumgoerli_Bytes
  provider_lt: arbitrumgoerli_Bytes
  provider_gte: arbitrumgoerli_Bytes
  provider_lte: arbitrumgoerli_Bytes
  provider_in: [arbitrumgoerli_Bytes!]
  provider_not_in: [arbitrumgoerli_Bytes!]
  provider_contains: arbitrumgoerli_Bytes
  provider_not_contains: arbitrumgoerli_Bytes
  tokenAmounts: [BigInt!]
  tokenAmounts_not: [BigInt!]
  tokenAmounts_contains: [BigInt!]
  tokenAmounts_contains_nocase: [BigInt!]
  tokenAmounts_not_contains: [BigInt!]
  tokenAmounts_not_contains_nocase: [BigInt!]
  fees: [BigInt!]
  fees_not: [BigInt!]
  fees_contains: [BigInt!]
  fees_contains_nocase: [BigInt!]
  fees_not_contains: [BigInt!]
  fees_not_contains_nocase: [BigInt!]
  invariant: BigInt
  invariant_not: BigInt
  invariant_gt: BigInt
  invariant_lt: BigInt
  invariant_gte: BigInt
  invariant_lte: BigInt
  invariant_in: [BigInt!]
  invariant_not_in: [BigInt!]
  lpTokenSupply: BigInt
  lpTokenSupply_not: BigInt
  lpTokenSupply_gt: BigInt
  lpTokenSupply_lt: BigInt
  lpTokenSupply_gte: BigInt
  lpTokenSupply_lte: BigInt
  lpTokenSupply_in: [BigInt!]
  lpTokenSupply_not_in: [BigInt!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: arbitrumgoerli_Bytes
  transaction_not: arbitrumgoerli_Bytes
  transaction_gt: arbitrumgoerli_Bytes
  transaction_lt: arbitrumgoerli_Bytes
  transaction_gte: arbitrumgoerli_Bytes
  transaction_lte: arbitrumgoerli_Bytes
  transaction_in: [arbitrumgoerli_Bytes!]
  transaction_not_in: [arbitrumgoerli_Bytes!]
  transaction_contains: arbitrumgoerli_Bytes
  transaction_not_contains: arbitrumgoerli_Bytes
  """Filter for the block changed event."""
  _change_block: arbitrumgoerli_BlockChangedFilter
}

enum arbitrumgoerli_StableSwapAddLiquidityEvent_orderBy {
  id
  stableSwap
  provider
  tokenAmounts
  fees
  invariant
  lpTokenSupply
  block
  timestamp
  transaction
}

interface arbitrumgoerli_StableSwapEvent {
  id: ID!
  stableSwap: arbitrumgoerli_StableSwap!
  block: BigInt!
  timestamp: BigInt!
  transaction: arbitrumgoerli_Bytes!
}

input arbitrumgoerli_StableSwapEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: arbitrumgoerli_StableSwap_filter
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: arbitrumgoerli_Bytes
  transaction_not: arbitrumgoerli_Bytes
  transaction_gt: arbitrumgoerli_Bytes
  transaction_lt: arbitrumgoerli_Bytes
  transaction_gte: arbitrumgoerli_Bytes
  transaction_lte: arbitrumgoerli_Bytes
  transaction_in: [arbitrumgoerli_Bytes!]
  transaction_not_in: [arbitrumgoerli_Bytes!]
  transaction_contains: arbitrumgoerli_Bytes
  transaction_not_contains: arbitrumgoerli_Bytes
  """Filter for the block changed event."""
  _change_block: arbitrumgoerli_BlockChangedFilter
}

enum arbitrumgoerli_StableSwapEvent_orderBy {
  id
  stableSwap
  block
  timestamp
  transaction
}

type arbitrumgoerli_StableSwapExchange {
  id: ID!
  stableSwap: arbitrumgoerli_StableSwap!
  buyer: arbitrumgoerli_Bytes!
  boughtId: BigInt!
  tokensBought: BigInt!
  soldId: BigInt!
  tokensSold: BigInt!
  block: BigInt!
  timestamp: BigInt!
  transaction: arbitrumgoerli_Bytes!
}

input arbitrumgoerli_StableSwapExchange_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: arbitrumgoerli_StableSwap_filter
  buyer: arbitrumgoerli_Bytes
  buyer_not: arbitrumgoerli_Bytes
  buyer_gt: arbitrumgoerli_Bytes
  buyer_lt: arbitrumgoerli_Bytes
  buyer_gte: arbitrumgoerli_Bytes
  buyer_lte: arbitrumgoerli_Bytes
  buyer_in: [arbitrumgoerli_Bytes!]
  buyer_not_in: [arbitrumgoerli_Bytes!]
  buyer_contains: arbitrumgoerli_Bytes
  buyer_not_contains: arbitrumgoerli_Bytes
  boughtId: BigInt
  boughtId_not: BigInt
  boughtId_gt: BigInt
  boughtId_lt: BigInt
  boughtId_gte: BigInt
  boughtId_lte: BigInt
  boughtId_in: [BigInt!]
  boughtId_not_in: [BigInt!]
  tokensBought: BigInt
  tokensBought_not: BigInt
  tokensBought_gt: BigInt
  tokensBought_lt: BigInt
  tokensBought_gte: BigInt
  tokensBought_lte: BigInt
  tokensBought_in: [BigInt!]
  tokensBought_not_in: [BigInt!]
  soldId: BigInt
  soldId_not: BigInt
  soldId_gt: BigInt
  soldId_lt: BigInt
  soldId_gte: BigInt
  soldId_lte: BigInt
  soldId_in: [BigInt!]
  soldId_not_in: [BigInt!]
  tokensSold: BigInt
  tokensSold_not: BigInt
  tokensSold_gt: BigInt
  tokensSold_lt: BigInt
  tokensSold_gte: BigInt
  tokensSold_lte: BigInt
  tokensSold_in: [BigInt!]
  tokensSold_not_in: [BigInt!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: arbitrumgoerli_Bytes
  transaction_not: arbitrumgoerli_Bytes
  transaction_gt: arbitrumgoerli_Bytes
  transaction_lt: arbitrumgoerli_Bytes
  transaction_gte: arbitrumgoerli_Bytes
  transaction_lte: arbitrumgoerli_Bytes
  transaction_in: [arbitrumgoerli_Bytes!]
  transaction_not_in: [arbitrumgoerli_Bytes!]
  transaction_contains: arbitrumgoerli_Bytes
  transaction_not_contains: arbitrumgoerli_Bytes
  """Filter for the block changed event."""
  _change_block: arbitrumgoerli_BlockChangedFilter
}

enum arbitrumgoerli_StableSwapExchange_orderBy {
  id
  stableSwap
  buyer
  boughtId
  tokensBought
  soldId
  tokensSold
  block
  timestamp
  transaction
}

type arbitrumgoerli_StableSwapRemoveLiquidityEvent implements arbitrumgoerli_StableSwapEvent {
  id: ID!
  stableSwap: arbitrumgoerli_StableSwap!
  provider: arbitrumgoerli_Bytes!
  tokenAmounts: [BigInt!]!
  fees: [BigInt!]
  invariant: BigInt
  lpTokenSupply: BigInt!
  block: BigInt!
  timestamp: BigInt!
  transaction: arbitrumgoerli_Bytes!
}

input arbitrumgoerli_StableSwapRemoveLiquidityEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: arbitrumgoerli_StableSwap_filter
  provider: arbitrumgoerli_Bytes
  provider_not: arbitrumgoerli_Bytes
  provider_gt: arbitrumgoerli_Bytes
  provider_lt: arbitrumgoerli_Bytes
  provider_gte: arbitrumgoerli_Bytes
  provider_lte: arbitrumgoerli_Bytes
  provider_in: [arbitrumgoerli_Bytes!]
  provider_not_in: [arbitrumgoerli_Bytes!]
  provider_contains: arbitrumgoerli_Bytes
  provider_not_contains: arbitrumgoerli_Bytes
  tokenAmounts: [BigInt!]
  tokenAmounts_not: [BigInt!]
  tokenAmounts_contains: [BigInt!]
  tokenAmounts_contains_nocase: [BigInt!]
  tokenAmounts_not_contains: [BigInt!]
  tokenAmounts_not_contains_nocase: [BigInt!]
  fees: [BigInt!]
  fees_not: [BigInt!]
  fees_contains: [BigInt!]
  fees_contains_nocase: [BigInt!]
  fees_not_contains: [BigInt!]
  fees_not_contains_nocase: [BigInt!]
  invariant: BigInt
  invariant_not: BigInt
  invariant_gt: BigInt
  invariant_lt: BigInt
  invariant_gte: BigInt
  invariant_lte: BigInt
  invariant_in: [BigInt!]
  invariant_not_in: [BigInt!]
  lpTokenSupply: BigInt
  lpTokenSupply_not: BigInt
  lpTokenSupply_gt: BigInt
  lpTokenSupply_lt: BigInt
  lpTokenSupply_gte: BigInt
  lpTokenSupply_lte: BigInt
  lpTokenSupply_in: [BigInt!]
  lpTokenSupply_not_in: [BigInt!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: arbitrumgoerli_Bytes
  transaction_not: arbitrumgoerli_Bytes
  transaction_gt: arbitrumgoerli_Bytes
  transaction_lt: arbitrumgoerli_Bytes
  transaction_gte: arbitrumgoerli_Bytes
  transaction_lte: arbitrumgoerli_Bytes
  transaction_in: [arbitrumgoerli_Bytes!]
  transaction_not_in: [arbitrumgoerli_Bytes!]
  transaction_contains: arbitrumgoerli_Bytes
  transaction_not_contains: arbitrumgoerli_Bytes
  """Filter for the block changed event."""
  _change_block: arbitrumgoerli_BlockChangedFilter
}

enum arbitrumgoerli_StableSwapRemoveLiquidityEvent_orderBy {
  id
  stableSwap
  provider
  tokenAmounts
  fees
  invariant
  lpTokenSupply
  block
  timestamp
  transaction
}

input arbitrumgoerli_StableSwap_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  isActive: Boolean
  isActive_not: Boolean
  isActive_in: [Boolean!]
  isActive_not_in: [Boolean!]
  key: arbitrumgoerli_Bytes
  key_not: arbitrumgoerli_Bytes
  key_gt: arbitrumgoerli_Bytes
  key_lt: arbitrumgoerli_Bytes
  key_gte: arbitrumgoerli_Bytes
  key_lte: arbitrumgoerli_Bytes
  key_in: [arbitrumgoerli_Bytes!]
  key_not_in: [arbitrumgoerli_Bytes!]
  key_contains: arbitrumgoerli_Bytes
  key_not_contains: arbitrumgoerli_Bytes
  canonicalId: arbitrumgoerli_Bytes
  canonicalId_not: arbitrumgoerli_Bytes
  canonicalId_gt: arbitrumgoerli_Bytes
  canonicalId_lt: arbitrumgoerli_Bytes
  canonicalId_gte: arbitrumgoerli_Bytes
  canonicalId_lte: arbitrumgoerli_Bytes
  canonicalId_in: [arbitrumgoerli_Bytes!]
  canonicalId_not_in: [arbitrumgoerli_Bytes!]
  canonicalId_contains: arbitrumgoerli_Bytes
  canonicalId_not_contains: arbitrumgoerli_Bytes
  domain: BigInt
  domain_not: BigInt
  domain_gt: BigInt
  domain_lt: BigInt
  domain_gte: BigInt
  domain_lte: BigInt
  domain_in: [BigInt!]
  domain_not_in: [BigInt!]
  swapPool: arbitrumgoerli_Bytes
  swapPool_not: arbitrumgoerli_Bytes
  swapPool_gt: arbitrumgoerli_Bytes
  swapPool_lt: arbitrumgoerli_Bytes
  swapPool_gte: arbitrumgoerli_Bytes
  swapPool_lte: arbitrumgoerli_Bytes
  swapPool_in: [arbitrumgoerli_Bytes!]
  swapPool_not_in: [arbitrumgoerli_Bytes!]
  swapPool_contains: arbitrumgoerli_Bytes
  swapPool_not_contains: arbitrumgoerli_Bytes
  lpToken: arbitrumgoerli_Bytes
  lpToken_not: arbitrumgoerli_Bytes
  lpToken_gt: arbitrumgoerli_Bytes
  lpToken_lt: arbitrumgoerli_Bytes
  lpToken_gte: arbitrumgoerli_Bytes
  lpToken_lte: arbitrumgoerli_Bytes
  lpToken_in: [arbitrumgoerli_Bytes!]
  lpToken_not_in: [arbitrumgoerli_Bytes!]
  lpToken_contains: arbitrumgoerli_Bytes
  lpToken_not_contains: arbitrumgoerli_Bytes
  initialA: BigInt
  initialA_not: BigInt
  initialA_gt: BigInt
  initialA_lt: BigInt
  initialA_gte: BigInt
  initialA_lte: BigInt
  initialA_in: [BigInt!]
  initialA_not_in: [BigInt!]
  futureA: BigInt
  futureA_not: BigInt
  futureA_gt: BigInt
  futureA_lt: BigInt
  futureA_gte: BigInt
  futureA_lte: BigInt
  futureA_in: [BigInt!]
  futureA_not_in: [BigInt!]
  initialATime: BigInt
  initialATime_not: BigInt
  initialATime_gt: BigInt
  initialATime_lt: BigInt
  initialATime_gte: BigInt
  initialATime_lte: BigInt
  initialATime_in: [BigInt!]
  initialATime_not_in: [BigInt!]
  futureATime: BigInt
  futureATime_not: BigInt
  futureATime_gt: BigInt
  futureATime_lt: BigInt
  futureATime_gte: BigInt
  futureATime_lte: BigInt
  futureATime_in: [BigInt!]
  futureATime_not_in: [BigInt!]
  swapFee: BigInt
  swapFee_not: BigInt
  swapFee_gt: BigInt
  swapFee_lt: BigInt
  swapFee_gte: BigInt
  swapFee_lte: BigInt
  swapFee_in: [BigInt!]
  swapFee_not_in: [BigInt!]
  adminFee: BigInt
  adminFee_not: BigInt
  adminFee_gt: BigInt
  adminFee_lt: BigInt
  adminFee_gte: BigInt
  adminFee_lte: BigInt
  adminFee_in: [BigInt!]
  adminFee_not_in: [BigInt!]
  pooledTokens: [String!]
  pooledTokens_not: [String!]
  pooledTokens_contains: [String!]
  pooledTokens_contains_nocase: [String!]
  pooledTokens_not_contains: [String!]
  pooledTokens_not_contains_nocase: [String!]
  pooledTokens_: arbitrumgoerli_PooledToken_filter
  tokenPrecisionMultipliers: [BigInt!]
  tokenPrecisionMultipliers_not: [BigInt!]
  tokenPrecisionMultipliers_contains: [BigInt!]
  tokenPrecisionMultipliers_contains_nocase: [BigInt!]
  tokenPrecisionMultipliers_not_contains: [BigInt!]
  tokenPrecisionMultipliers_not_contains_nocase: [BigInt!]
  balances: [BigInt!]
  balances_not: [BigInt!]
  balances_contains: [BigInt!]
  balances_contains_nocase: [BigInt!]
  balances_not_contains: [BigInt!]
  balances_not_contains_nocase: [BigInt!]
  adminFees: [BigInt!]
  adminFees_not: [BigInt!]
  adminFees_contains: [BigInt!]
  adminFees_contains_nocase: [BigInt!]
  adminFees_not_contains: [BigInt!]
  adminFees_not_contains_nocase: [BigInt!]
  virtualPrice: BigInt
  virtualPrice_not: BigInt
  virtualPrice_gt: BigInt
  virtualPrice_lt: BigInt
  virtualPrice_gte: BigInt
  virtualPrice_lte: BigInt
  virtualPrice_in: [BigInt!]
  virtualPrice_not_in: [BigInt!]
  invariant: BigInt
  invariant_not: BigInt
  invariant_gt: BigInt
  invariant_lt: BigInt
  invariant_gte: BigInt
  invariant_lte: BigInt
  invariant_in: [BigInt!]
  invariant_not_in: [BigInt!]
  lpTokenSupply: BigInt
  lpTokenSupply_not: BigInt
  lpTokenSupply_gt: BigInt
  lpTokenSupply_lt: BigInt
  lpTokenSupply_gte: BigInt
  lpTokenSupply_lte: BigInt
  lpTokenSupply_in: [BigInt!]
  lpTokenSupply_not_in: [BigInt!]
  events_: arbitrumgoerli_StableSwapEvent_filter
  exchanges_: arbitrumgoerli_StableSwapExchange_filter
  hourlyVolumes_: arbitrumgoerli_SwapHourlyVolume_filter
  dailyVolumes_: arbitrumgoerli_SwapDailyVolume_filter
  weeklyVolumes_: arbitrumgoerli_SwapWeeklyVolume_filter
  """Filter for the block changed event."""
  _change_block: arbitrumgoerli_BlockChangedFilter
}

enum arbitrumgoerli_StableSwap_orderBy {
  id
  isActive
  key
  canonicalId
  domain
  swapPool
  lpToken
  initialA
  futureA
  initialATime
  futureATime
  swapFee
  adminFee
  pooledTokens
  tokenPrecisionMultipliers
  balances
  adminFees
  virtualPrice
  invariant
  lpTokenSupply
  events
  exchanges
  hourlyVolumes
  dailyVolumes
  weeklyVolumes
}

type arbitrumgoerli_SwapDailyVolume implements arbitrumgoerli_SwapTradeVolume {
  id: ID!
  stableSwap: arbitrumgoerli_StableSwap!
  timestamp: BigInt!
  volume: arbitrumgoerli_BigDecimal!
}

input arbitrumgoerli_SwapDailyVolume_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: arbitrumgoerli_StableSwap_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  volume: arbitrumgoerli_BigDecimal
  volume_not: arbitrumgoerli_BigDecimal
  volume_gt: arbitrumgoerli_BigDecimal
  volume_lt: arbitrumgoerli_BigDecimal
  volume_gte: arbitrumgoerli_BigDecimal
  volume_lte: arbitrumgoerli_BigDecimal
  volume_in: [arbitrumgoerli_BigDecimal!]
  volume_not_in: [arbitrumgoerli_BigDecimal!]
  """Filter for the block changed event."""
  _change_block: arbitrumgoerli_BlockChangedFilter
}

enum arbitrumgoerli_SwapDailyVolume_orderBy {
  id
  stableSwap
  timestamp
  volume
}

type arbitrumgoerli_SwapHourlyVolume implements arbitrumgoerli_SwapTradeVolume {
  id: ID!
  stableSwap: arbitrumgoerli_StableSwap!
  timestamp: BigInt!
  volume: arbitrumgoerli_BigDecimal!
}

input arbitrumgoerli_SwapHourlyVolume_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: arbitrumgoerli_StableSwap_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  volume: arbitrumgoerli_BigDecimal
  volume_not: arbitrumgoerli_BigDecimal
  volume_gt: arbitrumgoerli_BigDecimal
  volume_lt: arbitrumgoerli_BigDecimal
  volume_gte: arbitrumgoerli_BigDecimal
  volume_lte: arbitrumgoerli_BigDecimal
  volume_in: [arbitrumgoerli_BigDecimal!]
  volume_not_in: [arbitrumgoerli_BigDecimal!]
  """Filter for the block changed event."""
  _change_block: arbitrumgoerli_BlockChangedFilter
}

enum arbitrumgoerli_SwapHourlyVolume_orderBy {
  id
  stableSwap
  timestamp
  volume
}

interface arbitrumgoerli_SwapTradeVolume {
  stableSwap: arbitrumgoerli_StableSwap!
  timestamp: BigInt!
  volume: arbitrumgoerli_BigDecimal!
}

input arbitrumgoerli_SwapTradeVolume_filter {
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: arbitrumgoerli_StableSwap_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  volume: arbitrumgoerli_BigDecimal
  volume_not: arbitrumgoerli_BigDecimal
  volume_gt: arbitrumgoerli_BigDecimal
  volume_lt: arbitrumgoerli_BigDecimal
  volume_gte: arbitrumgoerli_BigDecimal
  volume_lte: arbitrumgoerli_BigDecimal
  volume_in: [arbitrumgoerli_BigDecimal!]
  volume_not_in: [arbitrumgoerli_BigDecimal!]
  """Filter for the block changed event."""
  _change_block: arbitrumgoerli_BlockChangedFilter
}

enum arbitrumgoerli_SwapTradeVolume_orderBy {
  stableSwap
  timestamp
  volume
}

type arbitrumgoerli_SwapWeeklyVolume implements arbitrumgoerli_SwapTradeVolume {
  id: ID!
  stableSwap: arbitrumgoerli_StableSwap!
  timestamp: BigInt!
  volume: arbitrumgoerli_BigDecimal!
}

input arbitrumgoerli_SwapWeeklyVolume_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: arbitrumgoerli_StableSwap_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  volume: arbitrumgoerli_BigDecimal
  volume_not: arbitrumgoerli_BigDecimal
  volume_gt: arbitrumgoerli_BigDecimal
  volume_lt: arbitrumgoerli_BigDecimal
  volume_gte: arbitrumgoerli_BigDecimal
  volume_lte: arbitrumgoerli_BigDecimal
  volume_in: [arbitrumgoerli_BigDecimal!]
  volume_not_in: [arbitrumgoerli_BigDecimal!]
  """Filter for the block changed event."""
  _change_block: arbitrumgoerli_BlockChangedFilter
}

enum arbitrumgoerli_SwapWeeklyVolume_orderBy {
  id
  stableSwap
  timestamp
  volume
}

type arbitrumgoerli_SystemInfo {
  id: ID!
  exchangeCount: BigInt!
  swapCount: BigInt!
}

input arbitrumgoerli_SystemInfo_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  exchangeCount: BigInt
  exchangeCount_not: BigInt
  exchangeCount_gt: BigInt
  exchangeCount_lt: BigInt
  exchangeCount_gte: BigInt
  exchangeCount_lte: BigInt
  exchangeCount_in: [BigInt!]
  exchangeCount_not_in: [BigInt!]
  swapCount: BigInt
  swapCount_not: BigInt
  swapCount_gt: BigInt
  swapCount_lt: BigInt
  swapCount_gte: BigInt
  swapCount_lte: BigInt
  swapCount_in: [BigInt!]
  swapCount_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: arbitrumgoerli_BlockChangedFilter
}

enum arbitrumgoerli_SystemInfo_orderBy {
  id
  exchangeCount
  swapCount
}

type arbitrumgoerli__Block_ {
  """The hash of the block"""
  hash: arbitrumgoerli_Bytes
  """The block number"""
  number: Int!
  """Integer representation of the timestamp stored in blocks for the chain"""
  timestamp: Int
}

"""The type for the top-level _meta field"""
type arbitrumgoerli__Meta_ {
  """
  Information about a specific subgraph block. The hash of the block
  will be null if the _meta field has a block constraint that asks for
  a block number. It will be filled if the _meta field has no block constraint
  and therefore asks for the latest  block
  
  """
  block: arbitrumgoerli__Block_!
  """The deployment ID"""
  deployment: String!
  """If `true`, the subgraph encountered indexing errors at some past block"""
  hasIndexingErrors: Boolean!
}

scalar optimismgoerli_BigDecimal

input optimismgoerli_BlockChangedFilter {
  number_gte: Int!
}

input optimismgoerli_Block_height {
  hash: optimismgoerli_Bytes
  number: Int
  number_gte: Int
}

scalar optimismgoerli_Bytes

"""Defines the order direction, either ascending or descending"""
enum optimismgoerli_OrderDirection {
  asc
  desc
}

type optimismgoerli_PooledToken {
  id: ID!
  asset: optimismgoerli_Bytes!
}

input optimismgoerli_PooledToken_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  asset: optimismgoerli_Bytes
  asset_not: optimismgoerli_Bytes
  asset_gt: optimismgoerli_Bytes
  asset_lt: optimismgoerli_Bytes
  asset_gte: optimismgoerli_Bytes
  asset_lte: optimismgoerli_Bytes
  asset_in: [optimismgoerli_Bytes!]
  asset_not_in: [optimismgoerli_Bytes!]
  asset_contains: optimismgoerli_Bytes
  asset_not_contains: optimismgoerli_Bytes
  """Filter for the block changed event."""
  _change_block: optimismgoerli_BlockChangedFilter
}

enum optimismgoerli_PooledToken_orderBy {
  id
  asset
}

type optimismgoerli_StableSwap {
  id: ID!
  isActive: Boolean
  key: optimismgoerli_Bytes!
  canonicalId: optimismgoerli_Bytes
  domain: BigInt
  swapPool: optimismgoerli_Bytes
  lpToken: optimismgoerli_Bytes
  initialA: BigInt
  futureA: BigInt
  initialATime: BigInt
  futureATime: BigInt
  swapFee: BigInt
  adminFee: BigInt
  pooledTokens(skip: Int = 0, first: Int = 100, orderBy: optimismgoerli_PooledToken_orderBy, orderDirection: optimismgoerli_OrderDirection, where: optimismgoerli_PooledToken_filter): [optimismgoerli_PooledToken!]!
  tokenPrecisionMultipliers: [BigInt!]!
  balances: [BigInt!]!
  adminFees: [BigInt!]!
  virtualPrice: BigInt!
  invariant: BigInt!
  lpTokenSupply: BigInt!
  events(skip: Int = 0, first: Int = 100, orderBy: optimismgoerli_StableSwapEvent_orderBy, orderDirection: optimismgoerli_OrderDirection, where: optimismgoerli_StableSwapEvent_filter): [optimismgoerli_StableSwapEvent!]
  exchanges(skip: Int = 0, first: Int = 100, orderBy: optimismgoerli_StableSwapExchange_orderBy, orderDirection: optimismgoerli_OrderDirection, where: optimismgoerli_StableSwapExchange_filter): [optimismgoerli_StableSwapExchange!]
  hourlyVolumes(skip: Int = 0, first: Int = 100, orderBy: optimismgoerli_SwapHourlyVolume_orderBy, orderDirection: optimismgoerli_OrderDirection, where: optimismgoerli_SwapHourlyVolume_filter): [optimismgoerli_SwapHourlyVolume!]
  dailyVolumes(skip: Int = 0, first: Int = 100, orderBy: optimismgoerli_SwapDailyVolume_orderBy, orderDirection: optimismgoerli_OrderDirection, where: optimismgoerli_SwapDailyVolume_filter): [optimismgoerli_SwapDailyVolume!]
  weeklyVolumes(skip: Int = 0, first: Int = 100, orderBy: optimismgoerli_SwapWeeklyVolume_orderBy, orderDirection: optimismgoerli_OrderDirection, where: optimismgoerli_SwapWeeklyVolume_filter): [optimismgoerli_SwapWeeklyVolume!]
}

type optimismgoerli_StableSwapAddLiquidityEvent implements optimismgoerli_StableSwapEvent {
  id: ID!
  stableSwap: optimismgoerli_StableSwap!
  provider: optimismgoerli_Bytes!
  tokenAmounts: [BigInt!]!
  fees: [BigInt!]!
  invariant: BigInt
  lpTokenSupply: BigInt!
  block: BigInt!
  timestamp: BigInt!
  transaction: optimismgoerli_Bytes!
}

input optimismgoerli_StableSwapAddLiquidityEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: optimismgoerli_StableSwap_filter
  provider: optimismgoerli_Bytes
  provider_not: optimismgoerli_Bytes
  provider_gt: optimismgoerli_Bytes
  provider_lt: optimismgoerli_Bytes
  provider_gte: optimismgoerli_Bytes
  provider_lte: optimismgoerli_Bytes
  provider_in: [optimismgoerli_Bytes!]
  provider_not_in: [optimismgoerli_Bytes!]
  provider_contains: optimismgoerli_Bytes
  provider_not_contains: optimismgoerli_Bytes
  tokenAmounts: [BigInt!]
  tokenAmounts_not: [BigInt!]
  tokenAmounts_contains: [BigInt!]
  tokenAmounts_contains_nocase: [BigInt!]
  tokenAmounts_not_contains: [BigInt!]
  tokenAmounts_not_contains_nocase: [BigInt!]
  fees: [BigInt!]
  fees_not: [BigInt!]
  fees_contains: [BigInt!]
  fees_contains_nocase: [BigInt!]
  fees_not_contains: [BigInt!]
  fees_not_contains_nocase: [BigInt!]
  invariant: BigInt
  invariant_not: BigInt
  invariant_gt: BigInt
  invariant_lt: BigInt
  invariant_gte: BigInt
  invariant_lte: BigInt
  invariant_in: [BigInt!]
  invariant_not_in: [BigInt!]
  lpTokenSupply: BigInt
  lpTokenSupply_not: BigInt
  lpTokenSupply_gt: BigInt
  lpTokenSupply_lt: BigInt
  lpTokenSupply_gte: BigInt
  lpTokenSupply_lte: BigInt
  lpTokenSupply_in: [BigInt!]
  lpTokenSupply_not_in: [BigInt!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: optimismgoerli_Bytes
  transaction_not: optimismgoerli_Bytes
  transaction_gt: optimismgoerli_Bytes
  transaction_lt: optimismgoerli_Bytes
  transaction_gte: optimismgoerli_Bytes
  transaction_lte: optimismgoerli_Bytes
  transaction_in: [optimismgoerli_Bytes!]
  transaction_not_in: [optimismgoerli_Bytes!]
  transaction_contains: optimismgoerli_Bytes
  transaction_not_contains: optimismgoerli_Bytes
  """Filter for the block changed event."""
  _change_block: optimismgoerli_BlockChangedFilter
}

enum optimismgoerli_StableSwapAddLiquidityEvent_orderBy {
  id
  stableSwap
  provider
  tokenAmounts
  fees
  invariant
  lpTokenSupply
  block
  timestamp
  transaction
}

interface optimismgoerli_StableSwapEvent {
  id: ID!
  stableSwap: optimismgoerli_StableSwap!
  block: BigInt!
  timestamp: BigInt!
  transaction: optimismgoerli_Bytes!
}

input optimismgoerli_StableSwapEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: optimismgoerli_StableSwap_filter
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: optimismgoerli_Bytes
  transaction_not: optimismgoerli_Bytes
  transaction_gt: optimismgoerli_Bytes
  transaction_lt: optimismgoerli_Bytes
  transaction_gte: optimismgoerli_Bytes
  transaction_lte: optimismgoerli_Bytes
  transaction_in: [optimismgoerli_Bytes!]
  transaction_not_in: [optimismgoerli_Bytes!]
  transaction_contains: optimismgoerli_Bytes
  transaction_not_contains: optimismgoerli_Bytes
  """Filter for the block changed event."""
  _change_block: optimismgoerli_BlockChangedFilter
}

enum optimismgoerli_StableSwapEvent_orderBy {
  id
  stableSwap
  block
  timestamp
  transaction
}

type optimismgoerli_StableSwapExchange {
  id: ID!
  stableSwap: optimismgoerli_StableSwap!
  buyer: optimismgoerli_Bytes!
  boughtId: BigInt!
  tokensBought: BigInt!
  soldId: BigInt!
  tokensSold: BigInt!
  block: BigInt!
  timestamp: BigInt!
  transaction: optimismgoerli_Bytes!
}

input optimismgoerli_StableSwapExchange_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: optimismgoerli_StableSwap_filter
  buyer: optimismgoerli_Bytes
  buyer_not: optimismgoerli_Bytes
  buyer_gt: optimismgoerli_Bytes
  buyer_lt: optimismgoerli_Bytes
  buyer_gte: optimismgoerli_Bytes
  buyer_lte: optimismgoerli_Bytes
  buyer_in: [optimismgoerli_Bytes!]
  buyer_not_in: [optimismgoerli_Bytes!]
  buyer_contains: optimismgoerli_Bytes
  buyer_not_contains: optimismgoerli_Bytes
  boughtId: BigInt
  boughtId_not: BigInt
  boughtId_gt: BigInt
  boughtId_lt: BigInt
  boughtId_gte: BigInt
  boughtId_lte: BigInt
  boughtId_in: [BigInt!]
  boughtId_not_in: [BigInt!]
  tokensBought: BigInt
  tokensBought_not: BigInt
  tokensBought_gt: BigInt
  tokensBought_lt: BigInt
  tokensBought_gte: BigInt
  tokensBought_lte: BigInt
  tokensBought_in: [BigInt!]
  tokensBought_not_in: [BigInt!]
  soldId: BigInt
  soldId_not: BigInt
  soldId_gt: BigInt
  soldId_lt: BigInt
  soldId_gte: BigInt
  soldId_lte: BigInt
  soldId_in: [BigInt!]
  soldId_not_in: [BigInt!]
  tokensSold: BigInt
  tokensSold_not: BigInt
  tokensSold_gt: BigInt
  tokensSold_lt: BigInt
  tokensSold_gte: BigInt
  tokensSold_lte: BigInt
  tokensSold_in: [BigInt!]
  tokensSold_not_in: [BigInt!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: optimismgoerli_Bytes
  transaction_not: optimismgoerli_Bytes
  transaction_gt: optimismgoerli_Bytes
  transaction_lt: optimismgoerli_Bytes
  transaction_gte: optimismgoerli_Bytes
  transaction_lte: optimismgoerli_Bytes
  transaction_in: [optimismgoerli_Bytes!]
  transaction_not_in: [optimismgoerli_Bytes!]
  transaction_contains: optimismgoerli_Bytes
  transaction_not_contains: optimismgoerli_Bytes
  """Filter for the block changed event."""
  _change_block: optimismgoerli_BlockChangedFilter
}

enum optimismgoerli_StableSwapExchange_orderBy {
  id
  stableSwap
  buyer
  boughtId
  tokensBought
  soldId
  tokensSold
  block
  timestamp
  transaction
}

type optimismgoerli_StableSwapRemoveLiquidityEvent implements optimismgoerli_StableSwapEvent {
  id: ID!
  stableSwap: optimismgoerli_StableSwap!
  provider: optimismgoerli_Bytes!
  tokenAmounts: [BigInt!]!
  fees: [BigInt!]
  invariant: BigInt
  lpTokenSupply: BigInt!
  block: BigInt!
  timestamp: BigInt!
  transaction: optimismgoerli_Bytes!
}

input optimismgoerli_StableSwapRemoveLiquidityEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: optimismgoerli_StableSwap_filter
  provider: optimismgoerli_Bytes
  provider_not: optimismgoerli_Bytes
  provider_gt: optimismgoerli_Bytes
  provider_lt: optimismgoerli_Bytes
  provider_gte: optimismgoerli_Bytes
  provider_lte: optimismgoerli_Bytes
  provider_in: [optimismgoerli_Bytes!]
  provider_not_in: [optimismgoerli_Bytes!]
  provider_contains: optimismgoerli_Bytes
  provider_not_contains: optimismgoerli_Bytes
  tokenAmounts: [BigInt!]
  tokenAmounts_not: [BigInt!]
  tokenAmounts_contains: [BigInt!]
  tokenAmounts_contains_nocase: [BigInt!]
  tokenAmounts_not_contains: [BigInt!]
  tokenAmounts_not_contains_nocase: [BigInt!]
  fees: [BigInt!]
  fees_not: [BigInt!]
  fees_contains: [BigInt!]
  fees_contains_nocase: [BigInt!]
  fees_not_contains: [BigInt!]
  fees_not_contains_nocase: [BigInt!]
  invariant: BigInt
  invariant_not: BigInt
  invariant_gt: BigInt
  invariant_lt: BigInt
  invariant_gte: BigInt
  invariant_lte: BigInt
  invariant_in: [BigInt!]
  invariant_not_in: [BigInt!]
  lpTokenSupply: BigInt
  lpTokenSupply_not: BigInt
  lpTokenSupply_gt: BigInt
  lpTokenSupply_lt: BigInt
  lpTokenSupply_gte: BigInt
  lpTokenSupply_lte: BigInt
  lpTokenSupply_in: [BigInt!]
  lpTokenSupply_not_in: [BigInt!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: optimismgoerli_Bytes
  transaction_not: optimismgoerli_Bytes
  transaction_gt: optimismgoerli_Bytes
  transaction_lt: optimismgoerli_Bytes
  transaction_gte: optimismgoerli_Bytes
  transaction_lte: optimismgoerli_Bytes
  transaction_in: [optimismgoerli_Bytes!]
  transaction_not_in: [optimismgoerli_Bytes!]
  transaction_contains: optimismgoerli_Bytes
  transaction_not_contains: optimismgoerli_Bytes
  """Filter for the block changed event."""
  _change_block: optimismgoerli_BlockChangedFilter
}

enum optimismgoerli_StableSwapRemoveLiquidityEvent_orderBy {
  id
  stableSwap
  provider
  tokenAmounts
  fees
  invariant
  lpTokenSupply
  block
  timestamp
  transaction
}

input optimismgoerli_StableSwap_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  isActive: Boolean
  isActive_not: Boolean
  isActive_in: [Boolean!]
  isActive_not_in: [Boolean!]
  key: optimismgoerli_Bytes
  key_not: optimismgoerli_Bytes
  key_gt: optimismgoerli_Bytes
  key_lt: optimismgoerli_Bytes
  key_gte: optimismgoerli_Bytes
  key_lte: optimismgoerli_Bytes
  key_in: [optimismgoerli_Bytes!]
  key_not_in: [optimismgoerli_Bytes!]
  key_contains: optimismgoerli_Bytes
  key_not_contains: optimismgoerli_Bytes
  canonicalId: optimismgoerli_Bytes
  canonicalId_not: optimismgoerli_Bytes
  canonicalId_gt: optimismgoerli_Bytes
  canonicalId_lt: optimismgoerli_Bytes
  canonicalId_gte: optimismgoerli_Bytes
  canonicalId_lte: optimismgoerli_Bytes
  canonicalId_in: [optimismgoerli_Bytes!]
  canonicalId_not_in: [optimismgoerli_Bytes!]
  canonicalId_contains: optimismgoerli_Bytes
  canonicalId_not_contains: optimismgoerli_Bytes
  domain: BigInt
  domain_not: BigInt
  domain_gt: BigInt
  domain_lt: BigInt
  domain_gte: BigInt
  domain_lte: BigInt
  domain_in: [BigInt!]
  domain_not_in: [BigInt!]
  swapPool: optimismgoerli_Bytes
  swapPool_not: optimismgoerli_Bytes
  swapPool_gt: optimismgoerli_Bytes
  swapPool_lt: optimismgoerli_Bytes
  swapPool_gte: optimismgoerli_Bytes
  swapPool_lte: optimismgoerli_Bytes
  swapPool_in: [optimismgoerli_Bytes!]
  swapPool_not_in: [optimismgoerli_Bytes!]
  swapPool_contains: optimismgoerli_Bytes
  swapPool_not_contains: optimismgoerli_Bytes
  lpToken: optimismgoerli_Bytes
  lpToken_not: optimismgoerli_Bytes
  lpToken_gt: optimismgoerli_Bytes
  lpToken_lt: optimismgoerli_Bytes
  lpToken_gte: optimismgoerli_Bytes
  lpToken_lte: optimismgoerli_Bytes
  lpToken_in: [optimismgoerli_Bytes!]
  lpToken_not_in: [optimismgoerli_Bytes!]
  lpToken_contains: optimismgoerli_Bytes
  lpToken_not_contains: optimismgoerli_Bytes
  initialA: BigInt
  initialA_not: BigInt
  initialA_gt: BigInt
  initialA_lt: BigInt
  initialA_gte: BigInt
  initialA_lte: BigInt
  initialA_in: [BigInt!]
  initialA_not_in: [BigInt!]
  futureA: BigInt
  futureA_not: BigInt
  futureA_gt: BigInt
  futureA_lt: BigInt
  futureA_gte: BigInt
  futureA_lte: BigInt
  futureA_in: [BigInt!]
  futureA_not_in: [BigInt!]
  initialATime: BigInt
  initialATime_not: BigInt
  initialATime_gt: BigInt
  initialATime_lt: BigInt
  initialATime_gte: BigInt
  initialATime_lte: BigInt
  initialATime_in: [BigInt!]
  initialATime_not_in: [BigInt!]
  futureATime: BigInt
  futureATime_not: BigInt
  futureATime_gt: BigInt
  futureATime_lt: BigInt
  futureATime_gte: BigInt
  futureATime_lte: BigInt
  futureATime_in: [BigInt!]
  futureATime_not_in: [BigInt!]
  swapFee: BigInt
  swapFee_not: BigInt
  swapFee_gt: BigInt
  swapFee_lt: BigInt
  swapFee_gte: BigInt
  swapFee_lte: BigInt
  swapFee_in: [BigInt!]
  swapFee_not_in: [BigInt!]
  adminFee: BigInt
  adminFee_not: BigInt
  adminFee_gt: BigInt
  adminFee_lt: BigInt
  adminFee_gte: BigInt
  adminFee_lte: BigInt
  adminFee_in: [BigInt!]
  adminFee_not_in: [BigInt!]
  pooledTokens: [String!]
  pooledTokens_not: [String!]
  pooledTokens_contains: [String!]
  pooledTokens_contains_nocase: [String!]
  pooledTokens_not_contains: [String!]
  pooledTokens_not_contains_nocase: [String!]
  pooledTokens_: optimismgoerli_PooledToken_filter
  tokenPrecisionMultipliers: [BigInt!]
  tokenPrecisionMultipliers_not: [BigInt!]
  tokenPrecisionMultipliers_contains: [BigInt!]
  tokenPrecisionMultipliers_contains_nocase: [BigInt!]
  tokenPrecisionMultipliers_not_contains: [BigInt!]
  tokenPrecisionMultipliers_not_contains_nocase: [BigInt!]
  balances: [BigInt!]
  balances_not: [BigInt!]
  balances_contains: [BigInt!]
  balances_contains_nocase: [BigInt!]
  balances_not_contains: [BigInt!]
  balances_not_contains_nocase: [BigInt!]
  adminFees: [BigInt!]
  adminFees_not: [BigInt!]
  adminFees_contains: [BigInt!]
  adminFees_contains_nocase: [BigInt!]
  adminFees_not_contains: [BigInt!]
  adminFees_not_contains_nocase: [BigInt!]
  virtualPrice: BigInt
  virtualPrice_not: BigInt
  virtualPrice_gt: BigInt
  virtualPrice_lt: BigInt
  virtualPrice_gte: BigInt
  virtualPrice_lte: BigInt
  virtualPrice_in: [BigInt!]
  virtualPrice_not_in: [BigInt!]
  invariant: BigInt
  invariant_not: BigInt
  invariant_gt: BigInt
  invariant_lt: BigInt
  invariant_gte: BigInt
  invariant_lte: BigInt
  invariant_in: [BigInt!]
  invariant_not_in: [BigInt!]
  lpTokenSupply: BigInt
  lpTokenSupply_not: BigInt
  lpTokenSupply_gt: BigInt
  lpTokenSupply_lt: BigInt
  lpTokenSupply_gte: BigInt
  lpTokenSupply_lte: BigInt
  lpTokenSupply_in: [BigInt!]
  lpTokenSupply_not_in: [BigInt!]
  events_: optimismgoerli_StableSwapEvent_filter
  exchanges_: optimismgoerli_StableSwapExchange_filter
  hourlyVolumes_: optimismgoerli_SwapHourlyVolume_filter
  dailyVolumes_: optimismgoerli_SwapDailyVolume_filter
  weeklyVolumes_: optimismgoerli_SwapWeeklyVolume_filter
  """Filter for the block changed event."""
  _change_block: optimismgoerli_BlockChangedFilter
}

enum optimismgoerli_StableSwap_orderBy {
  id
  isActive
  key
  canonicalId
  domain
  swapPool
  lpToken
  initialA
  futureA
  initialATime
  futureATime
  swapFee
  adminFee
  pooledTokens
  tokenPrecisionMultipliers
  balances
  adminFees
  virtualPrice
  invariant
  lpTokenSupply
  events
  exchanges
  hourlyVolumes
  dailyVolumes
  weeklyVolumes
}

type optimismgoerli_SwapDailyVolume implements optimismgoerli_SwapTradeVolume {
  id: ID!
  stableSwap: optimismgoerli_StableSwap!
  timestamp: BigInt!
  volume: optimismgoerli_BigDecimal!
}

input optimismgoerli_SwapDailyVolume_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: optimismgoerli_StableSwap_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  volume: optimismgoerli_BigDecimal
  volume_not: optimismgoerli_BigDecimal
  volume_gt: optimismgoerli_BigDecimal
  volume_lt: optimismgoerli_BigDecimal
  volume_gte: optimismgoerli_BigDecimal
  volume_lte: optimismgoerli_BigDecimal
  volume_in: [optimismgoerli_BigDecimal!]
  volume_not_in: [optimismgoerli_BigDecimal!]
  """Filter for the block changed event."""
  _change_block: optimismgoerli_BlockChangedFilter
}

enum optimismgoerli_SwapDailyVolume_orderBy {
  id
  stableSwap
  timestamp
  volume
}

type optimismgoerli_SwapHourlyVolume implements optimismgoerli_SwapTradeVolume {
  id: ID!
  stableSwap: optimismgoerli_StableSwap!
  timestamp: BigInt!
  volume: optimismgoerli_BigDecimal!
}

input optimismgoerli_SwapHourlyVolume_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: optimismgoerli_StableSwap_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  volume: optimismgoerli_BigDecimal
  volume_not: optimismgoerli_BigDecimal
  volume_gt: optimismgoerli_BigDecimal
  volume_lt: optimismgoerli_BigDecimal
  volume_gte: optimismgoerli_BigDecimal
  volume_lte: optimismgoerli_BigDecimal
  volume_in: [optimismgoerli_BigDecimal!]
  volume_not_in: [optimismgoerli_BigDecimal!]
  """Filter for the block changed event."""
  _change_block: optimismgoerli_BlockChangedFilter
}

enum optimismgoerli_SwapHourlyVolume_orderBy {
  id
  stableSwap
  timestamp
  volume
}

interface optimismgoerli_SwapTradeVolume {
  stableSwap: optimismgoerli_StableSwap!
  timestamp: BigInt!
  volume: optimismgoerli_BigDecimal!
}

input optimismgoerli_SwapTradeVolume_filter {
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: optimismgoerli_StableSwap_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  volume: optimismgoerli_BigDecimal
  volume_not: optimismgoerli_BigDecimal
  volume_gt: optimismgoerli_BigDecimal
  volume_lt: optimismgoerli_BigDecimal
  volume_gte: optimismgoerli_BigDecimal
  volume_lte: optimismgoerli_BigDecimal
  volume_in: [optimismgoerli_BigDecimal!]
  volume_not_in: [optimismgoerli_BigDecimal!]
  """Filter for the block changed event."""
  _change_block: optimismgoerli_BlockChangedFilter
}

enum optimismgoerli_SwapTradeVolume_orderBy {
  stableSwap
  timestamp
  volume
}

type optimismgoerli_SwapWeeklyVolume implements optimismgoerli_SwapTradeVolume {
  id: ID!
  stableSwap: optimismgoerli_StableSwap!
  timestamp: BigInt!
  volume: optimismgoerli_BigDecimal!
}

input optimismgoerli_SwapWeeklyVolume_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: optimismgoerli_StableSwap_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  volume: optimismgoerli_BigDecimal
  volume_not: optimismgoerli_BigDecimal
  volume_gt: optimismgoerli_BigDecimal
  volume_lt: optimismgoerli_BigDecimal
  volume_gte: optimismgoerli_BigDecimal
  volume_lte: optimismgoerli_BigDecimal
  volume_in: [optimismgoerli_BigDecimal!]
  volume_not_in: [optimismgoerli_BigDecimal!]
  """Filter for the block changed event."""
  _change_block: optimismgoerli_BlockChangedFilter
}

enum optimismgoerli_SwapWeeklyVolume_orderBy {
  id
  stableSwap
  timestamp
  volume
}

type optimismgoerli_SystemInfo {
  id: ID!
  exchangeCount: BigInt!
  swapCount: BigInt!
}

input optimismgoerli_SystemInfo_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  exchangeCount: BigInt
  exchangeCount_not: BigInt
  exchangeCount_gt: BigInt
  exchangeCount_lt: BigInt
  exchangeCount_gte: BigInt
  exchangeCount_lte: BigInt
  exchangeCount_in: [BigInt!]
  exchangeCount_not_in: [BigInt!]
  swapCount: BigInt
  swapCount_not: BigInt
  swapCount_gt: BigInt
  swapCount_lt: BigInt
  swapCount_gte: BigInt
  swapCount_lte: BigInt
  swapCount_in: [BigInt!]
  swapCount_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: optimismgoerli_BlockChangedFilter
}

enum optimismgoerli_SystemInfo_orderBy {
  id
  exchangeCount
  swapCount
}

type optimismgoerli__Block_ {
  """The hash of the block"""
  hash: optimismgoerli_Bytes
  """The block number"""
  number: Int!
  """Integer representation of the timestamp stored in blocks for the chain"""
  timestamp: Int
}

"""The type for the top-level _meta field"""
type optimismgoerli__Meta_ {
  """
  Information about a specific subgraph block. The hash of the block
  will be null if the _meta field has a block constraint that asks for
  a block number. It will be filled if the _meta field has no block constraint
  and therefore asks for the latest  block
  
  """
  block: optimismgoerli__Block_!
  """The deployment ID"""
  deployment: String!
  """If `true`, the subgraph encountered indexing errors at some past block"""
  hasIndexingErrors: Boolean!
}

scalar stagingmumbai_BigDecimal

input stagingmumbai_BlockChangedFilter {
  number_gte: Int!
}

input stagingmumbai_Block_height {
  hash: stagingmumbai_Bytes
  number: Int
  number_gte: Int
}

scalar stagingmumbai_Bytes

"""Defines the order direction, either ascending or descending"""
enum stagingmumbai_OrderDirection {
  asc
  desc
}

type stagingmumbai_PooledToken {
  id: ID!
  asset: stagingmumbai_Bytes!
}

input stagingmumbai_PooledToken_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  asset: stagingmumbai_Bytes
  asset_not: stagingmumbai_Bytes
  asset_gt: stagingmumbai_Bytes
  asset_lt: stagingmumbai_Bytes
  asset_gte: stagingmumbai_Bytes
  asset_lte: stagingmumbai_Bytes
  asset_in: [stagingmumbai_Bytes!]
  asset_not_in: [stagingmumbai_Bytes!]
  asset_contains: stagingmumbai_Bytes
  asset_not_contains: stagingmumbai_Bytes
  """Filter for the block changed event."""
  _change_block: stagingmumbai_BlockChangedFilter
}

enum stagingmumbai_PooledToken_orderBy {
  id
  asset
}

type stagingmumbai_StableSwap {
  id: ID!
  isActive: Boolean
  key: stagingmumbai_Bytes!
  canonicalId: stagingmumbai_Bytes
  domain: BigInt
  swapPool: stagingmumbai_Bytes
  lpToken: stagingmumbai_Bytes
  initialA: BigInt
  futureA: BigInt
  initialATime: BigInt
  futureATime: BigInt
  swapFee: BigInt
  adminFee: BigInt
  pooledTokens(skip: Int = 0, first: Int = 100, orderBy: stagingmumbai_PooledToken_orderBy, orderDirection: stagingmumbai_OrderDirection, where: stagingmumbai_PooledToken_filter): [stagingmumbai_PooledToken!]!
  tokenPrecisionMultipliers: [BigInt!]!
  balances: [BigInt!]!
  adminFees: [BigInt!]!
  virtualPrice: BigInt!
  invariant: BigInt!
  lpTokenSupply: BigInt!
  events(skip: Int = 0, first: Int = 100, orderBy: stagingmumbai_StableSwapEvent_orderBy, orderDirection: stagingmumbai_OrderDirection, where: stagingmumbai_StableSwapEvent_filter): [stagingmumbai_StableSwapEvent!]
  exchanges(skip: Int = 0, first: Int = 100, orderBy: stagingmumbai_StableSwapExchange_orderBy, orderDirection: stagingmumbai_OrderDirection, where: stagingmumbai_StableSwapExchange_filter): [stagingmumbai_StableSwapExchange!]
  hourlyVolumes(skip: Int = 0, first: Int = 100, orderBy: stagingmumbai_SwapHourlyVolume_orderBy, orderDirection: stagingmumbai_OrderDirection, where: stagingmumbai_SwapHourlyVolume_filter): [stagingmumbai_SwapHourlyVolume!]
  dailyVolumes(skip: Int = 0, first: Int = 100, orderBy: stagingmumbai_SwapDailyVolume_orderBy, orderDirection: stagingmumbai_OrderDirection, where: stagingmumbai_SwapDailyVolume_filter): [stagingmumbai_SwapDailyVolume!]
  weeklyVolumes(skip: Int = 0, first: Int = 100, orderBy: stagingmumbai_SwapWeeklyVolume_orderBy, orderDirection: stagingmumbai_OrderDirection, where: stagingmumbai_SwapWeeklyVolume_filter): [stagingmumbai_SwapWeeklyVolume!]
}

type stagingmumbai_StableSwapAddLiquidityEvent implements stagingmumbai_StableSwapEvent {
  id: ID!
  stableSwap: stagingmumbai_StableSwap!
  provider: stagingmumbai_Bytes!
  tokenAmounts: [BigInt!]!
  fees: [BigInt!]!
  invariant: BigInt
  lpTokenSupply: BigInt!
  block: BigInt!
  timestamp: BigInt!
  transaction: stagingmumbai_Bytes!
}

input stagingmumbai_StableSwapAddLiquidityEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: stagingmumbai_StableSwap_filter
  provider: stagingmumbai_Bytes
  provider_not: stagingmumbai_Bytes
  provider_gt: stagingmumbai_Bytes
  provider_lt: stagingmumbai_Bytes
  provider_gte: stagingmumbai_Bytes
  provider_lte: stagingmumbai_Bytes
  provider_in: [stagingmumbai_Bytes!]
  provider_not_in: [stagingmumbai_Bytes!]
  provider_contains: stagingmumbai_Bytes
  provider_not_contains: stagingmumbai_Bytes
  tokenAmounts: [BigInt!]
  tokenAmounts_not: [BigInt!]
  tokenAmounts_contains: [BigInt!]
  tokenAmounts_contains_nocase: [BigInt!]
  tokenAmounts_not_contains: [BigInt!]
  tokenAmounts_not_contains_nocase: [BigInt!]
  fees: [BigInt!]
  fees_not: [BigInt!]
  fees_contains: [BigInt!]
  fees_contains_nocase: [BigInt!]
  fees_not_contains: [BigInt!]
  fees_not_contains_nocase: [BigInt!]
  invariant: BigInt
  invariant_not: BigInt
  invariant_gt: BigInt
  invariant_lt: BigInt
  invariant_gte: BigInt
  invariant_lte: BigInt
  invariant_in: [BigInt!]
  invariant_not_in: [BigInt!]
  lpTokenSupply: BigInt
  lpTokenSupply_not: BigInt
  lpTokenSupply_gt: BigInt
  lpTokenSupply_lt: BigInt
  lpTokenSupply_gte: BigInt
  lpTokenSupply_lte: BigInt
  lpTokenSupply_in: [BigInt!]
  lpTokenSupply_not_in: [BigInt!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: stagingmumbai_Bytes
  transaction_not: stagingmumbai_Bytes
  transaction_gt: stagingmumbai_Bytes
  transaction_lt: stagingmumbai_Bytes
  transaction_gte: stagingmumbai_Bytes
  transaction_lte: stagingmumbai_Bytes
  transaction_in: [stagingmumbai_Bytes!]
  transaction_not_in: [stagingmumbai_Bytes!]
  transaction_contains: stagingmumbai_Bytes
  transaction_not_contains: stagingmumbai_Bytes
  """Filter for the block changed event."""
  _change_block: stagingmumbai_BlockChangedFilter
}

enum stagingmumbai_StableSwapAddLiquidityEvent_orderBy {
  id
  stableSwap
  provider
  tokenAmounts
  fees
  invariant
  lpTokenSupply
  block
  timestamp
  transaction
}

interface stagingmumbai_StableSwapEvent {
  id: ID!
  stableSwap: stagingmumbai_StableSwap!
  block: BigInt!
  timestamp: BigInt!
  transaction: stagingmumbai_Bytes!
}

input stagingmumbai_StableSwapEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: stagingmumbai_StableSwap_filter
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: stagingmumbai_Bytes
  transaction_not: stagingmumbai_Bytes
  transaction_gt: stagingmumbai_Bytes
  transaction_lt: stagingmumbai_Bytes
  transaction_gte: stagingmumbai_Bytes
  transaction_lte: stagingmumbai_Bytes
  transaction_in: [stagingmumbai_Bytes!]
  transaction_not_in: [stagingmumbai_Bytes!]
  transaction_contains: stagingmumbai_Bytes
  transaction_not_contains: stagingmumbai_Bytes
  """Filter for the block changed event."""
  _change_block: stagingmumbai_BlockChangedFilter
}

enum stagingmumbai_StableSwapEvent_orderBy {
  id
  stableSwap
  block
  timestamp
  transaction
}

type stagingmumbai_StableSwapExchange {
  id: ID!
  stableSwap: stagingmumbai_StableSwap!
  buyer: stagingmumbai_Bytes!
  boughtId: BigInt!
  tokensBought: BigInt!
  soldId: BigInt!
  tokensSold: BigInt!
  block: BigInt!
  timestamp: BigInt!
  transaction: stagingmumbai_Bytes!
}

input stagingmumbai_StableSwapExchange_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: stagingmumbai_StableSwap_filter
  buyer: stagingmumbai_Bytes
  buyer_not: stagingmumbai_Bytes
  buyer_gt: stagingmumbai_Bytes
  buyer_lt: stagingmumbai_Bytes
  buyer_gte: stagingmumbai_Bytes
  buyer_lte: stagingmumbai_Bytes
  buyer_in: [stagingmumbai_Bytes!]
  buyer_not_in: [stagingmumbai_Bytes!]
  buyer_contains: stagingmumbai_Bytes
  buyer_not_contains: stagingmumbai_Bytes
  boughtId: BigInt
  boughtId_not: BigInt
  boughtId_gt: BigInt
  boughtId_lt: BigInt
  boughtId_gte: BigInt
  boughtId_lte: BigInt
  boughtId_in: [BigInt!]
  boughtId_not_in: [BigInt!]
  tokensBought: BigInt
  tokensBought_not: BigInt
  tokensBought_gt: BigInt
  tokensBought_lt: BigInt
  tokensBought_gte: BigInt
  tokensBought_lte: BigInt
  tokensBought_in: [BigInt!]
  tokensBought_not_in: [BigInt!]
  soldId: BigInt
  soldId_not: BigInt
  soldId_gt: BigInt
  soldId_lt: BigInt
  soldId_gte: BigInt
  soldId_lte: BigInt
  soldId_in: [BigInt!]
  soldId_not_in: [BigInt!]
  tokensSold: BigInt
  tokensSold_not: BigInt
  tokensSold_gt: BigInt
  tokensSold_lt: BigInt
  tokensSold_gte: BigInt
  tokensSold_lte: BigInt
  tokensSold_in: [BigInt!]
  tokensSold_not_in: [BigInt!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: stagingmumbai_Bytes
  transaction_not: stagingmumbai_Bytes
  transaction_gt: stagingmumbai_Bytes
  transaction_lt: stagingmumbai_Bytes
  transaction_gte: stagingmumbai_Bytes
  transaction_lte: stagingmumbai_Bytes
  transaction_in: [stagingmumbai_Bytes!]
  transaction_not_in: [stagingmumbai_Bytes!]
  transaction_contains: stagingmumbai_Bytes
  transaction_not_contains: stagingmumbai_Bytes
  """Filter for the block changed event."""
  _change_block: stagingmumbai_BlockChangedFilter
}

enum stagingmumbai_StableSwapExchange_orderBy {
  id
  stableSwap
  buyer
  boughtId
  tokensBought
  soldId
  tokensSold
  block
  timestamp
  transaction
}

type stagingmumbai_StableSwapRemoveLiquidityEvent implements stagingmumbai_StableSwapEvent {
  id: ID!
  stableSwap: stagingmumbai_StableSwap!
  provider: stagingmumbai_Bytes!
  tokenAmounts: [BigInt!]!
  fees: [BigInt!]
  invariant: BigInt
  lpTokenSupply: BigInt!
  block: BigInt!
  timestamp: BigInt!
  transaction: stagingmumbai_Bytes!
}

input stagingmumbai_StableSwapRemoveLiquidityEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: stagingmumbai_StableSwap_filter
  provider: stagingmumbai_Bytes
  provider_not: stagingmumbai_Bytes
  provider_gt: stagingmumbai_Bytes
  provider_lt: stagingmumbai_Bytes
  provider_gte: stagingmumbai_Bytes
  provider_lte: stagingmumbai_Bytes
  provider_in: [stagingmumbai_Bytes!]
  provider_not_in: [stagingmumbai_Bytes!]
  provider_contains: stagingmumbai_Bytes
  provider_not_contains: stagingmumbai_Bytes
  tokenAmounts: [BigInt!]
  tokenAmounts_not: [BigInt!]
  tokenAmounts_contains: [BigInt!]
  tokenAmounts_contains_nocase: [BigInt!]
  tokenAmounts_not_contains: [BigInt!]
  tokenAmounts_not_contains_nocase: [BigInt!]
  fees: [BigInt!]
  fees_not: [BigInt!]
  fees_contains: [BigInt!]
  fees_contains_nocase: [BigInt!]
  fees_not_contains: [BigInt!]
  fees_not_contains_nocase: [BigInt!]
  invariant: BigInt
  invariant_not: BigInt
  invariant_gt: BigInt
  invariant_lt: BigInt
  invariant_gte: BigInt
  invariant_lte: BigInt
  invariant_in: [BigInt!]
  invariant_not_in: [BigInt!]
  lpTokenSupply: BigInt
  lpTokenSupply_not: BigInt
  lpTokenSupply_gt: BigInt
  lpTokenSupply_lt: BigInt
  lpTokenSupply_gte: BigInt
  lpTokenSupply_lte: BigInt
  lpTokenSupply_in: [BigInt!]
  lpTokenSupply_not_in: [BigInt!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: stagingmumbai_Bytes
  transaction_not: stagingmumbai_Bytes
  transaction_gt: stagingmumbai_Bytes
  transaction_lt: stagingmumbai_Bytes
  transaction_gte: stagingmumbai_Bytes
  transaction_lte: stagingmumbai_Bytes
  transaction_in: [stagingmumbai_Bytes!]
  transaction_not_in: [stagingmumbai_Bytes!]
  transaction_contains: stagingmumbai_Bytes
  transaction_not_contains: stagingmumbai_Bytes
  """Filter for the block changed event."""
  _change_block: stagingmumbai_BlockChangedFilter
}

enum stagingmumbai_StableSwapRemoveLiquidityEvent_orderBy {
  id
  stableSwap
  provider
  tokenAmounts
  fees
  invariant
  lpTokenSupply
  block
  timestamp
  transaction
}

input stagingmumbai_StableSwap_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  isActive: Boolean
  isActive_not: Boolean
  isActive_in: [Boolean!]
  isActive_not_in: [Boolean!]
  key: stagingmumbai_Bytes
  key_not: stagingmumbai_Bytes
  key_gt: stagingmumbai_Bytes
  key_lt: stagingmumbai_Bytes
  key_gte: stagingmumbai_Bytes
  key_lte: stagingmumbai_Bytes
  key_in: [stagingmumbai_Bytes!]
  key_not_in: [stagingmumbai_Bytes!]
  key_contains: stagingmumbai_Bytes
  key_not_contains: stagingmumbai_Bytes
  canonicalId: stagingmumbai_Bytes
  canonicalId_not: stagingmumbai_Bytes
  canonicalId_gt: stagingmumbai_Bytes
  canonicalId_lt: stagingmumbai_Bytes
  canonicalId_gte: stagingmumbai_Bytes
  canonicalId_lte: stagingmumbai_Bytes
  canonicalId_in: [stagingmumbai_Bytes!]
  canonicalId_not_in: [stagingmumbai_Bytes!]
  canonicalId_contains: stagingmumbai_Bytes
  canonicalId_not_contains: stagingmumbai_Bytes
  domain: BigInt
  domain_not: BigInt
  domain_gt: BigInt
  domain_lt: BigInt
  domain_gte: BigInt
  domain_lte: BigInt
  domain_in: [BigInt!]
  domain_not_in: [BigInt!]
  swapPool: stagingmumbai_Bytes
  swapPool_not: stagingmumbai_Bytes
  swapPool_gt: stagingmumbai_Bytes
  swapPool_lt: stagingmumbai_Bytes
  swapPool_gte: stagingmumbai_Bytes
  swapPool_lte: stagingmumbai_Bytes
  swapPool_in: [stagingmumbai_Bytes!]
  swapPool_not_in: [stagingmumbai_Bytes!]
  swapPool_contains: stagingmumbai_Bytes
  swapPool_not_contains: stagingmumbai_Bytes
  lpToken: stagingmumbai_Bytes
  lpToken_not: stagingmumbai_Bytes
  lpToken_gt: stagingmumbai_Bytes
  lpToken_lt: stagingmumbai_Bytes
  lpToken_gte: stagingmumbai_Bytes
  lpToken_lte: stagingmumbai_Bytes
  lpToken_in: [stagingmumbai_Bytes!]
  lpToken_not_in: [stagingmumbai_Bytes!]
  lpToken_contains: stagingmumbai_Bytes
  lpToken_not_contains: stagingmumbai_Bytes
  initialA: BigInt
  initialA_not: BigInt
  initialA_gt: BigInt
  initialA_lt: BigInt
  initialA_gte: BigInt
  initialA_lte: BigInt
  initialA_in: [BigInt!]
  initialA_not_in: [BigInt!]
  futureA: BigInt
  futureA_not: BigInt
  futureA_gt: BigInt
  futureA_lt: BigInt
  futureA_gte: BigInt
  futureA_lte: BigInt
  futureA_in: [BigInt!]
  futureA_not_in: [BigInt!]
  initialATime: BigInt
  initialATime_not: BigInt
  initialATime_gt: BigInt
  initialATime_lt: BigInt
  initialATime_gte: BigInt
  initialATime_lte: BigInt
  initialATime_in: [BigInt!]
  initialATime_not_in: [BigInt!]
  futureATime: BigInt
  futureATime_not: BigInt
  futureATime_gt: BigInt
  futureATime_lt: BigInt
  futureATime_gte: BigInt
  futureATime_lte: BigInt
  futureATime_in: [BigInt!]
  futureATime_not_in: [BigInt!]
  swapFee: BigInt
  swapFee_not: BigInt
  swapFee_gt: BigInt
  swapFee_lt: BigInt
  swapFee_gte: BigInt
  swapFee_lte: BigInt
  swapFee_in: [BigInt!]
  swapFee_not_in: [BigInt!]
  adminFee: BigInt
  adminFee_not: BigInt
  adminFee_gt: BigInt
  adminFee_lt: BigInt
  adminFee_gte: BigInt
  adminFee_lte: BigInt
  adminFee_in: [BigInt!]
  adminFee_not_in: [BigInt!]
  pooledTokens: [String!]
  pooledTokens_not: [String!]
  pooledTokens_contains: [String!]
  pooledTokens_contains_nocase: [String!]
  pooledTokens_not_contains: [String!]
  pooledTokens_not_contains_nocase: [String!]
  pooledTokens_: stagingmumbai_PooledToken_filter
  tokenPrecisionMultipliers: [BigInt!]
  tokenPrecisionMultipliers_not: [BigInt!]
  tokenPrecisionMultipliers_contains: [BigInt!]
  tokenPrecisionMultipliers_contains_nocase: [BigInt!]
  tokenPrecisionMultipliers_not_contains: [BigInt!]
  tokenPrecisionMultipliers_not_contains_nocase: [BigInt!]
  balances: [BigInt!]
  balances_not: [BigInt!]
  balances_contains: [BigInt!]
  balances_contains_nocase: [BigInt!]
  balances_not_contains: [BigInt!]
  balances_not_contains_nocase: [BigInt!]
  adminFees: [BigInt!]
  adminFees_not: [BigInt!]
  adminFees_contains: [BigInt!]
  adminFees_contains_nocase: [BigInt!]
  adminFees_not_contains: [BigInt!]
  adminFees_not_contains_nocase: [BigInt!]
  virtualPrice: BigInt
  virtualPrice_not: BigInt
  virtualPrice_gt: BigInt
  virtualPrice_lt: BigInt
  virtualPrice_gte: BigInt
  virtualPrice_lte: BigInt
  virtualPrice_in: [BigInt!]
  virtualPrice_not_in: [BigInt!]
  invariant: BigInt
  invariant_not: BigInt
  invariant_gt: BigInt
  invariant_lt: BigInt
  invariant_gte: BigInt
  invariant_lte: BigInt
  invariant_in: [BigInt!]
  invariant_not_in: [BigInt!]
  lpTokenSupply: BigInt
  lpTokenSupply_not: BigInt
  lpTokenSupply_gt: BigInt
  lpTokenSupply_lt: BigInt
  lpTokenSupply_gte: BigInt
  lpTokenSupply_lte: BigInt
  lpTokenSupply_in: [BigInt!]
  lpTokenSupply_not_in: [BigInt!]
  events_: stagingmumbai_StableSwapEvent_filter
  exchanges_: stagingmumbai_StableSwapExchange_filter
  hourlyVolumes_: stagingmumbai_SwapHourlyVolume_filter
  dailyVolumes_: stagingmumbai_SwapDailyVolume_filter
  weeklyVolumes_: stagingmumbai_SwapWeeklyVolume_filter
  """Filter for the block changed event."""
  _change_block: stagingmumbai_BlockChangedFilter
}

enum stagingmumbai_StableSwap_orderBy {
  id
  isActive
  key
  canonicalId
  domain
  swapPool
  lpToken
  initialA
  futureA
  initialATime
  futureATime
  swapFee
  adminFee
  pooledTokens
  tokenPrecisionMultipliers
  balances
  adminFees
  virtualPrice
  invariant
  lpTokenSupply
  events
  exchanges
  hourlyVolumes
  dailyVolumes
  weeklyVolumes
}

type stagingmumbai_SwapDailyVolume implements stagingmumbai_SwapTradeVolume {
  id: ID!
  stableSwap: stagingmumbai_StableSwap!
  timestamp: BigInt!
  volume: stagingmumbai_BigDecimal!
}

input stagingmumbai_SwapDailyVolume_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: stagingmumbai_StableSwap_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  volume: stagingmumbai_BigDecimal
  volume_not: stagingmumbai_BigDecimal
  volume_gt: stagingmumbai_BigDecimal
  volume_lt: stagingmumbai_BigDecimal
  volume_gte: stagingmumbai_BigDecimal
  volume_lte: stagingmumbai_BigDecimal
  volume_in: [stagingmumbai_BigDecimal!]
  volume_not_in: [stagingmumbai_BigDecimal!]
  """Filter for the block changed event."""
  _change_block: stagingmumbai_BlockChangedFilter
}

enum stagingmumbai_SwapDailyVolume_orderBy {
  id
  stableSwap
  timestamp
  volume
}

type stagingmumbai_SwapHourlyVolume implements stagingmumbai_SwapTradeVolume {
  id: ID!
  stableSwap: stagingmumbai_StableSwap!
  timestamp: BigInt!
  volume: stagingmumbai_BigDecimal!
}

input stagingmumbai_SwapHourlyVolume_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: stagingmumbai_StableSwap_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  volume: stagingmumbai_BigDecimal
  volume_not: stagingmumbai_BigDecimal
  volume_gt: stagingmumbai_BigDecimal
  volume_lt: stagingmumbai_BigDecimal
  volume_gte: stagingmumbai_BigDecimal
  volume_lte: stagingmumbai_BigDecimal
  volume_in: [stagingmumbai_BigDecimal!]
  volume_not_in: [stagingmumbai_BigDecimal!]
  """Filter for the block changed event."""
  _change_block: stagingmumbai_BlockChangedFilter
}

enum stagingmumbai_SwapHourlyVolume_orderBy {
  id
  stableSwap
  timestamp
  volume
}

interface stagingmumbai_SwapTradeVolume {
  stableSwap: stagingmumbai_StableSwap!
  timestamp: BigInt!
  volume: stagingmumbai_BigDecimal!
}

input stagingmumbai_SwapTradeVolume_filter {
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: stagingmumbai_StableSwap_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  volume: stagingmumbai_BigDecimal
  volume_not: stagingmumbai_BigDecimal
  volume_gt: stagingmumbai_BigDecimal
  volume_lt: stagingmumbai_BigDecimal
  volume_gte: stagingmumbai_BigDecimal
  volume_lte: stagingmumbai_BigDecimal
  volume_in: [stagingmumbai_BigDecimal!]
  volume_not_in: [stagingmumbai_BigDecimal!]
  """Filter for the block changed event."""
  _change_block: stagingmumbai_BlockChangedFilter
}

enum stagingmumbai_SwapTradeVolume_orderBy {
  stableSwap
  timestamp
  volume
}

type stagingmumbai_SwapWeeklyVolume implements stagingmumbai_SwapTradeVolume {
  id: ID!
  stableSwap: stagingmumbai_StableSwap!
  timestamp: BigInt!
  volume: stagingmumbai_BigDecimal!
}

input stagingmumbai_SwapWeeklyVolume_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: stagingmumbai_StableSwap_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  volume: stagingmumbai_BigDecimal
  volume_not: stagingmumbai_BigDecimal
  volume_gt: stagingmumbai_BigDecimal
  volume_lt: stagingmumbai_BigDecimal
  volume_gte: stagingmumbai_BigDecimal
  volume_lte: stagingmumbai_BigDecimal
  volume_in: [stagingmumbai_BigDecimal!]
  volume_not_in: [stagingmumbai_BigDecimal!]
  """Filter for the block changed event."""
  _change_block: stagingmumbai_BlockChangedFilter
}

enum stagingmumbai_SwapWeeklyVolume_orderBy {
  id
  stableSwap
  timestamp
  volume
}

type stagingmumbai_SystemInfo {
  id: ID!
  exchangeCount: BigInt!
  swapCount: BigInt!
}

input stagingmumbai_SystemInfo_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  exchangeCount: BigInt
  exchangeCount_not: BigInt
  exchangeCount_gt: BigInt
  exchangeCount_lt: BigInt
  exchangeCount_gte: BigInt
  exchangeCount_lte: BigInt
  exchangeCount_in: [BigInt!]
  exchangeCount_not_in: [BigInt!]
  swapCount: BigInt
  swapCount_not: BigInt
  swapCount_gt: BigInt
  swapCount_lt: BigInt
  swapCount_gte: BigInt
  swapCount_lte: BigInt
  swapCount_in: [BigInt!]
  swapCount_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: stagingmumbai_BlockChangedFilter
}

enum stagingmumbai_SystemInfo_orderBy {
  id
  exchangeCount
  swapCount
}

type stagingmumbai__Block_ {
  """The hash of the block"""
  hash: stagingmumbai_Bytes
  """The block number"""
  number: Int!
  """Integer representation of the timestamp stored in blocks for the chain"""
  timestamp: Int
}

"""The type for the top-level _meta field"""
type stagingmumbai__Meta_ {
  """
  Information about a specific subgraph block. The hash of the block
  will be null if the _meta field has a block constraint that asks for
  a block number. It will be filled if the _meta field has no block constraint
  and therefore asks for the latest  block
  
  """
  block: stagingmumbai__Block_!
  """The deployment ID"""
  deployment: String!
  """If `true`, the subgraph encountered indexing errors at some past block"""
  hasIndexingErrors: Boolean!
}

scalar stagingarbitrumgoerli_BigDecimal

input stagingarbitrumgoerli_BlockChangedFilter {
  number_gte: Int!
}

input stagingarbitrumgoerli_Block_height {
  hash: stagingarbitrumgoerli_Bytes
  number: Int
  number_gte: Int
}

scalar stagingarbitrumgoerli_Bytes

"""Defines the order direction, either ascending or descending"""
enum stagingarbitrumgoerli_OrderDirection {
  asc
  desc
}

type stagingarbitrumgoerli_PooledToken {
  id: ID!
  asset: stagingarbitrumgoerli_Bytes!
}

input stagingarbitrumgoerli_PooledToken_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  asset: stagingarbitrumgoerli_Bytes
  asset_not: stagingarbitrumgoerli_Bytes
  asset_gt: stagingarbitrumgoerli_Bytes
  asset_lt: stagingarbitrumgoerli_Bytes
  asset_gte: stagingarbitrumgoerli_Bytes
  asset_lte: stagingarbitrumgoerli_Bytes
  asset_in: [stagingarbitrumgoerli_Bytes!]
  asset_not_in: [stagingarbitrumgoerli_Bytes!]
  asset_contains: stagingarbitrumgoerli_Bytes
  asset_not_contains: stagingarbitrumgoerli_Bytes
  """Filter for the block changed event."""
  _change_block: stagingarbitrumgoerli_BlockChangedFilter
}

enum stagingarbitrumgoerli_PooledToken_orderBy {
  id
  asset
}

type stagingarbitrumgoerli_StableSwap {
  id: ID!
  isActive: Boolean
  key: stagingarbitrumgoerli_Bytes!
  canonicalId: stagingarbitrumgoerli_Bytes
  domain: BigInt
  swapPool: stagingarbitrumgoerli_Bytes
  lpToken: stagingarbitrumgoerli_Bytes
  initialA: BigInt
  futureA: BigInt
  initialATime: BigInt
  futureATime: BigInt
  swapFee: BigInt
  adminFee: BigInt
  pooledTokens(skip: Int = 0, first: Int = 100, orderBy: stagingarbitrumgoerli_PooledToken_orderBy, orderDirection: stagingarbitrumgoerli_OrderDirection, where: stagingarbitrumgoerli_PooledToken_filter): [stagingarbitrumgoerli_PooledToken!]!
  tokenPrecisionMultipliers: [BigInt!]!
  balances: [BigInt!]!
  adminFees: [BigInt!]!
  virtualPrice: BigInt!
  invariant: BigInt!
  lpTokenSupply: BigInt!
  events(skip: Int = 0, first: Int = 100, orderBy: stagingarbitrumgoerli_StableSwapEvent_orderBy, orderDirection: stagingarbitrumgoerli_OrderDirection, where: stagingarbitrumgoerli_StableSwapEvent_filter): [stagingarbitrumgoerli_StableSwapEvent!]
  exchanges(skip: Int = 0, first: Int = 100, orderBy: stagingarbitrumgoerli_StableSwapExchange_orderBy, orderDirection: stagingarbitrumgoerli_OrderDirection, where: stagingarbitrumgoerli_StableSwapExchange_filter): [stagingarbitrumgoerli_StableSwapExchange!]
  hourlyVolumes(skip: Int = 0, first: Int = 100, orderBy: stagingarbitrumgoerli_SwapHourlyVolume_orderBy, orderDirection: stagingarbitrumgoerli_OrderDirection, where: stagingarbitrumgoerli_SwapHourlyVolume_filter): [stagingarbitrumgoerli_SwapHourlyVolume!]
  dailyVolumes(skip: Int = 0, first: Int = 100, orderBy: stagingarbitrumgoerli_SwapDailyVolume_orderBy, orderDirection: stagingarbitrumgoerli_OrderDirection, where: stagingarbitrumgoerli_SwapDailyVolume_filter): [stagingarbitrumgoerli_SwapDailyVolume!]
  weeklyVolumes(skip: Int = 0, first: Int = 100, orderBy: stagingarbitrumgoerli_SwapWeeklyVolume_orderBy, orderDirection: stagingarbitrumgoerli_OrderDirection, where: stagingarbitrumgoerli_SwapWeeklyVolume_filter): [stagingarbitrumgoerli_SwapWeeklyVolume!]
}

type stagingarbitrumgoerli_StableSwapAddLiquidityEvent implements stagingarbitrumgoerli_StableSwapEvent {
  id: ID!
  stableSwap: stagingarbitrumgoerli_StableSwap!
  provider: stagingarbitrumgoerli_Bytes!
  tokenAmounts: [BigInt!]!
  fees: [BigInt!]!
  invariant: BigInt
  lpTokenSupply: BigInt!
  block: BigInt!
  timestamp: BigInt!
  transaction: stagingarbitrumgoerli_Bytes!
}

input stagingarbitrumgoerli_StableSwapAddLiquidityEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: stagingarbitrumgoerli_StableSwap_filter
  provider: stagingarbitrumgoerli_Bytes
  provider_not: stagingarbitrumgoerli_Bytes
  provider_gt: stagingarbitrumgoerli_Bytes
  provider_lt: stagingarbitrumgoerli_Bytes
  provider_gte: stagingarbitrumgoerli_Bytes
  provider_lte: stagingarbitrumgoerli_Bytes
  provider_in: [stagingarbitrumgoerli_Bytes!]
  provider_not_in: [stagingarbitrumgoerli_Bytes!]
  provider_contains: stagingarbitrumgoerli_Bytes
  provider_not_contains: stagingarbitrumgoerli_Bytes
  tokenAmounts: [BigInt!]
  tokenAmounts_not: [BigInt!]
  tokenAmounts_contains: [BigInt!]
  tokenAmounts_contains_nocase: [BigInt!]
  tokenAmounts_not_contains: [BigInt!]
  tokenAmounts_not_contains_nocase: [BigInt!]
  fees: [BigInt!]
  fees_not: [BigInt!]
  fees_contains: [BigInt!]
  fees_contains_nocase: [BigInt!]
  fees_not_contains: [BigInt!]
  fees_not_contains_nocase: [BigInt!]
  invariant: BigInt
  invariant_not: BigInt
  invariant_gt: BigInt
  invariant_lt: BigInt
  invariant_gte: BigInt
  invariant_lte: BigInt
  invariant_in: [BigInt!]
  invariant_not_in: [BigInt!]
  lpTokenSupply: BigInt
  lpTokenSupply_not: BigInt
  lpTokenSupply_gt: BigInt
  lpTokenSupply_lt: BigInt
  lpTokenSupply_gte: BigInt
  lpTokenSupply_lte: BigInt
  lpTokenSupply_in: [BigInt!]
  lpTokenSupply_not_in: [BigInt!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: stagingarbitrumgoerli_Bytes
  transaction_not: stagingarbitrumgoerli_Bytes
  transaction_gt: stagingarbitrumgoerli_Bytes
  transaction_lt: stagingarbitrumgoerli_Bytes
  transaction_gte: stagingarbitrumgoerli_Bytes
  transaction_lte: stagingarbitrumgoerli_Bytes
  transaction_in: [stagingarbitrumgoerli_Bytes!]
  transaction_not_in: [stagingarbitrumgoerli_Bytes!]
  transaction_contains: stagingarbitrumgoerli_Bytes
  transaction_not_contains: stagingarbitrumgoerli_Bytes
  """Filter for the block changed event."""
  _change_block: stagingarbitrumgoerli_BlockChangedFilter
}

enum stagingarbitrumgoerli_StableSwapAddLiquidityEvent_orderBy {
  id
  stableSwap
  provider
  tokenAmounts
  fees
  invariant
  lpTokenSupply
  block
  timestamp
  transaction
}

interface stagingarbitrumgoerli_StableSwapEvent {
  id: ID!
  stableSwap: stagingarbitrumgoerli_StableSwap!
  block: BigInt!
  timestamp: BigInt!
  transaction: stagingarbitrumgoerli_Bytes!
}

input stagingarbitrumgoerli_StableSwapEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: stagingarbitrumgoerli_StableSwap_filter
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: stagingarbitrumgoerli_Bytes
  transaction_not: stagingarbitrumgoerli_Bytes
  transaction_gt: stagingarbitrumgoerli_Bytes
  transaction_lt: stagingarbitrumgoerli_Bytes
  transaction_gte: stagingarbitrumgoerli_Bytes
  transaction_lte: stagingarbitrumgoerli_Bytes
  transaction_in: [stagingarbitrumgoerli_Bytes!]
  transaction_not_in: [stagingarbitrumgoerli_Bytes!]
  transaction_contains: stagingarbitrumgoerli_Bytes
  transaction_not_contains: stagingarbitrumgoerli_Bytes
  """Filter for the block changed event."""
  _change_block: stagingarbitrumgoerli_BlockChangedFilter
}

enum stagingarbitrumgoerli_StableSwapEvent_orderBy {
  id
  stableSwap
  block
  timestamp
  transaction
}

type stagingarbitrumgoerli_StableSwapExchange {
  id: ID!
  stableSwap: stagingarbitrumgoerli_StableSwap!
  buyer: stagingarbitrumgoerli_Bytes!
  boughtId: BigInt!
  tokensBought: BigInt!
  soldId: BigInt!
  tokensSold: BigInt!
  block: BigInt!
  timestamp: BigInt!
  transaction: stagingarbitrumgoerli_Bytes!
}

input stagingarbitrumgoerli_StableSwapExchange_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: stagingarbitrumgoerli_StableSwap_filter
  buyer: stagingarbitrumgoerli_Bytes
  buyer_not: stagingarbitrumgoerli_Bytes
  buyer_gt: stagingarbitrumgoerli_Bytes
  buyer_lt: stagingarbitrumgoerli_Bytes
  buyer_gte: stagingarbitrumgoerli_Bytes
  buyer_lte: stagingarbitrumgoerli_Bytes
  buyer_in: [stagingarbitrumgoerli_Bytes!]
  buyer_not_in: [stagingarbitrumgoerli_Bytes!]
  buyer_contains: stagingarbitrumgoerli_Bytes
  buyer_not_contains: stagingarbitrumgoerli_Bytes
  boughtId: BigInt
  boughtId_not: BigInt
  boughtId_gt: BigInt
  boughtId_lt: BigInt
  boughtId_gte: BigInt
  boughtId_lte: BigInt
  boughtId_in: [BigInt!]
  boughtId_not_in: [BigInt!]
  tokensBought: BigInt
  tokensBought_not: BigInt
  tokensBought_gt: BigInt
  tokensBought_lt: BigInt
  tokensBought_gte: BigInt
  tokensBought_lte: BigInt
  tokensBought_in: [BigInt!]
  tokensBought_not_in: [BigInt!]
  soldId: BigInt
  soldId_not: BigInt
  soldId_gt: BigInt
  soldId_lt: BigInt
  soldId_gte: BigInt
  soldId_lte: BigInt
  soldId_in: [BigInt!]
  soldId_not_in: [BigInt!]
  tokensSold: BigInt
  tokensSold_not: BigInt
  tokensSold_gt: BigInt
  tokensSold_lt: BigInt
  tokensSold_gte: BigInt
  tokensSold_lte: BigInt
  tokensSold_in: [BigInt!]
  tokensSold_not_in: [BigInt!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: stagingarbitrumgoerli_Bytes
  transaction_not: stagingarbitrumgoerli_Bytes
  transaction_gt: stagingarbitrumgoerli_Bytes
  transaction_lt: stagingarbitrumgoerli_Bytes
  transaction_gte: stagingarbitrumgoerli_Bytes
  transaction_lte: stagingarbitrumgoerli_Bytes
  transaction_in: [stagingarbitrumgoerli_Bytes!]
  transaction_not_in: [stagingarbitrumgoerli_Bytes!]
  transaction_contains: stagingarbitrumgoerli_Bytes
  transaction_not_contains: stagingarbitrumgoerli_Bytes
  """Filter for the block changed event."""
  _change_block: stagingarbitrumgoerli_BlockChangedFilter
}

enum stagingarbitrumgoerli_StableSwapExchange_orderBy {
  id
  stableSwap
  buyer
  boughtId
  tokensBought
  soldId
  tokensSold
  block
  timestamp
  transaction
}

type stagingarbitrumgoerli_StableSwapRemoveLiquidityEvent implements stagingarbitrumgoerli_StableSwapEvent {
  id: ID!
  stableSwap: stagingarbitrumgoerli_StableSwap!
  provider: stagingarbitrumgoerli_Bytes!
  tokenAmounts: [BigInt!]!
  fees: [BigInt!]
  invariant: BigInt
  lpTokenSupply: BigInt!
  block: BigInt!
  timestamp: BigInt!
  transaction: stagingarbitrumgoerli_Bytes!
}

input stagingarbitrumgoerli_StableSwapRemoveLiquidityEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: stagingarbitrumgoerli_StableSwap_filter
  provider: stagingarbitrumgoerli_Bytes
  provider_not: stagingarbitrumgoerli_Bytes
  provider_gt: stagingarbitrumgoerli_Bytes
  provider_lt: stagingarbitrumgoerli_Bytes
  provider_gte: stagingarbitrumgoerli_Bytes
  provider_lte: stagingarbitrumgoerli_Bytes
  provider_in: [stagingarbitrumgoerli_Bytes!]
  provider_not_in: [stagingarbitrumgoerli_Bytes!]
  provider_contains: stagingarbitrumgoerli_Bytes
  provider_not_contains: stagingarbitrumgoerli_Bytes
  tokenAmounts: [BigInt!]
  tokenAmounts_not: [BigInt!]
  tokenAmounts_contains: [BigInt!]
  tokenAmounts_contains_nocase: [BigInt!]
  tokenAmounts_not_contains: [BigInt!]
  tokenAmounts_not_contains_nocase: [BigInt!]
  fees: [BigInt!]
  fees_not: [BigInt!]
  fees_contains: [BigInt!]
  fees_contains_nocase: [BigInt!]
  fees_not_contains: [BigInt!]
  fees_not_contains_nocase: [BigInt!]
  invariant: BigInt
  invariant_not: BigInt
  invariant_gt: BigInt
  invariant_lt: BigInt
  invariant_gte: BigInt
  invariant_lte: BigInt
  invariant_in: [BigInt!]
  invariant_not_in: [BigInt!]
  lpTokenSupply: BigInt
  lpTokenSupply_not: BigInt
  lpTokenSupply_gt: BigInt
  lpTokenSupply_lt: BigInt
  lpTokenSupply_gte: BigInt
  lpTokenSupply_lte: BigInt
  lpTokenSupply_in: [BigInt!]
  lpTokenSupply_not_in: [BigInt!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: stagingarbitrumgoerli_Bytes
  transaction_not: stagingarbitrumgoerli_Bytes
  transaction_gt: stagingarbitrumgoerli_Bytes
  transaction_lt: stagingarbitrumgoerli_Bytes
  transaction_gte: stagingarbitrumgoerli_Bytes
  transaction_lte: stagingarbitrumgoerli_Bytes
  transaction_in: [stagingarbitrumgoerli_Bytes!]
  transaction_not_in: [stagingarbitrumgoerli_Bytes!]
  transaction_contains: stagingarbitrumgoerli_Bytes
  transaction_not_contains: stagingarbitrumgoerli_Bytes
  """Filter for the block changed event."""
  _change_block: stagingarbitrumgoerli_BlockChangedFilter
}

enum stagingarbitrumgoerli_StableSwapRemoveLiquidityEvent_orderBy {
  id
  stableSwap
  provider
  tokenAmounts
  fees
  invariant
  lpTokenSupply
  block
  timestamp
  transaction
}

input stagingarbitrumgoerli_StableSwap_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  isActive: Boolean
  isActive_not: Boolean
  isActive_in: [Boolean!]
  isActive_not_in: [Boolean!]
  key: stagingarbitrumgoerli_Bytes
  key_not: stagingarbitrumgoerli_Bytes
  key_gt: stagingarbitrumgoerli_Bytes
  key_lt: stagingarbitrumgoerli_Bytes
  key_gte: stagingarbitrumgoerli_Bytes
  key_lte: stagingarbitrumgoerli_Bytes
  key_in: [stagingarbitrumgoerli_Bytes!]
  key_not_in: [stagingarbitrumgoerli_Bytes!]
  key_contains: stagingarbitrumgoerli_Bytes
  key_not_contains: stagingarbitrumgoerli_Bytes
  canonicalId: stagingarbitrumgoerli_Bytes
  canonicalId_not: stagingarbitrumgoerli_Bytes
  canonicalId_gt: stagingarbitrumgoerli_Bytes
  canonicalId_lt: stagingarbitrumgoerli_Bytes
  canonicalId_gte: stagingarbitrumgoerli_Bytes
  canonicalId_lte: stagingarbitrumgoerli_Bytes
  canonicalId_in: [stagingarbitrumgoerli_Bytes!]
  canonicalId_not_in: [stagingarbitrumgoerli_Bytes!]
  canonicalId_contains: stagingarbitrumgoerli_Bytes
  canonicalId_not_contains: stagingarbitrumgoerli_Bytes
  domain: BigInt
  domain_not: BigInt
  domain_gt: BigInt
  domain_lt: BigInt
  domain_gte: BigInt
  domain_lte: BigInt
  domain_in: [BigInt!]
  domain_not_in: [BigInt!]
  swapPool: stagingarbitrumgoerli_Bytes
  swapPool_not: stagingarbitrumgoerli_Bytes
  swapPool_gt: stagingarbitrumgoerli_Bytes
  swapPool_lt: stagingarbitrumgoerli_Bytes
  swapPool_gte: stagingarbitrumgoerli_Bytes
  swapPool_lte: stagingarbitrumgoerli_Bytes
  swapPool_in: [stagingarbitrumgoerli_Bytes!]
  swapPool_not_in: [stagingarbitrumgoerli_Bytes!]
  swapPool_contains: stagingarbitrumgoerli_Bytes
  swapPool_not_contains: stagingarbitrumgoerli_Bytes
  lpToken: stagingarbitrumgoerli_Bytes
  lpToken_not: stagingarbitrumgoerli_Bytes
  lpToken_gt: stagingarbitrumgoerli_Bytes
  lpToken_lt: stagingarbitrumgoerli_Bytes
  lpToken_gte: stagingarbitrumgoerli_Bytes
  lpToken_lte: stagingarbitrumgoerli_Bytes
  lpToken_in: [stagingarbitrumgoerli_Bytes!]
  lpToken_not_in: [stagingarbitrumgoerli_Bytes!]
  lpToken_contains: stagingarbitrumgoerli_Bytes
  lpToken_not_contains: stagingarbitrumgoerli_Bytes
  initialA: BigInt
  initialA_not: BigInt
  initialA_gt: BigInt
  initialA_lt: BigInt
  initialA_gte: BigInt
  initialA_lte: BigInt
  initialA_in: [BigInt!]
  initialA_not_in: [BigInt!]
  futureA: BigInt
  futureA_not: BigInt
  futureA_gt: BigInt
  futureA_lt: BigInt
  futureA_gte: BigInt
  futureA_lte: BigInt
  futureA_in: [BigInt!]
  futureA_not_in: [BigInt!]
  initialATime: BigInt
  initialATime_not: BigInt
  initialATime_gt: BigInt
  initialATime_lt: BigInt
  initialATime_gte: BigInt
  initialATime_lte: BigInt
  initialATime_in: [BigInt!]
  initialATime_not_in: [BigInt!]
  futureATime: BigInt
  futureATime_not: BigInt
  futureATime_gt: BigInt
  futureATime_lt: BigInt
  futureATime_gte: BigInt
  futureATime_lte: BigInt
  futureATime_in: [BigInt!]
  futureATime_not_in: [BigInt!]
  swapFee: BigInt
  swapFee_not: BigInt
  swapFee_gt: BigInt
  swapFee_lt: BigInt
  swapFee_gte: BigInt
  swapFee_lte: BigInt
  swapFee_in: [BigInt!]
  swapFee_not_in: [BigInt!]
  adminFee: BigInt
  adminFee_not: BigInt
  adminFee_gt: BigInt
  adminFee_lt: BigInt
  adminFee_gte: BigInt
  adminFee_lte: BigInt
  adminFee_in: [BigInt!]
  adminFee_not_in: [BigInt!]
  pooledTokens: [String!]
  pooledTokens_not: [String!]
  pooledTokens_contains: [String!]
  pooledTokens_contains_nocase: [String!]
  pooledTokens_not_contains: [String!]
  pooledTokens_not_contains_nocase: [String!]
  pooledTokens_: stagingarbitrumgoerli_PooledToken_filter
  tokenPrecisionMultipliers: [BigInt!]
  tokenPrecisionMultipliers_not: [BigInt!]
  tokenPrecisionMultipliers_contains: [BigInt!]
  tokenPrecisionMultipliers_contains_nocase: [BigInt!]
  tokenPrecisionMultipliers_not_contains: [BigInt!]
  tokenPrecisionMultipliers_not_contains_nocase: [BigInt!]
  balances: [BigInt!]
  balances_not: [BigInt!]
  balances_contains: [BigInt!]
  balances_contains_nocase: [BigInt!]
  balances_not_contains: [BigInt!]
  balances_not_contains_nocase: [BigInt!]
  adminFees: [BigInt!]
  adminFees_not: [BigInt!]
  adminFees_contains: [BigInt!]
  adminFees_contains_nocase: [BigInt!]
  adminFees_not_contains: [BigInt!]
  adminFees_not_contains_nocase: [BigInt!]
  virtualPrice: BigInt
  virtualPrice_not: BigInt
  virtualPrice_gt: BigInt
  virtualPrice_lt: BigInt
  virtualPrice_gte: BigInt
  virtualPrice_lte: BigInt
  virtualPrice_in: [BigInt!]
  virtualPrice_not_in: [BigInt!]
  invariant: BigInt
  invariant_not: BigInt
  invariant_gt: BigInt
  invariant_lt: BigInt
  invariant_gte: BigInt
  invariant_lte: BigInt
  invariant_in: [BigInt!]
  invariant_not_in: [BigInt!]
  lpTokenSupply: BigInt
  lpTokenSupply_not: BigInt
  lpTokenSupply_gt: BigInt
  lpTokenSupply_lt: BigInt
  lpTokenSupply_gte: BigInt
  lpTokenSupply_lte: BigInt
  lpTokenSupply_in: [BigInt!]
  lpTokenSupply_not_in: [BigInt!]
  events_: stagingarbitrumgoerli_StableSwapEvent_filter
  exchanges_: stagingarbitrumgoerli_StableSwapExchange_filter
  hourlyVolumes_: stagingarbitrumgoerli_SwapHourlyVolume_filter
  dailyVolumes_: stagingarbitrumgoerli_SwapDailyVolume_filter
  weeklyVolumes_: stagingarbitrumgoerli_SwapWeeklyVolume_filter
  """Filter for the block changed event."""
  _change_block: stagingarbitrumgoerli_BlockChangedFilter
}

enum stagingarbitrumgoerli_StableSwap_orderBy {
  id
  isActive
  key
  canonicalId
  domain
  swapPool
  lpToken
  initialA
  futureA
  initialATime
  futureATime
  swapFee
  adminFee
  pooledTokens
  tokenPrecisionMultipliers
  balances
  adminFees
  virtualPrice
  invariant
  lpTokenSupply
  events
  exchanges
  hourlyVolumes
  dailyVolumes
  weeklyVolumes
}

type stagingarbitrumgoerli_SwapDailyVolume implements stagingarbitrumgoerli_SwapTradeVolume {
  id: ID!
  stableSwap: stagingarbitrumgoerli_StableSwap!
  timestamp: BigInt!
  volume: stagingarbitrumgoerli_BigDecimal!
}

input stagingarbitrumgoerli_SwapDailyVolume_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: stagingarbitrumgoerli_StableSwap_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  volume: stagingarbitrumgoerli_BigDecimal
  volume_not: stagingarbitrumgoerli_BigDecimal
  volume_gt: stagingarbitrumgoerli_BigDecimal
  volume_lt: stagingarbitrumgoerli_BigDecimal
  volume_gte: stagingarbitrumgoerli_BigDecimal
  volume_lte: stagingarbitrumgoerli_BigDecimal
  volume_in: [stagingarbitrumgoerli_BigDecimal!]
  volume_not_in: [stagingarbitrumgoerli_BigDecimal!]
  """Filter for the block changed event."""
  _change_block: stagingarbitrumgoerli_BlockChangedFilter
}

enum stagingarbitrumgoerli_SwapDailyVolume_orderBy {
  id
  stableSwap
  timestamp
  volume
}

type stagingarbitrumgoerli_SwapHourlyVolume implements stagingarbitrumgoerli_SwapTradeVolume {
  id: ID!
  stableSwap: stagingarbitrumgoerli_StableSwap!
  timestamp: BigInt!
  volume: stagingarbitrumgoerli_BigDecimal!
}

input stagingarbitrumgoerli_SwapHourlyVolume_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: stagingarbitrumgoerli_StableSwap_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  volume: stagingarbitrumgoerli_BigDecimal
  volume_not: stagingarbitrumgoerli_BigDecimal
  volume_gt: stagingarbitrumgoerli_BigDecimal
  volume_lt: stagingarbitrumgoerli_BigDecimal
  volume_gte: stagingarbitrumgoerli_BigDecimal
  volume_lte: stagingarbitrumgoerli_BigDecimal
  volume_in: [stagingarbitrumgoerli_BigDecimal!]
  volume_not_in: [stagingarbitrumgoerli_BigDecimal!]
  """Filter for the block changed event."""
  _change_block: stagingarbitrumgoerli_BlockChangedFilter
}

enum stagingarbitrumgoerli_SwapHourlyVolume_orderBy {
  id
  stableSwap
  timestamp
  volume
}

interface stagingarbitrumgoerli_SwapTradeVolume {
  stableSwap: stagingarbitrumgoerli_StableSwap!
  timestamp: BigInt!
  volume: stagingarbitrumgoerli_BigDecimal!
}

input stagingarbitrumgoerli_SwapTradeVolume_filter {
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: stagingarbitrumgoerli_StableSwap_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  volume: stagingarbitrumgoerli_BigDecimal
  volume_not: stagingarbitrumgoerli_BigDecimal
  volume_gt: stagingarbitrumgoerli_BigDecimal
  volume_lt: stagingarbitrumgoerli_BigDecimal
  volume_gte: stagingarbitrumgoerli_BigDecimal
  volume_lte: stagingarbitrumgoerli_BigDecimal
  volume_in: [stagingarbitrumgoerli_BigDecimal!]
  volume_not_in: [stagingarbitrumgoerli_BigDecimal!]
  """Filter for the block changed event."""
  _change_block: stagingarbitrumgoerli_BlockChangedFilter
}

enum stagingarbitrumgoerli_SwapTradeVolume_orderBy {
  stableSwap
  timestamp
  volume
}

type stagingarbitrumgoerli_SwapWeeklyVolume implements stagingarbitrumgoerli_SwapTradeVolume {
  id: ID!
  stableSwap: stagingarbitrumgoerli_StableSwap!
  timestamp: BigInt!
  volume: stagingarbitrumgoerli_BigDecimal!
}

input stagingarbitrumgoerli_SwapWeeklyVolume_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: stagingarbitrumgoerli_StableSwap_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  volume: stagingarbitrumgoerli_BigDecimal
  volume_not: stagingarbitrumgoerli_BigDecimal
  volume_gt: stagingarbitrumgoerli_BigDecimal
  volume_lt: stagingarbitrumgoerli_BigDecimal
  volume_gte: stagingarbitrumgoerli_BigDecimal
  volume_lte: stagingarbitrumgoerli_BigDecimal
  volume_in: [stagingarbitrumgoerli_BigDecimal!]
  volume_not_in: [stagingarbitrumgoerli_BigDecimal!]
  """Filter for the block changed event."""
  _change_block: stagingarbitrumgoerli_BlockChangedFilter
}

enum stagingarbitrumgoerli_SwapWeeklyVolume_orderBy {
  id
  stableSwap
  timestamp
  volume
}

type stagingarbitrumgoerli_SystemInfo {
  id: ID!
  exchangeCount: BigInt!
  swapCount: BigInt!
}

input stagingarbitrumgoerli_SystemInfo_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  exchangeCount: BigInt
  exchangeCount_not: BigInt
  exchangeCount_gt: BigInt
  exchangeCount_lt: BigInt
  exchangeCount_gte: BigInt
  exchangeCount_lte: BigInt
  exchangeCount_in: [BigInt!]
  exchangeCount_not_in: [BigInt!]
  swapCount: BigInt
  swapCount_not: BigInt
  swapCount_gt: BigInt
  swapCount_lt: BigInt
  swapCount_gte: BigInt
  swapCount_lte: BigInt
  swapCount_in: [BigInt!]
  swapCount_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: stagingarbitrumgoerli_BlockChangedFilter
}

enum stagingarbitrumgoerli_SystemInfo_orderBy {
  id
  exchangeCount
  swapCount
}

type stagingarbitrumgoerli__Block_ {
  """The hash of the block"""
  hash: stagingarbitrumgoerli_Bytes
  """The block number"""
  number: Int!
  """Integer representation of the timestamp stored in blocks for the chain"""
  timestamp: Int
}

"""The type for the top-level _meta field"""
type stagingarbitrumgoerli__Meta_ {
  """
  Information about a specific subgraph block. The hash of the block
  will be null if the _meta field has a block constraint that asks for
  a block number. It will be filled if the _meta field has no block constraint
  and therefore asks for the latest  block
  
  """
  block: stagingarbitrumgoerli__Block_!
  """The deployment ID"""
  deployment: String!
  """If `true`, the subgraph encountered indexing errors at some past block"""
  hasIndexingErrors: Boolean!
}