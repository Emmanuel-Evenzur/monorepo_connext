{
  "address": "0x69009c6f567590d8B469dbF4C8808e8ee32b8a45",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "_domain",
          "type": "uint32"
        },
        {
          "internalType": "uint32",
          "name": "_mirrorDomain",
          "type": "uint32"
        },
        {
          "internalType": "address",
          "name": "_amb",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_rootManager",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_mirrorConnector",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "_gasCap",
          "type": "uint256"
        },
        {
          "internalType": "uint16",
          "name": "_mirrorWormholeChainId",
          "type": "uint16"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [],
      "name": "Connector__processMessage_notUsed",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ProposedOwnable__onlyOwner_notOwner",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ProposedOwnable__onlyProposed_notProposedOwner",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ProposedOwnable__ownershipDelayElapsed_delayNotElapsed",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ProposedOwnable__proposeNewOwner_invalidProposal",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ProposedOwnable__proposeNewOwner_noOwnershipChange",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ProposedOwnable__renounceOwnership_invalidProposal",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ProposedOwnable__renounceOwnership_noProposal",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "_previous",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "_updated",
          "type": "uint256"
        }
      ],
      "name": "GasCapUpdated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "caller",
          "type": "address"
        }
      ],
      "name": "MessageProcessed",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        },
        {
          "indexed": false,
          "internalType": "bytes",
          "name": "encodedData",
          "type": "bytes"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "caller",
          "type": "address"
        }
      ],
      "name": "MessageSent",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "previous",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "current",
          "type": "address"
        }
      ],
      "name": "MirrorConnectorUpdated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint32",
          "name": "domain",
          "type": "uint32"
        },
        {
          "indexed": true,
          "internalType": "uint32",
          "name": "mirrorDomain",
          "type": "uint32"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "amb",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "rootManager",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "mirrorConnector",
          "type": "address"
        }
      ],
      "name": "NewConnector",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "proposedOwner",
          "type": "address"
        }
      ],
      "name": "OwnershipProposed",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "previousOwner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "OwnershipTransferred",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "previous",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "updated",
          "type": "address"
        }
      ],
      "name": "RefundAddressUpdated",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "AMB",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "DOMAIN",
      "outputs": [
        {
          "internalType": "uint32",
          "name": "",
          "type": "uint32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "MIRROR_DOMAIN",
      "outputs": [
        {
          "internalType": "uint32",
          "name": "",
          "type": "uint32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "MIRROR_WORMHOLE_ID",
      "outputs": [
        {
          "internalType": "uint16",
          "name": "",
          "type": "uint16"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "ROOT_MANAGER",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "acceptProposedOwner",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "delay",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "mirrorConnector",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "owner",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "_data",
          "type": "bytes"
        }
      ],
      "name": "processMessage",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "name": "processedWhMessages",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newlyProposed",
          "type": "address"
        }
      ],
      "name": "proposeNewOwner",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "proposed",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "proposedTimestamp",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_gasLimit",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "_amb",
          "type": "address"
        }
      ],
      "name": "quoteEVMDeliveryPrice",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "_cost",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "_payload",
          "type": "bytes"
        },
        {
          "internalType": "bytes[]",
          "name": "",
          "type": "bytes[]"
        },
        {
          "internalType": "bytes32",
          "name": "_sourceAddress",
          "type": "bytes32"
        },
        {
          "internalType": "uint16",
          "name": "_sourceChain",
          "type": "uint16"
        },
        {
          "internalType": "bytes32",
          "name": "_deliveryHash",
          "type": "bytes32"
        }
      ],
      "name": "receiveWormholeMessages",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "refundAddress",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "renounceOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "renounced",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "_data",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "_encodedData",
          "type": "bytes"
        }
      ],
      "name": "sendMessage",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_gasCap",
          "type": "uint256"
        }
      ],
      "name": "setGasCap",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_mirrorConnector",
          "type": "address"
        }
      ],
      "name": "setMirrorConnector",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_updated",
          "type": "address"
        }
      ],
      "name": "setRefundAddress",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_expected",
          "type": "address"
        }
      ],
      "name": "verifySender",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "stateMutability": "payable",
      "type": "receive"
    }
  ],
  "transactionHash": "0xfd467ca2bda2a7a5fb532b774fe2f69947e80e1df7f9873be5d90f92a458a60a",
  "receipt": {
    "to": null,
    "from": "0xade09131C6f43fe22C2CbABb759636C43cFc181e",
    "contractAddress": "0x69009c6f567590d8B469dbF4C8808e8ee32b8a45",
    "transactionIndex": 494,
    "gasUsed": "1331451",
    "logsBloom": "0x00800002000000000000000000000000000000000008401000800000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000080040000001000000000000000000000040000000000000020000000000000000000800000040000010008000000000000000400000000000000000000000000000000000000000000040000000000000000000000002000000080000000000000000000000000000000000000000000000000000000000000000000000000000010000000000020000000000000000001020000000000000200000000000040000000000000000000002000000000000000000",
    "blockHash": "0x5926e801a7ef5ec8f10700a309411809e156624c16b48ee87056e65dd7fc583a",
    "transactionHash": "0xfd467ca2bda2a7a5fb532b774fe2f69947e80e1df7f9873be5d90f92a458a60a",
    "logs": [
      {
        "transactionIndex": 494,
        "blockNumber": 17640454,
        "transactionHash": "0xfd467ca2bda2a7a5fb532b774fe2f69947e80e1df7f9873be5d90f92a458a60a",
        "address": "0x69009c6f567590d8B469dbF4C8808e8ee32b8a45",
        "topics": [
          "0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x000000000000000000000000ade09131c6f43fe22c2cbabb759636c43cfc181e"
        ],
        "data": "0x",
        "logIndex": 497,
        "blockHash": "0x5926e801a7ef5ec8f10700a309411809e156624c16b48ee87056e65dd7fc583a"
      },
      {
        "transactionIndex": 494,
        "blockNumber": 17640454,
        "transactionHash": "0xfd467ca2bda2a7a5fb532b774fe2f69947e80e1df7f9873be5d90f92a458a60a",
        "address": "0x69009c6f567590d8B469dbF4C8808e8ee32b8a45",
        "topics": [
          "0x4f9c27c2fe3f84576ea469d367d044da53c45e951617e8389f2b5ed8db9d25f0",
          "0x0000000000000000000000000000000000000000000000000000000000657468",
          "0x0000000000000000000000000000000000000000000000000000000000626e62"
        ],
        "data": "0x00000000000000000000000027428dd2d3dd32a4d7f7c497eaaa23130d894911000000000000000000000000d5d61e9dfb6680cba8353988ba0337802811c2e10000000000000000000000000000000000000000000000000000000000000000",
        "logIndex": 498,
        "blockHash": "0x5926e801a7ef5ec8f10700a309411809e156624c16b48ee87056e65dd7fc583a"
      },
      {
        "transactionIndex": 494,
        "blockNumber": 17640454,
        "transactionHash": "0xfd467ca2bda2a7a5fb532b774fe2f69947e80e1df7f9873be5d90f92a458a60a",
        "address": "0x69009c6f567590d8B469dbF4C8808e8ee32b8a45",
        "topics": [
          "0x877a02cb809da0364d23adca3cd50c451b53f279d3df632e1fc11eb66335bce5"
        ],
        "data": "0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000493e0",
        "logIndex": 499,
        "blockHash": "0x5926e801a7ef5ec8f10700a309411809e156624c16b48ee87056e65dd7fc583a"
      },
      {
        "transactionIndex": 494,
        "blockNumber": 17640454,
        "transactionHash": "0xfd467ca2bda2a7a5fb532b774fe2f69947e80e1df7f9873be5d90f92a458a60a",
        "address": "0x69009c6f567590d8B469dbF4C8808e8ee32b8a45",
        "topics": [
          "0x57b5839c3435f5b2eb2d2e286fb44ca7303d01d9b25a5d9c05c4895234742859",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x000000000000000000000000ade09131c6f43fe22c2cbabb759636c43cfc181e"
        ],
        "data": "0x",
        "logIndex": 500,
        "blockHash": "0x5926e801a7ef5ec8f10700a309411809e156624c16b48ee87056e65dd7fc583a"
      }
    ],
    "blockNumber": 17640454,
    "cumulativeGasUsed": "23273609",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "6648936",
    "6450786",
    "0x27428DD2d3DD32A4D7f7C497eAaa23130d894911",
    "0xd5d61E9dfb6680Cba8353988Ba0337802811C2e1",
    "0x0000000000000000000000000000000000000000",
    "300000",
    "4"
  ],
  "numDeployments": 1,
  "solcInputHash": "e708ecce32e6efc9e346efa212a85361",
  "metadata": "{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_domain\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_mirrorDomain\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"_amb\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_rootManager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_mirrorConnector\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_gasCap\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"_mirrorWormholeChainId\",\"type\":\"uint16\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"Connector__processMessage_notUsed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ProposedOwnable__onlyOwner_notOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ProposedOwnable__onlyProposed_notProposedOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ProposedOwnable__ownershipDelayElapsed_delayNotElapsed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ProposedOwnable__proposeNewOwner_invalidProposal\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ProposedOwnable__proposeNewOwner_noOwnershipChange\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ProposedOwnable__renounceOwnership_invalidProposal\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ProposedOwnable__renounceOwnership_noProposal\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_previous\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_updated\",\"type\":\"uint256\"}],\"name\":\"GasCapUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"MessageProcessed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"encodedData\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"MessageSent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"previous\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"current\",\"type\":\"address\"}],\"name\":\"MirrorConnectorUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"domain\",\"type\":\"uint32\"},{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"mirrorDomain\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"amb\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"rootManager\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"mirrorConnector\",\"type\":\"address\"}],\"name\":\"NewConnector\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"proposedOwner\",\"type\":\"address\"}],\"name\":\"OwnershipProposed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previous\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"updated\",\"type\":\"address\"}],\"name\":\"RefundAddressUpdated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"AMB\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DOMAIN\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIRROR_DOMAIN\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIRROR_WORMHOLE_ID\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ROOT_MANAGER\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptProposedOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"delay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mirrorConnector\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"processMessage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"processedWhMessages\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newlyProposed\",\"type\":\"address\"}],\"name\":\"proposeNewOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proposed\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proposedTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_amb\",\"type\":\"address\"}],\"name\":\"quoteEVMDeliveryPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_cost\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_payload\",\"type\":\"bytes\"},{\"internalType\":\"bytes[]\",\"name\":\"\",\"type\":\"bytes[]\"},{\"internalType\":\"bytes32\",\"name\":\"_sourceAddress\",\"type\":\"bytes32\"},{\"internalType\":\"uint16\",\"name\":\"_sourceChain\",\"type\":\"uint16\"},{\"internalType\":\"bytes32\",\"name\":\"_deliveryHash\",\"type\":\"bytes32\"}],\"name\":\"receiveWormholeMessages\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"refundAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounced\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_encodedData\",\"type\":\"bytes\"}],\"name\":\"sendMessage\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_gasCap\",\"type\":\"uint256\"}],\"name\":\"setGasCap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_mirrorConnector\",\"type\":\"address\"}],\"name\":\"setMirrorConnector\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_updated\",\"type\":\"address\"}],\"name\":\"setRefundAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_expected\",\"type\":\"address\"}],\"name\":\"verifySender\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"processMessage(bytes)\":{\"details\":\"This is called by AMBs to process messages originating from mirror connector\"},\"quoteEVMDeliveryPrice(uint256,address)\":{\"details\":\"calculcate gas to call `receiveWormholeMessages` on target chain https://github.com/wormhole-foundation/wormhole/blob/main/ethereum/contracts/relayer/deliveryProvider/DeliveryProvider.sol\"},\"receiveWormholeMessages(bytes,bytes[],bytes32,uint16,bytes32)\":{\"details\":\"This is defined here instead of the `BaseWormhole` to avoid storing AMB values twice.\"},\"sendMessage(bytes,bytes)\":{\"details\":\"This is called by the root manager *only* on mainnet to propagate the aggregate root\"},\"setRefundAddress(address)\":{\"params\":{\"_updated\":\"The updated refund address\"}}},\"version\":1},\"userdoc\":{\"events\":{\"GasCapUpdated(uint256,uint256)\":{\"notice\":\"Emitted when admin updates the gas cap\"},\"MessageProcessed(bytes,address)\":{\"notice\":\"Emitted whenever a message is successfully received over an AMB\"},\"MessageSent(bytes,bytes,address)\":{\"notice\":\"Emitted whenever a message is successfully sent over an AMB\"}},\"kind\":\"user\",\"methods\":{\"AMB()\":{\"notice\":\"Address of the AMB on this domain.\"},\"DOMAIN()\":{\"notice\":\"The domain of this Messaging (i.e. Connector) contract.\"},\"MIRROR_DOMAIN()\":{\"notice\":\"The domain of the corresponding messaging (i.e. Connector) contract.\"},\"MIRROR_WORMHOLE_ID()\":{\"notice\":\"The wormhole id for the mirror network\"},\"ROOT_MANAGER()\":{\"notice\":\"RootManager contract address.\"},\"acceptProposedOwner()\":{\"notice\":\"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.\"},\"delay()\":{\"notice\":\"Returns the delay period before a new owner can be accepted.\"},\"mirrorConnector()\":{\"notice\":\"Connector on L2 for L1 connectors, and vice versa.\"},\"owner()\":{\"notice\":\"Returns the address of the current owner.\"},\"processMessage(bytes)\":{\"notice\":\"Processes a message received by an AMB\"},\"processedWhMessages(bytes32)\":{\"notice\":\"Mapping of processed messages from wormhole.\"},\"proposeNewOwner(address)\":{\"notice\":\"Sets the timestamp for an owner to be proposed, and sets the newly proposed owner as step 1 in a 2-step process\"},\"proposed()\":{\"notice\":\"Returns the address of the proposed owner.\"},\"proposedTimestamp()\":{\"notice\":\"Returns the address of the proposed owner.\"},\"receiveWormholeMessages(bytes,bytes[],bytes32,uint16,bytes32)\":{\"notice\":\"This function is called to receive messages through the wormhole relayer module https://book.wormhole.com/technical/evm/relayer.html\"},\"refundAddress()\":{\"notice\":\"The address on this chain any refunds from wormhole fees will be sent to\"},\"renounceOwnership()\":{\"notice\":\"Renounces ownership of the contract after a delay\"},\"renounced()\":{\"notice\":\"Indicates if the ownership has been renounced() by checking if current owner is address(0)\"},\"sendMessage(bytes,bytes)\":{\"notice\":\"Sends a message over the amb\"},\"setMirrorConnector(address)\":{\"notice\":\"Sets the address of the l2Connector for this domain\"},\"setRefundAddress(address)\":{\"notice\":\"Allows the owner to set a new address to collect excess wormhole fees.\"},\"verifySender(address)\":{\"notice\":\"Checks the cross domain sender for a given address\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/messaging/connectors/wormhole/WormholeHubConnector.sol\":\"WormholeHubConnector\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"contracts/messaging/connectors/Connector.sol\":{\"content\":\"// SPDX-License-Identifier: MIT OR Apache-2.0\\npragma solidity 0.8.17;\\n\\nimport {ProposedOwnable} from \\\"../../shared/ProposedOwnable.sol\\\";\\nimport {IConnector} from \\\"../interfaces/IConnector.sol\\\";\\n\\n/**\\n * @title Connector\\n * @author Connext Labs, Inc.\\n * @notice This contract has the messaging interface functions used by all connectors.\\n *\\n * @dev This contract stores information about mirror connectors, but can be used as a\\n * base for contracts that do not have a mirror (i.e. the connector handling messaging on\\n * mainnet). In this case, the `mirrorConnector` and `MIRROR_DOMAIN`\\n * will be empty\\n *\\n * @dev If ownership is renounced, this contract will be unable to update its `mirrorConnector`\\n * or `mirrorGas`\\n */\\nabstract contract Connector is ProposedOwnable, IConnector {\\n  // ========== Custom Errors ===========\\n\\n  error Connector__processMessage_notUsed();\\n\\n  // ============ Events ============\\n\\n  event NewConnector(\\n    uint32 indexed domain,\\n    uint32 indexed mirrorDomain,\\n    address amb,\\n    address rootManager,\\n    address mirrorConnector\\n  );\\n\\n  event MirrorConnectorUpdated(address previous, address current);\\n\\n  // ============ Public Storage ============\\n\\n  /**\\n   * @notice The domain of this Messaging (i.e. Connector) contract.\\n   */\\n  uint32 public immutable DOMAIN;\\n\\n  /**\\n   * @notice Address of the AMB on this domain.\\n   */\\n  address public immutable AMB;\\n\\n  /**\\n   * @notice RootManager contract address.\\n   */\\n  address public immutable ROOT_MANAGER;\\n\\n  /**\\n   * @notice The domain of the corresponding messaging (i.e. Connector) contract.\\n   */\\n  uint32 public immutable MIRROR_DOMAIN;\\n\\n  /**\\n   * @notice Connector on L2 for L1 connectors, and vice versa.\\n   */\\n  address public mirrorConnector;\\n\\n  // ============ Modifiers ============\\n\\n  /**\\n   * @notice Errors if the msg.sender is not the registered AMB\\n   */\\n  modifier onlyAMB() {\\n    require(msg.sender == AMB, \\\"!AMB\\\");\\n    _;\\n  }\\n\\n  /**\\n   * @notice Errors if the msg.sender is not the registered ROOT_MANAGER\\n   */\\n  modifier onlyRootManager() {\\n    // NOTE: RootManager will be zero address for spoke connectors.\\n    // Only root manager can dispatch a message to spokes/L2s via the hub connector.\\n    require(msg.sender == ROOT_MANAGER, \\\"!rootManager\\\");\\n    _;\\n  }\\n\\n  // ============ Constructor ============\\n\\n  /**\\n   * @notice Creates a new HubConnector instance\\n   * @dev The connectors are deployed such that there is one on each side of an AMB (i.e.\\n   * for optimism, there is one connector on optimism and one connector on mainnet)\\n   * @param _domain The domain this connector lives on\\n   * @param _mirrorDomain The spoke domain\\n   * @param _amb The address of the amb on the domain this connector lives on\\n   * @param _rootManager The address of the RootManager on mainnet\\n   * @param _mirrorConnector The address of the spoke connector\\n   */\\n  constructor(\\n    uint32 _domain,\\n    uint32 _mirrorDomain,\\n    address _amb,\\n    address _rootManager,\\n    address _mirrorConnector\\n  ) ProposedOwnable() {\\n    // set the owner\\n    _setOwner(msg.sender);\\n\\n    // sanity checks on values\\n    require(_domain != 0, \\\"empty domain\\\");\\n    require(_rootManager != address(0), \\\"empty rootManager\\\");\\n    // see note at top of contract on why the mirror values are not sanity checked\\n\\n    // set immutables\\n    DOMAIN = _domain;\\n    AMB = _amb;\\n    ROOT_MANAGER = _rootManager;\\n    MIRROR_DOMAIN = _mirrorDomain;\\n    // set mutables if defined\\n    if (_mirrorConnector != address(0)) {\\n      _setMirrorConnector(_mirrorConnector);\\n    }\\n\\n    emit NewConnector(_domain, _mirrorDomain, _amb, _rootManager, _mirrorConnector);\\n  }\\n\\n  // ============ Receivable ============\\n  /**\\n   * @notice Connectors may need to receive native asset to handle fees when sending a\\n   * message\\n   */\\n  receive() external payable {}\\n\\n  // ============ Admin Functions ============\\n\\n  /**\\n   * @notice Sets the address of the l2Connector for this domain\\n   */\\n  function setMirrorConnector(address _mirrorConnector) public onlyOwner {\\n    _setMirrorConnector(_mirrorConnector);\\n  }\\n\\n  // ============ Public Functions ============\\n\\n  /**\\n   * @notice Processes a message received by an AMB\\n   * @dev This is called by AMBs to process messages originating from mirror connector\\n   */\\n  function processMessage(bytes memory _data) external virtual onlyAMB {\\n    _processMessage(_data);\\n    emit MessageProcessed(_data, msg.sender);\\n  }\\n\\n  /**\\n   * @notice Checks the cross domain sender for a given address\\n   */\\n  function verifySender(address _expected) external returns (bool) {\\n    return _verifySender(_expected);\\n  }\\n\\n  // ============ Virtual Functions ============\\n\\n  /**\\n   * @notice This function is used by the Connext contract on the l2 domain to send a message to the\\n   * l1 domain (i.e. called by Connext on optimism to send a message to mainnet with roots)\\n   * @param _data The contents of the message\\n   * @param _encodedData Data used to send the message; specific to connector\\n   */\\n  function _sendMessage(bytes memory _data, bytes memory _encodedData) internal virtual;\\n\\n  /**\\n   * @notice This function is used by the AMBs to handle incoming messages. Should store the latest\\n   * root generated on the l2 domain.\\n   */\\n  function _processMessage(\\n    bytes memory /* _data */\\n  ) internal virtual {\\n    // By default, reverts. This is to ensure the call path is not used unless this function is\\n    // overridden by the inheriting class\\n    revert Connector__processMessage_notUsed();\\n  }\\n\\n  /**\\n   * @notice Verify that the msg.sender is the correct AMB contract, and that the message's origin sender\\n   * is the expected address.\\n   * @dev Should be overridden by the implementing Connector contract.\\n   */\\n  function _verifySender(address _expected) internal virtual returns (bool);\\n\\n  // ============ Private Functions ============\\n\\n  function _setMirrorConnector(address _mirrorConnector) internal virtual {\\n    emit MirrorConnectorUpdated(mirrorConnector, _mirrorConnector);\\n    mirrorConnector = _mirrorConnector;\\n  }\\n}\\n\",\"keccak256\":\"0x08d4077a1b5caf9f46491206064bb24bee467dd741b42fed3d30a608eea83368\",\"license\":\"MIT OR Apache-2.0\"},\"contracts/messaging/connectors/GasCap.sol\":{\"content\":\"// SPDX-License-Identifier: MIT OR Apache-2.0\\npragma solidity 0.8.17;\\n\\nimport {ProposedOwnable} from \\\"../../shared/ProposedOwnable.sol\\\";\\n\\nabstract contract GasCap is ProposedOwnable {\\n  // ============ Storage ============\\n  /**\\n   * @notice The gnosis amb requires destination gas to be specified on the origin.\\n   * The gas used will be passed in by the relayer to allow for real-time estimates,\\n   * but will be capped at the admin-set cap.\\n   */\\n  uint256 gasCap;\\n\\n  // ============ Events ============\\n\\n  /**\\n   * @notice Emitted when admin updates the gas cap\\n   * @param _previous The starting value\\n   * @param _updated The final value\\n   */\\n  event GasCapUpdated(uint256 _previous, uint256 _updated);\\n\\n  // ============ Constructor ============\\n  constructor(uint256 _gasCap) {\\n    _setGasCap(_gasCap);\\n  }\\n\\n  // ============ Admin Fns ============\\n  function setGasCap(uint256 _gasCap) public onlyOwner {\\n    _setGasCap(_gasCap);\\n  }\\n\\n  // ============ Internal Fns ============\\n\\n  /**\\n   * @notice Used (by admin) to update the gas cap\\n   * @param _gasCap The new value\\n   */\\n  function _setGasCap(uint256 _gasCap) internal {\\n    emit GasCapUpdated(gasCap, _gasCap);\\n    gasCap = _gasCap;\\n  }\\n\\n  /**\\n   * @notice Used to get the gas to use. Will be the original value IFF it\\n   * is less than the cap\\n   * @param _gas The proposed gas value\\n   */\\n  function _getGas(uint256 _gas) internal view returns (uint256) {\\n    if (_gas > gasCap) {\\n      _gas = gasCap;\\n    }\\n    return _gas;\\n  }\\n}\\n\",\"keccak256\":\"0xb8b52a3372f08490c918d1f490ad80764d54bd62d1638e4d17a5b552efe6587d\",\"license\":\"MIT OR Apache-2.0\"},\"contracts/messaging/connectors/HubConnector.sol\":{\"content\":\"// SPDX-License-Identifier: MIT OR Apache-2.0\\npragma solidity 0.8.17;\\n\\nimport {Connector} from \\\"./Connector.sol\\\";\\n\\n/**\\n * @title HubConnector\\n * @author Connext Labs, Inc.\\n * @notice This contract implements the messaging functions needed on the hub-side of a given AMB.\\n * The HubConnector has a limited set of functionality compared to the SpokeConnector, namely that\\n * it contains no logic to store or prove messages.\\n *\\n * @dev This contract should be deployed on the hub-side of an AMB (i.e. on L1), and contracts\\n * which extend this should implement the virtual functions defined in the BaseConnector class\\n */\\nabstract contract HubConnector is Connector {\\n  /**\\n   * @notice Creates a new HubConnector instance\\n   * @dev The connectors are deployed such that there is one on each side of an AMB (i.e.\\n   * for optimism, there is one connector on optimism and one connector on mainnet)\\n   * @param _domain The domain this connector lives on\\n   * @param _mirrorDomain The spoke domain\\n   * @param _amb The address of the amb on the domain this connector lives on\\n   * @param _rootManager The address of the RootManager on mainnet\\n   * @param _mirrorConnector The address of the spoke connector\\n   */\\n  constructor(\\n    uint32 _domain,\\n    uint32 _mirrorDomain,\\n    address _amb,\\n    address _rootManager,\\n    address _mirrorConnector\\n  ) Connector(_domain, _mirrorDomain, _amb, _rootManager, _mirrorConnector) {}\\n\\n  // ============ Public fns ============\\n  /**\\n   * @notice Sends a message over the amb\\n   * @dev This is called by the root manager *only* on mainnet to propagate the aggregate root\\n   */\\n  function sendMessage(bytes memory _data, bytes memory _encodedData) external payable onlyRootManager {\\n    _sendMessage(_data, _encodedData);\\n    emit MessageSent(_data, _encodedData, msg.sender);\\n  }\\n}\\n\",\"keccak256\":\"0xc35621419ca872ed0550b0943a577b39942f3d2c9b54de008fee382d5ad290e4\",\"license\":\"MIT OR Apache-2.0\"},\"contracts/messaging/connectors/wormhole/BaseWormhole.sol\":{\"content\":\"// SPDX-License-Identifier: MIT OR Apache-2.0\\npragma solidity 0.8.17;\\n\\nimport {IWormholeRelayer} from \\\"../../interfaces/ambs/wormhole/IWormholeRelayer.sol\\\";\\n\\nimport {GasCap} from \\\"../GasCap.sol\\\";\\n\\nabstract contract BaseWormhole is GasCap {\\n  // ============ Events ============\\n\\n  event RefundAddressUpdated(address indexed previous, address indexed updated);\\n\\n  // ============ Storage ============\\n  /**\\n   * @notice The wormhole id for the mirror network\\n   */\\n  uint16 public immutable MIRROR_WORMHOLE_ID;\\n\\n  /**\\n   * @notice The address on this chain any refunds from wormhole fees will be\\n   * sent to\\n   */\\n  address public refundAddress;\\n\\n  /**\\n   * @notice Mapping of processed messages from wormhole.\\n   * @dev Used for replay protection.\\n   */\\n  mapping(bytes32 => bool) public processedWhMessages;\\n\\n  // ============ Constructor ============\\n  constructor(uint256 _gasCap, uint16 _mirrorWormholeChainId) GasCap(_gasCap) {\\n    MIRROR_WORMHOLE_ID = _mirrorWormholeChainId;\\n    _setRefundAddress(msg.sender);\\n  }\\n\\n  // ============ Admin fns ============\\n  /**\\n   * @notice Allows the owner to set a new address to collect excess wormhole fees.\\n   * @param _updated The updated refund address\\n   */\\n  function setRefundAddress(address _updated) public onlyOwner {\\n    _setRefundAddress(_updated);\\n  }\\n\\n  // ============ Public fns ============\\n\\n  /**\\n   * @dev calculcate gas to call `receiveWormholeMessages` on target chain\\n   * https://github.com/wormhole-foundation/wormhole/blob/main/ethereum/contracts/relayer/deliveryProvider/DeliveryProvider.sol\\n   */\\n  function quoteEVMDeliveryPrice(uint256 _gasLimit, address _amb) public view returns (uint256 _cost) {\\n    // First Get the gas, if it is more than the cap use the cap\\n    // And calculcate delievery price with gasCap\\n    (_cost, ) = IWormholeRelayer(_amb).quoteEVMDeliveryPrice(MIRROR_WORMHOLE_ID, 0, _getGas(_gasLimit));\\n  }\\n\\n  // ============ Private fns ============\\n\\n  function _setRefundAddress(address _updated) internal {\\n    require(_updated != refundAddress, \\\"!changed\\\");\\n    emit RefundAddressUpdated(refundAddress, _updated);\\n    refundAddress = _updated;\\n  }\\n\\n  /**\\n   * @dev Asserts the sender of a cross domain message\\n   */\\n  function _verifySender(address _mirrorConnector, address _expected) internal pure returns (bool) {\\n    return _mirrorConnector == _expected;\\n  }\\n\\n  // DO NOT override _processMessage, should revert from `Connector` class. All messages must use the _processMessageFrom function\\n  /**\\n   * @notice This function is called to handle incoming messages. Should store the latest\\n   * root generated on the l2 domain.\\n   */\\n  function _processMessageFrom(address _sender, bytes memory _data) internal virtual;\\n\\n  /**\\n   * @notice Performs sanity checks specific to receiving wormhole messages.\\n   * @dev Checks the sender is the AMB, the chain is the mirror, and replay.\\n   */\\n  function _wormholeSanityChecks(uint16 _sourceChain, address _amb, bytes32 _deliveryHash) internal {\\n    require(_sourceChain == MIRROR_WORMHOLE_ID, \\\"!source chain\\\");\\n    require(msg.sender == _amb, \\\"!relayer\\\");\\n\\n    // Check that the VAA hasn't already been processed (replay protection)\\n    require(!processedWhMessages[_deliveryHash], \\\"already processed\\\");\\n\\n    // Add the VAA to processed messages so it can't be replayed\\n    // you can alternatively rely on the replay protection\\n    // of something like transferWithPayload from the Token Bridge module\\n    processedWhMessages[_deliveryHash] = true;\\n  }\\n\\n  /**\\n   * @dev send message via wormhole.\\n   * https://book.wormhole.com/technical/evm/relayer.html#sending-messages\\n   */\\n  function _sendMessage(\\n    address _amb,\\n    address _mirrorConnector,\\n    bytes memory _data,\\n    bytes memory _encodedData\\n  ) internal {\\n    // Should always be sending a merkle root\\n    require(_data.length == 32, \\\"!data length\\\");\\n\\n    // Should include gas limit info in specialized calldata\\n    require(_encodedData.length == 32, \\\"!encoded data length\\\");\\n\\n    //calculate cost to deliver message\\n    uint256 gasLimit = abi.decode(_encodedData, (uint256));\\n    uint256 deliveryCost = quoteEVMDeliveryPrice(gasLimit, _amb);\\n    require(deliveryCost == msg.value, \\\"!msg.value\\\");\\n\\n    // publish delivery request\\n    IWormholeRelayer(_amb).sendPayloadToEvm{value: deliveryCost}(\\n      MIRROR_WORMHOLE_ID,\\n      _mirrorConnector,\\n      _data,\\n      0,\\n      gasLimit,\\n      MIRROR_WORMHOLE_ID, // refundChain\\n      refundAddress // refundAddress\\n    );\\n  }\\n\\n  /**\\n   * @notice Converts from wormhole 32 byte identifier format to evm address\\n   */\\n  function _fromWormholeFormat(bytes32 _whFormatAddress) internal pure returns (address) {\\n    require(uint256(_whFormatAddress) >> 160 == 0, \\\"!evm address\\\");\\n    return address(uint160(uint256(_whFormatAddress)));\\n  }\\n}\\n\",\"keccak256\":\"0x4499e417c5c476aff8fdfd68e01bd92077c9fdd0e7b4bb941a2f348cc3c4cdd4\",\"license\":\"MIT OR Apache-2.0\"},\"contracts/messaging/connectors/wormhole/WormholeHubConnector.sol\":{\"content\":\"// SPDX-License-Identifier: MIT OR Apache-2.0\\npragma solidity 0.8.17;\\n\\nimport {IRootManager} from \\\"../../interfaces/IRootManager.sol\\\";\\nimport {IWormholeReceiver} from \\\"../../interfaces/ambs/wormhole/IWormholeReceiver.sol\\\";\\n\\nimport {HubConnector, Connector} from \\\"../HubConnector.sol\\\";\\n\\nimport {BaseWormhole} from \\\"./BaseWormhole.sol\\\";\\n\\ncontract WormholeHubConnector is HubConnector, BaseWormhole, IWormholeReceiver {\\n  // ============ Constructor ============\\n  constructor(\\n    uint32 _domain,\\n    uint32 _mirrorDomain,\\n    address _amb,\\n    address _rootManager,\\n    address _mirrorConnector,\\n    uint256 _gasCap,\\n    uint16 _mirrorWormholeChainId\\n  )\\n    HubConnector(_domain, _mirrorDomain, _amb, _rootManager, _mirrorConnector)\\n    BaseWormhole(_gasCap, _mirrorWormholeChainId)\\n  {}\\n\\n  // ============ Override Fns ============\\n  function _verifySender(address _expected) internal view override returns (bool) {\\n    return _verifySender(mirrorConnector, _expected);\\n  }\\n\\n  // ============ Public fns ============\\n  /**\\n   * @notice This function is called to receive messages through the wormhole relayer module\\n   * https://book.wormhole.com/technical/evm/relayer.html\\n   * @dev This is defined here instead of the `BaseWormhole` to avoid storing AMB values twice.\\n   */\\n  function receiveWormholeMessages(\\n    bytes memory _payload,\\n    bytes[] memory, // additionalVaas,\\n    bytes32 _sourceAddress,\\n    uint16 _sourceChain,\\n    bytes32 _deliveryHash\\n  ) public payable override {\\n    _wormholeSanityChecks(_sourceChain, AMB, _deliveryHash);\\n\\n    _processMessageFrom(_fromWormholeFormat(_sourceAddress), _payload);\\n  }\\n\\n  // ============ Private fns ============\\n  /**\\n   * @dev Handles an incoming `outboundRoot`\\n   */\\n  function _processMessageFrom(address _sender, bytes memory _data) internal override(BaseWormhole) {\\n    // enforce this came from connector on l2\\n    require(_verifySender(_sender), \\\"!l2Connector\\\");\\n\\n    // get the data (should be the outbound root)\\n    require(_data.length == 32, \\\"!length\\\");\\n\\n    // set the outbound root for BSC domain\\n    IRootManager(ROOT_MANAGER).aggregate(MIRROR_DOMAIN, bytes32(_data));\\n\\n    emit MessageProcessed(_data, msg.sender);\\n  }\\n\\n  function _sendMessage(bytes memory _data, bytes memory _encodedData) internal override {\\n    _sendMessage(AMB, mirrorConnector, _data, _encodedData);\\n  }\\n}\\n\",\"keccak256\":\"0xaece8ff814a098399414a5a3a752c8d491a19bf18b365a7c1babca271510fdbb\",\"license\":\"MIT OR Apache-2.0\"},\"contracts/messaging/interfaces/IConnector.sol\":{\"content\":\"// SPDX-License-Identifier: MIT OR Apache-2.0\\npragma solidity 0.8.17;\\n\\nimport {IProposedOwnable} from \\\"../../shared/interfaces/IProposedOwnable.sol\\\";\\n\\n/**\\n * @notice This interface is what the Connext contract will send and receive messages through.\\n * The messaging layer should conform to this interface, and should be interchangeable (i.e.\\n * could be Nomad or a generic AMB under the hood).\\n *\\n * @dev This uses the nomad format to ensure nomad can be added in as it comes back online.\\n *\\n * Flow from transfer from polygon to optimism:\\n * 1. User calls `xcall` with destination specified\\n * 2. This will swap in to the bridge assets\\n * 3. The swapped assets will get burned\\n * 4. The Connext contract will call `dispatch` on the messaging contract to add the transfer\\n *    to the root\\n * 5. [At some time interval] Relayers call `send` to send the current root from polygon to\\n *    mainnet. This is done on all \\\"spoke\\\" domains.\\n * 6. [At some time interval] Relayers call `propagate` [better name] on mainnet, this generates a new merkle\\n *    root from all of the AMBs\\n *    - This function must be able to read root data from all AMBs and aggregate them into a single merkle\\n *      tree root\\n *    - Will send the mixed root from all chains back through the respective AMBs to all other chains\\n * 7. AMB will call `update` to update the latest root on the messaging contract on spoke domains\\n * 8. [At any point] Relayers can call `proveAndProcess` to prove inclusion of dispatched message, and call\\n *    process on the `Connext` contract\\n * 9. Takes minted bridge tokens and credits the LP\\n *\\n * AMB requirements:\\n * - Access `msg.sender` both from mainnet -> spoke and vice versa\\n * - Ability to read *our root* from the AMB\\n *\\n * AMBs:\\n * - PoS bridge from polygon\\n * - arbitrum bridge\\n * - optimism bridge\\n * - gnosis chain\\n * - bsc (use multichain for messaging)\\n */\\ninterface IConnector is IProposedOwnable {\\n  // ============ Events ============\\n  /**\\n   * @notice Emitted whenever a message is successfully sent over an AMB\\n   * @param data The contents of the message\\n   * @param encodedData Data used to send the message; specific to connector\\n   * @param caller Who called the function (sent the message)\\n   */\\n  event MessageSent(bytes data, bytes encodedData, address caller);\\n\\n  /**\\n   * @notice Emitted whenever a message is successfully received over an AMB\\n   * @param data The contents of the message\\n   * @param caller Who called the function\\n   */\\n  event MessageProcessed(bytes data, address caller);\\n\\n  // ============ Public fns ============\\n\\n  function processMessage(bytes memory _data) external;\\n\\n  function verifySender(address _expected) external returns (bool);\\n}\\n\",\"keccak256\":\"0xfba166354b442fa72b05be07aed38400b47f68498e8dfdd94fc43df00c401ed1\",\"license\":\"MIT OR Apache-2.0\"},\"contracts/messaging/interfaces/IRootManager.sol\":{\"content\":\"// SPDX-License-Identifier: MIT OR Apache-2.0\\npragma solidity 0.8.17;\\n\\ninterface IRootManager {\\n  /**\\n   * @notice This is called by relayers to generate + send the mixed root from mainnet via AMB to\\n   * spoke domains.\\n   * @dev This must read information for the root from the registered AMBs.\\n   */\\n  function propagate(\\n    address[] calldata _connectors,\\n    uint256[] calldata _fees,\\n    bytes[] memory _encodedData\\n  ) external payable;\\n\\n  /**\\n   * @notice Called by the connectors for various domains on the hub to aggregate their latest\\n   * inbound root.\\n   * @dev This must read information for the root from the registered AMBs\\n   */\\n  function aggregate(uint32 _domain, bytes32 _outbound) external;\\n}\\n\",\"keccak256\":\"0xa895dfaa4baad37a636e7e7e7da72a0a4badfd2d3d8256f975e5101cd5a98236\",\"license\":\"MIT OR Apache-2.0\"},\"contracts/messaging/interfaces/ambs/wormhole/IWormholeReceiver.sol\":{\"content\":\"// SPDX-License-Identifier: Apache 2\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @notice Interface for a contract which can receive Wormhole messages.\\n */\\ninterface IWormholeReceiver {\\n  /**\\n   * @notice When a `send` is performed with this contract as the target, this function will be\\n   *     invoked by the WormholeRelayer contract\\n   *\\n   * NOTE: This function should be restricted such that only the Wormhole Relayer contract can call it.\\n   *\\n   * We also recommend that this function:\\n   *   - Stores all received `deliveryHash`s in a mapping `(bytes32 => bool)`, and\\n   *       on every call, checks that deliveryHash has not already been stored in the\\n   *       map (This is to prevent other users maliciously trying to relay the same message)\\n   *   - Checks that `sourceChain` and `sourceAddress` are indeed who\\n   *       you expect to have requested the calling of `send` or `forward` on the source chain\\n   *\\n   * The invocation of this function corresponding to the `send` request will have msg.value equal\\n   *   to the receiverValue specified in the send request.\\n   *\\n   * If the invocation of this function reverts or exceeds the gas limit\\n   *   specified by the send requester, this delivery will result in a `ReceiverFailure`.\\n   *\\n   * @param payload - an arbitrary message which was included in the delivery by the\\n   *     requester.\\n   * @param additionalVaas - Additional VAAs which were requested to be included in this delivery.\\n   *   They are guaranteed to all be included and in the same order as was specified in the\\n   *     delivery request.\\n   * @param sourceAddress - the (wormhole format) address on the sending chain which requested\\n   *     this delivery.\\n   * @param sourceChain - the wormhole chain ID where this delivery was requested.\\n   * @param deliveryHash - the VAA hash of the deliveryVAA.\\n   *\\n   * NOTE: These signedVaas are NOT verified by the Wormhole core contract prior to being provided\\n   *     to this call. Always make sure `parseAndVerify()` is called on the Wormhole core contract\\n   *     before trusting the content of a raw VAA, otherwise the VAA may be invalid or malicious.\\n   */\\n  function receiveWormholeMessages(\\n    bytes memory payload,\\n    bytes[] memory additionalVaas,\\n    bytes32 sourceAddress,\\n    uint16 sourceChain,\\n    bytes32 deliveryHash\\n  ) external payable;\\n}\\n\",\"keccak256\":\"0xc34fa3395bbbfceb401bc4f2070ad42f7b80e6404a0944ca575397194816c2fb\",\"license\":\"Apache 2\"},\"contracts/messaging/interfaces/ambs/wormhole/IWormholeRelayer.sol\":{\"content\":\"// SPDX-License-Identifier: Apache 2\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title WormholeRelayer\\n * @author\\n * @notice This project allows developers to build cross-chain applications powered by Wormhole without needing to\\n * write and run their own relaying infrastructure\\n *\\n * We implement the IWormholeRelayer interface that allows users to request a delivery provider to relay a payload (and/or additional VAAs)\\n * to a chain and address of their choice.\\n */\\n\\n/**\\n * @notice VaaKey identifies a wormhole message\\n *\\n * @custom:member chainId Wormhole chain ID of the chain where this VAA was emitted from\\n * @custom:member emitterAddress Address of the emitter of the VAA, in Wormhole bytes32 format\\n * @custom:member sequence Sequence number of the VAA\\n */\\nstruct VaaKey {\\n  uint16 chainId;\\n  bytes32 emitterAddress;\\n  uint64 sequence;\\n}\\n\\ninterface IWormholeRelayerBase {\\n  event SendEvent(uint64 indexed sequence, uint256 deliveryQuote, uint256 paymentForExtraReceiverValue);\\n\\n  function getRegisteredWormholeRelayerContract(uint16 chainId) external view returns (bytes32);\\n}\\n\\n/**\\n * @title IWormholeRelayerSend\\n * @notice The interface to request deliveries\\n */\\ninterface IWormholeRelayerSend is IWormholeRelayerBase {\\n  /**\\n   * @notice Publishes an instruction for the default delivery provider\\n   * to relay a payload to the address `targetAddress` on chain `targetChain`\\n   * with gas limit `gasLimit` and `msg.value` equal to `receiverValue`\\n   *\\n   * `targetAddress` must implement the IWormholeReceiver interface\\n   *\\n   * This function must be called with `msg.value` equal to `quoteEVMDeliveryPrice(targetChain, receiverValue, gasLimit)`\\n   *\\n   * Any refunds (from leftover gas) will be paid to the delivery provider. In order to receive the refunds, use the `sendPayloadToEvm` function\\n   * with `refundChain` and `refundAddress` as parameters\\n   *\\n   * @param targetChain in Wormhole Chain ID format\\n   * @param targetAddress address to call on targetChain (that implements IWormholeReceiver)\\n   * @param payload arbitrary bytes to pass in as parameter in call to `targetAddress`\\n   * @param receiverValue msg.value that delivery provider should pass in for call to `targetAddress` (in targetChain currency units)\\n   * @param gasLimit gas limit with which to call `targetAddress`.\\n   * @return sequence sequence number of published VAA containing delivery instructions\\n   */\\n  function sendPayloadToEvm(\\n    uint16 targetChain,\\n    address targetAddress,\\n    bytes memory payload,\\n    uint256 receiverValue,\\n    uint256 gasLimit\\n  ) external payable returns (uint64 sequence);\\n\\n  /**\\n   * @notice Publishes an instruction for the default delivery provider\\n   * to relay a payload to the address `targetAddress` on chain `targetChain`\\n   * with gas limit `gasLimit` and `msg.value` equal to `receiverValue`\\n   *\\n   * Any refunds (from leftover gas) will be sent to `refundAddress` on chain `refundChain`\\n   * `targetAddress` must implement the IWormholeReceiver interface\\n   *\\n   * This function must be called with `msg.value` equal to `quoteEVMDeliveryPrice(targetChain, receiverValue, gasLimit)`\\n   *\\n   * @param targetChain in Wormhole Chain ID format\\n   * @param targetAddress address to call on targetChain (that implements IWormholeReceiver)\\n   * @param payload arbitrary bytes to pass in as parameter in call to `targetAddress`\\n   * @param receiverValue msg.value that delivery provider should pass in for call to `targetAddress` (in targetChain currency units)\\n   * @param gasLimit gas limit with which to call `targetAddress`. Any units of gas unused will be refunded according to the\\n   *        `targetChainRefundPerGasUnused` rate quoted by the delivery provider\\n   * @param refundChain The chain to deliver any refund to, in Wormhole Chain ID format\\n   * @param refundAddress The address on `refundChain` to deliver any refund to\\n   * @return sequence sequence number of published VAA containing delivery instructions\\n   */\\n  function sendPayloadToEvm(\\n    uint16 targetChain,\\n    address targetAddress,\\n    bytes memory payload,\\n    uint256 receiverValue,\\n    uint256 gasLimit,\\n    uint16 refundChain,\\n    address refundAddress\\n  ) external payable returns (uint64 sequence);\\n\\n  /**\\n   * @notice Publishes an instruction for the default delivery provider\\n   * to relay a payload and VAAs specified by `vaaKeys` to the address `targetAddress` on chain `targetChain`\\n   * with gas limit `gasLimit` and `msg.value` equal to `receiverValue`\\n   *\\n   * `targetAddress` must implement the IWormholeReceiver interface\\n   *\\n   * This function must be called with `msg.value` equal to `quoteEVMDeliveryPrice(targetChain, receiverValue, gasLimit)`\\n   *\\n   * Any refunds (from leftover gas) will be paid to the delivery provider. In order to receive the refunds, use the `sendVaasToEvm` function\\n   * with `refundChain` and `refundAddress` as parameters\\n   *\\n   * @param targetChain in Wormhole Chain ID format\\n   * @param targetAddress address to call on targetChain (that implements IWormholeReceiver)\\n   * @param payload arbitrary bytes to pass in as parameter in call to `targetAddress`\\n   * @param receiverValue msg.value that delivery provider should pass in for call to `targetAddress` (in targetChain currency units)\\n   * @param gasLimit gas limit with which to call `targetAddress`.\\n   * @param vaaKeys Additional VAAs to pass in as parameter in call to `targetAddress`\\n   * @return sequence sequence number of published VAA containing delivery instructions\\n   */\\n  function sendVaasToEvm(\\n    uint16 targetChain,\\n    address targetAddress,\\n    bytes memory payload,\\n    uint256 receiverValue,\\n    uint256 gasLimit,\\n    VaaKey[] memory vaaKeys\\n  ) external payable returns (uint64 sequence);\\n\\n  /**\\n   * @notice Publishes an instruction for the default delivery provider\\n   * to relay a payload and VAAs specified by `vaaKeys` to the address `targetAddress` on chain `targetChain`\\n   * with gas limit `gasLimit` and `msg.value` equal to `receiverValue`\\n   *\\n   * Any refunds (from leftover gas) will be sent to `refundAddress` on chain `refundChain`\\n   * `targetAddress` must implement the IWormholeReceiver interface\\n   *\\n   * This function must be called with `msg.value` equal to `quoteEVMDeliveryPrice(targetChain, receiverValue, gasLimit)`\\n   *\\n   * @param targetChain in Wormhole Chain ID format\\n   * @param targetAddress address to call on targetChain (that implements IWormholeReceiver)\\n   * @param payload arbitrary bytes to pass in as parameter in call to `targetAddress`\\n   * @param receiverValue msg.value that delivery provider should pass in for call to `targetAddress` (in targetChain currency units)\\n   * @param gasLimit gas limit with which to call `targetAddress`. Any units of gas unused will be refunded according to the\\n   *        `targetChainRefundPerGasUnused` rate quoted by the delivery provider\\n   * @param vaaKeys Additional VAAs to pass in as parameter in call to `targetAddress`\\n   * @param refundChain The chain to deliver any refund to, in Wormhole Chain ID format\\n   * @param refundAddress The address on `refundChain` to deliver any refund to\\n   * @return sequence sequence number of published VAA containing delivery instructions\\n   */\\n  function sendVaasToEvm(\\n    uint16 targetChain,\\n    address targetAddress,\\n    bytes memory payload,\\n    uint256 receiverValue,\\n    uint256 gasLimit,\\n    VaaKey[] memory vaaKeys,\\n    uint16 refundChain,\\n    address refundAddress\\n  ) external payable returns (uint64 sequence);\\n\\n  /**\\n   * @notice Publishes an instruction for the delivery provider at `deliveryProviderAddress`\\n   * to relay a payload and VAAs specified by `vaaKeys` to the address `targetAddress` on chain `targetChain`\\n   * with gas limit `gasLimit` and `msg.value` equal to\\n   * receiverValue + (arbitrary amount that is paid for by paymentForExtraReceiverValue of this chain's wei) in targetChain wei.\\n   *\\n   * Any refunds (from leftover gas) will be sent to `refundAddress` on chain `refundChain`\\n   * `targetAddress` must implement the IWormholeReceiver interface\\n   *\\n   * This function must be called with `msg.value` equal to\\n   * quoteEVMDeliveryPrice(targetChain, receiverValue, gasLimit, deliveryProviderAddress) + paymentForExtraReceiverValue\\n   *\\n   * @param targetChain in Wormhole Chain ID format\\n   * @param targetAddress address to call on targetChain (that implements IWormholeReceiver)\\n   * @param payload arbitrary bytes to pass in as parameter in call to `targetAddress`\\n   * @param receiverValue msg.value that delivery provider should pass in for call to `targetAddress` (in targetChain currency units)\\n   * @param paymentForExtraReceiverValue amount (in current chain currency units) to spend on extra receiverValue\\n   *        (in addition to the `receiverValue` specified)\\n   * @param gasLimit gas limit with which to call `targetAddress`. Any units of gas unused will be refunded according to the\\n   *        `targetChainRefundPerGasUnused` rate quoted by the delivery provider\\n   * @param refundChain The chain to deliver any refund to, in Wormhole Chain ID format\\n   * @param refundAddress The address on `refundChain` to deliver any refund to\\n   * @param deliveryProviderAddress The address of the desired delivery provider's implementation of IDeliveryProvider\\n   * @param vaaKeys Additional VAAs to pass in as parameter in call to `targetAddress`\\n   * @param consistencyLevel Consistency level with which to publish the delivery instructions - see\\n   *        https://book.wormhole.com/wormhole/3_coreLayerContracts.html?highlight=consistency#consistency-levels\\n   * @return sequence sequence number of published VAA containing delivery instructions\\n   */\\n  function sendToEvm(\\n    uint16 targetChain,\\n    address targetAddress,\\n    bytes memory payload,\\n    uint256 receiverValue,\\n    uint256 paymentForExtraReceiverValue,\\n    uint256 gasLimit,\\n    uint16 refundChain,\\n    address refundAddress,\\n    address deliveryProviderAddress,\\n    VaaKey[] memory vaaKeys,\\n    uint8 consistencyLevel\\n  ) external payable returns (uint64 sequence);\\n\\n  /**\\n   * @notice Publishes an instruction for the delivery provider at `deliveryProviderAddress`\\n   * to relay a payload and VAAs specified by `vaaKeys` to the address `targetAddress` on chain `targetChain`\\n   * with `msg.value` equal to\\n   * receiverValue + (arbitrary amount that is paid for by paymentForExtraReceiverValue of this chain's wei) in targetChain wei.\\n   *\\n   * Any refunds (from leftover gas) will be sent to `refundAddress` on chain `refundChain`\\n   * `targetAddress` must implement the IWormholeReceiver interface\\n   *\\n   * This function must be called with `msg.value` equal to\\n   * quoteDeliveryPrice(targetChain, receiverValue, encodedExecutionParameters, deliveryProviderAddress) + paymentForExtraReceiverValue\\n   *\\n   * @param targetChain in Wormhole Chain ID format\\n   * @param targetAddress address to call on targetChain (that implements IWormholeReceiver), in Wormhole bytes32 format\\n   * @param payload arbitrary bytes to pass in as parameter in call to `targetAddress`\\n   * @param receiverValue msg.value that delivery provider should pass in for call to `targetAddress` (in targetChain currency units)\\n   * @param paymentForExtraReceiverValue amount (in current chain currency units) to spend on extra receiverValue\\n   *        (in addition to the `receiverValue` specified)\\n   * @param encodedExecutionParameters encoded information on how to execute delivery that may impact pricing\\n   *        e.g. for version EVM_V1, this is a struct that encodes the `gasLimit` with which to call `targetAddress`\\n   * @param refundChain The chain to deliver any refund to, in Wormhole Chain ID format\\n   * @param refundAddress The address on `refundChain` to deliver any refund to, in Wormhole bytes32 format\\n   * @param deliveryProviderAddress The address of the desired delivery provider's implementation of IDeliveryProvider\\n   * @param vaaKeys Additional VAAs to pass in as parameter in call to `targetAddress`\\n   * @param consistencyLevel Consistency level with which to publish the delivery instructions - see\\n   *        https://book.wormhole.com/wormhole/3_coreLayerContracts.html?highlight=consistency#consistency-levels\\n   * @return sequence sequence number of published VAA containing delivery instructions\\n   */\\n  function send(\\n    uint16 targetChain,\\n    bytes32 targetAddress,\\n    bytes memory payload,\\n    uint256 receiverValue,\\n    uint256 paymentForExtraReceiverValue,\\n    bytes memory encodedExecutionParameters,\\n    uint16 refundChain,\\n    bytes32 refundAddress,\\n    address deliveryProviderAddress,\\n    VaaKey[] memory vaaKeys,\\n    uint8 consistencyLevel\\n  ) external payable returns (uint64 sequence);\\n\\n  /**\\n   * @notice Performs the same function as a `send`, except:\\n   * 1)  Can only be used during a delivery (i.e. in execution of `receiveWormholeMessages`)\\n   * 2)  Is paid for (along with any other calls to forward) by (any msg.value passed in) + (refund leftover from current delivery)\\n   * 3)  Only executes after `receiveWormholeMessages` is completed (and thus does not return a sequence number)\\n   *\\n   * The refund from the delivery currently in progress will not be sent to the user; it will instead\\n   * be paid to the delivery provider to perform the instruction specified here\\n   *\\n   * Publishes an instruction for the same delivery provider (or default, if the same one doesn't support the new target chain)\\n   * to relay a payload to the address `targetAddress` on chain `targetChain`\\n   * with gas limit `gasLimit` and with `msg.value` equal to `receiverValue`\\n   *\\n   * The following equation must be satisfied (sum_f indicates summing over all forwards requested in `receiveWormholeMessages`):\\n   * (refund amount from current execution of receiveWormholeMessages) + sum_f [msg.value_f]\\n   * >= sum_f [quoteEVMDeliveryPrice(targetChain_f, receiverValue_f, gasLimit_f)]\\n   *\\n   * The difference between the two sides of the above inequality will be added to `paymentForExtraReceiverValue` of the first forward requested\\n   *\\n   * Any refunds (from leftover gas) from this forward will be paid to the same refundChain and refundAddress specified for the current delivery.\\n   *\\n   * @param targetChain in Wormhole Chain ID format\\n   * @param targetAddress address to call on targetChain (that implements IWormholeReceiver), in Wormhole bytes32 format\\n   * @param payload arbitrary bytes to pass in as parameter in call to `targetAddress`\\n   * @param receiverValue msg.value that delivery provider should pass in for call to `targetAddress` (in targetChain currency units)\\n   * @param gasLimit gas limit with which to call `targetAddress`.\\n   */\\n  function forwardPayloadToEvm(\\n    uint16 targetChain,\\n    address targetAddress,\\n    bytes memory payload,\\n    uint256 receiverValue,\\n    uint256 gasLimit\\n  ) external payable;\\n\\n  /**\\n   * @notice Performs the same function as a `send`, except:\\n   * 1)  Can only be used during a delivery (i.e. in execution of `receiveWormholeMessages`)\\n   * 2)  Is paid for (along with any other calls to forward) by (any msg.value passed in) + (refund leftover from current delivery)\\n   * 3)  Only executes after `receiveWormholeMessages` is completed (and thus does not return a sequence number)\\n   *\\n   * The refund from the delivery currently in progress will not be sent to the user; it will instead\\n   * be paid to the delivery provider to perform the instruction specified here\\n   *\\n   * Publishes an instruction for the same delivery provider (or default, if the same one doesn't support the new target chain)\\n   * to relay a payload and VAAs specified by `vaaKeys` to the address `targetAddress` on chain `targetChain`\\n   * with gas limit `gasLimit` and with `msg.value` equal to `receiverValue`\\n   *\\n   * The following equation must be satisfied (sum_f indicates summing over all forwards requested in `receiveWormholeMessages`):\\n   * (refund amount from current execution of receiveWormholeMessages) + sum_f [msg.value_f]\\n   * >= sum_f [quoteEVMDeliveryPrice(targetChain_f, receiverValue_f, gasLimit_f)]\\n   *\\n   * The difference between the two sides of the above inequality will be added to `paymentForExtraReceiverValue` of the first forward requested\\n   *\\n   * Any refunds (from leftover gas) from this forward will be paid to the same refundChain and refundAddress specified for the current delivery.\\n   *\\n   * @param targetChain in Wormhole Chain ID format\\n   * @param targetAddress address to call on targetChain (that implements IWormholeReceiver), in Wormhole bytes32 format\\n   * @param payload arbitrary bytes to pass in as parameter in call to `targetAddress`\\n   * @param receiverValue msg.value that delivery provider should pass in for call to `targetAddress` (in targetChain currency units)\\n   * @param gasLimit gas limit with which to call `targetAddress`.\\n   * @param vaaKeys Additional VAAs to pass in as parameter in call to `targetAddress`\\n   */\\n  function forwardVaasToEvm(\\n    uint16 targetChain,\\n    address targetAddress,\\n    bytes memory payload,\\n    uint256 receiverValue,\\n    uint256 gasLimit,\\n    VaaKey[] memory vaaKeys\\n  ) external payable;\\n\\n  /**\\n   * @notice Performs the same function as a `send`, except:\\n   * 1)  Can only be used during a delivery (i.e. in execution of `receiveWormholeMessages`)\\n   * 2)  Is paid for (along with any other calls to forward) by (any msg.value passed in) + (refund leftover from current delivery)\\n   * 3)  Only executes after `receiveWormholeMessages` is completed (and thus does not return a sequence number)\\n   *\\n   * The refund from the delivery currently in progress will not be sent to the user; it will instead\\n   * be paid to the delivery provider to perform the instruction specified here\\n   *\\n   * Publishes an instruction for the delivery provider at `deliveryProviderAddress`\\n   * to relay a payload and VAAs specified by `vaaKeys` to the address `targetAddress` on chain `targetChain`\\n   * with gas limit `gasLimit` and with `msg.value` equal to\\n   * receiverValue + (arbitrary amount that is paid for by paymentForExtraReceiverValue of this chain's wei) in targetChain wei.\\n   *\\n   * Any refunds (from leftover gas) will be sent to `refundAddress` on chain `refundChain`\\n   * `targetAddress` must implement the IWormholeReceiver interface\\n   *\\n   * The following equation must be satisfied (sum_f indicates summing over all forwards requested in `receiveWormholeMessages`):\\n   * (refund amount from current execution of receiveWormholeMessages) + sum_f [msg.value_f]\\n   * >= sum_f [quoteEVMDeliveryPrice(targetChain_f, receiverValue_f, gasLimit_f, deliveryProviderAddress_f) + paymentForExtraReceiverValue_f]\\n   *\\n   * The difference between the two sides of the above inequality will be added to `paymentForExtraReceiverValue` of the first forward requested\\n   *\\n   * @param targetChain in Wormhole Chain ID format\\n   * @param targetAddress address to call on targetChain (that implements IWormholeReceiver), in Wormhole bytes32 format\\n   * @param payload arbitrary bytes to pass in as parameter in call to `targetAddress`\\n   * @param receiverValue msg.value that delivery provider should pass in for call to `targetAddress` (in targetChain currency units)\\n   * @param paymentForExtraReceiverValue amount (in current chain currency units) to spend on extra receiverValue\\n   *        (in addition to the `receiverValue` specified)\\n   * @param gasLimit gas limit with which to call `targetAddress`. Any units of gas unused will be refunded according to the\\n   *        `targetChainRefundPerGasUnused` rate quoted by the delivery provider\\n   * @param refundChain The chain to deliver any refund to, in Wormhole Chain ID format\\n   * @param refundAddress The address on `refundChain` to deliver any refund to, in Wormhole bytes32 format\\n   * @param deliveryProviderAddress The address of the desired delivery provider's implementation of IDeliveryProvider\\n   * @param vaaKeys Additional VAAs to pass in as parameter in call to `targetAddress`\\n   * @param consistencyLevel Consistency level with which to publish the delivery instructions - see\\n   *        https://book.wormhole.com/wormhole/3_coreLayerContracts.html?highlight=consistency#consistency-levels\\n   */\\n  function forwardToEvm(\\n    uint16 targetChain,\\n    address targetAddress,\\n    bytes memory payload,\\n    uint256 receiverValue,\\n    uint256 paymentForExtraReceiverValue,\\n    uint256 gasLimit,\\n    uint16 refundChain,\\n    address refundAddress,\\n    address deliveryProviderAddress,\\n    VaaKey[] memory vaaKeys,\\n    uint8 consistencyLevel\\n  ) external payable;\\n\\n  /**\\n   * @notice Performs the same function as a `send`, except:\\n   * 1)  Can only be used during a delivery (i.e. in execution of `receiveWormholeMessages`)\\n   * 2)  Is paid for (along with any other calls to forward) by (any msg.value passed in) + (refund leftover from current delivery)\\n   * 3)  Only executes after `receiveWormholeMessages` is completed (and thus does not return a sequence number)\\n   *\\n   * The refund from the delivery currently in progress will not be sent to the user; it will instead\\n   * be paid to the delivery provider to perform the instruction specified here\\n   *\\n   * Publishes an instruction for the delivery provider at `deliveryProviderAddress`\\n   * to relay a payload and VAAs specified by `vaaKeys` to the address `targetAddress` on chain `targetChain`\\n   * with `msg.value` equal to\\n   * receiverValue + (arbitrary amount that is paid for by paymentForExtraReceiverValue of this chain's wei) in targetChain wei.\\n   *\\n   * Any refunds (from leftover gas) will be sent to `refundAddress` on chain `refundChain`\\n   * `targetAddress` must implement the IWormholeReceiver interface\\n   *\\n   * The following equation must be satisfied (sum_f indicates summing over all forwards requested in `receiveWormholeMessages`):\\n   * (refund amount from current execution of receiveWormholeMessages) + sum_f [msg.value_f]\\n   * >= sum_f [quoteDeliveryPrice(targetChain_f, receiverValue_f, encodedExecutionParameters_f, deliveryProviderAddress_f) + paymentForExtraReceiverValue_f]\\n   *\\n   * The difference between the two sides of the above inequality will be added to `paymentForExtraReceiverValue` of the first forward requested\\n   *\\n   * @param targetChain in Wormhole Chain ID format\\n   * @param targetAddress address to call on targetChain (that implements IWormholeReceiver), in Wormhole bytes32 format\\n   * @param payload arbitrary bytes to pass in as parameter in call to `targetAddress`\\n   * @param receiverValue msg.value that delivery provider should pass in for call to `targetAddress` (in targetChain currency units)\\n   * @param paymentForExtraReceiverValue amount (in current chain currency units) to spend on extra receiverValue\\n   *        (in addition to the `receiverValue` specified)\\n   * @param encodedExecutionParameters encoded information on how to execute delivery that may impact pricing\\n   *        e.g. for version EVM_V1, this is a struct that encodes the `gasLimit` with which to call `targetAddress`\\n   * @param refundChain The chain to deliver any refund to, in Wormhole Chain ID format\\n   * @param refundAddress The address on `refundChain` to deliver any refund to, in Wormhole bytes32 format\\n   * @param deliveryProviderAddress The address of the desired delivery provider's implementation of IDeliveryProvider\\n   * @param vaaKeys Additional VAAs to pass in as parameter in call to `targetAddress`\\n   * @param consistencyLevel Consistency level with which to publish the delivery instructions - see\\n   *        https://book.wormhole.com/wormhole/3_coreLayerContracts.html?highlight=consistency#consistency-levels\\n   */\\n  function forward(\\n    uint16 targetChain,\\n    bytes32 targetAddress,\\n    bytes memory payload,\\n    uint256 receiverValue,\\n    uint256 paymentForExtraReceiverValue,\\n    bytes memory encodedExecutionParameters,\\n    uint16 refundChain,\\n    bytes32 refundAddress,\\n    address deliveryProviderAddress,\\n    VaaKey[] memory vaaKeys,\\n    uint8 consistencyLevel\\n  ) external payable;\\n\\n  /**\\n   * @notice Requests a previously published delivery instruction to be redelivered\\n   * (e.g. with a different delivery provider)\\n   *\\n   * This function must be called with `msg.value` equal to\\n   * quoteEVMDeliveryPrice(targetChain, newReceiverValue, newGasLimit, newDeliveryProviderAddress)\\n   *\\n   * @param deliveryVaaKey VaaKey identifying the wormhole message containing the\\n   *        previously published delivery instructions\\n   * @param targetChain The target chain that the original delivery targeted. Must match targetChain from original delivery instructions\\n   * @param newReceiverValue new msg.value that delivery provider should pass in for call to `targetAddress` (in targetChain currency units)\\n   * @param newGasLimit gas limit with which to call `targetAddress`. Any units of gas unused will be refunded according to the\\n   *        `targetChainRefundPerGasUnused` rate quoted by the delivery provider, to the refund chain and address specified in the original request\\n   * @param newDeliveryProviderAddress The address of the desired delivery provider's implementation of IDeliveryProvider\\n   * @return sequence sequence number of published VAA containing redelivery instructions\\n   */\\n  function resendToEvm(\\n    VaaKey memory deliveryVaaKey,\\n    uint16 targetChain,\\n    uint256 newReceiverValue,\\n    uint256 newGasLimit,\\n    address newDeliveryProviderAddress\\n  ) external payable returns (uint64 sequence);\\n\\n  /**\\n   * @notice Requests a previously published delivery instruction to be redelivered\\n   *\\n   *\\n   * This function must be called with `msg.value` equal to\\n   * quoteDeliveryPrice(targetChain, newReceiverValue, newEncodedExecutionParameters, newDeliveryProviderAddress)\\n   *\\n   * @param deliveryVaaKey VaaKey identifying the wormhole message containing the\\n   *        previously published delivery instructions\\n   * @param targetChain The target chain that the original delivery targeted. Must match targetChain from original delivery instructions\\n   * @param newReceiverValue new msg.value that delivery provider should pass in for call to `targetAddress` (in targetChain currency units)\\n   * @param newEncodedExecutionParameters new encoded information on how to execute delivery that may impact pricing\\n   *        e.g. for version EVM_V1, this is a struct that encodes the `gasLimit` with which to call `targetAddress`\\n   * @param newDeliveryProviderAddress The address of the desired delivery provider's implementation of IDeliveryProvider\\n   * @return sequence sequence number of published VAA containing redelivery instructions\\n   */\\n  function resend(\\n    VaaKey memory deliveryVaaKey,\\n    uint16 targetChain,\\n    uint256 newReceiverValue,\\n    bytes memory newEncodedExecutionParameters,\\n    address newDeliveryProviderAddress\\n  ) external payable returns (uint64 sequence);\\n\\n  /**\\n   * @notice Returns the price to request a relay to chain `targetChain`, using the default delivery provider\\n   *\\n   * @param targetChain in Wormhole Chain ID format\\n   * @param receiverValue msg.value that delivery provider should pass in for call to `targetAddress` (in targetChain currency units)\\n   * @param gasLimit gas limit with which to call `targetAddress`.\\n   * @return nativePriceQuote Price, in units of current chain currency, that the delivery provider charges to perform the relay\\n   * @return targetChainRefundPerGasUnused amount of target chain currency that will be refunded per unit of gas unused,\\n   *         if a refundAddress is specified\\n   */\\n  function quoteEVMDeliveryPrice(\\n    uint16 targetChain,\\n    uint256 receiverValue,\\n    uint256 gasLimit\\n  ) external view returns (uint256 nativePriceQuote, uint256 targetChainRefundPerGasUnused);\\n\\n  /**\\n   * @notice Returns the price to request a relay to chain `targetChain`, using delivery provider `deliveryProviderAddress`\\n   *\\n   * @param targetChain in Wormhole Chain ID format\\n   * @param receiverValue msg.value that delivery provider should pass in for call to `targetAddress` (in targetChain currency units)\\n   * @param gasLimit gas limit with which to call `targetAddress`.\\n   * @param deliveryProviderAddress The address of the desired delivery provider's implementation of IDeliveryProvider\\n   * @return nativePriceQuote Price, in units of current chain currency, that the delivery provider charges to perform the relay\\n   * @return targetChainRefundPerGasUnused amount of target chain currency that will be refunded per unit of gas unused,\\n   *         if a refundAddress is specified\\n   */\\n  function quoteEVMDeliveryPrice(\\n    uint16 targetChain,\\n    uint256 receiverValue,\\n    uint256 gasLimit,\\n    address deliveryProviderAddress\\n  ) external view returns (uint256 nativePriceQuote, uint256 targetChainRefundPerGasUnused);\\n\\n  /**\\n   * @notice Returns the price to request a relay to chain `targetChain`, using delivery provider `deliveryProviderAddress`\\n   *\\n   * @param targetChain in Wormhole Chain ID format\\n   * @param receiverValue msg.value that delivery provider should pass in for call to `targetAddress` (in targetChain currency units)\\n   * @param encodedExecutionParameters encoded information on how to execute delivery that may impact pricing\\n   *        e.g. for version EVM_V1, this is a struct that encodes the `gasLimit` with which to call `targetAddress`\\n   * @param deliveryProviderAddress The address of the desired delivery provider's implementation of IDeliveryProvider\\n   * @return nativePriceQuote Price, in units of current chain currency, that the delivery provider charges to perform the relay\\n   * @return encodedExecutionInfo encoded information on how the delivery will be executed\\n   *        e.g. for version EVM_V1, this is a struct that encodes the `gasLimit` and `targetChainRefundPerGasUnused`\\n   *             (which is the amount of target chain currency that will be refunded per unit of gas unused,\\n   *              if a refundAddress is specified)\\n   */\\n  function quoteDeliveryPrice(\\n    uint16 targetChain,\\n    uint256 receiverValue,\\n    bytes memory encodedExecutionParameters,\\n    address deliveryProviderAddress\\n  ) external view returns (uint256 nativePriceQuote, bytes memory encodedExecutionInfo);\\n\\n  /**\\n   * @notice Returns the (extra) amount of target chain currency that `targetAddress`\\n   * will be called with, if the `paymentForExtraReceiverValue` field is set to `currentChainAmount`\\n   *\\n   * @param targetChain in Wormhole Chain ID format\\n   * @param currentChainAmount The value that `paymentForExtraReceiverValue` will be set to\\n   * @param deliveryProviderAddress The address of the desired delivery provider's implementation of IDeliveryProvider\\n   * @return targetChainAmount The amount such that if `targetAddress` will be called with `msg.value` equal to\\n   *         receiverValue + targetChainAmount\\n   */\\n  function quoteNativeForChain(\\n    uint16 targetChain,\\n    uint256 currentChainAmount,\\n    address deliveryProviderAddress\\n  ) external view returns (uint256 targetChainAmount);\\n\\n  /**\\n   * @notice Returns the address of the current default delivery provider\\n   * @return deliveryProvider The address of (the default delivery provider)'s contract on this source\\n   *   chain. This must be a contract that implements IDeliveryProvider.\\n   */\\n  function getDefaultDeliveryProvider() external view returns (address deliveryProvider);\\n}\\n\\n/**\\n * @title IWormholeRelayerDelivery\\n * @notice The interface to execute deliveries. Only relevant for Delivery Providers\\n */\\ninterface IWormholeRelayerDelivery is IWormholeRelayerBase {\\n  enum DeliveryStatus {\\n    SUCCESS,\\n    RECEIVER_FAILURE,\\n    FORWARD_REQUEST_FAILURE,\\n    FORWARD_REQUEST_SUCCESS\\n  }\\n\\n  enum RefundStatus {\\n    REFUND_SENT,\\n    REFUND_FAIL,\\n    CROSS_CHAIN_REFUND_SENT,\\n    CROSS_CHAIN_REFUND_FAIL_PROVIDER_NOT_SUPPORTED,\\n    CROSS_CHAIN_REFUND_FAIL_NOT_ENOUGH\\n  }\\n\\n  /**\\n   * @custom:member recipientContract - The target contract address\\n   * @custom:member sourceChain - The chain which this delivery was requested from (in wormhole\\n   *     ChainID format)\\n   * @custom:member sequence - The wormhole sequence number of the delivery VAA on the source chain\\n   *     corresponding to this delivery request\\n   * @custom:member deliveryVaaHash - The hash of the delivery VAA corresponding to this delivery\\n   *     request\\n   * @custom:member gasUsed - The amount of gas that was used to call your target contract\\n   * @custom:member status:\\n   *   - RECEIVER_FAILURE, if the target contract reverts\\n   *   - SUCCESS, if the target contract doesn't revert and no forwards were requested\\n   *   - FORWARD_REQUEST_FAILURE, if the target contract doesn't revert, forwards were requested,\\n   *       but provided/leftover funds were not sufficient to cover them all\\n   *   - FORWARD_REQUEST_SUCCESS, if the target contract doesn't revert and all forwards are covered\\n   * @custom:member additionalStatusInfo:\\n   *   - If status is SUCCESS or FORWARD_REQUEST_SUCCESS, then this is empty.\\n   *   - If status is RECEIVER_FAILURE, this is `RETURNDATA_TRUNCATION_THRESHOLD` bytes of the\\n   *       return data (i.e. potentially truncated revert reason information).\\n   *   - If status is FORWARD_REQUEST_FAILURE, this is also the revert data - the reason the forward failed.\\n   *     This will be either an encoded Cancelled, DeliveryProviderReverted, or DeliveryProviderPaymentFailed error\\n   * @custom:member refundStatus - Result of the refund. REFUND_SUCCESS or REFUND_FAIL are for\\n   *     refunds where targetChain=refundChain; the others are for targetChain!=refundChain,\\n   *     where a cross chain refund is necessary\\n   * @custom:member overridesInfo:\\n   *   - If not an override: empty bytes array\\n   *   - Otherwise: An encoded `DeliveryOverride`\\n   */\\n  event Delivery(\\n    address indexed recipientContract,\\n    uint16 indexed sourceChain,\\n    uint64 indexed sequence,\\n    bytes32 deliveryVaaHash,\\n    DeliveryStatus status,\\n    uint256 gasUsed,\\n    RefundStatus refundStatus,\\n    bytes additionalStatusInfo,\\n    bytes overridesInfo\\n  );\\n\\n  /**\\n   * @notice The delivery provider calls `deliver` to relay messages as described by one delivery instruction\\n   *\\n   * The delivery provider must pass in the specified (by VaaKeys[]) signed wormhole messages (VAAs) from the source chain\\n   * as well as the signed wormhole message with the delivery instructions (the delivery VAA)\\n   *\\n   * The messages will be relayed to the target address (with the specified gas limit and receiver value) iff the following checks are met:\\n   * - the delivery VAA has a valid signature\\n   * - the delivery VAA's emitter is one of these WormholeRelayer contracts\\n   * - the delivery provider passed in at least enough of this chain's currency as msg.value (enough meaning the maximum possible refund)\\n   * - the instruction's target chain is this chain\\n   * - the relayed signed VAAs match the descriptions in container.messages (the VAA hashes match, or the emitter address, sequence number pair matches, depending on the description given)\\n   *\\n   * @param encodedVMs - An array of signed wormhole messages (all from the same source chain\\n   *     transaction)\\n   * @param encodedDeliveryVAA - Signed wormhole message from the source chain's WormholeRelayer\\n   *     contract with payload being the encoded delivery instruction container\\n   * @param relayerRefundAddress - The address to which any refunds to the delivery provider\\n   *     should be sent\\n   * @param deliveryOverrides - Optional overrides field which must be either an empty bytes array or\\n   *     an encoded DeliveryOverride struct\\n   */\\n  function deliver(\\n    bytes[] memory encodedVMs,\\n    bytes memory encodedDeliveryVAA,\\n    address payable relayerRefundAddress,\\n    bytes memory deliveryOverrides\\n  ) external payable;\\n}\\n\\ninterface IWormholeRelayer is IWormholeRelayerDelivery, IWormholeRelayerSend {}\\n\\n/*\\n *  Errors thrown by IWormholeRelayer contract\\n */\\n\\n// Bound chosen by the following formula: `memoryWord * 4 + selectorSize`.\\n// This means that an error identifier plus four fixed size arguments should be available to developers.\\n// In the case of a `require` revert with error message, this should provide 2 memory word's worth of data.\\nuint256 constant RETURNDATA_TRUNCATION_THRESHOLD = 132;\\n\\n//When msg.value was not equal to `delivery provider's quoted delivery price` + `paymentForExtraReceiverValue`\\nerror InvalidMsgValue(uint256 msgValue, uint256 totalFee);\\n\\nerror RequestedGasLimitTooLow();\\n\\nerror DeliveryProviderDoesNotSupportTargetChain(address relayer, uint16 chainId);\\nerror DeliveryProviderCannotReceivePayment();\\n\\n//When calling `forward()` on the WormholeRelayer if no delivery is in progress\\nerror NoDeliveryInProgress();\\n//When calling `delivery()` a second time even though a delivery is already in progress\\nerror ReentrantDelivery(address msgSender, address lockedBy);\\n//When any other contract but the delivery target calls `forward()` on the WormholeRelayer while a\\n//  delivery is in progress\\nerror ForwardRequestFromWrongAddress(address msgSender, address deliveryTarget);\\n\\nerror InvalidPayloadId(uint8 parsed, uint8 expected);\\nerror InvalidPayloadLength(uint256 received, uint256 expected);\\nerror InvalidVaaKeyType(uint8 parsed);\\n\\nerror InvalidDeliveryVaa(string reason);\\n//When the delivery VAA (signed wormhole message with delivery instructions) was not emitted by the\\n//  registered WormholeRelayer contract\\nerror InvalidEmitter(bytes32 emitter, bytes32 registered, uint16 chainId);\\nerror VaaKeysLengthDoesNotMatchVaasLength(uint256 keys, uint256 vaas);\\nerror VaaKeysDoNotMatchVaas(uint8 index);\\n//When someone tries to call an external function of the WormholeRelayer that is only intended to be\\n//  called by the WormholeRelayer itself (to allow retroactive reverts for atomicity)\\nerror RequesterNotWormholeRelayer();\\n\\n//When trying to relay a `DeliveryInstruction` to any other chain but the one it was specified for\\nerror TargetChainIsNotThisChain(uint16 targetChain);\\nerror ForwardNotSufficientlyFunded(uint256 amountOfFunds, uint256 amountOfFundsNeeded);\\n//When a `DeliveryOverride` contains a gas limit that's less than the original\\nerror InvalidOverrideGasLimit();\\n//When a `DeliveryOverride` contains a receiver value that's less than the original\\nerror InvalidOverrideReceiverValue();\\n//When a `DeliveryOverride` contains a 'refund per unit of gas unused' that's less than the original\\nerror InvalidOverrideRefundPerGasUnused();\\n\\n//When the delivery provider doesn't pass in sufficient funds (i.e. msg.value does not cover the\\n// maximum possible refund to the user)\\nerror InsufficientRelayerFunds(uint256 msgValue, uint256 minimum);\\n\\n//When a bytes32 field can't be converted into a 20 byte EVM address, because the 12 padding bytes\\n//  are non-zero (duplicated from Utils.sol)\\nerror NotAnEvmAddress(bytes32);\\n\",\"keccak256\":\"0x93361f2586d3ae96bf07c4e5843ad779347f4178c23b66f240431f3a0f9b3faf\",\"license\":\"Apache 2\"},\"contracts/shared/ProposedOwnable.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.17;\\n\\nimport {IProposedOwnable} from \\\"./interfaces/IProposedOwnable.sol\\\";\\n\\n/**\\n * @title ProposedOwnable\\n * @notice Contract module which provides a basic access control mechanism,\\n * where there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed via a two step process:\\n * 1. Call `proposeOwner`\\n * 2. Wait out the delay period\\n * 3. Call `acceptOwner`\\n *\\n * @dev This module is used through inheritance. It will make available the\\n * modifier `onlyOwner`, which can be applied to your functions to restrict\\n * their use to the owner.\\n *\\n * @dev The majority of this code was taken from the openzeppelin Ownable\\n * contract\\n *\\n */\\nabstract contract ProposedOwnable is IProposedOwnable {\\n  // ========== Custom Errors ===========\\n\\n  error ProposedOwnable__onlyOwner_notOwner();\\n  error ProposedOwnable__onlyProposed_notProposedOwner();\\n  error ProposedOwnable__ownershipDelayElapsed_delayNotElapsed();\\n  error ProposedOwnable__proposeNewOwner_invalidProposal();\\n  error ProposedOwnable__proposeNewOwner_noOwnershipChange();\\n  error ProposedOwnable__renounceOwnership_noProposal();\\n  error ProposedOwnable__renounceOwnership_invalidProposal();\\n\\n  // ============ Properties ============\\n\\n  address private _owner;\\n\\n  address private _proposed;\\n  uint256 private _proposedOwnershipTimestamp;\\n\\n  uint256 private constant _delay = 7 days;\\n\\n  // ======== Getters =========\\n\\n  /**\\n   * @notice Returns the address of the current owner.\\n   */\\n  function owner() public view virtual returns (address) {\\n    return _owner;\\n  }\\n\\n  /**\\n   * @notice Returns the address of the proposed owner.\\n   */\\n  function proposed() public view virtual returns (address) {\\n    return _proposed;\\n  }\\n\\n  /**\\n   * @notice Returns the address of the proposed owner.\\n   */\\n  function proposedTimestamp() public view virtual returns (uint256) {\\n    return _proposedOwnershipTimestamp;\\n  }\\n\\n  /**\\n   * @notice Returns the delay period before a new owner can be accepted.\\n   */\\n  function delay() public view virtual returns (uint256) {\\n    return _delay;\\n  }\\n\\n  /**\\n   * @notice Throws if called by any account other than the owner.\\n   */\\n  modifier onlyOwner() {\\n    if (_owner != msg.sender) revert ProposedOwnable__onlyOwner_notOwner();\\n    _;\\n  }\\n\\n  /**\\n   * @notice Throws if called by any account other than the proposed owner.\\n   */\\n  modifier onlyProposed() {\\n    if (_proposed != msg.sender) revert ProposedOwnable__onlyProposed_notProposedOwner();\\n    _;\\n  }\\n\\n  /**\\n   * @notice Throws if the ownership delay has not elapsed\\n   */\\n  modifier ownershipDelayElapsed() {\\n    // Ensure delay has elapsed\\n    if ((block.timestamp - _proposedOwnershipTimestamp) <= _delay)\\n      revert ProposedOwnable__ownershipDelayElapsed_delayNotElapsed();\\n    _;\\n  }\\n\\n  /**\\n   * @notice Indicates if the ownership has been renounced() by\\n   * checking if current owner is address(0)\\n   */\\n  function renounced() public view returns (bool) {\\n    return _owner == address(0);\\n  }\\n\\n  // ======== External =========\\n\\n  /**\\n   * @notice Sets the timestamp for an owner to be proposed, and sets the\\n   * newly proposed owner as step 1 in a 2-step process\\n   */\\n  function proposeNewOwner(address newlyProposed) public virtual onlyOwner {\\n    // Contract as source of truth\\n    if (_proposed == newlyProposed && _proposedOwnershipTimestamp != 0)\\n      revert ProposedOwnable__proposeNewOwner_invalidProposal();\\n\\n    // Sanity check: reasonable proposal\\n    if (_owner == newlyProposed) revert ProposedOwnable__proposeNewOwner_noOwnershipChange();\\n\\n    _setProposed(newlyProposed);\\n  }\\n\\n  /**\\n   * @notice Renounces ownership of the contract after a delay\\n   */\\n  function renounceOwnership() public virtual onlyOwner ownershipDelayElapsed {\\n    // Ensure there has been a proposal cycle started\\n    if (_proposedOwnershipTimestamp == 0) revert ProposedOwnable__renounceOwnership_noProposal();\\n\\n    // Require proposed is set to 0\\n    if (_proposed != address(0)) revert ProposedOwnable__renounceOwnership_invalidProposal();\\n\\n    // Emit event, set new owner, reset timestamp\\n    _setOwner(address(0));\\n  }\\n\\n  /**\\n   * @notice Transfers ownership of the contract to a new account (`newOwner`).\\n   * Can only be called by the current owner.\\n   */\\n  function acceptProposedOwner() public virtual onlyProposed ownershipDelayElapsed {\\n    // NOTE: no need to check if _owner == _proposed, because the _proposed\\n    // is 0-d out and this check is implicitly enforced by modifier\\n\\n    // NOTE: no need to check if _proposedOwnershipTimestamp > 0 because\\n    // the only time this would happen is if the _proposed was never\\n    // set (will fail from modifier) or if the owner == _proposed (checked\\n    // above)\\n\\n    // Emit event, set new owner, reset timestamp\\n    _setOwner(_proposed);\\n  }\\n\\n  // ======== Internal =========\\n\\n  function _setOwner(address newOwner) internal {\\n    emit OwnershipTransferred(_owner, newOwner);\\n    _owner = newOwner;\\n    delete _proposedOwnershipTimestamp;\\n    delete _proposed;\\n  }\\n\\n  function _setProposed(address newlyProposed) private {\\n    _proposedOwnershipTimestamp = block.timestamp;\\n    _proposed = newlyProposed;\\n    emit OwnershipProposed(newlyProposed);\\n  }\\n}\\n\",\"keccak256\":\"0xa96eff4fdff55ffa29cda5c18285a9af04c3cbaf55f83696085cdd2251a8d6c0\",\"license\":\"UNLICENSED\"},\"contracts/shared/interfaces/IProposedOwnable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\n/**\\n * @title IProposedOwnable\\n * @notice Defines a minimal interface for ownership with a two step proposal and acceptance\\n * process\\n */\\ninterface IProposedOwnable {\\n  /**\\n   * @dev This emits when change in ownership of a contract is proposed.\\n   */\\n  event OwnershipProposed(address indexed proposedOwner);\\n\\n  /**\\n   * @dev This emits when ownership of a contract changes.\\n   */\\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n  /**\\n   * @notice Get the address of the owner\\n   * @return owner_ The address of the owner.\\n   */\\n  function owner() external view returns (address owner_);\\n\\n  /**\\n   * @notice Get the address of the proposed owner\\n   * @return proposed_ The address of the proposed.\\n   */\\n  function proposed() external view returns (address proposed_);\\n\\n  /**\\n   * @notice Set the address of the proposed owner of the contract\\n   * @param newlyProposed The proposed new owner of the contract\\n   */\\n  function proposeNewOwner(address newlyProposed) external;\\n\\n  /**\\n   * @notice Set the address of the proposed owner of the contract\\n   */\\n  function acceptProposedOwner() external;\\n}\\n\",\"keccak256\":\"0x4ec1aa589d37d0c1eac9966e26d2d3540d1661b81763e678f14d2c6fa0682323\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x6101206040523480156200001257600080fd5b5060405162001a2038038062001a2083398101604081905262000035916200039b565b818181898989898984848484846200004d33620001b3565b8463ffffffff16600003620000985760405162461bcd60e51b815260206004820152600c60248201526b32b6b83a3c903237b6b0b4b760a11b60448201526064015b60405180910390fd5b6001600160a01b038216620000e45760405162461bcd60e51b815260206004820152601160248201527032b6b83a3c903937b7ba26b0b730b3b2b960791b60448201526064016200008f565b63ffffffff8086166080526001600160a01b0380851660a05283811660c05290851660e0528116156200011c576200011c8162000218565b604080516001600160a01b0385811682528481166020830152831681830152905163ffffffff86811692908816917f4f9c27c2fe3f84576ea469d367d044da53c45e951617e8389f2b5ed8db9d25f09181900360600190a3505050505050505050506200018f816200028160201b60201c565b5061ffff811661010052620001a433620002c2565b50505050505050505062000431565b600080546040516001600160a01b03808516939216917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e091a3600080546001600160a01b039092166001600160a01b0319928316178155600255600180549091169055565b600354604080516001600160a01b03928316815291831660208301527fc77bec288fc88f168427f2f7da682eadb26cac89d8d591af6e443da98dff2bbc910160405180910390a1600380546001600160a01b0319166001600160a01b0392909216919091179055565b60045460408051918252602082018390527f877a02cb809da0364d23adca3cd50c451b53f279d3df632e1fc11eb66335bce5910160405180910390a1600455565b6005546001600160a01b03908116908216036200030d5760405162461bcd60e51b81526020600482015260086024820152670858da185b99d95960c21b60448201526064016200008f565b6005546040516001600160a01b038084169216907f57b5839c3435f5b2eb2d2e286fb44ca7303d01d9b25a5d9c05c489523474285990600090a3600580546001600160a01b0319166001600160a01b0392909216919091179055565b805163ffffffff811681146200037e57600080fd5b919050565b80516001600160a01b03811681146200037e57600080fd5b600080600080600080600060e0888a031215620003b757600080fd5b620003c28862000369565b9650620003d26020890162000369565b9550620003e26040890162000383565b9450620003f26060890162000383565b9350620004026080890162000383565b925060a0880151915060c088015161ffff811681146200042157600080fd5b8091505092959891949750929550565b60805160a05160c05160e0516101005161156b620004b560003960008181610255015281816105e501528181610abe01526110080152600081816101aa0152610cc9015260008181610375015281816105280152610ca20152600081816104a401528181610691015281816107320152610a5901526000610321015261156b6000f3fe60806040526004361061014f5760003560e01c80635f61e3ec116100b6578063c5b350df1161006f578063c5b350df14610420578063cc39428314610435578063d1851c9214610455578063d232c22014610473578063d69f9d6114610492578063db1b7659146104c657600080fd5b80635f61e3ec146103635780636a42b8f814610397578063715018a6146103ad5780637850b020146103c25780638da5cb5b146103e2578063b1f8100d1461040057600080fd5b806348e6fa231161010857806348e6fa23146102a95780634d93538b146102bc5780634ff746f6146102dc578063529dca32146102fc57806352a9674b1461030f5780635bd11efc1461034357600080fd5b80630cb61f6c1461015b578063141684161461019857806315b75bea146101e157806318c8170914610203578063194ea996146102435780633cf52ffb1461028a57600080fd5b3661015657005b600080fd5b34801561016757600080fd5b5060055461017b906001600160a01b031681565b6040516001600160a01b0390911681526020015b60405180910390f35b3480156101a457600080fd5b506101cc7f000000000000000000000000000000000000000000000000000000000000000081565b60405163ffffffff909116815260200161018f565b3480156101ed57600080fd5b506102016101fc3660046110a5565b6104e6565b005b34801561020f57600080fd5b5061023361021e3660046110c7565b60066020526000908152604090205460ff1681565b604051901515815260200161018f565b34801561024f57600080fd5b506102777f000000000000000000000000000000000000000000000000000000000000000081565b60405161ffff909116815260200161018f565b34801561029657600080fd5b506002545b60405190815260200161018f565b6102016102b7366004611197565b61051d565b3480156102c857600080fd5b5061029b6102d73660046111fb565b6105d2565b3480156102e857600080fd5b506102016102f7366004611227565b610686565b61020161030a366004611276565b61072c565b34801561031b57600080fd5b506101cc7f000000000000000000000000000000000000000000000000000000000000000081565b34801561034f57600080fd5b5061020161035e3660046110a5565b610770565b34801561036f57600080fd5b5061017b7f000000000000000000000000000000000000000000000000000000000000000081565b3480156103a357600080fd5b5062093a8061029b565b3480156103b957600080fd5b506102016107a4565b3480156103ce57600080fd5b506102016103dd3660046110c7565b610858565b3480156103ee57600080fd5b506000546001600160a01b031661017b565b34801561040c57600080fd5b5061020161041b3660046110a5565b61088c565b34801561042c57600080fd5b5061020161092a565b34801561044157600080fd5b5060035461017b906001600160a01b031681565b34801561046157600080fd5b506001546001600160a01b031661017b565b34801561047f57600080fd5b506000546001600160a01b031615610233565b34801561049e57600080fd5b5061017b7f000000000000000000000000000000000000000000000000000000000000000081565b3480156104d257600080fd5b506102336104e13660046110a5565b61099a565b6000546001600160a01b03163314610511576040516311a8a1bb60e31b815260040160405180910390fd5b61051a816109ab565b50565b336001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016146105895760405162461bcd60e51b815260206004820152600c60248201526b10b937b7ba26b0b730b3b2b960a11b60448201526064015b60405180910390fd5b6105938282610a50565b7fdcaa37a042a0087de79018c629bbd29cee82ca80bd9be394e1696bf9e93550778282336040516105c6939291906113c5565b60405180910390a15050565b6000816001600160a01b031663c23ee3c37f0000000000000000000000000000000000000000000000000000000000000000600061060f87610a8d565b6040516001600160e01b031960e086901b16815261ffff9093166004840152602483019190915260448201526064016040805180830381865afa15801561065a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061067e9190611403565b509392505050565b336001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016146106e75760405162461bcd60e51b81526004016105809060208082526004908201526310a0a6a160e11b604082015260600190565b6106f081610aa3565b7fb3abc57bfeebd2cac918901db582f71972a8e628bccf19f5ae3e3482b98a5ced8133604051610721929190611427565b60405180910390a150565b610757827f000000000000000000000000000000000000000000000000000000000000000083610abc565b61076961076384610bd6565b86610c19565b5050505050565b6000546001600160a01b0316331461079b576040516311a8a1bb60e31b815260040160405180910390fd5b61051a81610d7e565b6000546001600160a01b031633146107cf576040516311a8a1bb60e31b815260040160405180910390fd5b62093a80600254426107e19190611451565b116107ff576040516324e0285f60e21b815260040160405180910390fd5b60025460000361082257604051630e4b303f60e21b815260040160405180910390fd5b6001546001600160a01b03161561084c576040516323295ef960e01b815260040160405180910390fd5b6108566000610de7565b565b6000546001600160a01b03163314610883576040516311a8a1bb60e31b815260040160405180910390fd5b61051a81610e4c565b6000546001600160a01b031633146108b7576040516311a8a1bb60e31b815260040160405180910390fd5b6001546001600160a01b0382811691161480156108d5575060025415155b156108f3576040516311bc066560e11b815260040160405180910390fd5b6000546001600160a01b0380831691160361092157604051634a2fb73f60e11b815260040160405180910390fd5b61051a81610e8d565b6001546001600160a01b03163314610955576040516311a7f27160e11b815260040160405180910390fd5b62093a80600254426109679190611451565b11610985576040516324e0285f60e21b815260040160405180910390fd5b600154610856906001600160a01b0316610de7565b60006109a582610edb565b92915050565b6005546001600160a01b03908116908216036109f45760405162461bcd60e51b81526020600482015260086024820152670858da185b99d95960c21b6044820152606401610580565b6005546040516001600160a01b038084169216907f57b5839c3435f5b2eb2d2e286fb44ca7303d01d9b25a5d9c05c489523474285990600090a3600580546001600160a01b0319166001600160a01b0392909216919091179055565b600354610a89907f0000000000000000000000000000000000000000000000000000000000000000906001600160a01b03168484610ef4565b5050565b6000600454821115610a9f5760045491505b5090565b6040516316c2fdb560e21b815260040160405180910390fd5b7f000000000000000000000000000000000000000000000000000000000000000061ffff168361ffff1614610b235760405162461bcd60e51b815260206004820152600d60248201526c10b9b7bab931b29031b430b4b760991b6044820152606401610580565b336001600160a01b03831614610b665760405162461bcd60e51b815260206004820152600860248201526710b932b630bcb2b960c11b6044820152606401610580565b60008181526006602052604090205460ff1615610bb95760405162461bcd60e51b8152602060048201526011602482015270185b1c9958591e481c1c9bd8d95cdcd959607a1b6044820152606401610580565b6000908152600660205260409020805460ff191660011790555050565b600060a082901c15610a9f5760405162461bcd60e51b815260206004820152600c60248201526b2165766d206164647265737360a01b6044820152606401610580565b610c2282610edb565b610c5d5760405162461bcd60e51b815260206004820152600c60248201526b10b61921b7b73732b1ba37b960a11b6044820152606401610580565b8051602014610c985760405162461bcd60e51b8152602060048201526007602482015266042d8cadccee8d60cb1b6044820152606401610580565b6001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016638e7d93fa7f0000000000000000000000000000000000000000000000000000000000000000610cf184611472565b6040516001600160e01b031960e085901b16815263ffffffff9290921660048301526024820152604401600060405180830381600087803b158015610d3557600080fd5b505af1158015610d49573d6000803e3d6000fd5b505050507fb3abc57bfeebd2cac918901db582f71972a8e628bccf19f5ae3e3482b98a5ced81336040516105c6929190611427565b600354604080516001600160a01b03928316815291831660208301527fc77bec288fc88f168427f2f7da682eadb26cac89d8d591af6e443da98dff2bbc910160405180910390a1600380546001600160a01b0319166001600160a01b0392909216919091179055565b600080546040516001600160a01b03808516939216917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e091a3600080546001600160a01b039092166001600160a01b0319928316178155600255600180549091169055565b60045460408051918252602082018390527f877a02cb809da0364d23adca3cd50c451b53f279d3df632e1fc11eb66335bce5910160405180910390a1600455565b42600255600180546001600160a01b0319166001600160a01b0383169081179091556040517f6ab4d119f23076e8ad491bc65ce85f017fb0591dce08755ba8591059cc51737a90600090a250565b6003546000906001600160a01b038381169116146109a5565b8151602014610f345760405162461bcd60e51b815260206004820152600c60248201526b042c8c2e8c240d8cadccee8d60a31b6044820152606401610580565b8051602014610f7c5760405162461bcd60e51b8152602060048201526014602482015273042cadcc6dec8cac840c8c2e8c240d8cadccee8d60631b6044820152606401610580565b600081806020019051810190610f929190611499565b90506000610fa082876105d2565b9050348114610fde5760405162461bcd60e51b815260206004820152600a602482015269216d73672e76616c756560b01b6044820152606401610580565b6005546040516312d729bd60e21b81526001600160a01b0380891692634b5ca6f492859261103d927f0000000000000000000000000000000000000000000000000000000000000000928c928c926000928c92879216906004016114b2565b60206040518083038185885af115801561105b573d6000803e3d6000fd5b50505050506040513d601f19601f82011682018060405250810190611080919061150b565b50505050505050565b80356001600160a01b03811681146110a057600080fd5b919050565b6000602082840312156110b757600080fd5b6110c082611089565b9392505050565b6000602082840312156110d957600080fd5b5035919050565b634e487b7160e01b600052604160045260246000fd5b604051601f8201601f1916810167ffffffffffffffff8111828210171561111f5761111f6110e0565b604052919050565b600082601f83011261113857600080fd5b813567ffffffffffffffff811115611152576111526110e0565b611165601f8201601f19166020016110f6565b81815284602083860101111561117a57600080fd5b816020850160208301376000918101602001919091529392505050565b600080604083850312156111aa57600080fd5b823567ffffffffffffffff808211156111c257600080fd5b6111ce86838701611127565b935060208501359150808211156111e457600080fd5b506111f185828601611127565b9150509250929050565b6000806040838503121561120e57600080fd5b8235915061121e60208401611089565b90509250929050565b60006020828403121561123957600080fd5b813567ffffffffffffffff81111561125057600080fd5b61125c84828501611127565b949350505050565b803561ffff811681146110a057600080fd5b600080600080600060a0868803121561128e57600080fd5b853567ffffffffffffffff808211156112a657600080fd5b6112b289838a01611127565b96506020915081880135818111156112c957600080fd5b8801601f81018a136112da57600080fd5b8035828111156112ec576112ec6110e0565b8060051b6112fb8582016110f6565b918252828101850191858101908d84111561131557600080fd5b86850192505b83831015611351578235868111156113335760008081fd5b6113418f8983890101611127565b835250918601919086019061131b565b809a50505050505050506040860135925061136e60608701611264565b949793965091946080013592915050565b6000815180845260005b818110156113a557602081850181015186830182015201611389565b506000602082860101526020601f19601f83011685010191505092915050565b6060815260006113d8606083018661137f565b82810360208401526113ea818661137f565b91505060018060a01b0383166040830152949350505050565b6000806040838503121561141657600080fd5b505080516020909101519092909150565b60408152600061143a604083018561137f565b905060018060a01b03831660208301529392505050565b818103818111156109a557634e487b7160e01b600052601160045260246000fd5b80516020808301519190811015611493576000198160200360031b1b821691505b50919050565b6000602082840312156114ab57600080fd5b5051919050565b600061ffff808a16835260018060a01b03808a16602085015260e060408501526114df60e085018a61137f565b925087606085015286608085015281861660a085015280851660c0850152505098975050505050505050565b60006020828403121561151d57600080fd5b815167ffffffffffffffff811681146110c057600080fdfea26469706673582212207fae5ae139ba9412dd3eb66ea44881835a9cf3d5dfc7e4643f136b945ae492a364736f6c63430008110033",
  "deployedBytecode": "0x60806040526004361061014f5760003560e01c80635f61e3ec116100b6578063c5b350df1161006f578063c5b350df14610420578063cc39428314610435578063d1851c9214610455578063d232c22014610473578063d69f9d6114610492578063db1b7659146104c657600080fd5b80635f61e3ec146103635780636a42b8f814610397578063715018a6146103ad5780637850b020146103c25780638da5cb5b146103e2578063b1f8100d1461040057600080fd5b806348e6fa231161010857806348e6fa23146102a95780634d93538b146102bc5780634ff746f6146102dc578063529dca32146102fc57806352a9674b1461030f5780635bd11efc1461034357600080fd5b80630cb61f6c1461015b578063141684161461019857806315b75bea146101e157806318c8170914610203578063194ea996146102435780633cf52ffb1461028a57600080fd5b3661015657005b600080fd5b34801561016757600080fd5b5060055461017b906001600160a01b031681565b6040516001600160a01b0390911681526020015b60405180910390f35b3480156101a457600080fd5b506101cc7f000000000000000000000000000000000000000000000000000000000000000081565b60405163ffffffff909116815260200161018f565b3480156101ed57600080fd5b506102016101fc3660046110a5565b6104e6565b005b34801561020f57600080fd5b5061023361021e3660046110c7565b60066020526000908152604090205460ff1681565b604051901515815260200161018f565b34801561024f57600080fd5b506102777f000000000000000000000000000000000000000000000000000000000000000081565b60405161ffff909116815260200161018f565b34801561029657600080fd5b506002545b60405190815260200161018f565b6102016102b7366004611197565b61051d565b3480156102c857600080fd5b5061029b6102d73660046111fb565b6105d2565b3480156102e857600080fd5b506102016102f7366004611227565b610686565b61020161030a366004611276565b61072c565b34801561031b57600080fd5b506101cc7f000000000000000000000000000000000000000000000000000000000000000081565b34801561034f57600080fd5b5061020161035e3660046110a5565b610770565b34801561036f57600080fd5b5061017b7f000000000000000000000000000000000000000000000000000000000000000081565b3480156103a357600080fd5b5062093a8061029b565b3480156103b957600080fd5b506102016107a4565b3480156103ce57600080fd5b506102016103dd3660046110c7565b610858565b3480156103ee57600080fd5b506000546001600160a01b031661017b565b34801561040c57600080fd5b5061020161041b3660046110a5565b61088c565b34801561042c57600080fd5b5061020161092a565b34801561044157600080fd5b5060035461017b906001600160a01b031681565b34801561046157600080fd5b506001546001600160a01b031661017b565b34801561047f57600080fd5b506000546001600160a01b031615610233565b34801561049e57600080fd5b5061017b7f000000000000000000000000000000000000000000000000000000000000000081565b3480156104d257600080fd5b506102336104e13660046110a5565b61099a565b6000546001600160a01b03163314610511576040516311a8a1bb60e31b815260040160405180910390fd5b61051a816109ab565b50565b336001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016146105895760405162461bcd60e51b815260206004820152600c60248201526b10b937b7ba26b0b730b3b2b960a11b60448201526064015b60405180910390fd5b6105938282610a50565b7fdcaa37a042a0087de79018c629bbd29cee82ca80bd9be394e1696bf9e93550778282336040516105c6939291906113c5565b60405180910390a15050565b6000816001600160a01b031663c23ee3c37f0000000000000000000000000000000000000000000000000000000000000000600061060f87610a8d565b6040516001600160e01b031960e086901b16815261ffff9093166004840152602483019190915260448201526064016040805180830381865afa15801561065a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061067e9190611403565b509392505050565b336001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016146106e75760405162461bcd60e51b81526004016105809060208082526004908201526310a0a6a160e11b604082015260600190565b6106f081610aa3565b7fb3abc57bfeebd2cac918901db582f71972a8e628bccf19f5ae3e3482b98a5ced8133604051610721929190611427565b60405180910390a150565b610757827f000000000000000000000000000000000000000000000000000000000000000083610abc565b61076961076384610bd6565b86610c19565b5050505050565b6000546001600160a01b0316331461079b576040516311a8a1bb60e31b815260040160405180910390fd5b61051a81610d7e565b6000546001600160a01b031633146107cf576040516311a8a1bb60e31b815260040160405180910390fd5b62093a80600254426107e19190611451565b116107ff576040516324e0285f60e21b815260040160405180910390fd5b60025460000361082257604051630e4b303f60e21b815260040160405180910390fd5b6001546001600160a01b03161561084c576040516323295ef960e01b815260040160405180910390fd5b6108566000610de7565b565b6000546001600160a01b03163314610883576040516311a8a1bb60e31b815260040160405180910390fd5b61051a81610e4c565b6000546001600160a01b031633146108b7576040516311a8a1bb60e31b815260040160405180910390fd5b6001546001600160a01b0382811691161480156108d5575060025415155b156108f3576040516311bc066560e11b815260040160405180910390fd5b6000546001600160a01b0380831691160361092157604051634a2fb73f60e11b815260040160405180910390fd5b61051a81610e8d565b6001546001600160a01b03163314610955576040516311a7f27160e11b815260040160405180910390fd5b62093a80600254426109679190611451565b11610985576040516324e0285f60e21b815260040160405180910390fd5b600154610856906001600160a01b0316610de7565b60006109a582610edb565b92915050565b6005546001600160a01b03908116908216036109f45760405162461bcd60e51b81526020600482015260086024820152670858da185b99d95960c21b6044820152606401610580565b6005546040516001600160a01b038084169216907f57b5839c3435f5b2eb2d2e286fb44ca7303d01d9b25a5d9c05c489523474285990600090a3600580546001600160a01b0319166001600160a01b0392909216919091179055565b600354610a89907f0000000000000000000000000000000000000000000000000000000000000000906001600160a01b03168484610ef4565b5050565b6000600454821115610a9f5760045491505b5090565b6040516316c2fdb560e21b815260040160405180910390fd5b7f000000000000000000000000000000000000000000000000000000000000000061ffff168361ffff1614610b235760405162461bcd60e51b815260206004820152600d60248201526c10b9b7bab931b29031b430b4b760991b6044820152606401610580565b336001600160a01b03831614610b665760405162461bcd60e51b815260206004820152600860248201526710b932b630bcb2b960c11b6044820152606401610580565b60008181526006602052604090205460ff1615610bb95760405162461bcd60e51b8152602060048201526011602482015270185b1c9958591e481c1c9bd8d95cdcd959607a1b6044820152606401610580565b6000908152600660205260409020805460ff191660011790555050565b600060a082901c15610a9f5760405162461bcd60e51b815260206004820152600c60248201526b2165766d206164647265737360a01b6044820152606401610580565b610c2282610edb565b610c5d5760405162461bcd60e51b815260206004820152600c60248201526b10b61921b7b73732b1ba37b960a11b6044820152606401610580565b8051602014610c985760405162461bcd60e51b8152602060048201526007602482015266042d8cadccee8d60cb1b6044820152606401610580565b6001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016638e7d93fa7f0000000000000000000000000000000000000000000000000000000000000000610cf184611472565b6040516001600160e01b031960e085901b16815263ffffffff9290921660048301526024820152604401600060405180830381600087803b158015610d3557600080fd5b505af1158015610d49573d6000803e3d6000fd5b505050507fb3abc57bfeebd2cac918901db582f71972a8e628bccf19f5ae3e3482b98a5ced81336040516105c6929190611427565b600354604080516001600160a01b03928316815291831660208301527fc77bec288fc88f168427f2f7da682eadb26cac89d8d591af6e443da98dff2bbc910160405180910390a1600380546001600160a01b0319166001600160a01b0392909216919091179055565b600080546040516001600160a01b03808516939216917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e091a3600080546001600160a01b039092166001600160a01b0319928316178155600255600180549091169055565b60045460408051918252602082018390527f877a02cb809da0364d23adca3cd50c451b53f279d3df632e1fc11eb66335bce5910160405180910390a1600455565b42600255600180546001600160a01b0319166001600160a01b0383169081179091556040517f6ab4d119f23076e8ad491bc65ce85f017fb0591dce08755ba8591059cc51737a90600090a250565b6003546000906001600160a01b038381169116146109a5565b8151602014610f345760405162461bcd60e51b815260206004820152600c60248201526b042c8c2e8c240d8cadccee8d60a31b6044820152606401610580565b8051602014610f7c5760405162461bcd60e51b8152602060048201526014602482015273042cadcc6dec8cac840c8c2e8c240d8cadccee8d60631b6044820152606401610580565b600081806020019051810190610f929190611499565b90506000610fa082876105d2565b9050348114610fde5760405162461bcd60e51b815260206004820152600a602482015269216d73672e76616c756560b01b6044820152606401610580565b6005546040516312d729bd60e21b81526001600160a01b0380891692634b5ca6f492859261103d927f0000000000000000000000000000000000000000000000000000000000000000928c928c926000928c92879216906004016114b2565b60206040518083038185885af115801561105b573d6000803e3d6000fd5b50505050506040513d601f19601f82011682018060405250810190611080919061150b565b50505050505050565b80356001600160a01b03811681146110a057600080fd5b919050565b6000602082840312156110b757600080fd5b6110c082611089565b9392505050565b6000602082840312156110d957600080fd5b5035919050565b634e487b7160e01b600052604160045260246000fd5b604051601f8201601f1916810167ffffffffffffffff8111828210171561111f5761111f6110e0565b604052919050565b600082601f83011261113857600080fd5b813567ffffffffffffffff811115611152576111526110e0565b611165601f8201601f19166020016110f6565b81815284602083860101111561117a57600080fd5b816020850160208301376000918101602001919091529392505050565b600080604083850312156111aa57600080fd5b823567ffffffffffffffff808211156111c257600080fd5b6111ce86838701611127565b935060208501359150808211156111e457600080fd5b506111f185828601611127565b9150509250929050565b6000806040838503121561120e57600080fd5b8235915061121e60208401611089565b90509250929050565b60006020828403121561123957600080fd5b813567ffffffffffffffff81111561125057600080fd5b61125c84828501611127565b949350505050565b803561ffff811681146110a057600080fd5b600080600080600060a0868803121561128e57600080fd5b853567ffffffffffffffff808211156112a657600080fd5b6112b289838a01611127565b96506020915081880135818111156112c957600080fd5b8801601f81018a136112da57600080fd5b8035828111156112ec576112ec6110e0565b8060051b6112fb8582016110f6565b918252828101850191858101908d84111561131557600080fd5b86850192505b83831015611351578235868111156113335760008081fd5b6113418f8983890101611127565b835250918601919086019061131b565b809a50505050505050506040860135925061136e60608701611264565b949793965091946080013592915050565b6000815180845260005b818110156113a557602081850181015186830182015201611389565b506000602082860101526020601f19601f83011685010191505092915050565b6060815260006113d8606083018661137f565b82810360208401526113ea818661137f565b91505060018060a01b0383166040830152949350505050565b6000806040838503121561141657600080fd5b505080516020909101519092909150565b60408152600061143a604083018561137f565b905060018060a01b03831660208301529392505050565b818103818111156109a557634e487b7160e01b600052601160045260246000fd5b80516020808301519190811015611493576000198160200360031b1b821691505b50919050565b6000602082840312156114ab57600080fd5b5051919050565b600061ffff808a16835260018060a01b03808a16602085015260e060408501526114df60e085018a61137f565b925087606085015286608085015281861660a085015280851660c0850152505098975050505050505050565b60006020828403121561151d57600080fd5b815167ffffffffffffffff811681146110c057600080fdfea26469706673582212207fae5ae139ba9412dd3eb66ea44881835a9cf3d5dfc7e4643f136b945ae492a364736f6c63430008110033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "processMessage(bytes)": {
        "details": "This is called by AMBs to process messages originating from mirror connector"
      },
      "quoteEVMDeliveryPrice(uint256,address)": {
        "details": "calculcate gas to call `receiveWormholeMessages` on target chain https://github.com/wormhole-foundation/wormhole/blob/main/ethereum/contracts/relayer/deliveryProvider/DeliveryProvider.sol"
      },
      "receiveWormholeMessages(bytes,bytes[],bytes32,uint16,bytes32)": {
        "details": "This is defined here instead of the `BaseWormhole` to avoid storing AMB values twice."
      },
      "sendMessage(bytes,bytes)": {
        "details": "This is called by the root manager *only* on mainnet to propagate the aggregate root"
      },
      "setRefundAddress(address)": {
        "params": {
          "_updated": "The updated refund address"
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "events": {
      "GasCapUpdated(uint256,uint256)": {
        "notice": "Emitted when admin updates the gas cap"
      },
      "MessageProcessed(bytes,address)": {
        "notice": "Emitted whenever a message is successfully received over an AMB"
      },
      "MessageSent(bytes,bytes,address)": {
        "notice": "Emitted whenever a message is successfully sent over an AMB"
      }
    },
    "kind": "user",
    "methods": {
      "AMB()": {
        "notice": "Address of the AMB on this domain."
      },
      "DOMAIN()": {
        "notice": "The domain of this Messaging (i.e. Connector) contract."
      },
      "MIRROR_DOMAIN()": {
        "notice": "The domain of the corresponding messaging (i.e. Connector) contract."
      },
      "MIRROR_WORMHOLE_ID()": {
        "notice": "The wormhole id for the mirror network"
      },
      "ROOT_MANAGER()": {
        "notice": "RootManager contract address."
      },
      "acceptProposedOwner()": {
        "notice": "Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."
      },
      "delay()": {
        "notice": "Returns the delay period before a new owner can be accepted."
      },
      "mirrorConnector()": {
        "notice": "Connector on L2 for L1 connectors, and vice versa."
      },
      "owner()": {
        "notice": "Returns the address of the current owner."
      },
      "processMessage(bytes)": {
        "notice": "Processes a message received by an AMB"
      },
      "processedWhMessages(bytes32)": {
        "notice": "Mapping of processed messages from wormhole."
      },
      "proposeNewOwner(address)": {
        "notice": "Sets the timestamp for an owner to be proposed, and sets the newly proposed owner as step 1 in a 2-step process"
      },
      "proposed()": {
        "notice": "Returns the address of the proposed owner."
      },
      "proposedTimestamp()": {
        "notice": "Returns the address of the proposed owner."
      },
      "receiveWormholeMessages(bytes,bytes[],bytes32,uint16,bytes32)": {
        "notice": "This function is called to receive messages through the wormhole relayer module https://book.wormhole.com/technical/evm/relayer.html"
      },
      "refundAddress()": {
        "notice": "The address on this chain any refunds from wormhole fees will be sent to"
      },
      "renounceOwnership()": {
        "notice": "Renounces ownership of the contract after a delay"
      },
      "renounced()": {
        "notice": "Indicates if the ownership has been renounced() by checking if current owner is address(0)"
      },
      "sendMessage(bytes,bytes)": {
        "notice": "Sends a message over the amb"
      },
      "setMirrorConnector(address)": {
        "notice": "Sets the address of the l2Connector for this domain"
      },
      "setRefundAddress(address)": {
        "notice": "Allows the owner to set a new address to collect excess wormhole fees."
      },
      "verifySender(address)": {
        "notice": "Checks the cross domain sender for a given address"
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 43323,
        "contract": "contracts/messaging/connectors/wormhole/WormholeHubConnector.sol:WormholeHubConnector",
        "label": "_owner",
        "offset": 0,
        "slot": "0",
        "type": "t_address"
      },
      {
        "astId": 43325,
        "contract": "contracts/messaging/connectors/wormhole/WormholeHubConnector.sol:WormholeHubConnector",
        "label": "_proposed",
        "offset": 0,
        "slot": "1",
        "type": "t_address"
      },
      {
        "astId": 43327,
        "contract": "contracts/messaging/connectors/wormhole/WormholeHubConnector.sol:WormholeHubConnector",
        "label": "_proposedOwnershipTimestamp",
        "offset": 0,
        "slot": "2",
        "type": "t_uint256"
      },
      {
        "astId": 32363,
        "contract": "contracts/messaging/connectors/wormhole/WormholeHubConnector.sol:WormholeHubConnector",
        "label": "mirrorConnector",
        "offset": 0,
        "slot": "3",
        "type": "t_address"
      },
      {
        "astId": 32613,
        "contract": "contracts/messaging/connectors/wormhole/WormholeHubConnector.sol:WormholeHubConnector",
        "label": "gasCap",
        "offset": 0,
        "slot": "4",
        "type": "t_uint256"
      },
      {
        "astId": 39468,
        "contract": "contracts/messaging/connectors/wormhole/WormholeHubConnector.sol:WormholeHubConnector",
        "label": "refundAddress",
        "offset": 0,
        "slot": "5",
        "type": "t_address"
      },
      {
        "astId": 39473,
        "contract": "contracts/messaging/connectors/wormhole/WormholeHubConnector.sol:WormholeHubConnector",
        "label": "processedWhMessages",
        "offset": 0,
        "slot": "6",
        "type": "t_mapping(t_bytes32,t_bool)"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_bytes32": {
        "encoding": "inplace",
        "label": "bytes32",
        "numberOfBytes": "32"
      },
      "t_mapping(t_bytes32,t_bool)": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => bool)",
        "numberOfBytes": "32",
        "value": "t_bool"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      }
    }
  }
}