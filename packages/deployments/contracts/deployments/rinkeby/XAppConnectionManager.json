{
  "address": "0x3dd9BD00487b2B9639F888c3BC00f3453b62A34b",
  "abi": [
    {
      "inputs": [],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "previousOwner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "OwnershipTransferred",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint32",
          "name": "domain",
          "type": "uint32"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "replica",
          "type": "address"
        }
      ],
      "name": "ReplicaEnrolled",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint32",
          "name": "domain",
          "type": "uint32"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "replica",
          "type": "address"
        }
      ],
      "name": "ReplicaUnenrolled",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint32",
          "name": "domain",
          "type": "uint32"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "watcher",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "bool",
          "name": "access",
          "type": "bool"
        }
      ],
      "name": "WatcherPermissionSet",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "",
          "type": "uint32"
        }
      ],
      "name": "domainToReplica",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "home",
      "outputs": [
        {
          "internalType": "contract Home",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_replica",
          "type": "address"
        }
      ],
      "name": "isReplica",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "localDomain",
      "outputs": [
        {
          "internalType": "uint32",
          "name": "",
          "type": "uint32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "owner",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_replica",
          "type": "address"
        },
        {
          "internalType": "uint32",
          "name": "_domain",
          "type": "uint32"
        }
      ],
      "name": "ownerEnrollReplica",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_replica",
          "type": "address"
        }
      ],
      "name": "ownerUnenrollReplica",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "renounceOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "replicaToDomain",
      "outputs": [
        {
          "internalType": "uint32",
          "name": "",
          "type": "uint32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_home",
          "type": "address"
        }
      ],
      "name": "setHome",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_watcher",
          "type": "address"
        },
        {
          "internalType": "uint32",
          "name": "_domain",
          "type": "uint32"
        },
        {
          "internalType": "bool",
          "name": "_access",
          "type": "bool"
        }
      ],
      "name": "setWatcherPermission",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "transferOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "_domain",
          "type": "uint32"
        },
        {
          "internalType": "bytes32",
          "name": "_updater",
          "type": "bytes32"
        },
        {
          "internalType": "bytes",
          "name": "_signature",
          "type": "bytes"
        }
      ],
      "name": "unenrollReplica",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_watcher",
          "type": "address"
        },
        {
          "internalType": "uint32",
          "name": "_domain",
          "type": "uint32"
        }
      ],
      "name": "watcherPermission",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0xfd4775abf0cee60394d637091e074951df9121948ab67a8515e020f5912ffaca",
  "receipt": {
    "to": null,
    "from": "0x627306090abaB3A6e1400e9345bC60c78a8BEf57",
    "contractAddress": "0x3dd9BD00487b2B9639F888c3BC00f3453b62A34b",
    "transactionIndex": 39,
    "gasUsed": "935956",
    "logsBloom": "0x00000000000000000000000002000000000000000000010000800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000001000000000000000000000000000000000000020000000000000000000800000000000000000000000000000000400000000000000000000000000000000000000000000000000000010000000002000000000000000000000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x1c4b062e847308e5223bf58d0ae48ec2bf0065243210cb3d8b47503fdb999fd4",
    "transactionHash": "0xfd4775abf0cee60394d637091e074951df9121948ab67a8515e020f5912ffaca",
    "logs": [
      {
        "transactionIndex": 39,
        "blockNumber": 10335928,
        "transactionHash": "0xfd4775abf0cee60394d637091e074951df9121948ab67a8515e020f5912ffaca",
        "address": "0x3dd9BD00487b2B9639F888c3BC00f3453b62A34b",
        "topics": [
          "0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x000000000000000000000000627306090abab3a6e1400e9345bc60c78a8bef57"
        ],
        "data": "0x",
        "logIndex": 96,
        "blockHash": "0x1c4b062e847308e5223bf58d0ae48ec2bf0065243210cb3d8b47503fdb999fd4"
      }
    ],
    "blockNumber": 10335928,
    "cumulativeGasUsed": "7389712",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 2,
  "solcInputHash": "1ebbc5c3123c90f00055611021767f70",
  "metadata": "{\"compiler\":{\"version\":\"0.8.11+commit.d7f03943\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"domain\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"replica\",\"type\":\"address\"}],\"name\":\"ReplicaEnrolled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"domain\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"replica\",\"type\":\"address\"}],\"name\":\"ReplicaUnenrolled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"domain\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"watcher\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"access\",\"type\":\"bool\"}],\"name\":\"WatcherPermissionSet\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"name\":\"domainToReplica\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"home\",\"outputs\":[{\"internalType\":\"contract Home\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_replica\",\"type\":\"address\"}],\"name\":\"isReplica\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"localDomain\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_replica\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"_domain\",\"type\":\"uint32\"}],\"name\":\"ownerEnrollReplica\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_replica\",\"type\":\"address\"}],\"name\":\"ownerUnenrollReplica\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"replicaToDomain\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_home\",\"type\":\"address\"}],\"name\":\"setHome\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_watcher\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"_domain\",\"type\":\"uint32\"},{\"internalType\":\"bool\",\"name\":\"_access\",\"type\":\"bool\"}],\"name\":\"setWatcherPermission\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_domain\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"_updater\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"_signature\",\"type\":\"bytes\"}],\"name\":\"unenrollReplica\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_watcher\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"_domain\",\"type\":\"uint32\"}],\"name\":\"watcherPermission\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"author\":\"Illusory Systems Inc.\",\"events\":{\"ReplicaEnrolled(uint32,address)\":{\"params\":{\"domain\":\"the remote domain of the Home contract for the Replica\",\"replica\":\"the address of the Replica\"}},\"ReplicaUnenrolled(uint32,address)\":{\"params\":{\"domain\":\"the remote domain of the Home contract for the Replica\",\"replica\":\"the address of the Replica\"}},\"WatcherPermissionSet(uint32,address,bool)\":{\"params\":{\"access\":\"TRUE if the Watcher was given permissions, FALSE if permissions were removed\",\"domain\":\"the remote domain of the Home contract for the Replica\",\"watcher\":\"the address of the Watcher\"}}},\"kind\":\"dev\",\"methods\":{\"isReplica(address)\":{\"params\":{\"_replica\":\"the replica to check for enrollment\"},\"returns\":{\"_0\":\"TRUE iff _replica is enrolled\"}},\"localDomain()\":{\"returns\":{\"_0\":\"local domain\"}},\"owner()\":{\"details\":\"Returns the address of the current owner.\"},\"ownerEnrollReplica(address,uint32)\":{\"params\":{\"_domain\":\"the remote domain of the Home contract for the Replica\",\"_replica\":\"the address of the Replica\"}},\"ownerUnenrollReplica(address)\":{\"params\":{\"_replica\":\"the address of the Replica\"}},\"renounceOwnership()\":{\"details\":\"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.\"},\"setHome(address)\":{\"params\":{\"_home\":\"the address of the local Home contract\"}},\"setWatcherPermission(address,uint32,bool)\":{\"params\":{\"_access\":\"TRUE to give the Watcher permissions, FALSE to remove permissions\",\"_domain\":\"the remote domain of the Home contract for the Replica\",\"_watcher\":\"the address of the Watcher\"}},\"transferOwnership(address)\":{\"details\":\"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.\"},\"unenrollReplica(uint32,bytes32,bytes)\":{\"details\":\"in the future, if fraud occurs on the Home contract, the Watcher will submit their signature directly to the Home and it can be relayed to all remote chains to un-enroll the Replicas\",\"params\":{\"_domain\":\"the remote domain of the Home contract for the Replica\",\"_signature\":\"signature of watcher on (domain, replica address, updater address)\",\"_updater\":\"the address of the Updater for the Home contract (also stored on Replica)\"}},\"watcherPermission(address,uint32)\":{\"params\":{\"_domain\":\"the domain to check for watcher permissions\",\"_watcher\":\"the address of the watcher\"},\"returns\":{\"_0\":\"TRUE iff _watcher has permission to un-enroll replicas on _domain\"}}},\"title\":\"XAppConnectionManager\",\"version\":1},\"userdoc\":{\"events\":{\"ReplicaEnrolled(uint32,address)\":{\"notice\":\"Emitted when a new Replica is enrolled / added\"},\"ReplicaUnenrolled(uint32,address)\":{\"notice\":\"Emitted when a new Replica is un-enrolled / removed\"},\"WatcherPermissionSet(uint32,address,bool)\":{\"notice\":\"Emitted when Watcher permissions are changed\"}},\"kind\":\"user\",\"methods\":{\"isReplica(address)\":{\"notice\":\"Check whether _replica is enrolled\"},\"localDomain()\":{\"notice\":\"Query local domain from Home\"},\"ownerEnrollReplica(address,uint32)\":{\"notice\":\"Allow Owner to enroll Replica contract\"},\"ownerUnenrollReplica(address)\":{\"notice\":\"Allow Owner to un-enroll Replica contract\"},\"setHome(address)\":{\"notice\":\"Set the address of the local Home contract\"},\"setWatcherPermission(address,uint32,bool)\":{\"notice\":\"Allow Owner to set Watcher permissions for a Replica\"},\"unenrollReplica(uint32,bytes32,bytes)\":{\"notice\":\"Un-Enroll a replica contract in the case that fraud was detected on the Home\"},\"watcherPermission(address,uint32)\":{\"notice\":\"Get access permissions for the watcher on the domain\"}},\"notice\":\"Manages a registry of local Replica contracts for remote Home domains. Accepts Watcher signatures to un-enroll Replicas attached to fraudulent remote Homes\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/nomad-core/contracts/XAppConnectionManager.sol\":\"XAppConnectionManager\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    function __Ownable_init() internal onlyInitializing {\\n        __Ownable_init_unchained();\\n    }\\n\\n    function __Ownable_init_unchained() internal onlyInitializing {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\",\"keccak256\":\"0x652fee292f698d8dba81bf287cb71f1682f6483b67ebe601a5f7387dcfc30b34\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To initialize the implementation contract, you can either invoke the\\n * initializer manually, or you can include a constructor to automatically mark it as initialized when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() initializer {}\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\\n        // inheritance patterns, but we only do this in the context of a constructor, because in other contexts the\\n        // contract may have been reentered.\\n        require(_initializing ? _isConstructor() : !_initialized, \\\"Initializable: contract is already initialized\\\");\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} modifier, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    function _isConstructor() private view returns (bool) {\\n        return !AddressUpgradeable.isContract(address(this));\\n    }\\n}\\n\",\"keccak256\":\"0x372b0bc04e3b4c074559bbbfb1317afddb56de5504158ca25a7f9cd403980445\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x55cf2bd9fc76704ddcdc19834cd288b7de00fc0f298a40ea16a954ae8991db2d\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal onlyInitializing {\\n    }\\n\\n    function __Context_init_unchained() internal onlyInitializing {\\n    }\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\",\"keccak256\":\"0x963ea7f0b48b032eef72fe3a7582edf78408d6f834115b9feadd673a4d5bd149\",\"license\":\"MIT\"},\"@openzeppelin/contracts/access/Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\",\"keccak256\":\"0x24e0364e503a9bbde94c715d26573a76f14cd2a202d45f96f52134ab806b67b9\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x2ccf9d2313a313d41a791505f2b5abfdc62191b5d4334f7f7a82691c088a1c87\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\",\"keccak256\":\"0xe2e337e6dde9ef6b680e07338c493ebea1b5fd09b43424112868e9cc1706bca7\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Strings.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\",\"keccak256\":\"0x32c202bd28995dd20c4347b7c6467a6d3241c74c8ad3edcbb610cd9205916c45\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/cryptography/ECDSA.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../Strings.sol\\\";\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    enum RecoverError {\\n        NoError,\\n        InvalidSignature,\\n        InvalidSignatureLength,\\n        InvalidSignatureS,\\n        InvalidSignatureV\\n    }\\n\\n    function _throwError(RecoverError error) private pure {\\n        if (error == RecoverError.NoError) {\\n            return; // no error: do nothing\\n        } else if (error == RecoverError.InvalidSignature) {\\n            revert(\\\"ECDSA: invalid signature\\\");\\n        } else if (error == RecoverError.InvalidSignatureLength) {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        } else if (error == RecoverError.InvalidSignatureS) {\\n            revert(\\\"ECDSA: invalid signature 's' value\\\");\\n        } else if (error == RecoverError.InvalidSignatureV) {\\n            revert(\\\"ECDSA: invalid signature 'v' value\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature` or error string. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     *\\n     * Documentation for signature generation:\\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\\n        // Check the signature length\\n        // - case 65: r,s,v signature (standard)\\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\\n        if (signature.length == 65) {\\n            bytes32 r;\\n            bytes32 s;\\n            uint8 v;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                s := mload(add(signature, 0x40))\\n                v := byte(0, mload(add(signature, 0x60)))\\n            }\\n            return tryRecover(hash, v, r, s);\\n        } else if (signature.length == 64) {\\n            bytes32 r;\\n            bytes32 vs;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                vs := mload(add(signature, 0x40))\\n            }\\n            return tryRecover(hash, r, vs);\\n        } else {\\n            return (address(0), RecoverError.InvalidSignatureLength);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\\n     *\\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address, RecoverError) {\\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\\n        return tryRecover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\\n     *\\n     * _Available since v4.2._\\n     */\\n    function recover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address, RecoverError) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (301): 0 < s < secp256k1n \\u00f7 2 + 1, and for v in (302): v \\u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            return (address(0), RecoverError.InvalidSignatureS);\\n        }\\n        if (v != 27 && v != 28) {\\n            return (address(0), RecoverError.InvalidSignatureV);\\n        }\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        if (signer == address(0)) {\\n            return (address(0), RecoverError.InvalidSignature);\\n        }\\n\\n        return (signer, RecoverError.NoError);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n\\\", Strings.toString(s.length), s));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Typed Data, created from a\\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\\n     * to the one signed with the\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\\n     * JSON-RPC method as part of EIP-712.\\n     *\\n     * See {recover}.\\n     */\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash));\\n    }\\n}\\n\",\"keccak256\":\"0x3c07f43e60e099b3b157243b3152722e73b80eeb7985c2cd73712828d7f7da29\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/math/SafeMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler's built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xa2f576be637946f767aa56601c26d717f48a0aff44f82e46f13807eea1009a21\",\"license\":\"MIT\"},\"contracts/nomad-core/contracts/Home.sol\":{\"content\":\"// SPDX-License-Identifier: MIT OR Apache-2.0\\r\\npragma solidity >=0.6.11;\\r\\n\\r\\n// ============ Internal Imports ============\\r\\nimport {Version0} from \\\"./Version0.sol\\\";\\r\\nimport {NomadBase} from \\\"./NomadBase.sol\\\";\\r\\nimport {QueueLib} from \\\"../libs/Queue.sol\\\";\\r\\nimport {MerkleLib} from \\\"../libs/Merkle.sol\\\";\\r\\nimport {Message} from \\\"../libs/Message.sol\\\";\\r\\nimport {MerkleTreeManager} from \\\"./Merkle.sol\\\";\\r\\nimport {QueueManager} from \\\"./Queue.sol\\\";\\r\\nimport {IUpdaterManager} from \\\"../interfaces/IUpdaterManager.sol\\\";\\r\\n// ============ External Imports ============\\r\\nimport {Address} from \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title Home\\r\\n * @author Illusory Systems Inc.\\r\\n * @notice Accepts messages to be dispatched to remote chains,\\r\\n * constructs a Merkle tree of the messages,\\r\\n * and accepts signatures from a bonded Updater\\r\\n * which notarize the Merkle tree roots.\\r\\n * Accepts submissions of fraudulent signatures\\r\\n * by the Updater and slashes the Updater in this case.\\r\\n */\\r\\ncontract Home is Version0, QueueManager, MerkleTreeManager, NomadBase {\\r\\n    // ============ Libraries ============\\r\\n\\r\\n    using QueueLib for QueueLib.Queue;\\r\\n    using MerkleLib for MerkleLib.Tree;\\r\\n\\r\\n    // ============ Constants ============\\r\\n\\r\\n    // Maximum bytes per message = 2 KiB\\r\\n    // (somewhat arbitrarily set to begin)\\r\\n    uint256 public constant MAX_MESSAGE_BODY_BYTES = 2 * 2**10;\\r\\n\\r\\n    // ============ Public Storage Variables ============\\r\\n\\r\\n    // domain => next available nonce for the domain\\r\\n    mapping(uint32 => uint32) public nonces;\\r\\n    // contract responsible for Updater bonding, slashing and rotation\\r\\n    IUpdaterManager public updaterManager;\\r\\n\\r\\n    // ============ Upgrade Gap ============\\r\\n\\r\\n    // gap for upgrade safety\\r\\n    uint256[48] private __GAP;\\r\\n\\r\\n    // ============ Events ============\\r\\n\\r\\n    /**\\r\\n     * @notice Emitted when a new message is dispatched via Nomad\\r\\n     * @param leafIndex Index of message's leaf in merkle tree\\r\\n     * @param destinationAndNonce Destination and destination-specific\\r\\n     * nonce combined in single field ((destination << 32) & nonce)\\r\\n     * @param messageHash Hash of message; the leaf inserted to the Merkle tree for the message\\r\\n     * @param committedRoot the latest notarized root submitted in the last signed Update\\r\\n     * @param message Raw bytes of message\\r\\n     */\\r\\n    event Dispatch(\\r\\n        bytes32 indexed messageHash,\\r\\n        uint256 indexed leafIndex,\\r\\n        uint64 indexed destinationAndNonce,\\r\\n        bytes32 committedRoot,\\r\\n        bytes message\\r\\n    );\\r\\n\\r\\n    /**\\r\\n     * @notice Emitted when proof of an improper update is submitted,\\r\\n     * which sets the contract to FAILED state\\r\\n     * @param oldRoot Old root of the improper update\\r\\n     * @param newRoot New root of the improper update\\r\\n     * @param signature Signature on `oldRoot` and `newRoot\\r\\n     */\\r\\n    event ImproperUpdate(bytes32 oldRoot, bytes32 newRoot, bytes signature);\\r\\n\\r\\n    /**\\r\\n     * @notice Emitted when the Updater is slashed\\r\\n     * (should be paired with ImproperUpdater or DoubleUpdate event)\\r\\n     * @param updater The address of the updater\\r\\n     * @param reporter The address of the entity that reported the updater misbehavior\\r\\n     */\\r\\n    event UpdaterSlashed(address indexed updater, address indexed reporter);\\r\\n\\r\\n    /**\\r\\n     * @notice Emitted when the UpdaterManager contract is changed\\r\\n     * @param updaterManager The address of the new updaterManager\\r\\n     */\\r\\n    event NewUpdaterManager(address updaterManager);\\r\\n\\r\\n    // ============ Constructor ============\\r\\n\\r\\n    constructor(uint32 _localDomain) NomadBase(_localDomain) {} // solhint-disable-line no-empty-blocks\\r\\n\\r\\n    // ============ Initializer ============\\r\\n\\r\\n    function initialize(IUpdaterManager _updaterManager) public initializer {\\r\\n        // initialize queue, set Updater Manager, and initialize\\r\\n        __QueueManager_initialize();\\r\\n        _setUpdaterManager(_updaterManager);\\r\\n        __NomadBase_initialize(updaterManager.updater());\\r\\n    }\\r\\n\\r\\n    // ============ Modifiers ============\\r\\n\\r\\n    /**\\r\\n     * @notice Ensures that function is called by the UpdaterManager contract\\r\\n     */\\r\\n    modifier onlyUpdaterManager() {\\r\\n        require(msg.sender == address(updaterManager), \\\"!updaterManager\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    // ============ External: Updater & UpdaterManager Configuration  ============\\r\\n\\r\\n    /**\\r\\n     * @notice Set a new Updater\\r\\n     * @param _updater the new Updater\\r\\n     */\\r\\n    function setUpdater(address _updater) external onlyUpdaterManager {\\r\\n        _setUpdater(_updater);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Set a new UpdaterManager contract\\r\\n     * @dev Home(s) will initially be initialized using a trusted UpdaterManager contract;\\r\\n     * we will progressively decentralize by swapping the trusted contract with a new implementation\\r\\n     * that implements Updater bonding & slashing, and rules for Updater selection & rotation\\r\\n     * @param _updaterManager the new UpdaterManager contract\\r\\n     */\\r\\n    function setUpdaterManager(address _updaterManager) external onlyOwner {\\r\\n        _setUpdaterManager(IUpdaterManager(_updaterManager));\\r\\n    }\\r\\n\\r\\n    // ============ External Functions  ============\\r\\n\\r\\n    /**\\r\\n     * @notice Dispatch the message it to the destination domain & recipient\\r\\n     * @dev Format the message, insert its hash into Merkle tree,\\r\\n     * enqueue the new Merkle root, and emit `Dispatch` event with message information.\\r\\n     * @param _destinationDomain Domain of destination chain\\r\\n     * @param _recipientAddress Address of recipient on destination chain as bytes32\\r\\n     * @param _messageBody Raw bytes content of message\\r\\n     */\\r\\n    function dispatch(\\r\\n        uint32 _destinationDomain,\\r\\n        bytes32 _recipientAddress,\\r\\n        bytes memory _messageBody\\r\\n    ) external notFailed {\\r\\n        require(_messageBody.length <= MAX_MESSAGE_BODY_BYTES, \\\"msg too long\\\");\\r\\n        // get the next nonce for the destination domain, then increment it\\r\\n        uint32 _nonce = nonces[_destinationDomain];\\r\\n        nonces[_destinationDomain] = _nonce + 1;\\r\\n        // format the message into packed bytes\\r\\n        bytes memory _message = Message.formatMessage(\\r\\n            localDomain,\\r\\n            bytes32(uint256(uint160(msg.sender))),\\r\\n            _nonce,\\r\\n            _destinationDomain,\\r\\n            _recipientAddress,\\r\\n            _messageBody\\r\\n        );\\r\\n        // insert the hashed message into the Merkle tree\\r\\n        bytes32 _messageHash = keccak256(_message);\\r\\n        tree.insert(_messageHash);\\r\\n        // enqueue the new Merkle root after inserting the message\\r\\n        queue.enqueue(root());\\r\\n        // Emit Dispatch event with message information\\r\\n        // note: leafIndex is count() - 1 since new leaf has already been inserted\\r\\n        emit Dispatch(\\r\\n            _messageHash,\\r\\n            count() - 1,\\r\\n            _destinationAndNonce(_destinationDomain, _nonce),\\r\\n            committedRoot,\\r\\n            _message\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Submit a signature from the Updater \\\"notarizing\\\" a root,\\r\\n     * which updates the Home contract's `committedRoot`,\\r\\n     * and publishes the signature which will be relayed to Replica contracts\\r\\n     * @dev emits Update event\\r\\n     * @dev If _newRoot is not contained in the queue,\\r\\n     * the Update is a fraudulent Improper Update, so\\r\\n     * the Updater is slashed & Home is set to FAILED state\\r\\n     * @param _committedRoot Current updated merkle root which the update is building off of\\r\\n     * @param _newRoot New merkle root to update the contract state to\\r\\n     * @param _signature Updater signature on `_committedRoot` and `_newRoot`\\r\\n     */\\r\\n    function update(\\r\\n        bytes32 _committedRoot,\\r\\n        bytes32 _newRoot,\\r\\n        bytes memory _signature\\r\\n    ) external notFailed {\\r\\n        // check that the update is not fraudulent;\\r\\n        // if fraud is detected, Updater is slashed & Home is set to FAILED state\\r\\n        if (improperUpdate(_committedRoot, _newRoot, _signature)) return;\\r\\n        // clear all of the intermediate roots contained in this update from the queue\\r\\n        while (true) {\\r\\n            bytes32 _next = queue.dequeue();\\r\\n            if (_next == _newRoot) break;\\r\\n        }\\r\\n        // update the Home state with the latest signed root & emit event\\r\\n        committedRoot = _newRoot;\\r\\n        emit Update(localDomain, _committedRoot, _newRoot, _signature);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Suggest an update for the Updater to sign and submit.\\r\\n     * @dev If queue is empty, null bytes returned for both\\r\\n     * (No update is necessary because no messages have been dispatched since the last update)\\r\\n     * @return _committedRoot Latest root signed by the Updater\\r\\n     * @return _new Latest enqueued Merkle root\\r\\n     */\\r\\n    function suggestUpdate()\\r\\n        external\\r\\n        view\\r\\n        returns (bytes32 _committedRoot, bytes32 _new)\\r\\n    {\\r\\n        if (queue.length() != 0) {\\r\\n            _committedRoot = committedRoot;\\r\\n            _new = queue.lastItem();\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // ============ Public Functions  ============\\r\\n\\r\\n    /**\\r\\n     * @notice Hash of Home domain concatenated with \\\"NOMAD\\\"\\r\\n     */\\r\\n    function homeDomainHash() public view override returns (bytes32) {\\r\\n        return _homeDomainHash(localDomain);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Check if an Update is an Improper Update;\\r\\n     * if so, slash the Updater and set the contract to FAILED state.\\r\\n     *\\r\\n     * An Improper Update is an update building off of the Home's `committedRoot`\\r\\n     * for which the `_newRoot` does not currently exist in the Home's queue.\\r\\n     * This would mean that message(s) that were not truly\\r\\n     * dispatched on Home were falsely included in the signed root.\\r\\n     *\\r\\n     * An Improper Update will only be accepted as valid by the Replica\\r\\n     * If an Improper Update is attempted on Home,\\r\\n     * the Updater will be slashed immediately.\\r\\n     * If an Improper Update is submitted to the Replica,\\r\\n     * it should be relayed to the Home contract using this function\\r\\n     * in order to slash the Updater with an Improper Update.\\r\\n     *\\r\\n     * An Improper Update submitted to the Replica is only valid\\r\\n     * while the `_oldRoot` is still equal to the `committedRoot` on Home;\\r\\n     * if the `committedRoot` on Home has already been updated with a valid Update,\\r\\n     * then the Updater should be slashed with a Double Update.\\r\\n     * @dev Reverts (and doesn't slash updater) if signature is invalid or\\r\\n     * update not current\\r\\n     * @param _oldRoot Old merkle tree root (should equal home's committedRoot)\\r\\n     * @param _newRoot New merkle tree root\\r\\n     * @param _signature Updater signature on `_oldRoot` and `_newRoot`\\r\\n     * @return TRUE if update was an Improper Update (implying Updater was slashed)\\r\\n     */\\r\\n    function improperUpdate(\\r\\n        bytes32 _oldRoot,\\r\\n        bytes32 _newRoot,\\r\\n        bytes memory _signature\\r\\n    ) public notFailed returns (bool) {\\r\\n        require(\\r\\n            _isUpdaterSignature(_oldRoot, _newRoot, _signature),\\r\\n            \\\"!updater sig\\\"\\r\\n        );\\r\\n        require(_oldRoot == committedRoot, \\\"not a current update\\\");\\r\\n        // if the _newRoot is not currently contained in the queue,\\r\\n        // slash the Updater and set the contract to FAILED state\\r\\n        if (!queue.contains(_newRoot)) {\\r\\n            _fail();\\r\\n            emit ImproperUpdate(_oldRoot, _newRoot, _signature);\\r\\n            return true;\\r\\n        }\\r\\n        // if the _newRoot is contained in the queue,\\r\\n        // this is not an improper update\\r\\n        return false;\\r\\n    }\\r\\n\\r\\n    // ============ Internal Functions  ============\\r\\n\\r\\n    /**\\r\\n     * @notice Set the UpdaterManager\\r\\n     * @param _updaterManager Address of the UpdaterManager\\r\\n     */\\r\\n    function _setUpdaterManager(IUpdaterManager _updaterManager) internal {\\r\\n        require(\\r\\n            Address.isContract(address(_updaterManager)),\\r\\n            \\\"!contract updaterManager\\\"\\r\\n        );\\r\\n        updaterManager = IUpdaterManager(_updaterManager);\\r\\n        emit NewUpdaterManager(address(_updaterManager));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Slash the Updater and set contract state to FAILED\\r\\n     * @dev Called when fraud is proven (Improper Update or Double Update)\\r\\n     */\\r\\n    function _fail() internal override {\\r\\n        // set contract to FAILED\\r\\n        _setFailed();\\r\\n        // slash Updater\\r\\n        updaterManager.slashUpdater(payable(msg.sender));\\r\\n        emit UpdaterSlashed(updater, msg.sender);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Internal utility function that combines\\r\\n     * `_destination` and `_nonce`.\\r\\n     * @dev Both destination and nonce should be less than 2^32 - 1\\r\\n     * @param _destination Domain of destination chain\\r\\n     * @param _nonce Current nonce for given destination chain\\r\\n     * @return Returns (`_destination` << 32) & `_nonce`\\r\\n     */\\r\\n    function _destinationAndNonce(uint32 _destination, uint32 _nonce)\\r\\n        internal\\r\\n        pure\\r\\n        returns (uint64)\\r\\n    {\\r\\n        return (uint64(_destination) << 32) | _nonce;\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0xa6040d947f71c1d380e31fc63b123222b1f3a214c6ac5369fdefa23674828980\",\"license\":\"MIT OR Apache-2.0\"},\"contracts/nomad-core/contracts/Merkle.sol\":{\"content\":\"// SPDX-License-Identifier: MIT OR Apache-2.0\\r\\npragma solidity >=0.6.11;\\r\\n\\r\\n// ============ Internal Imports ============\\r\\nimport {MerkleLib} from \\\"../libs/Merkle.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title MerkleTreeManager\\r\\n * @author Illusory Systems Inc.\\r\\n * @notice Contains a Merkle tree instance and\\r\\n * exposes view functions for the tree.\\r\\n */\\r\\ncontract MerkleTreeManager {\\r\\n    // ============ Libraries ============\\r\\n\\r\\n    using MerkleLib for MerkleLib.Tree;\\r\\n    MerkleLib.Tree public tree;\\r\\n\\r\\n    // ============ Upgrade Gap ============\\r\\n\\r\\n    // gap for upgrade safety\\r\\n    uint256[49] private __GAP;\\r\\n\\r\\n    // ============ Public Functions ============\\r\\n\\r\\n    /**\\r\\n     * @notice Calculates and returns tree's current root\\r\\n     */\\r\\n    function root() public view returns (bytes32) {\\r\\n        return tree.root();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Returns the number of inserted leaves in the tree (current index)\\r\\n     */\\r\\n    function count() public view returns (uint256) {\\r\\n        return tree.count;\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0x9bdabee5e1458ab8df45d8c224df33fbd3a58d53ec3f08671cb1121f2a59ff46\",\"license\":\"MIT OR Apache-2.0\"},\"contracts/nomad-core/contracts/NomadBase.sol\":{\"content\":\"// SPDX-License-Identifier: MIT OR Apache-2.0\\r\\npragma solidity >=0.6.11;\\r\\n\\r\\n// ============ Internal Imports ============\\r\\nimport {Message} from \\\"../libs/Message.sol\\\";\\r\\n// ============ External Imports ============\\r\\nimport {ECDSA} from \\\"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\\\";\\r\\nimport {Initializable} from \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\r\\nimport {OwnableUpgradeable} from \\\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title NomadBase\\r\\n * @author Illusory Systems Inc.\\r\\n * @notice Shared utilities between Home and Replica.\\r\\n */\\r\\nabstract contract NomadBase is Initializable, OwnableUpgradeable {\\r\\n    // ============ Enums ============\\r\\n\\r\\n    // States:\\r\\n    //   0 - UnInitialized - before initialize function is called\\r\\n    //   note: the contract is initialized at deploy time, so it should never be in this state\\r\\n    //   1 - Active - as long as the contract has not become fraudulent\\r\\n    //   2 - Failed - after a valid fraud proof has been submitted;\\r\\n    //   contract will no longer accept updates or new messages\\r\\n    enum States {\\r\\n        UnInitialized,\\r\\n        Active,\\r\\n        Failed\\r\\n    }\\r\\n\\r\\n    // ============ Immutable Variables ============\\r\\n\\r\\n    // Domain of chain on which the contract is deployed\\r\\n    uint32 public immutable localDomain;\\r\\n\\r\\n    // ============ Public Variables ============\\r\\n\\r\\n    // Address of bonded Updater\\r\\n    address public updater;\\r\\n    // Current state of contract\\r\\n    States public state;\\r\\n    // The latest root that has been signed by the Updater\\r\\n    bytes32 public committedRoot;\\r\\n\\r\\n    // ============ Upgrade Gap ============\\r\\n\\r\\n    // gap for upgrade safety\\r\\n    uint256[47] private __GAP;\\r\\n\\r\\n    // ============ Events ============\\r\\n\\r\\n    /**\\r\\n     * @notice Emitted when update is made on Home\\r\\n     * or unconfirmed update root is submitted on Replica\\r\\n     * @param homeDomain Domain of home contract\\r\\n     * @param oldRoot Old merkle root\\r\\n     * @param newRoot New merkle root\\r\\n     * @param signature Updater's signature on `oldRoot` and `newRoot`\\r\\n     */\\r\\n    event Update(\\r\\n        uint32 indexed homeDomain,\\r\\n        bytes32 indexed oldRoot,\\r\\n        bytes32 indexed newRoot,\\r\\n        bytes signature\\r\\n    );\\r\\n\\r\\n    /**\\r\\n     * @notice Emitted when proof of a double update is submitted,\\r\\n     * which sets the contract to FAILED state\\r\\n     * @param oldRoot Old root shared between two conflicting updates\\r\\n     * @param newRoot Array containing two conflicting new roots\\r\\n     * @param signature Signature on `oldRoot` and `newRoot`[0]\\r\\n     * @param signature2 Signature on `oldRoot` and `newRoot`[1]\\r\\n     */\\r\\n    event DoubleUpdate(\\r\\n        bytes32 oldRoot,\\r\\n        bytes32[2] newRoot,\\r\\n        bytes signature,\\r\\n        bytes signature2\\r\\n    );\\r\\n\\r\\n    /**\\r\\n     * @notice Emitted when Updater is rotated\\r\\n     * @param oldUpdater The address of the old updater\\r\\n     * @param newUpdater The address of the new updater\\r\\n     */\\r\\n    event NewUpdater(address oldUpdater, address newUpdater);\\r\\n\\r\\n    // ============ Modifiers ============\\r\\n\\r\\n    /**\\r\\n     * @notice Ensures that contract state != FAILED when the function is called\\r\\n     */\\r\\n    modifier notFailed() {\\r\\n        require(state != States.Failed, \\\"failed state\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    // ============ Constructor ============\\r\\n\\r\\n    constructor(uint32 _localDomain) {\\r\\n        localDomain = _localDomain;\\r\\n    }\\r\\n\\r\\n    // ============ Initializer ============\\r\\n\\r\\n    function __NomadBase_initialize(address _updater) internal initializer {\\r\\n        __Ownable_init();\\r\\n        _setUpdater(_updater);\\r\\n        state = States.Active;\\r\\n    }\\r\\n\\r\\n    // ============ External Functions ============\\r\\n\\r\\n    /**\\r\\n     * @notice Called by external agent. Checks that signatures on two sets of\\r\\n     * roots are valid and that the new roots conflict with each other. If both\\r\\n     * cases hold true, the contract is failed and a `DoubleUpdate` event is\\r\\n     * emitted.\\r\\n     * @dev When `fail()` is called on Home, updater is slashed.\\r\\n     * @param _oldRoot Old root shared between two conflicting updates\\r\\n     * @param _newRoot Array containing two conflicting new roots\\r\\n     * @param _signature Signature on `_oldRoot` and `_newRoot`[0]\\r\\n     * @param _signature2 Signature on `_oldRoot` and `_newRoot`[1]\\r\\n     */\\r\\n    function doubleUpdate(\\r\\n        bytes32 _oldRoot,\\r\\n        bytes32[2] calldata _newRoot,\\r\\n        bytes calldata _signature,\\r\\n        bytes calldata _signature2\\r\\n    ) external notFailed {\\r\\n        if (\\r\\n            NomadBase._isUpdaterSignature(_oldRoot, _newRoot[0], _signature) &&\\r\\n            NomadBase._isUpdaterSignature(_oldRoot, _newRoot[1], _signature2) &&\\r\\n            _newRoot[0] != _newRoot[1]\\r\\n        ) {\\r\\n            _fail();\\r\\n            emit DoubleUpdate(_oldRoot, _newRoot, _signature, _signature2);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // ============ Public Functions ============\\r\\n\\r\\n    /**\\r\\n     * @notice Hash of Home domain concatenated with \\\"NOMAD\\\"\\r\\n     */\\r\\n    function homeDomainHash() public view virtual returns (bytes32);\\r\\n\\r\\n    // ============ Internal Functions ============\\r\\n\\r\\n    /**\\r\\n     * @notice Hash of Home domain concatenated with \\\"NOMAD\\\"\\r\\n     * @param _homeDomain the Home domain to hash\\r\\n     */\\r\\n    function _homeDomainHash(uint32 _homeDomain)\\r\\n        internal\\r\\n        pure\\r\\n        returns (bytes32)\\r\\n    {\\r\\n        return keccak256(abi.encodePacked(_homeDomain, \\\"NOMAD\\\"));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Set contract state to FAILED\\r\\n     * @dev Called when a valid fraud proof is submitted\\r\\n     */\\r\\n    function _setFailed() internal {\\r\\n        state = States.Failed;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Moves the contract into failed state\\r\\n     * @dev Called when fraud is proven\\r\\n     * (Double Update is submitted on Home or Replica,\\r\\n     * or Improper Update is submitted on Home)\\r\\n     */\\r\\n    function _fail() internal virtual;\\r\\n\\r\\n    /**\\r\\n     * @notice Set the Updater\\r\\n     * @param _newUpdater Address of the new Updater\\r\\n     */\\r\\n    function _setUpdater(address _newUpdater) internal {\\r\\n        address _oldUpdater = updater;\\r\\n        updater = _newUpdater;\\r\\n        emit NewUpdater(_oldUpdater, _newUpdater);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Checks that signature was signed by Updater\\r\\n     * @param _oldRoot Old merkle root\\r\\n     * @param _newRoot New merkle root\\r\\n     * @param _signature Signature on `_oldRoot` and `_newRoot`\\r\\n     * @return TRUE iff signature is valid signed by updater\\r\\n     **/\\r\\n    function _isUpdaterSignature(\\r\\n        bytes32 _oldRoot,\\r\\n        bytes32 _newRoot,\\r\\n        bytes memory _signature\\r\\n    ) internal view returns (bool) {\\r\\n        bytes32 _digest = keccak256(\\r\\n            abi.encodePacked(homeDomainHash(), _oldRoot, _newRoot)\\r\\n        );\\r\\n        _digest = ECDSA.toEthSignedMessageHash(_digest);\\r\\n        return (ECDSA.recover(_digest, _signature) == updater);\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0xf671ac6620a66ff2683e853931648317f5603367faeb1cb34801d7a44a03381a\",\"license\":\"MIT OR Apache-2.0\"},\"contracts/nomad-core/contracts/Queue.sol\":{\"content\":\"// SPDX-License-Identifier: MIT OR Apache-2.0\\r\\npragma solidity >=0.6.11;\\r\\n\\r\\n// ============ Internal Imports ============\\r\\nimport {QueueLib} from \\\"../libs/Queue.sol\\\";\\r\\n// ============ External Imports ============\\r\\nimport {Initializable} from \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title QueueManager\\r\\n * @author Illusory Systems Inc.\\r\\n * @notice Contains a queue instance and\\r\\n * exposes view functions for the queue.\\r\\n **/\\r\\ncontract QueueManager is Initializable {\\r\\n    // ============ Libraries ============\\r\\n\\r\\n    using QueueLib for QueueLib.Queue;\\r\\n    QueueLib.Queue internal queue;\\r\\n\\r\\n    // ============ Upgrade Gap ============\\r\\n\\r\\n    // gap for upgrade safety\\r\\n    uint256[49] private __GAP;\\r\\n\\r\\n    // ============ Initializer ============\\r\\n\\r\\n    function __QueueManager_initialize() internal initializer {\\r\\n        queue.initialize();\\r\\n    }\\r\\n\\r\\n    // ============ Public Functions ============\\r\\n\\r\\n    /**\\r\\n     * @notice Returns number of elements in queue\\r\\n     */\\r\\n    function queueLength() external view returns (uint256) {\\r\\n        return queue.length();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Returns TRUE iff `_item` is in the queue\\r\\n     */\\r\\n    function queueContains(bytes32 _item) external view returns (bool) {\\r\\n        return queue.contains(_item);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Returns last item enqueued to the queue\\r\\n     */\\r\\n    function queueEnd() external view returns (bytes32) {\\r\\n        return queue.lastItem();\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0x928e09902599ba7c5daf5df3cb4385533fc09a1ed8a814d0317fb1987178ff9e\",\"license\":\"MIT OR Apache-2.0\"},\"contracts/nomad-core/contracts/Replica.sol\":{\"content\":\"// SPDX-License-Identifier: MIT OR Apache-2.0\\r\\npragma solidity >=0.6.11;\\r\\n\\r\\n// ============ Internal Imports ============\\r\\nimport {Version0} from \\\"./Version0.sol\\\";\\r\\nimport {NomadBase} from \\\"./NomadBase.sol\\\";\\r\\nimport {MerkleLib} from \\\"../libs/Merkle.sol\\\";\\r\\nimport {Message} from \\\"../libs/Message.sol\\\";\\r\\n// ============ External Imports ============\\r\\n// import {TypedMemView} from \\\"@summa-tx/memview-sol/contracts/TypedMemView.sol\\\";\\r\\nimport {TypedMemView} from \\\"../libs/TypedMemView.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title Replica\\r\\n * @author Illusory Systems Inc.\\r\\n * @notice Track root updates on Home,\\r\\n * prove and dispatch messages to end recipients.\\r\\n */\\r\\ncontract Replica is Version0, NomadBase {\\r\\n    // ============ Libraries ============\\r\\n\\r\\n    using MerkleLib for MerkleLib.Tree;\\r\\n    using TypedMemView for bytes;\\r\\n    using TypedMemView for bytes29;\\r\\n    using Message for bytes29;\\r\\n\\r\\n    // ============ Enums ============\\r\\n\\r\\n    // Status of Message:\\r\\n    //   0 - None - message has not been proven or processed\\r\\n    //   1 - Proven - message inclusion proof has been validated\\r\\n    //   2 - Processed - message has been dispatched to recipient\\r\\n    enum MessageStatus {\\r\\n        None,\\r\\n        Proven,\\r\\n        Processed\\r\\n    }\\r\\n\\r\\n    // ============ Immutables ============\\r\\n\\r\\n    // Minimum gas for message processing\\r\\n    uint256 public immutable PROCESS_GAS;\\r\\n    // Reserved gas (to ensure tx completes in case message processing runs out)\\r\\n    uint256 public immutable RESERVE_GAS;\\r\\n\\r\\n    // ============ Public Storage ============\\r\\n\\r\\n    // Domain of home chain\\r\\n    uint32 public remoteDomain;\\r\\n    // Number of seconds to wait before root becomes confirmable\\r\\n    uint256 public optimisticSeconds;\\r\\n    // re-entrancy guard\\r\\n    uint8 private entered;\\r\\n    // Mapping of roots to allowable confirmation times\\r\\n    mapping(bytes32 => uint256) public confirmAt;\\r\\n    // Mapping of message leaves to MessageStatus\\r\\n    mapping(bytes32 => MessageStatus) public messages;\\r\\n\\r\\n    // ============ Upgrade Gap ============\\r\\n\\r\\n    // gap for upgrade safety\\r\\n    uint256[45] private __GAP;\\r\\n\\r\\n    // ============ Events ============\\r\\n\\r\\n    /**\\r\\n     * @notice Emitted when message is processed\\r\\n     * @param messageHash Hash of message that failed to process\\r\\n     * @param success TRUE if the call was executed successfully, FALSE if the call reverted\\r\\n     * @param returnData the return data from the external call\\r\\n     */\\r\\n    event Process(\\r\\n        bytes32 indexed messageHash,\\r\\n        bool indexed success,\\r\\n        bytes indexed returnData\\r\\n    );\\r\\n\\r\\n    /**\\r\\n     * @notice Emitted when the value for optimisticTimeout is set\\r\\n     * @param timeout The new value for optimistic timeout\\r\\n     */\\r\\n    event SetOptimisticTimeout(uint256 timeout);\\r\\n\\r\\n    /**\\r\\n     * @notice Emitted when a root's confirmation is modified by governance\\r\\n     * @param root The root for which confirmAt has been set\\r\\n     * @param previousConfirmAt The previous value of confirmAt\\r\\n     * @param newConfirmAt The new value of confirmAt\\r\\n     */\\r\\n    event SetConfirmation(\\r\\n        bytes32 indexed root,\\r\\n        uint256 previousConfirmAt,\\r\\n        uint256 newConfirmAt\\r\\n    );\\r\\n\\r\\n    // ============ Constructor ============\\r\\n\\r\\n    // solhint-disable-next-line no-empty-blocks\\r\\n    constructor(\\r\\n        uint32 _localDomain,\\r\\n        uint256 _processGas,\\r\\n        uint256 _reserveGas\\r\\n    ) NomadBase(_localDomain) {\\r\\n        require(_processGas >= 850_000, \\\"!process gas\\\");\\r\\n        require(_reserveGas >= 15_000, \\\"!reserve gas\\\");\\r\\n        PROCESS_GAS = _processGas;\\r\\n        RESERVE_GAS = _reserveGas;\\r\\n    }\\r\\n\\r\\n    // ============ Initializer ============\\r\\n\\r\\n    function initialize(\\r\\n        uint32 _remoteDomain,\\r\\n        address _updater,\\r\\n        bytes32 _committedRoot,\\r\\n        uint256 _optimisticSeconds\\r\\n    ) public initializer {\\r\\n        __NomadBase_initialize(_updater);\\r\\n        // set storage variables\\r\\n        entered = 1;\\r\\n        remoteDomain = _remoteDomain;\\r\\n        committedRoot = _committedRoot;\\r\\n        confirmAt[_committedRoot] = 1;\\r\\n        optimisticSeconds = _optimisticSeconds;\\r\\n        emit SetOptimisticTimeout(_optimisticSeconds);\\r\\n    }\\r\\n\\r\\n    // ============ External Functions ============\\r\\n\\r\\n    /**\\r\\n     * @notice Called by external agent. Submits the signed update's new root,\\r\\n     * marks root's allowable confirmation time, and emits an `Update` event.\\r\\n     * @dev Reverts if update doesn't build off latest committedRoot\\r\\n     * or if signature is invalid.\\r\\n     * @param _oldRoot Old merkle root\\r\\n     * @param _newRoot New merkle root\\r\\n     * @param _signature Updater's signature on `_oldRoot` and `_newRoot`\\r\\n     */\\r\\n    function update(\\r\\n        bytes32 _oldRoot,\\r\\n        bytes32 _newRoot,\\r\\n        bytes memory _signature\\r\\n    ) external notFailed {\\r\\n        // ensure that update is building off the last submitted root\\r\\n        require(_oldRoot == committedRoot, \\\"not current update\\\");\\r\\n        // validate updater signature\\r\\n        require(\\r\\n            _isUpdaterSignature(_oldRoot, _newRoot, _signature),\\r\\n            \\\"!updater sig\\\"\\r\\n        );\\r\\n        // Hook for future use\\r\\n        _beforeUpdate();\\r\\n        // set the new root's confirmation timer\\r\\n        confirmAt[_newRoot] = block.timestamp + optimisticSeconds;\\r\\n        // update committedRoot\\r\\n        committedRoot = _newRoot;\\r\\n        emit Update(remoteDomain, _oldRoot, _newRoot, _signature);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice First attempts to prove the validity of provided formatted\\r\\n     * `message`. If the message is successfully proven, then tries to process\\r\\n     * message.\\r\\n     * @dev Reverts if `prove` call returns false\\r\\n     * @param _message Formatted message (refer to NomadBase.sol Message library)\\r\\n     * @param _proof Merkle proof of inclusion for message's leaf\\r\\n     * @param _index Index of leaf in home's merkle tree\\r\\n     */\\r\\n    function proveAndProcess(\\r\\n        bytes memory _message,\\r\\n        bytes32[32] calldata _proof,\\r\\n        uint256 _index\\r\\n    ) external {\\r\\n        require(prove(keccak256(_message), _proof, _index), \\\"!prove\\\");\\r\\n        process(_message);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Given formatted message, attempts to dispatch\\r\\n     * message payload to end recipient.\\r\\n     * @dev Recipient must implement a `handle` method (refer to IMessageRecipient.sol)\\r\\n     * Reverts if formatted message's destination domain is not the Replica's domain,\\r\\n     * if message has not been proven,\\r\\n     * or if not enough gas is provided for the dispatch transaction.\\r\\n     * @param _message Formatted message\\r\\n     * @return _success TRUE iff dispatch transaction succeeded\\r\\n     */\\r\\n    function process(bytes memory _message) public returns (bool _success) {\\r\\n        bytes29 _m = _message.ref(0);\\r\\n        // ensure message was meant for this domain\\r\\n        require(_m.destination() == localDomain, \\\"!destination\\\");\\r\\n        // ensure message has been proven\\r\\n        bytes32 _messageHash = _m.keccak();\\r\\n        require(messages[_messageHash] == MessageStatus.Proven, \\\"!proven\\\");\\r\\n        // check re-entrancy guard\\r\\n        require(entered == 1, \\\"!reentrant\\\");\\r\\n        entered = 0;\\r\\n        // update message status as processed\\r\\n        messages[_messageHash] = MessageStatus.Processed;\\r\\n        // A call running out of gas TYPICALLY errors the whole tx. We want to\\r\\n        // a) ensure the call has a sufficient amount of gas to make a\\r\\n        //    meaningful state change.\\r\\n        // b) ensure that if the subcall runs out of gas, that the tx as a whole\\r\\n        //    does not revert (i.e. we still mark the message processed)\\r\\n        // To do this, we require that we have enough gas to process\\r\\n        // and still return. We then delegate only the minimum processing gas.\\r\\n        require(gasleft() >= PROCESS_GAS + RESERVE_GAS, \\\"!gas\\\");\\r\\n        // get the message recipient\\r\\n        address _recipient = _m.recipientAddress();\\r\\n        // set up for assembly call\\r\\n        uint256 _toCopy;\\r\\n        uint256 _maxCopy = 256;\\r\\n        uint256 _gas = PROCESS_GAS;\\r\\n        // allocate memory for returndata\\r\\n        bytes memory _returnData = new bytes(_maxCopy);\\r\\n        bytes memory _calldata = abi.encodeWithSignature(\\r\\n            \\\"handle(uint32,uint32,bytes32,bytes)\\\",\\r\\n            _m.origin(),\\r\\n            _m.nonce(),\\r\\n            _m.sender(),\\r\\n            _m.body().clone()\\r\\n        );\\r\\n        // dispatch message to recipient\\r\\n        // by assembly calling \\\"handle\\\" function\\r\\n        // we call via assembly to avoid memcopying a very large returndata\\r\\n        // returned by a malicious contract\\r\\n        assembly {\\r\\n            _success := call(\\r\\n                _gas, // gas\\r\\n                _recipient, // recipient\\r\\n                0, // ether value\\r\\n                add(_calldata, 0x20), // inloc\\r\\n                mload(_calldata), // inlen\\r\\n                0, // outloc\\r\\n                0 // outlen\\r\\n            )\\r\\n            // limit our copy to 256 bytes\\r\\n            _toCopy := returndatasize()\\r\\n            if gt(_toCopy, _maxCopy) {\\r\\n                _toCopy := _maxCopy\\r\\n            }\\r\\n            // Store the length of the copied bytes\\r\\n            mstore(_returnData, _toCopy)\\r\\n            // copy the bytes from returndata[0:_toCopy]\\r\\n            returndatacopy(add(_returnData, 0x20), 0, _toCopy)\\r\\n        }\\r\\n        // emit process results\\r\\n        emit Process(_messageHash, _success, _returnData);\\r\\n        // reset re-entrancy guard\\r\\n        entered = 1;\\r\\n    }\\r\\n\\r\\n    // ============ External Owner Functions ============\\r\\n\\r\\n    /**\\r\\n     * @notice Set optimistic timeout period for new roots\\r\\n     * @dev Only callable by owner (Governance)\\r\\n     * @param _optimisticSeconds New optimistic timeout period\\r\\n     */\\r\\n    function setOptimisticTimeout(uint256 _optimisticSeconds)\\r\\n        external\\r\\n        onlyOwner\\r\\n    {\\r\\n        optimisticSeconds = _optimisticSeconds;\\r\\n        emit SetOptimisticTimeout(_optimisticSeconds);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Set Updater role\\r\\n     * @dev MUST ensure that all roots signed by previous Updater have\\r\\n     * been relayed before calling. Only callable by owner (Governance)\\r\\n     * @param _updater New Updater\\r\\n     */\\r\\n    function setUpdater(address _updater) external onlyOwner {\\r\\n        _setUpdater(_updater);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Set confirmAt for a given root\\r\\n     * @dev To be used if in the case that fraud is proven\\r\\n     * and roots need to be deleted / added. Only callable by owner (Governance)\\r\\n     * @param _root The root for which to modify confirm time\\r\\n     * @param _confirmAt The new confirmation time. Set to 0 to \\\"delete\\\" a root.\\r\\n     */\\r\\n    function setConfirmation(bytes32 _root, uint256 _confirmAt)\\r\\n        external\\r\\n        onlyOwner\\r\\n    {\\r\\n        uint256 _previousConfirmAt = confirmAt[_root];\\r\\n        confirmAt[_root] = _confirmAt;\\r\\n        emit SetConfirmation(_root, _previousConfirmAt, _confirmAt);\\r\\n    }\\r\\n\\r\\n    // ============ Public Functions ============\\r\\n\\r\\n    /**\\r\\n     * @notice Check that the root has been submitted\\r\\n     * and that the optimistic timeout period has expired,\\r\\n     * meaning the root can be processed\\r\\n     * @param _root the Merkle root, submitted in an update, to check\\r\\n     * @return TRUE iff root has been submitted & timeout has expired\\r\\n     */\\r\\n    function acceptableRoot(bytes32 _root) public view returns (bool) {\\r\\n        uint256 _time = confirmAt[_root];\\r\\n        if (_time == 0) {\\r\\n            return false;\\r\\n        }\\r\\n        return block.timestamp >= _time;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Attempts to prove the validity of message given its leaf, the\\r\\n     * merkle proof of inclusion for the leaf, and the index of the leaf.\\r\\n     * @dev Reverts if message's MessageStatus != None (i.e. if message was\\r\\n     * already proven or processed)\\r\\n     * @dev For convenience, we allow proving against any previous root.\\r\\n     * This means that witnesses never need to be updated for the new root\\r\\n     * @param _leaf Leaf of message to prove\\r\\n     * @param _proof Merkle proof of inclusion for leaf\\r\\n     * @param _index Index of leaf in home's merkle tree\\r\\n     * @return Returns true if proof was valid and `prove` call succeeded\\r\\n     **/\\r\\n    function prove(\\r\\n        bytes32 _leaf,\\r\\n        bytes32[32] calldata _proof,\\r\\n        uint256 _index\\r\\n    ) public returns (bool) {\\r\\n        // ensure that message has not been proven or processed\\r\\n        require(messages[_leaf] == MessageStatus.None, \\\"!MessageStatus.None\\\");\\r\\n        // calculate the expected root based on the proof\\r\\n        bytes32 _calculatedRoot = MerkleLib.branchRoot(_leaf, _proof, _index);\\r\\n        // if the root is valid, change status to Proven\\r\\n        if (acceptableRoot(_calculatedRoot)) {\\r\\n            messages[_leaf] = MessageStatus.Proven;\\r\\n            return true;\\r\\n        }\\r\\n        return false;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Hash of Home domain concatenated with \\\"NOMAD\\\"\\r\\n     */\\r\\n    function homeDomainHash() public view override returns (bytes32) {\\r\\n        return _homeDomainHash(remoteDomain);\\r\\n    }\\r\\n\\r\\n    // ============ Internal Functions ============\\r\\n\\r\\n    /**\\r\\n     * @notice Moves the contract into failed state\\r\\n     * @dev Called when a Double Update is submitted\\r\\n     */\\r\\n    function _fail() internal override {\\r\\n        _setFailed();\\r\\n    }\\r\\n\\r\\n    /// @notice Hook for potential future use\\r\\n    // solhint-disable-next-line no-empty-blocks\\r\\n    function _beforeUpdate() internal {}\\r\\n}\\r\\n\",\"keccak256\":\"0x44b9a670177218810c79c1675f1e92bff73ae7c19a3291852c5766f8935232f2\",\"license\":\"MIT OR Apache-2.0\"},\"contracts/nomad-core/contracts/Version0.sol\":{\"content\":\"// SPDX-License-Identifier: MIT OR Apache-2.0\\r\\npragma solidity >=0.6.11;\\r\\n\\r\\n/**\\r\\n * @title Version0\\r\\n * @notice Version getter for contracts\\r\\n **/\\r\\ncontract Version0 {\\r\\n    uint8 public constant VERSION = 0;\\r\\n}\\r\\n\",\"keccak256\":\"0x85dc63a6a5ca29d27cb35a9c42998292618e7798c8cff7fa601254cf50dbf1c1\",\"license\":\"MIT OR Apache-2.0\"},\"contracts/nomad-core/contracts/XAppConnectionManager.sol\":{\"content\":\"// SPDX-License-Identifier: MIT OR Apache-2.0\\r\\npragma solidity >=0.6.11;\\r\\n\\r\\n// ============ Internal Imports ============\\r\\nimport {Home} from \\\"./Home.sol\\\";\\r\\nimport {Replica} from \\\"./Replica.sol\\\";\\r\\nimport {TypeCasts} from \\\"../libs/TypeCasts.sol\\\";\\r\\n// ============ External Imports ============\\r\\nimport {ECDSA} from \\\"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\\\";\\r\\nimport {Ownable} from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title XAppConnectionManager\\r\\n * @author Illusory Systems Inc.\\r\\n * @notice Manages a registry of local Replica contracts\\r\\n * for remote Home domains. Accepts Watcher signatures\\r\\n * to un-enroll Replicas attached to fraudulent remote Homes\\r\\n */\\r\\ncontract XAppConnectionManager is Ownable {\\r\\n    // ============ Public Storage ============\\r\\n\\r\\n    // Home contract\\r\\n    Home public home;\\r\\n    // local Replica address => remote Home domain\\r\\n    mapping(address => uint32) public replicaToDomain;\\r\\n    // remote Home domain => local Replica address\\r\\n    mapping(uint32 => address) public domainToReplica;\\r\\n    // watcher address => replica remote domain => has/doesn't have permission\\r\\n    mapping(address => mapping(uint32 => bool)) private watcherPermissions;\\r\\n\\r\\n    // ============ Events ============\\r\\n\\r\\n    /**\\r\\n     * @notice Emitted when a new Replica is enrolled / added\\r\\n     * @param domain the remote domain of the Home contract for the Replica\\r\\n     * @param replica the address of the Replica\\r\\n     */\\r\\n    event ReplicaEnrolled(uint32 indexed domain, address replica);\\r\\n\\r\\n    /**\\r\\n     * @notice Emitted when a new Replica is un-enrolled / removed\\r\\n     * @param domain the remote domain of the Home contract for the Replica\\r\\n     * @param replica the address of the Replica\\r\\n     */\\r\\n    event ReplicaUnenrolled(uint32 indexed domain, address replica);\\r\\n\\r\\n    /**\\r\\n     * @notice Emitted when Watcher permissions are changed\\r\\n     * @param domain the remote domain of the Home contract for the Replica\\r\\n     * @param watcher the address of the Watcher\\r\\n     * @param access TRUE if the Watcher was given permissions, FALSE if permissions were removed\\r\\n     */\\r\\n    event WatcherPermissionSet(\\r\\n        uint32 indexed domain,\\r\\n        address watcher,\\r\\n        bool access\\r\\n    );\\r\\n\\r\\n    // ============ Modifiers ============\\r\\n\\r\\n    modifier onlyReplica() {\\r\\n        require(isReplica(msg.sender), \\\"!replica\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    // ============ Constructor ============\\r\\n\\r\\n    // solhint-disable-next-line no-empty-blocks\\r\\n    constructor() Ownable() {}\\r\\n\\r\\n    // ============ External Functions ============\\r\\n\\r\\n    /**\\r\\n     * @notice Un-Enroll a replica contract\\r\\n     * in the case that fraud was detected on the Home\\r\\n     * @dev in the future, if fraud occurs on the Home contract,\\r\\n     * the Watcher will submit their signature directly to the Home\\r\\n     * and it can be relayed to all remote chains to un-enroll the Replicas\\r\\n     * @param _domain the remote domain of the Home contract for the Replica\\r\\n     * @param _updater the address of the Updater for the Home contract (also stored on Replica)\\r\\n     * @param _signature signature of watcher on (domain, replica address, updater address)\\r\\n     */\\r\\n    function unenrollReplica(\\r\\n        uint32 _domain,\\r\\n        bytes32 _updater,\\r\\n        bytes memory _signature\\r\\n    ) external {\\r\\n        // ensure that the replica is currently set\\r\\n        address _replica = domainToReplica[_domain];\\r\\n        require(_replica != address(0), \\\"!replica exists\\\");\\r\\n        // ensure that the signature is on the proper updater\\r\\n        require(\\r\\n            Replica(_replica).updater() == TypeCasts.bytes32ToAddress(_updater),\\r\\n            \\\"!current updater\\\"\\r\\n        );\\r\\n        // get the watcher address from the signature\\r\\n        // and ensure that the watcher has permission to un-enroll this replica\\r\\n        address _watcher = _recoverWatcherFromSig(\\r\\n            _domain,\\r\\n            TypeCasts.addressToBytes32(_replica),\\r\\n            _updater,\\r\\n            _signature\\r\\n        );\\r\\n        require(watcherPermissions[_watcher][_domain], \\\"!valid watcher\\\");\\r\\n        // remove the replica from mappings\\r\\n        _unenrollReplica(_replica);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Set the address of the local Home contract\\r\\n     * @param _home the address of the local Home contract\\r\\n     */\\r\\n    function setHome(address _home) external onlyOwner {\\r\\n        home = Home(_home);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Allow Owner to enroll Replica contract\\r\\n     * @param _replica the address of the Replica\\r\\n     * @param _domain the remote domain of the Home contract for the Replica\\r\\n     */\\r\\n    function ownerEnrollReplica(address _replica, uint32 _domain)\\r\\n        external\\r\\n        onlyOwner\\r\\n    {\\r\\n        // un-enroll any existing replica\\r\\n        _unenrollReplica(_replica);\\r\\n        // add replica and domain to two-way mapping\\r\\n        replicaToDomain[_replica] = _domain;\\r\\n        domainToReplica[_domain] = _replica;\\r\\n        emit ReplicaEnrolled(_domain, _replica);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Allow Owner to un-enroll Replica contract\\r\\n     * @param _replica the address of the Replica\\r\\n     */\\r\\n    function ownerUnenrollReplica(address _replica) external onlyOwner {\\r\\n        _unenrollReplica(_replica);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Allow Owner to set Watcher permissions for a Replica\\r\\n     * @param _watcher the address of the Watcher\\r\\n     * @param _domain the remote domain of the Home contract for the Replica\\r\\n     * @param _access TRUE to give the Watcher permissions, FALSE to remove permissions\\r\\n     */\\r\\n    function setWatcherPermission(\\r\\n        address _watcher,\\r\\n        uint32 _domain,\\r\\n        bool _access\\r\\n    ) external onlyOwner {\\r\\n        watcherPermissions[_watcher][_domain] = _access;\\r\\n        emit WatcherPermissionSet(_domain, _watcher, _access);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Query local domain from Home\\r\\n     * @return local domain\\r\\n     */\\r\\n    function localDomain() external view returns (uint32) {\\r\\n        return home.localDomain();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Get access permissions for the watcher on the domain\\r\\n     * @param _watcher the address of the watcher\\r\\n     * @param _domain the domain to check for watcher permissions\\r\\n     * @return TRUE iff _watcher has permission to un-enroll replicas on _domain\\r\\n     */\\r\\n    function watcherPermission(address _watcher, uint32 _domain)\\r\\n        external\\r\\n        view\\r\\n        returns (bool)\\r\\n    {\\r\\n        return watcherPermissions[_watcher][_domain];\\r\\n    }\\r\\n\\r\\n    // ============ Public Functions ============\\r\\n\\r\\n    /**\\r\\n     * @notice Check whether _replica is enrolled\\r\\n     * @param _replica the replica to check for enrollment\\r\\n     * @return TRUE iff _replica is enrolled\\r\\n     */\\r\\n    function isReplica(address _replica) public view returns (bool) {\\r\\n        return replicaToDomain[_replica] != 0;\\r\\n    }\\r\\n\\r\\n    // ============ Internal Functions ============\\r\\n\\r\\n    /**\\r\\n     * @notice Remove the replica from the two-way mappings\\r\\n     * @param _replica replica to un-enroll\\r\\n     */\\r\\n    function _unenrollReplica(address _replica) internal {\\r\\n        uint32 _currentDomain = replicaToDomain[_replica];\\r\\n        domainToReplica[_currentDomain] = address(0);\\r\\n        replicaToDomain[_replica] = 0;\\r\\n        emit ReplicaUnenrolled(_currentDomain, _replica);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Get the Watcher address from the provided signature\\r\\n     * @return address of watcher that signed\\r\\n     */\\r\\n    function _recoverWatcherFromSig(\\r\\n        uint32 _domain,\\r\\n        bytes32 _replica,\\r\\n        bytes32 _updater,\\r\\n        bytes memory _signature\\r\\n    ) internal view returns (address) {\\r\\n        bytes32 _homeDomainHash = Replica(TypeCasts.bytes32ToAddress(_replica))\\r\\n            .homeDomainHash();\\r\\n        bytes32 _digest = keccak256(\\r\\n            abi.encodePacked(_homeDomainHash, _domain, _updater)\\r\\n        );\\r\\n        _digest = ECDSA.toEthSignedMessageHash(_digest);\\r\\n        return ECDSA.recover(_digest, _signature);\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0x1fbf51873d250aa977a5b83b8fd75a8545b8baaddf95655bd61ccd15db550a49\",\"license\":\"MIT OR Apache-2.0\"},\"contracts/nomad-core/interfaces/IUpdaterManager.sol\":{\"content\":\"// SPDX-License-Identifier: MIT OR Apache-2.0\\r\\npragma solidity >=0.6.11;\\r\\n\\r\\ninterface IUpdaterManager {\\r\\n    function slashUpdater(address payable _reporter) external;\\r\\n\\r\\n    function updater() external view returns (address);\\r\\n}\\r\\n\",\"keccak256\":\"0xc3fd50e375e2096221ab5419152e5fd36165d9cb0466d21580184eb6cc529c4b\",\"license\":\"MIT OR Apache-2.0\"},\"contracts/nomad-core/libs/Merkle.sol\":{\"content\":\"// SPDX-License-Identifier: MIT OR Apache-2.0\\r\\npragma solidity >=0.6.11;\\r\\n\\r\\n// work based on eth2 deposit contract, which is used under CC0-1.0\\r\\n\\r\\n/**\\r\\n * @title MerkleLib\\r\\n * @author Illusory Systems Inc.\\r\\n * @notice An incremental merkle tree modeled on the eth2 deposit contract.\\r\\n **/\\r\\nlibrary MerkleLib {\\r\\n    uint256 internal constant TREE_DEPTH = 32;\\r\\n    uint256 internal constant MAX_LEAVES = 2**TREE_DEPTH - 1;\\r\\n\\r\\n    /**\\r\\n     * @notice Struct representing incremental merkle tree. Contains current\\r\\n     * branch and the number of inserted leaves in the tree.\\r\\n     **/\\r\\n    struct Tree {\\r\\n        bytes32[TREE_DEPTH] branch;\\r\\n        uint256 count;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Inserts `_node` into merkle tree\\r\\n     * @dev Reverts if tree is full\\r\\n     * @param _node Element to insert into tree\\r\\n     **/\\r\\n    function insert(Tree storage _tree, bytes32 _node) internal {\\r\\n        require(_tree.count < MAX_LEAVES, \\\"merkle tree full\\\");\\r\\n\\r\\n        _tree.count += 1;\\r\\n        uint256 size = _tree.count;\\r\\n        for (uint256 i = 0; i < TREE_DEPTH; i++) {\\r\\n            if ((size & 1) == 1) {\\r\\n                _tree.branch[i] = _node;\\r\\n                return;\\r\\n            }\\r\\n            _node = keccak256(abi.encodePacked(_tree.branch[i], _node));\\r\\n            size /= 2;\\r\\n        }\\r\\n        // As the loop should always end prematurely with the `return` statement,\\r\\n        // this code should be unreachable. We assert `false` just to be safe.\\r\\n        assert(false);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Calculates and returns`_tree`'s current root given array of zero\\r\\n     * hashes\\r\\n     * @param _zeroes Array of zero hashes\\r\\n     * @return _current Calculated root of `_tree`\\r\\n     **/\\r\\n    function rootWithCtx(Tree storage _tree, bytes32[TREE_DEPTH] memory _zeroes)\\r\\n        internal\\r\\n        view\\r\\n        returns (bytes32 _current)\\r\\n    {\\r\\n        uint256 _index = _tree.count;\\r\\n\\r\\n        for (uint256 i = 0; i < TREE_DEPTH; i++) {\\r\\n            uint256 _ithBit = (_index >> i) & 0x01;\\r\\n            bytes32 _next = _tree.branch[i];\\r\\n            if (_ithBit == 1) {\\r\\n                _current = keccak256(abi.encodePacked(_next, _current));\\r\\n            } else {\\r\\n                _current = keccak256(abi.encodePacked(_current, _zeroes[i]));\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @notice Calculates and returns`_tree`'s current root\\r\\n    function root(Tree storage _tree) internal view returns (bytes32) {\\r\\n        return rootWithCtx(_tree, zeroHashes());\\r\\n    }\\r\\n\\r\\n    /// @notice Returns array of TREE_DEPTH zero hashes\\r\\n    /// @return _zeroes Array of TREE_DEPTH zero hashes\\r\\n    function zeroHashes()\\r\\n        internal\\r\\n        pure\\r\\n        returns (bytes32[TREE_DEPTH] memory _zeroes)\\r\\n    {\\r\\n        _zeroes[0] = Z_0;\\r\\n        _zeroes[1] = Z_1;\\r\\n        _zeroes[2] = Z_2;\\r\\n        _zeroes[3] = Z_3;\\r\\n        _zeroes[4] = Z_4;\\r\\n        _zeroes[5] = Z_5;\\r\\n        _zeroes[6] = Z_6;\\r\\n        _zeroes[7] = Z_7;\\r\\n        _zeroes[8] = Z_8;\\r\\n        _zeroes[9] = Z_9;\\r\\n        _zeroes[10] = Z_10;\\r\\n        _zeroes[11] = Z_11;\\r\\n        _zeroes[12] = Z_12;\\r\\n        _zeroes[13] = Z_13;\\r\\n        _zeroes[14] = Z_14;\\r\\n        _zeroes[15] = Z_15;\\r\\n        _zeroes[16] = Z_16;\\r\\n        _zeroes[17] = Z_17;\\r\\n        _zeroes[18] = Z_18;\\r\\n        _zeroes[19] = Z_19;\\r\\n        _zeroes[20] = Z_20;\\r\\n        _zeroes[21] = Z_21;\\r\\n        _zeroes[22] = Z_22;\\r\\n        _zeroes[23] = Z_23;\\r\\n        _zeroes[24] = Z_24;\\r\\n        _zeroes[25] = Z_25;\\r\\n        _zeroes[26] = Z_26;\\r\\n        _zeroes[27] = Z_27;\\r\\n        _zeroes[28] = Z_28;\\r\\n        _zeroes[29] = Z_29;\\r\\n        _zeroes[30] = Z_30;\\r\\n        _zeroes[31] = Z_31;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Calculates and returns the merkle root for the given leaf\\r\\n     * `_item`, a merkle branch, and the index of `_item` in the tree.\\r\\n     * @param _item Merkle leaf\\r\\n     * @param _branch Merkle proof\\r\\n     * @param _index Index of `_item` in tree\\r\\n     * @return _current Calculated merkle root\\r\\n     **/\\r\\n    function branchRoot(\\r\\n        bytes32 _item,\\r\\n        bytes32[TREE_DEPTH] memory _branch,\\r\\n        uint256 _index\\r\\n    ) internal pure returns (bytes32 _current) {\\r\\n        _current = _item;\\r\\n\\r\\n        for (uint256 i = 0; i < TREE_DEPTH; i++) {\\r\\n            uint256 _ithBit = (_index >> i) & 0x01;\\r\\n            bytes32 _next = _branch[i];\\r\\n            if (_ithBit == 1) {\\r\\n                _current = keccak256(abi.encodePacked(_next, _current));\\r\\n            } else {\\r\\n                _current = keccak256(abi.encodePacked(_current, _next));\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // keccak256 zero hashes\\r\\n    bytes32 internal constant Z_0 =\\r\\n        hex\\\"0000000000000000000000000000000000000000000000000000000000000000\\\";\\r\\n    bytes32 internal constant Z_1 =\\r\\n        hex\\\"ad3228b676f7d3cd4284a5443f17f1962b36e491b30a40b2405849e597ba5fb5\\\";\\r\\n    bytes32 internal constant Z_2 =\\r\\n        hex\\\"b4c11951957c6f8f642c4af61cd6b24640fec6dc7fc607ee8206a99e92410d30\\\";\\r\\n    bytes32 internal constant Z_3 =\\r\\n        hex\\\"21ddb9a356815c3fac1026b6dec5df3124afbadb485c9ba5a3e3398a04b7ba85\\\";\\r\\n    bytes32 internal constant Z_4 =\\r\\n        hex\\\"e58769b32a1beaf1ea27375a44095a0d1fb664ce2dd358e7fcbfb78c26a19344\\\";\\r\\n    bytes32 internal constant Z_5 =\\r\\n        hex\\\"0eb01ebfc9ed27500cd4dfc979272d1f0913cc9f66540d7e8005811109e1cf2d\\\";\\r\\n    bytes32 internal constant Z_6 =\\r\\n        hex\\\"887c22bd8750d34016ac3c66b5ff102dacdd73f6b014e710b51e8022af9a1968\\\";\\r\\n    bytes32 internal constant Z_7 =\\r\\n        hex\\\"ffd70157e48063fc33c97a050f7f640233bf646cc98d9524c6b92bcf3ab56f83\\\";\\r\\n    bytes32 internal constant Z_8 =\\r\\n        hex\\\"9867cc5f7f196b93bae1e27e6320742445d290f2263827498b54fec539f756af\\\";\\r\\n    bytes32 internal constant Z_9 =\\r\\n        hex\\\"cefad4e508c098b9a7e1d8feb19955fb02ba9675585078710969d3440f5054e0\\\";\\r\\n    bytes32 internal constant Z_10 =\\r\\n        hex\\\"f9dc3e7fe016e050eff260334f18a5d4fe391d82092319f5964f2e2eb7c1c3a5\\\";\\r\\n    bytes32 internal constant Z_11 =\\r\\n        hex\\\"f8b13a49e282f609c317a833fb8d976d11517c571d1221a265d25af778ecf892\\\";\\r\\n    bytes32 internal constant Z_12 =\\r\\n        hex\\\"3490c6ceeb450aecdc82e28293031d10c7d73bf85e57bf041a97360aa2c5d99c\\\";\\r\\n    bytes32 internal constant Z_13 =\\r\\n        hex\\\"c1df82d9c4b87413eae2ef048f94b4d3554cea73d92b0f7af96e0271c691e2bb\\\";\\r\\n    bytes32 internal constant Z_14 =\\r\\n        hex\\\"5c67add7c6caf302256adedf7ab114da0acfe870d449a3a489f781d659e8becc\\\";\\r\\n    bytes32 internal constant Z_15 =\\r\\n        hex\\\"da7bce9f4e8618b6bd2f4132ce798cdc7a60e7e1460a7299e3c6342a579626d2\\\";\\r\\n    bytes32 internal constant Z_16 =\\r\\n        hex\\\"2733e50f526ec2fa19a22b31e8ed50f23cd1fdf94c9154ed3a7609a2f1ff981f\\\";\\r\\n    bytes32 internal constant Z_17 =\\r\\n        hex\\\"e1d3b5c807b281e4683cc6d6315cf95b9ade8641defcb32372f1c126e398ef7a\\\";\\r\\n    bytes32 internal constant Z_18 =\\r\\n        hex\\\"5a2dce0a8a7f68bb74560f8f71837c2c2ebbcbf7fffb42ae1896f13f7c7479a0\\\";\\r\\n    bytes32 internal constant Z_19 =\\r\\n        hex\\\"b46a28b6f55540f89444f63de0378e3d121be09e06cc9ded1c20e65876d36aa0\\\";\\r\\n    bytes32 internal constant Z_20 =\\r\\n        hex\\\"c65e9645644786b620e2dd2ad648ddfcbf4a7e5b1a3a4ecfe7f64667a3f0b7e2\\\";\\r\\n    bytes32 internal constant Z_21 =\\r\\n        hex\\\"f4418588ed35a2458cffeb39b93d26f18d2ab13bdce6aee58e7b99359ec2dfd9\\\";\\r\\n    bytes32 internal constant Z_22 =\\r\\n        hex\\\"5a9c16dc00d6ef18b7933a6f8dc65ccb55667138776f7dea101070dc8796e377\\\";\\r\\n    bytes32 internal constant Z_23 =\\r\\n        hex\\\"4df84f40ae0c8229d0d6069e5c8f39a7c299677a09d367fc7b05e3bc380ee652\\\";\\r\\n    bytes32 internal constant Z_24 =\\r\\n        hex\\\"cdc72595f74c7b1043d0e1ffbab734648c838dfb0527d971b602bc216c9619ef\\\";\\r\\n    bytes32 internal constant Z_25 =\\r\\n        hex\\\"0abf5ac974a1ed57f4050aa510dd9c74f508277b39d7973bb2dfccc5eeb0618d\\\";\\r\\n    bytes32 internal constant Z_26 =\\r\\n        hex\\\"b8cd74046ff337f0a7bf2c8e03e10f642c1886798d71806ab1e888d9e5ee87d0\\\";\\r\\n    bytes32 internal constant Z_27 =\\r\\n        hex\\\"838c5655cb21c6cb83313b5a631175dff4963772cce9108188b34ac87c81c41e\\\";\\r\\n    bytes32 internal constant Z_28 =\\r\\n        hex\\\"662ee4dd2dd7b2bc707961b1e646c4047669dcb6584f0d8d770daf5d7e7deb2e\\\";\\r\\n    bytes32 internal constant Z_29 =\\r\\n        hex\\\"388ab20e2573d171a88108e79d820e98f26c0b84aa8b2f4aa4968dbb818ea322\\\";\\r\\n    bytes32 internal constant Z_30 =\\r\\n        hex\\\"93237c50ba75ee485f4c22adf2f741400bdf8d6a9cc7df7ecae576221665d735\\\";\\r\\n    bytes32 internal constant Z_31 =\\r\\n        hex\\\"8448818bb4ae4562849e949e17ac16e0be16688e156b5cf15e098c627c0056a9\\\";\\r\\n}\\r\\n\",\"keccak256\":\"0x55b1d8df57eb38fd4118ccf224388cc899445e7bc8081bc7567c48652450d8cd\",\"license\":\"MIT OR Apache-2.0\"},\"contracts/nomad-core/libs/Message.sol\":{\"content\":\"// SPDX-License-Identifier: MIT OR Apache-2.0\\r\\npragma solidity >=0.6.11;\\r\\n\\r\\n// import \\\"@summa-tx/memview-sol/contracts/TypedMemView.sol\\\";\\r\\n\\r\\nimport \\\"./TypedMemView.sol\\\";\\r\\n\\r\\nimport {\\r\\n    TypeCasts\\r\\n} from \\\"./TypeCasts.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title Message Library\\r\\n * @author Illusory Systems Inc.\\r\\n * @notice Library for formatted messages used by Home and Replica.\\r\\n **/\\r\\nlibrary Message {\\r\\n    using TypedMemView for bytes;\\r\\n    using TypedMemView for bytes29;\\r\\n\\r\\n    // Number of bytes in formatted message before `body` field\\r\\n    uint256 internal constant PREFIX_LENGTH = 76;\\r\\n\\r\\n    /**\\r\\n     * @notice Returns formatted (packed) message with provided fields\\r\\n     * @param _originDomain Domain of home chain\\r\\n     * @param _sender Address of sender as bytes32\\r\\n     * @param _nonce Destination-specific nonce\\r\\n     * @param _destinationDomain Domain of destination chain\\r\\n     * @param _recipient Address of recipient on destination chain as bytes32\\r\\n     * @param _messageBody Raw bytes of message body\\r\\n     * @return Formatted message\\r\\n     **/\\r\\n    function formatMessage(\\r\\n        uint32 _originDomain,\\r\\n        bytes32 _sender,\\r\\n        uint32 _nonce,\\r\\n        uint32 _destinationDomain,\\r\\n        bytes32 _recipient,\\r\\n        bytes memory _messageBody\\r\\n    ) internal pure returns (bytes memory) {\\r\\n        return\\r\\n            abi.encodePacked(\\r\\n                _originDomain,\\r\\n                _sender,\\r\\n                _nonce,\\r\\n                _destinationDomain,\\r\\n                _recipient,\\r\\n                _messageBody\\r\\n            );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Returns leaf of formatted message with provided fields.\\r\\n     * @param _origin Domain of home chain\\r\\n     * @param _sender Address of sender as bytes32\\r\\n     * @param _nonce Destination-specific nonce number\\r\\n     * @param _destination Domain of destination chain\\r\\n     * @param _recipient Address of recipient on destination chain as bytes32\\r\\n     * @param _body Raw bytes of message body\\r\\n     * @return Leaf (hash) of formatted message\\r\\n     **/\\r\\n    function messageHash(\\r\\n        uint32 _origin,\\r\\n        bytes32 _sender,\\r\\n        uint32 _nonce,\\r\\n        uint32 _destination,\\r\\n        bytes32 _recipient,\\r\\n        bytes memory _body\\r\\n    ) internal pure returns (bytes32) {\\r\\n        return\\r\\n            keccak256(\\r\\n                formatMessage(\\r\\n                    _origin,\\r\\n                    _sender,\\r\\n                    _nonce,\\r\\n                    _destination,\\r\\n                    _recipient,\\r\\n                    _body\\r\\n                )\\r\\n            );\\r\\n    }\\r\\n\\r\\n    /// @notice Returns message's origin field\\r\\n    function origin(bytes29 _message) internal pure returns (uint32) {\\r\\n        return uint32(_message.indexUint(0, 4));\\r\\n    }\\r\\n\\r\\n    /// @notice Returns message's sender field\\r\\n    function sender(bytes29 _message) internal pure returns (bytes32) {\\r\\n        return _message.index(4, 32);\\r\\n    }\\r\\n\\r\\n    /// @notice Returns message's nonce field\\r\\n    function nonce(bytes29 _message) internal pure returns (uint32) {\\r\\n        return uint32(_message.indexUint(36, 4));\\r\\n    }\\r\\n\\r\\n    /// @notice Returns message's destination field\\r\\n    function destination(bytes29 _message) internal pure returns (uint32) {\\r\\n        return uint32(_message.indexUint(40, 4));\\r\\n    }\\r\\n\\r\\n    /// @notice Returns message's recipient field as bytes32\\r\\n    function recipient(bytes29 _message) internal pure returns (bytes32) {\\r\\n        return _message.index(44, 32);\\r\\n    }\\r\\n\\r\\n    /// @notice Returns message's recipient field as an address\\r\\n    function recipientAddress(bytes29 _message)\\r\\n        internal\\r\\n        pure\\r\\n        returns (address)\\r\\n    {\\r\\n        return TypeCasts.bytes32ToAddress(recipient(_message));\\r\\n    }\\r\\n\\r\\n    /// @notice Returns message's body field as bytes29 (refer to TypedMemView library for details on bytes29 type)\\r\\n    function body(bytes29 _message) internal pure returns (bytes29) {\\r\\n        return _message.slice(PREFIX_LENGTH, _message.len() - PREFIX_LENGTH, 0);\\r\\n    }\\r\\n\\r\\n    function leaf(bytes29 _message) internal view returns (bytes32) {\\r\\n        return messageHash(origin(_message), sender(_message), nonce(_message), destination(_message), recipient(_message), TypedMemView.clone(body(_message)));\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0x53f8b1b252d1e0e07e611dc1d908b75055187c73f7816277a4da51a514e6da39\",\"license\":\"MIT OR Apache-2.0\"},\"contracts/nomad-core/libs/Queue.sol\":{\"content\":\"// SPDX-License-Identifier: MIT OR Apache-2.0\\r\\npragma solidity >=0.6.11;\\r\\n\\r\\n/**\\r\\n * @title QueueLib\\r\\n * @author Illusory Systems Inc.\\r\\n * @notice Library containing queue struct and operations for queue used by\\r\\n * Home and Replica.\\r\\n **/\\r\\nlibrary QueueLib {\\r\\n    /**\\r\\n     * @notice Queue struct\\r\\n     * @dev Internally keeps track of the `first` and `last` elements through\\r\\n     * indices and a mapping of indices to enqueued elements.\\r\\n     **/\\r\\n    struct Queue {\\r\\n        uint128 first;\\r\\n        uint128 last;\\r\\n        mapping(uint256 => bytes32) queue;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Initializes the queue\\r\\n     * @dev Empty state denoted by _q.first > q._last. Queue initialized\\r\\n     * with _q.first = 1 and _q.last = 0.\\r\\n     **/\\r\\n    function initialize(Queue storage _q) internal {\\r\\n        if (_q.first == 0) {\\r\\n            _q.first = 1;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Enqueues a single new element\\r\\n     * @param _item New element to be enqueued\\r\\n     * @return _last Index of newly enqueued element\\r\\n     **/\\r\\n    function enqueue(Queue storage _q, bytes32 _item)\\r\\n        internal\\r\\n        returns (uint128 _last)\\r\\n    {\\r\\n        _last = _q.last + 1;\\r\\n        _q.last = _last;\\r\\n        if (_item != bytes32(0)) {\\r\\n            // saves gas if we're queueing 0\\r\\n            _q.queue[_last] = _item;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Dequeues element at front of queue\\r\\n     * @dev Removes dequeued element from storage\\r\\n     * @return _item Dequeued element\\r\\n     **/\\r\\n    function dequeue(Queue storage _q) internal returns (bytes32 _item) {\\r\\n        uint128 _last = _q.last;\\r\\n        uint128 _first = _q.first;\\r\\n        require(_length(_last, _first) != 0, \\\"Empty\\\");\\r\\n        _item = _q.queue[_first];\\r\\n        if (_item != bytes32(0)) {\\r\\n            // saves gas if we're dequeuing 0\\r\\n            delete _q.queue[_first];\\r\\n        }\\r\\n        _q.first = _first + 1;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Batch enqueues several elements\\r\\n     * @param _items Array of elements to be enqueued\\r\\n     * @return _last Index of last enqueued element\\r\\n     **/\\r\\n    function enqueue(Queue storage _q, bytes32[] memory _items)\\r\\n        internal\\r\\n        returns (uint128 _last)\\r\\n    {\\r\\n        _last = _q.last;\\r\\n        for (uint256 i = 0; i < _items.length; i += 1) {\\r\\n            _last += 1;\\r\\n            bytes32 _item = _items[i];\\r\\n            if (_item != bytes32(0)) {\\r\\n                _q.queue[_last] = _item;\\r\\n            }\\r\\n        }\\r\\n        _q.last = _last;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Batch dequeues `_number` elements\\r\\n     * @dev Reverts if `_number` > queue length\\r\\n     * @param _number Number of elements to dequeue\\r\\n     * @return Array of dequeued elements\\r\\n     **/\\r\\n    function dequeue(Queue storage _q, uint256 _number)\\r\\n        internal\\r\\n        returns (bytes32[] memory)\\r\\n    {\\r\\n        uint128 _last = _q.last;\\r\\n        uint128 _first = _q.first;\\r\\n        // Cannot underflow unless state is corrupted\\r\\n        require(_length(_last, _first) >= _number, \\\"Insufficient\\\");\\r\\n\\r\\n        bytes32[] memory _items = new bytes32[](_number);\\r\\n\\r\\n        for (uint256 i = 0; i < _number; i++) {\\r\\n            _items[i] = _q.queue[_first];\\r\\n            delete _q.queue[_first];\\r\\n            _first++;\\r\\n        }\\r\\n        _q.first = _first;\\r\\n        return _items;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Returns true if `_item` is in the queue and false if otherwise\\r\\n     * @dev Linearly scans from _q.first to _q.last looking for `_item`\\r\\n     * @param _item Item being searched for in queue\\r\\n     * @return True if `_item` currently exists in queue, false if otherwise\\r\\n     **/\\r\\n    function contains(Queue storage _q, bytes32 _item)\\r\\n        internal\\r\\n        view\\r\\n        returns (bool)\\r\\n    {\\r\\n        for (uint256 i = _q.first; i <= _q.last; i++) {\\r\\n            if (_q.queue[i] == _item) {\\r\\n                return true;\\r\\n            }\\r\\n        }\\r\\n        return false;\\r\\n    }\\r\\n\\r\\n    /// @notice Returns last item in queue\\r\\n    /// @dev Returns bytes32(0) if queue empty\\r\\n    function lastItem(Queue storage _q) internal view returns (bytes32) {\\r\\n        return _q.queue[_q.last];\\r\\n    }\\r\\n\\r\\n    /// @notice Returns element at front of queue without removing element\\r\\n    /// @dev Reverts if queue is empty\\r\\n    function peek(Queue storage _q) internal view returns (bytes32 _item) {\\r\\n        require(!isEmpty(_q), \\\"Empty\\\");\\r\\n        _item = _q.queue[_q.first];\\r\\n    }\\r\\n\\r\\n    /// @notice Returns true if queue is empty and false if otherwise\\r\\n    function isEmpty(Queue storage _q) internal view returns (bool) {\\r\\n        return _q.last < _q.first;\\r\\n    }\\r\\n\\r\\n    /// @notice Returns number of elements in queue\\r\\n    function length(Queue storage _q) internal view returns (uint256) {\\r\\n        uint128 _last = _q.last;\\r\\n        uint128 _first = _q.first;\\r\\n        // Cannot underflow unless state is corrupted\\r\\n        return _length(_last, _first);\\r\\n    }\\r\\n\\r\\n    /// @notice Returns number of elements between `_last` and `_first` (used internally)\\r\\n    function _length(uint128 _last, uint128 _first)\\r\\n        internal\\r\\n        pure\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return uint256(_last + 1 - _first);\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0x9819dd4b1f54b6945a75bd6089807d81e63fb66b5bff02e94ae6159f17c8c36a\",\"license\":\"MIT OR Apache-2.0\"},\"contracts/nomad-core/libs/TypeCasts.sol\":{\"content\":\"// SPDX-License-Identifier: MIT OR Apache-2.0\\r\\npragma solidity >=0.6.11;\\r\\n\\r\\n// import \\\"@summa-tx/memview-sol/contracts/TypedMemView.sol\\\";\\r\\nimport \\\"./TypedMemView.sol\\\";\\r\\n\\r\\n\\r\\nlibrary TypeCasts {\\r\\n    using TypedMemView for bytes;\\r\\n    using TypedMemView for bytes29;\\r\\n\\r\\n    function coerceBytes32(string memory _s)\\r\\n        internal\\r\\n        pure\\r\\n        returns (bytes32 _b)\\r\\n    {\\r\\n        _b = bytes(_s).ref(0).index(0, uint8(bytes(_s).length));\\r\\n    }\\r\\n\\r\\n    // treat it as a null-terminated string of max 32 bytes\\r\\n    function coerceString(bytes32 _buf)\\r\\n        internal\\r\\n        pure\\r\\n        returns (string memory _newStr)\\r\\n    {\\r\\n        uint8 _slen = 0;\\r\\n        while (_slen < 32 && _buf[_slen] != 0) {\\r\\n            _slen++;\\r\\n        }\\r\\n\\r\\n        // solhint-disable-next-line no-inline-assembly\\r\\n        assembly {\\r\\n            _newStr := mload(0x40)\\r\\n            mstore(0x40, add(_newStr, 0x40)) // may end up with extra\\r\\n            mstore(_newStr, _slen)\\r\\n            mstore(add(_newStr, 0x20), _buf)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // alignment preserving cast\\r\\n    function addressToBytes32(address _addr) internal pure returns (bytes32) {\\r\\n        return bytes32(uint256(uint160(_addr)));\\r\\n    }\\r\\n\\r\\n    // alignment preserving cast\\r\\n    function bytes32ToAddress(bytes32 _buf) internal pure returns (address) {\\r\\n        return address(uint160(uint256(_buf)));\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0x09f90de8fd9a85644948cab19e96adfaf13c944c691f0b5c94eed98c2c9cbe0e\",\"license\":\"MIT OR Apache-2.0\"},\"contracts/nomad-core/libs/TypedMemView.sol\":{\"content\":\"// SPDX-License-Identifier: MIT OR Apache-2.0\\r\\npragma solidity >=0.5.10;\\r\\n\\r\\nimport {SafeMath} from \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\r\\n\\r\\nlibrary TypedMemView {\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    // Why does this exist?\\r\\n    // the solidity `bytes memory` type has a few weaknesses.\\r\\n    // 1. You can't index ranges effectively\\r\\n    // 2. You can't slice without copying\\r\\n    // 3. The underlying data may represent any type\\r\\n    // 4. Solidity never deallocates memory, and memory costs grow\\r\\n    //    superlinearly\\r\\n\\r\\n    // By using a memory view instead of a `bytes memory` we get the following\\r\\n    // advantages:\\r\\n    // 1. Slices are done on the stack, by manipulating the pointer\\r\\n    // 2. We can index arbitrary ranges and quickly convert them to stack types\\r\\n    // 3. We can insert type info into the pointer, and typecheck at runtime\\r\\n\\r\\n    // This makes `TypedMemView` a useful tool for efficient zero-copy\\r\\n    // algorithms.\\r\\n\\r\\n    // Why bytes29?\\r\\n    // We want to avoid confusion between views, digests, and other common\\r\\n    // types so we chose a large and uncommonly used odd number of bytes\\r\\n    //\\r\\n    // Note that while bytes are left-aligned in a word, integers and addresses\\r\\n    // are right-aligned. This means when working in assembly we have to\\r\\n    // account for the 3 unused bytes on the righthand side\\r\\n    //\\r\\n    // First 5 bytes are a type flag.\\r\\n    // - ff_ffff_fffe is reserved for unknown type.\\r\\n    // - ff_ffff_ffff is reserved for invalid types/errors.\\r\\n    // next 12 are memory address\\r\\n    // next 12 are len\\r\\n    // bottom 3 bytes are empty\\r\\n\\r\\n    // Assumptions:\\r\\n    // - non-modification of memory.\\r\\n    // - No Solidity updates\\r\\n    // - - wrt free mem point\\r\\n    // - - wrt bytes representation in memory\\r\\n    // - - wrt memory addressing in general\\r\\n\\r\\n    // Usage:\\r\\n    // - create type constants\\r\\n    // - use `assertType` for runtime type assertions\\r\\n    // - - unfortunately we can't do this at compile time yet :(\\r\\n    // - recommended: implement modifiers that perform type checking\\r\\n    // - - e.g.\\r\\n    // - - `uint40 constant MY_TYPE = 3;`\\r\\n    // - - ` modifer onlyMyType(bytes29 myView) { myView.assertType(MY_TYPE); }`\\r\\n    // - instantiate a typed view from a bytearray using `ref`\\r\\n    // - use `index` to inspect the contents of the view\\r\\n    // - use `slice` to create smaller views into the same memory\\r\\n    // - - `slice` can increase the offset\\r\\n    // - - `slice can decrease the length`\\r\\n    // - - must specify the output type of `slice`\\r\\n    // - - `slice` will return a null view if you try to overrun\\r\\n    // - - make sure to explicitly check for this with `notNull` or `assertType`\\r\\n    // - use `equal` for typed comparisons.\\r\\n\\r\\n\\r\\n    // The null view\\r\\n    bytes29 public constant NULL = hex\\\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\\\";\\r\\n    uint256 constant LOW_12_MASK = 0xffffffffffffffffffffffff;\\r\\n    uint8 constant TWELVE_BYTES = 96;\\r\\n\\r\\n    /**\\r\\n     * @notice      Returns the encoded hex character that represents the lower 4 bits of the argument.\\r\\n     * @param _b    The byte\\r\\n     * @return      char - The encoded hex character\\r\\n     */\\r\\n    function nibbleHex(uint8 _b) internal pure returns (uint8 char) {\\r\\n        // This can probably be done more efficiently, but it's only in error\\r\\n        // paths, so we don't really care :)\\r\\n        uint8 _nibble = _b | 0xf0; // set top 4, keep bottom 4\\r\\n        if (_nibble == 0xf0) {return 0x30;} // 0\\r\\n        if (_nibble == 0xf1) {return 0x31;} // 1\\r\\n        if (_nibble == 0xf2) {return 0x32;} // 2\\r\\n        if (_nibble == 0xf3) {return 0x33;} // 3\\r\\n        if (_nibble == 0xf4) {return 0x34;} // 4\\r\\n        if (_nibble == 0xf5) {return 0x35;} // 5\\r\\n        if (_nibble == 0xf6) {return 0x36;} // 6\\r\\n        if (_nibble == 0xf7) {return 0x37;} // 7\\r\\n        if (_nibble == 0xf8) {return 0x38;} // 8\\r\\n        if (_nibble == 0xf9) {return 0x39;} // 9\\r\\n        if (_nibble == 0xfa) {return 0x61;} // a\\r\\n        if (_nibble == 0xfb) {return 0x62;} // b\\r\\n        if (_nibble == 0xfc) {return 0x63;} // c\\r\\n        if (_nibble == 0xfd) {return 0x64;} // d\\r\\n        if (_nibble == 0xfe) {return 0x65;} // e\\r\\n        if (_nibble == 0xff) {return 0x66;} // f\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice      Returns a uint16 containing the hex-encoded byte.\\r\\n     * @param _b    The byte\\r\\n     * @return      encoded - The hex-encoded byte\\r\\n     */\\r\\n    function byteHex(uint8 _b) internal pure returns (uint16 encoded) {\\r\\n        encoded |= nibbleHex(_b >> 4); // top 4 bits\\r\\n        encoded <<= 8;\\r\\n        encoded |= nibbleHex(_b); // lower 4 bits\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice      Encodes the uint256 to hex. `first` contains the encoded top 16 bytes.\\r\\n     *              `second` contains the encoded lower 16 bytes.\\r\\n     *\\r\\n     * @param _b    The 32 bytes as uint256\\r\\n     * @return      first - The top 16 bytes\\r\\n     * @return      second - The bottom 16 bytes\\r\\n     */\\r\\n    function encodeHex(uint256 _b) internal pure returns (uint256 first, uint256 second) {\\r\\n        for (uint8 i = 31; i > 15; i -= 1) {\\r\\n            uint8 _byte = uint8(_b >> (i * 8));\\r\\n            first |= byteHex(_byte);\\r\\n            if (i != 16) {\\r\\n                first <<= 16;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // abusing underflow here =_=\\r\\n        for (uint8 i = 15; i < 255 ; i -= 1) {\\r\\n            uint8 _byte = uint8(_b >> (i * 8));\\r\\n            second |= byteHex(_byte);\\r\\n            if (i != 0) {\\r\\n                second <<= 16;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice          Changes the endianness of a uint256.\\r\\n     * @dev             https://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel\\r\\n     * @param _b        The unsigned integer to reverse\\r\\n     * @return          v - The reversed value\\r\\n     */\\r\\n    function reverseUint256(uint256 _b) internal pure returns (uint256 v) {\\r\\n        v = _b;\\r\\n\\r\\n        // swap bytes\\r\\n        v = ((v >> 8) & 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) |\\r\\n            ((v & 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) << 8);\\r\\n        // swap 2-byte long pairs\\r\\n        v = ((v >> 16) & 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) |\\r\\n            ((v & 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) << 16);\\r\\n        // swap 4-byte long pairs\\r\\n        v = ((v >> 32) & 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) |\\r\\n            ((v & 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) << 32);\\r\\n        // swap 8-byte long pairs\\r\\n        v = ((v >> 64) & 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) |\\r\\n            ((v & 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) << 64);\\r\\n        // swap 16-byte long pairs\\r\\n        v = (v >> 128) | (v << 128);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice      Create a mask with the highest `_len` bits set.\\r\\n     * @param _len  The length\\r\\n     * @return      mask - The mask\\r\\n     */\\r\\n    function leftMask(uint8 _len) private pure returns (uint256 mask) {\\r\\n        // ugly. redo without assembly?\\r\\n        assembly {\\r\\n            // solium-disable-previous-line security/no-inline-assembly\\r\\n            mask := sar(\\r\\n                sub(_len, 1),\\r\\n                0x8000000000000000000000000000000000000000000000000000000000000000\\r\\n            )\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice      Return the null view.\\r\\n     * @return      bytes29 - The null view\\r\\n     */\\r\\n    function nullView() internal pure returns (bytes29) {\\r\\n        return NULL;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice      Check if the view is null.\\r\\n     * @return      bool - True if the view is null\\r\\n     */\\r\\n    function isNull(bytes29 memView) internal pure returns (bool) {\\r\\n        return memView == NULL;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice      Check if the view is not null.\\r\\n     * @return      bool - True if the view is not null\\r\\n     */\\r\\n    function notNull(bytes29 memView) internal pure returns (bool) {\\r\\n        return !isNull(memView);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice          Check if the view is of a valid type and points to a valid location\\r\\n     *                  in memory.\\r\\n     * @dev             We perform this check by examining solidity's unallocated memory\\r\\n     *                  pointer and ensuring that the view's upper bound is less than that.\\r\\n     * @param memView   The view\\r\\n     * @return          ret - True if the view is valid\\r\\n     */\\r\\n    function isValid(bytes29 memView) internal pure returns (bool ret) {\\r\\n        if (typeOf(memView) == 0xffffffffff) {return false;}\\r\\n        uint256 _end = end(memView);\\r\\n        assembly {\\r\\n            // solium-disable-previous-line security/no-inline-assembly\\r\\n            ret := not(gt(_end, mload(0x40)))\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice          Require that a typed memory view be valid.\\r\\n     * @dev             Returns the view for easy chaining.\\r\\n     * @param memView   The view\\r\\n     * @return          bytes29 - The validated view\\r\\n     */\\r\\n    function assertValid(bytes29 memView) internal pure returns (bytes29) {\\r\\n        require(isValid(memView), \\\"Validity assertion failed\\\");\\r\\n        return memView;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice          Return true if the memview is of the expected type. Otherwise false.\\r\\n     * @param memView   The view\\r\\n     * @param _expected The expected type\\r\\n     * @return          bool - True if the memview is of the expected type\\r\\n     */\\r\\n    function isType(bytes29 memView, uint40 _expected) internal pure returns (bool) {\\r\\n        return typeOf(memView) == _expected;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice          Require that a typed memory view has a specific type.\\r\\n     * @dev             Returns the view for easy chaining.\\r\\n     * @param memView   The view\\r\\n     * @param _expected The expected type\\r\\n     * @return          bytes29 - The view with validated type\\r\\n     */\\r\\n    function assertType(bytes29 memView, uint40 _expected) internal pure returns (bytes29) {\\r\\n        if (!isType(memView, _expected)) {\\r\\n            (, uint256 g) = encodeHex(uint256(typeOf(memView)));\\r\\n            (, uint256 e) = encodeHex(uint256(_expected));\\r\\n            string memory err = string(\\r\\n                abi.encodePacked(\\r\\n                    \\\"Type assertion failed. Got 0x\\\",\\r\\n                    uint80(g),\\r\\n                    \\\". Expected 0x\\\",\\r\\n                    uint80(e)\\r\\n                )\\r\\n            );\\r\\n            revert(err);\\r\\n        }\\r\\n        return memView;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice          Return an identical view with a different type.\\r\\n     * @param memView   The view\\r\\n     * @param _newType  The new type\\r\\n     * @return          newView - The new view with the specified type\\r\\n     */\\r\\n    function castTo(bytes29 memView, uint40 _newType) internal pure returns (bytes29 newView) {\\r\\n        // then | in the new type\\r\\n        assembly {\\r\\n            // solium-disable-previous-line security/no-inline-assembly\\r\\n            // shift off the top 5 bytes\\r\\n            newView := or(newView, shr(40, shl(40, memView)))\\r\\n            newView := or(newView, shl(216, _newType))\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice          Unsafe raw pointer construction. This should generally not be called\\r\\n     *                  directly. Prefer `ref` wherever possible.\\r\\n     * @dev             Unsafe raw pointer construction. This should generally not be called\\r\\n     *                  directly. Prefer `ref` wherever possible.\\r\\n     * @param _type     The type\\r\\n     * @param _loc      The memory address\\r\\n     * @param _len      The length\\r\\n     * @return          newView - The new view with the specified type, location and length\\r\\n     */\\r\\n    function unsafeBuildUnchecked(uint256 _type, uint256 _loc, uint256 _len) private pure returns (bytes29 newView) {\\r\\n        assembly {\\r\\n            // solium-disable-previous-line security/no-inline-assembly\\r\\n            newView := shl(96, or(newView, _type)) // insert type\\r\\n            newView := shl(96, or(newView, _loc))  // insert loc\\r\\n            newView := shl(24, or(newView, _len))  // empty bottom 3 bytes\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice          Instantiate a new memory view. This should generally not be called\\r\\n     *                  directly. Prefer `ref` wherever possible.\\r\\n     * @dev             Instantiate a new memory view. This should generally not be called\\r\\n     *                  directly. Prefer `ref` wherever possible.\\r\\n     * @param _type     The type\\r\\n     * @param _loc      The memory address\\r\\n     * @param _len      The length\\r\\n     * @return          newView - The new view with the specified type, location and length\\r\\n     */\\r\\n    function build(uint256 _type, uint256 _loc, uint256 _len) internal pure returns (bytes29 newView) {\\r\\n        uint256 _end = _loc.add(_len);\\r\\n        assembly {\\r\\n            // solium-disable-previous-line security/no-inline-assembly\\r\\n            if gt(_end, mload(0x40)) {\\r\\n                _end := 0\\r\\n            }\\r\\n        }\\r\\n        if (_end == 0) {\\r\\n            return NULL;\\r\\n        }\\r\\n        newView = unsafeBuildUnchecked(_type, _loc, _len);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice          Instantiate a memory view from a byte array.\\r\\n     * @dev             Note that due to Solidity memory representation, it is not possible to\\r\\n     *                  implement a deref, as the `bytes` type stores its len in memory.\\r\\n     * @param arr       The byte array\\r\\n     * @param newType   The type\\r\\n     * @return          bytes29 - The memory view\\r\\n     */\\r\\n    function ref(bytes memory arr, uint40 newType) internal pure returns (bytes29) {\\r\\n        uint256 _len = arr.length;\\r\\n\\r\\n        uint256 _loc;\\r\\n        assembly {\\r\\n            // solium-disable-previous-line security/no-inline-assembly\\r\\n            _loc := add(arr, 0x20)  // our view is of the data, not the struct\\r\\n        }\\r\\n\\r\\n        return build(newType, _loc, _len);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice          Return the associated type information.\\r\\n     * @param memView   The memory view\\r\\n     * @return          _type - The type associated with the view\\r\\n     */\\r\\n    function typeOf(bytes29 memView) internal pure returns (uint40 _type) {\\r\\n        assembly {\\r\\n            // solium-disable-previous-line security/no-inline-assembly\\r\\n            // 216 == 256 - 40\\r\\n            _type := shr(216, memView) // shift out lower 24 bytes\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice          Optimized type comparison. Checks that the 5-byte type flag is equal.\\r\\n     * @param left      The first view\\r\\n     * @param right     The second view\\r\\n     * @return          bool - True if the 5-byte type flag is equal\\r\\n     */\\r\\n    function sameType(bytes29 left, bytes29 right) internal pure returns (bool) {\\r\\n        return (left ^ right) >> (2 * TWELVE_BYTES) == 0;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice          Return the memory address of the underlying bytes.\\r\\n     * @param memView   The view\\r\\n     * @return          _loc - The memory address\\r\\n     */\\r\\n    function loc(bytes29 memView) internal pure returns (uint96 _loc) {\\r\\n        uint256 _mask = LOW_12_MASK;  // assembly can't use globals\\r\\n        assembly {\\r\\n            // solium-disable-previous-line security/no-inline-assembly\\r\\n            // 120 bits = 12 bytes (the encoded loc) + 3 bytes (empty low space)\\r\\n            _loc := and(shr(120, memView), _mask)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice          The number of memory words this memory view occupies, rounded up.\\r\\n     * @param memView   The view\\r\\n     * @return          uint256 - The number of memory words\\r\\n     */\\r\\n    function words(bytes29 memView) internal pure returns (uint256) {\\r\\n        return uint256(len(memView)).add(32) / 32;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice          The in-memory footprint of a fresh copy of the view.\\r\\n     * @param memView   The view\\r\\n     * @return          uint256 - The in-memory footprint of a fresh copy of the view.\\r\\n     */\\r\\n    function footprint(bytes29 memView) internal pure returns (uint256) {\\r\\n        return words(memView) * 32;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice          The number of bytes of the view.\\r\\n     * @param memView   The view\\r\\n     * @return          _len - The length of the view\\r\\n     */\\r\\n    function len(bytes29 memView) internal pure returns (uint96 _len) {\\r\\n        uint256 _mask = LOW_12_MASK;  // assembly can't use globals\\r\\n        assembly {\\r\\n            // solium-disable-previous-line security/no-inline-assembly\\r\\n            _len := and(shr(24, memView), _mask)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice          Returns the endpoint of `memView`.\\r\\n     * @param memView   The view\\r\\n     * @return          uint256 - The endpoint of `memView`\\r\\n     */\\r\\n    function end(bytes29 memView) internal pure returns (uint256) {\\r\\n        return loc(memView) + len(memView);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice          Safe slicing without memory modification.\\r\\n     * @param memView   The view\\r\\n     * @param _index    The start index\\r\\n     * @param _len      The length\\r\\n     * @param newType   The new type\\r\\n     * @return          bytes29 - The new view\\r\\n     */\\r\\n    function slice(bytes29 memView, uint256 _index, uint256 _len, uint40 newType) internal pure returns (bytes29) {\\r\\n        uint256 _loc = loc(memView);\\r\\n\\r\\n        // Ensure it doesn't overrun the view\\r\\n        if (_loc.add(_index).add(_len) > end(memView)) {\\r\\n            return NULL;\\r\\n        }\\r\\n\\r\\n        _loc = _loc.add(_index);\\r\\n        return build(newType, _loc, _len);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice          Shortcut to `slice`. Gets a view representing the first `_len` bytes.\\r\\n     * @param memView   The view\\r\\n     * @param _len      The length\\r\\n     * @param newType   The new type\\r\\n     * @return          bytes29 - The new view\\r\\n     */\\r\\n    function prefix(bytes29 memView, uint256 _len, uint40 newType) internal pure returns (bytes29) {\\r\\n        return slice(memView, 0, _len, newType);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice          Shortcut to `slice`. Gets a view representing the last `_len` byte.\\r\\n     * @param memView   The view\\r\\n     * @param _len      The length\\r\\n     * @param newType   The new type\\r\\n     * @return          bytes29 - The new view\\r\\n     */\\r\\n    function postfix(bytes29 memView, uint256 _len, uint40 newType) internal pure returns (bytes29) {\\r\\n        return slice(memView, uint256(len(memView)).sub(_len), _len, newType);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice          Construct an error message for an indexing overrun.\\r\\n     * @param _loc      The memory address\\r\\n     * @param _len      The length\\r\\n     * @param _index    The index\\r\\n     * @param _slice    The slice where the overrun occurred\\r\\n     * @return          err - The err\\r\\n     */\\r\\n    function indexErrOverrun(\\r\\n        uint256 _loc,\\r\\n        uint256 _len,\\r\\n        uint256 _index,\\r\\n        uint256 _slice\\r\\n    ) internal pure returns (string memory err) {\\r\\n        (, uint256 a) = encodeHex(_loc);\\r\\n        (, uint256 b) = encodeHex(_len);\\r\\n        (, uint256 c) = encodeHex(_index);\\r\\n        (, uint256 d) = encodeHex(_slice);\\r\\n        err = string(\\r\\n            abi.encodePacked(\\r\\n                \\\"TypedMemView/index - Overran the view. Slice is at 0x\\\",\\r\\n                uint48(a),\\r\\n                \\\" with length 0x\\\",\\r\\n                uint48(b),\\r\\n                \\\". Attempted to index at offset 0x\\\",\\r\\n                uint48(c),\\r\\n                \\\" with length 0x\\\",\\r\\n                uint48(d),\\r\\n                \\\".\\\"\\r\\n            )\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice          Load up to 32 bytes from the view onto the stack.\\r\\n     * @dev             Returns a bytes32 with only the `_bytes` highest bytes set.\\r\\n     *                  This can be immediately cast to a smaller fixed-length byte array.\\r\\n     *                  To automatically cast to an integer, use `indexUint`.\\r\\n     * @param memView   The view\\r\\n     * @param _index    The index\\r\\n     * @param _bytes    The bytes\\r\\n     * @return          result - The 32 byte result\\r\\n     */\\r\\n    function index(bytes29 memView, uint256 _index, uint8 _bytes) internal pure returns (bytes32 result) {\\r\\n        if (_bytes == 0) {return bytes32(0);}\\r\\n        if (_index.add(_bytes) > len(memView)) {\\r\\n            revert(indexErrOverrun(loc(memView), len(memView), _index, uint256(_bytes)));\\r\\n        }\\r\\n        require(_bytes <= 32, \\\"TypedMemView/index - Attempted to index more than 32 bytes\\\");\\r\\n\\r\\n        uint8 bitLength;\\r\\n        unchecked {\\r\\n            bitLength = _bytes * 8;\\r\\n        }\\r\\n        uint256 _loc = loc(memView);\\r\\n        uint256 _mask = leftMask(bitLength);\\r\\n        assembly {\\r\\n            // solium-disable-previous-line security/no-inline-assembly\\r\\n            result := and(mload(add(_loc, _index)), _mask)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice          Parse an unsigned integer from the view at `_index`.\\r\\n     * @dev             Requires that the view have >= `_bytes` bytes following that index.\\r\\n     * @param memView   The view\\r\\n     * @param _index    The index\\r\\n     * @param _bytes    The bytes\\r\\n     * @return          result - The unsigned integer\\r\\n     */\\r\\n    function indexUint(bytes29 memView, uint256 _index, uint8 _bytes) internal pure returns (uint256 result) {\\r\\n        return uint256(index(memView, _index, _bytes)) >> ((32 - _bytes) * 8);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice          Parse an unsigned integer from LE bytes.\\r\\n     * @param memView   The view\\r\\n     * @param _index    The index\\r\\n     * @param _bytes    The bytes\\r\\n     * @return          result - The unsigned integer\\r\\n     */\\r\\n    function indexLEUint(bytes29 memView, uint256 _index, uint8 _bytes) internal pure returns (uint256 result) {\\r\\n        return reverseUint256(uint256(index(memView, _index, _bytes)));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice          Parse an address from the view at `_index`. Requires that the view have >= 20 bytes\\r\\n     *                  following that index.\\r\\n     * @param memView   The view\\r\\n     * @param _index    The index\\r\\n     * @return          address - The address\\r\\n     */\\r\\n    function indexAddress(bytes29 memView, uint256 _index) internal pure returns (address) {\\r\\n        return address(uint160(indexUint(memView, _index, 20)));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice          Return the keccak256 hash of the underlying memory\\r\\n     * @param memView   The view\\r\\n     * @return          digest - The keccak256 hash of the underlying memory\\r\\n     */\\r\\n    function keccak(bytes29 memView) internal pure returns (bytes32 digest) {\\r\\n        uint256 _loc = loc(memView);\\r\\n        uint256 _len = len(memView);\\r\\n        assembly {\\r\\n            // solium-disable-previous-line security/no-inline-assembly\\r\\n            digest := keccak256(_loc, _len)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice          Return the sha2 digest of the underlying memory.\\r\\n     * @dev             We explicitly deallocate memory afterwards.\\r\\n     * @param memView   The view\\r\\n     * @return          digest - The sha2 hash of the underlying memory\\r\\n     */\\r\\n    function sha2(bytes29 memView) internal view returns (bytes32 digest) {\\r\\n        uint256 _loc = loc(memView);\\r\\n        uint256 _len = len(memView);\\r\\n        assembly {\\r\\n            // solium-disable-previous-line security/no-inline-assembly\\r\\n            let ptr := mload(0x40)\\r\\n            pop(staticcall(gas(), 2, _loc, _len, ptr, 0x20)) // sha2 #1\\r\\n            digest := mload(ptr)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice          Implements bitcoin's hash160 (rmd160(sha2()))\\r\\n     * @param memView   The pre-image\\r\\n     * @return          digest - the Digest\\r\\n     */\\r\\n    function hash160(bytes29 memView) internal view returns (bytes20 digest) {\\r\\n        uint256 _loc = loc(memView);\\r\\n        uint256 _len = len(memView);\\r\\n        assembly {\\r\\n            // solium-disable-previous-line security/no-inline-assembly\\r\\n            let ptr := mload(0x40)\\r\\n            pop(staticcall(gas(), 2, _loc, _len, ptr, 0x20)) // sha2\\r\\n            pop(staticcall(gas(), 3, ptr, 0x20, ptr, 0x20)) // rmd160\\r\\n            digest := mload(add(ptr, 0xc)) // return value is 0-prefixed.\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice          Implements bitcoin's hash256 (double sha2)\\r\\n     * @param memView   A view of the preimage\\r\\n     * @return          digest - the Digest\\r\\n     */\\r\\n    function hash256(bytes29 memView) internal view returns (bytes32 digest) {\\r\\n        uint256 _loc = loc(memView);\\r\\n        uint256 _len = len(memView);\\r\\n        assembly {\\r\\n            // solium-disable-previous-line security/no-inline-assembly\\r\\n            let ptr := mload(0x40)\\r\\n            pop(staticcall(gas(), 2, _loc, _len, ptr, 0x20)) // sha2 #1\\r\\n            pop(staticcall(gas(), 2, ptr, 0x20, ptr, 0x20)) // sha2 #2\\r\\n            digest := mload(ptr)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice          Return true if the underlying memory is equal. Else false.\\r\\n     * @param left      The first view\\r\\n     * @param right     The second view\\r\\n     * @return          bool - True if the underlying memory is equal\\r\\n     */\\r\\n    function untypedEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\\r\\n        return (loc(left) == loc(right) && len(left) == len(right)) || keccak(left) == keccak(right);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice          Return false if the underlying memory is equal. Else true.\\r\\n     * @param left      The first view\\r\\n     * @param right     The second view\\r\\n     * @return          bool - False if the underlying memory is equal\\r\\n     */\\r\\n    function untypedNotEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\\r\\n        return !untypedEqual(left, right);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice          Compares type equality.\\r\\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\\r\\n     * @param left      The first view\\r\\n     * @param right     The second view\\r\\n     * @return          bool - True if the types are the same\\r\\n     */\\r\\n    function equal(bytes29 left, bytes29 right) internal pure returns (bool) {\\r\\n        return left == right || (typeOf(left) == typeOf(right) && keccak(left) == keccak(right));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice          Compares type inequality.\\r\\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\\r\\n     * @param left      The first view\\r\\n     * @param right     The second view\\r\\n     * @return          bool - True if the types are not the same\\r\\n     */\\r\\n    function notEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\\r\\n        return !equal(left, right);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice          Copy the view to a location, return an unsafe memory reference\\r\\n     * @dev             Super Dangerous direct memory access.\\r\\n     *\\r\\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\\r\\n     *                  As such it MUST be consumed IMMEDIATELY.\\r\\n     *                  This function is private to prevent unsafe usage by callers.\\r\\n     * @param memView   The view\\r\\n     * @param _newLoc   The new location\\r\\n     * @return          written - the unsafe memory reference\\r\\n     */\\r\\n    function unsafeCopyTo(bytes29 memView, uint256 _newLoc) private view returns (bytes29 written) {\\r\\n        require(notNull(memView), \\\"TypedMemView/copyTo - Null pointer deref\\\");\\r\\n        require(isValid(memView), \\\"TypedMemView/copyTo - Invalid pointer deref\\\");\\r\\n        uint256 _len = len(memView);\\r\\n        uint256 _oldLoc = loc(memView);\\r\\n\\r\\n        uint256 ptr;\\r\\n        assembly {\\r\\n            // solium-disable-previous-line security/no-inline-assembly\\r\\n            ptr := mload(0x40)\\r\\n            // revert if we're writing in occupied memory\\r\\n            if gt(ptr, _newLoc) {\\r\\n                revert(0x60, 0x20) // empty revert message\\r\\n            }\\r\\n\\r\\n            // use the identity precompile to copy\\r\\n            // guaranteed not to fail, so pop the success\\r\\n            pop(staticcall(gas(), 4, _oldLoc, _len, _newLoc, _len))\\r\\n        }\\r\\n\\r\\n        written = unsafeBuildUnchecked(typeOf(memView), _newLoc, _len);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice          Copies the referenced memory to a new loc in memory, returning a `bytes` pointing to\\r\\n     *                  the new memory\\r\\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\\r\\n     * @param memView   The view\\r\\n     * @return          ret - The view pointing to the new memory\\r\\n     */\\r\\n    function clone(bytes29 memView) internal view returns (bytes memory ret) {\\r\\n        uint256 ptr;\\r\\n        uint256 _len = len(memView);\\r\\n        assembly {\\r\\n            // solium-disable-previous-line security/no-inline-assembly\\r\\n            ptr := mload(0x40) // load unused memory pointer\\r\\n            ret := ptr\\r\\n        }\\r\\n        unsafeCopyTo(memView, ptr + 0x20);\\r\\n        assembly {\\r\\n            // solium-disable-previous-line security/no-inline-assembly\\r\\n            mstore(0x40, add(add(ptr, _len), 0x20)) // write new unused pointer\\r\\n            mstore(ptr, _len) // write len of new array (in bytes)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice          Join the views in memory, return an unsafe reference to the memory.\\r\\n     * @dev             Super Dangerous direct memory access.\\r\\n     *\\r\\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\\r\\n     *                  As such it MUST be consumed IMMEDIATELY.\\r\\n     *                  This function is private to prevent unsafe usage by callers.\\r\\n     * @param memViews  The views\\r\\n     * @return          unsafeView - The conjoined view pointing to the new memory\\r\\n     */\\r\\n    function unsafeJoin(bytes29[] memory memViews, uint256 _location) private view returns (bytes29 unsafeView) {\\r\\n        assembly {\\r\\n            // solium-disable-previous-line security/no-inline-assembly\\r\\n            let ptr := mload(0x40)\\r\\n            // revert if we're writing in occupied memory\\r\\n            if gt(ptr, _location) {\\r\\n                revert(0x60, 0x20) // empty revert message\\r\\n            }\\r\\n        }\\r\\n\\r\\n        uint256 _offset = 0;\\r\\n        for (uint256 i = 0; i < memViews.length; i ++) {\\r\\n            bytes29 memView = memViews[i];\\r\\n            unsafeCopyTo(memView, _location + _offset);\\r\\n            _offset += len(memView);\\r\\n        }\\r\\n        unsafeView = unsafeBuildUnchecked(0, _location, _offset);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice          Produce the keccak256 digest of the concatenated contents of multiple views.\\r\\n     * @param memViews  The views\\r\\n     * @return          bytes32 - The keccak256 digest\\r\\n     */\\r\\n    function joinKeccak(bytes29[] memory memViews) internal view returns (bytes32) {\\r\\n        uint256 ptr;\\r\\n        assembly {\\r\\n            // solium-disable-previous-line security/no-inline-assembly\\r\\n            ptr := mload(0x40) // load unused memory pointer\\r\\n        }\\r\\n        return keccak(unsafeJoin(memViews, ptr));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice          Produce the sha256 digest of the concatenated contents of multiple views.\\r\\n     * @param memViews  The views\\r\\n     * @return          bytes32 - The sha256 digest\\r\\n     */\\r\\n    function joinSha2(bytes29[] memory memViews) internal view returns (bytes32) {\\r\\n        uint256 ptr;\\r\\n        assembly {\\r\\n            // solium-disable-previous-line security/no-inline-assembly\\r\\n            ptr := mload(0x40) // load unused memory pointer\\r\\n        }\\r\\n        return sha2(unsafeJoin(memViews, ptr));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice          copies all views, joins them into a new bytearray.\\r\\n     * @param memViews  The views\\r\\n     * @return          ret - The new byte array\\r\\n     */\\r\\n    function join(bytes29[] memory memViews) internal view returns (bytes memory ret) {\\r\\n        uint256 ptr;\\r\\n        assembly {\\r\\n            // solium-disable-previous-line security/no-inline-assembly\\r\\n            ptr := mload(0x40) // load unused memory pointer\\r\\n        }\\r\\n\\r\\n        bytes29 _newView = unsafeJoin(memViews, ptr + 0x20);\\r\\n        uint256 _written = len(_newView);\\r\\n        uint256 _footprint = footprint(_newView);\\r\\n\\r\\n        assembly {\\r\\n            // solium-disable-previous-line security/no-inline-assembly\\r\\n            // store the legnth\\r\\n            mstore(ptr, _written)\\r\\n            // new pointer is old + 0x20 + the footprint of the body\\r\\n            mstore(0x40, add(add(ptr, _footprint), 0x20))\\r\\n            ret := ptr\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0x44f9cff1dbf97c3835e9e1f2712268f7a7b328bc662d83feaad7355439a5d94d\",\"license\":\"MIT OR Apache-2.0\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b5061001a3361001f565b61006f565b600080546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b610f838061007e6000396000f3fe608060405234801561001057600080fd5b50600436106100ea5760003560e01c80638f5d90e01161008c578063b9cff16211610066578063b9cff16214610234578063e0e7a9131461025d578063f2fde38b14610270578063f31faefb1461028357600080fd5b80638f5d90e0146101fb578063916c34701461020e5780639fa92f9d1461022157600080fd5b80636ef0f37f116100c85780636ef0f37f146101b1578063715018a6146101c65780638d3638f4146101ce5780638da5cb5b146101d657600080fd5b8063427ebef5146100ef5780635190bc53146101455780635f8b1dba14610176575b600080fd5b6101306100fd366004610cdc565b6001600160a01b038216600090815260046020908152604080832063ffffffff8516845290915290205460ff1692915050565b60405190151581526020015b60405180910390f35b610130610153366004610d15565b6001600160a01b031660009081526002602052604090205463ffffffff16151590565b61019c610184366004610d15565b60026020526000908152604090205463ffffffff1681565b60405163ffffffff909116815260200161013c565b6101c46101bf366004610d15565b610296565b005b6101c46102eb565b61019c610321565b6000546001600160a01b03165b6040516001600160a01b03909116815260200161013c565b6101c4610209366004610d15565b610394565b6101c461021c366004610d39565b6103ca565b6001546101e3906001600160a01b031681565b6101e3610242366004610d89565b6003602052600090815260409020546001600160a01b031681565b6101c461026b366004610dbc565b61046d565b6101c461027e366004610d15565b610614565b6101c4610291366004610cdc565b6106ac565b6000546001600160a01b031633146102c95760405162461bcd60e51b81526004016102c090610e89565b60405180910390fd5b600180546001600160a01b0319166001600160a01b0392909216919091179055565b6000546001600160a01b031633146103155760405162461bcd60e51b81526004016102c090610e89565b61031f6000610761565b565b6001546040805163234d8e3d60e21b815290516000926001600160a01b031691638d3638f49160048083019260209291908290030181865afa15801561036b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061038f9190610ebe565b905090565b6000546001600160a01b031633146103be5760405162461bcd60e51b81526004016102c090610e89565b6103c7816107b1565b50565b6000546001600160a01b031633146103f45760405162461bcd60e51b81526004016102c090610e89565b6001600160a01b038316600081815260046020908152604080832063ffffffff871680855290835292819020805460ff191686151590811790915581519485529184019190915290917f517de16b526853f481451c5151e87484e1b251ec7d0302efa1019c2ece179c2c910160405180910390a2505050565b63ffffffff83166000908152600360205260409020546001600160a01b0316806104cb5760405162461bcd60e51b815260206004820152600f60248201526e217265706c6963612065786973747360881b60448201526064016102c0565b826001600160a01b0316816001600160a01b031663df034cd06040518163ffffffff1660e01b8152600401602060405180830381865afa158015610513573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105379190610edb565b6001600160a01b0316146105805760405162461bcd60e51b815260206004820152601060248201526f10b1bab93932b73a103ab83230ba32b960811b60448201526064016102c0565b6000610597856001600160a01b0384168686610830565b6001600160a01b038116600090815260046020908152604080832063ffffffff8a16845290915290205490915060ff166106045760405162461bcd60e51b815260206004820152600e60248201526d10bb30b634b2103bb0ba31b432b960911b60448201526064016102c0565b61060d826107b1565b5050505050565b6000546001600160a01b0316331461063e5760405162461bcd60e51b81526004016102c090610e89565b6001600160a01b0381166106a35760405162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201526564647265737360d01b60648201526084016102c0565b6103c781610761565b6000546001600160a01b031633146106d65760405162461bcd60e51b81526004016102c090610e89565b6106df826107b1565b6001600160a01b0382166000818152600260209081526040808320805463ffffffff191663ffffffff8716908117909155808452600383529281902080546001600160a01b031916851790555192835290917f8440df9bf8a8542634a9eb196da1735b786ed9aa2fc12b080ac34c5fa81a923491015b60405180910390a25050565b600080546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b6001600160a01b0381166000818152600260208181526040808420805463ffffffff168086526003845282862080546001600160a01b031916905594869052928252825463ffffffff19169092559051928352909182917fce1533133fb359ace801d3176bbad25ace030d714aed35e38a6293c8a60b115b9101610755565b600080846001600160a01b03166345630b1a6040518163ffffffff1660e01b8152600401602060405180830381865afa158015610871573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108959190610ef8565b905060008187866040516020016108cc9392919092835260e09190911b6001600160e01b0319166020830152602482015260440190565b60408051808303601f1901815282825280516020918201207f19457468657265756d205369676e6564204d6573736167653a0a33320000000082850152603c8085019190915282518085039091018152605c909301909152815191012090506109358185610940565b979650505050505050565b600080600061094f8585610964565b9150915061095c816109d4565b509392505050565b60008082516041141561099b5760208301516040840151606085015160001a61098f87828585610b8f565b945094505050506109cd565b8251604014156109c557602083015160408401516109ba868383610c7c565b9350935050506109cd565b506000905060025b9250929050565b60008160048111156109e8576109e8610f11565b14156109f15750565b6001816004811115610a0557610a05610f11565b1415610a535760405162461bcd60e51b815260206004820152601860248201527f45434453413a20696e76616c6964207369676e6174757265000000000000000060448201526064016102c0565b6002816004811115610a6757610a67610f11565b1415610ab55760405162461bcd60e51b815260206004820152601f60248201527f45434453413a20696e76616c6964207369676e6174757265206c656e6774680060448201526064016102c0565b6003816004811115610ac957610ac9610f11565b1415610b225760405162461bcd60e51b815260206004820152602260248201527f45434453413a20696e76616c6964207369676e6174757265202773272076616c604482015261756560f01b60648201526084016102c0565b6004816004811115610b3657610b36610f11565b14156103c75760405162461bcd60e51b815260206004820152602260248201527f45434453413a20696e76616c6964207369676e6174757265202776272076616c604482015261756560f01b60648201526084016102c0565b6000807f7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0831115610bc65750600090506003610c73565b8460ff16601b14158015610bde57508460ff16601c14155b15610bef5750600090506004610c73565b6040805160008082526020820180845289905260ff881692820192909252606081018690526080810185905260019060a0016020604051602081039080840390855afa158015610c43573d6000803e3d6000fd5b5050604051601f1901519150506001600160a01b038116610c6c57600060019250925050610c73565b9150600090505b94509492505050565b6000806001600160ff1b03831681610c9960ff86901c601b610f27565b9050610ca787828885610b8f565b935093505050935093915050565b6001600160a01b03811681146103c757600080fd5b63ffffffff811681146103c757600080fd5b60008060408385031215610cef57600080fd5b8235610cfa81610cb5565b91506020830135610d0a81610cca565b809150509250929050565b600060208284031215610d2757600080fd5b8135610d3281610cb5565b9392505050565b600080600060608486031215610d4e57600080fd5b8335610d5981610cb5565b92506020840135610d6981610cca565b915060408401358015158114610d7e57600080fd5b809150509250925092565b600060208284031215610d9b57600080fd5b8135610d3281610cca565b634e487b7160e01b600052604160045260246000fd5b600080600060608486031215610dd157600080fd5b8335610ddc81610cca565b925060208401359150604084013567ffffffffffffffff80821115610e0057600080fd5b818601915086601f830112610e1457600080fd5b813581811115610e2657610e26610da6565b604051601f8201601f19908116603f01168101908382118183101715610e4e57610e4e610da6565b81604052828152896020848701011115610e6757600080fd5b8260208601602083013760006020848301015280955050505050509250925092565b6020808252818101527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572604082015260600190565b600060208284031215610ed057600080fd5b8151610d3281610cca565b600060208284031215610eed57600080fd5b8151610d3281610cb5565b600060208284031215610f0a57600080fd5b5051919050565b634e487b7160e01b600052602160045260246000fd5b60008219821115610f4857634e487b7160e01b600052601160045260246000fd5b50019056fea2646970667358221220b7f4022f4e0a8bdc5351bd7c4bf6c37399c22d8d21c0d02823dc5417e3959fdb64736f6c634300080b0033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100ea5760003560e01c80638f5d90e01161008c578063b9cff16211610066578063b9cff16214610234578063e0e7a9131461025d578063f2fde38b14610270578063f31faefb1461028357600080fd5b80638f5d90e0146101fb578063916c34701461020e5780639fa92f9d1461022157600080fd5b80636ef0f37f116100c85780636ef0f37f146101b1578063715018a6146101c65780638d3638f4146101ce5780638da5cb5b146101d657600080fd5b8063427ebef5146100ef5780635190bc53146101455780635f8b1dba14610176575b600080fd5b6101306100fd366004610cdc565b6001600160a01b038216600090815260046020908152604080832063ffffffff8516845290915290205460ff1692915050565b60405190151581526020015b60405180910390f35b610130610153366004610d15565b6001600160a01b031660009081526002602052604090205463ffffffff16151590565b61019c610184366004610d15565b60026020526000908152604090205463ffffffff1681565b60405163ffffffff909116815260200161013c565b6101c46101bf366004610d15565b610296565b005b6101c46102eb565b61019c610321565b6000546001600160a01b03165b6040516001600160a01b03909116815260200161013c565b6101c4610209366004610d15565b610394565b6101c461021c366004610d39565b6103ca565b6001546101e3906001600160a01b031681565b6101e3610242366004610d89565b6003602052600090815260409020546001600160a01b031681565b6101c461026b366004610dbc565b61046d565b6101c461027e366004610d15565b610614565b6101c4610291366004610cdc565b6106ac565b6000546001600160a01b031633146102c95760405162461bcd60e51b81526004016102c090610e89565b60405180910390fd5b600180546001600160a01b0319166001600160a01b0392909216919091179055565b6000546001600160a01b031633146103155760405162461bcd60e51b81526004016102c090610e89565b61031f6000610761565b565b6001546040805163234d8e3d60e21b815290516000926001600160a01b031691638d3638f49160048083019260209291908290030181865afa15801561036b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061038f9190610ebe565b905090565b6000546001600160a01b031633146103be5760405162461bcd60e51b81526004016102c090610e89565b6103c7816107b1565b50565b6000546001600160a01b031633146103f45760405162461bcd60e51b81526004016102c090610e89565b6001600160a01b038316600081815260046020908152604080832063ffffffff871680855290835292819020805460ff191686151590811790915581519485529184019190915290917f517de16b526853f481451c5151e87484e1b251ec7d0302efa1019c2ece179c2c910160405180910390a2505050565b63ffffffff83166000908152600360205260409020546001600160a01b0316806104cb5760405162461bcd60e51b815260206004820152600f60248201526e217265706c6963612065786973747360881b60448201526064016102c0565b826001600160a01b0316816001600160a01b031663df034cd06040518163ffffffff1660e01b8152600401602060405180830381865afa158015610513573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105379190610edb565b6001600160a01b0316146105805760405162461bcd60e51b815260206004820152601060248201526f10b1bab93932b73a103ab83230ba32b960811b60448201526064016102c0565b6000610597856001600160a01b0384168686610830565b6001600160a01b038116600090815260046020908152604080832063ffffffff8a16845290915290205490915060ff166106045760405162461bcd60e51b815260206004820152600e60248201526d10bb30b634b2103bb0ba31b432b960911b60448201526064016102c0565b61060d826107b1565b5050505050565b6000546001600160a01b0316331461063e5760405162461bcd60e51b81526004016102c090610e89565b6001600160a01b0381166106a35760405162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201526564647265737360d01b60648201526084016102c0565b6103c781610761565b6000546001600160a01b031633146106d65760405162461bcd60e51b81526004016102c090610e89565b6106df826107b1565b6001600160a01b0382166000818152600260209081526040808320805463ffffffff191663ffffffff8716908117909155808452600383529281902080546001600160a01b031916851790555192835290917f8440df9bf8a8542634a9eb196da1735b786ed9aa2fc12b080ac34c5fa81a923491015b60405180910390a25050565b600080546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b6001600160a01b0381166000818152600260208181526040808420805463ffffffff168086526003845282862080546001600160a01b031916905594869052928252825463ffffffff19169092559051928352909182917fce1533133fb359ace801d3176bbad25ace030d714aed35e38a6293c8a60b115b9101610755565b600080846001600160a01b03166345630b1a6040518163ffffffff1660e01b8152600401602060405180830381865afa158015610871573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108959190610ef8565b905060008187866040516020016108cc9392919092835260e09190911b6001600160e01b0319166020830152602482015260440190565b60408051808303601f1901815282825280516020918201207f19457468657265756d205369676e6564204d6573736167653a0a33320000000082850152603c8085019190915282518085039091018152605c909301909152815191012090506109358185610940565b979650505050505050565b600080600061094f8585610964565b9150915061095c816109d4565b509392505050565b60008082516041141561099b5760208301516040840151606085015160001a61098f87828585610b8f565b945094505050506109cd565b8251604014156109c557602083015160408401516109ba868383610c7c565b9350935050506109cd565b506000905060025b9250929050565b60008160048111156109e8576109e8610f11565b14156109f15750565b6001816004811115610a0557610a05610f11565b1415610a535760405162461bcd60e51b815260206004820152601860248201527f45434453413a20696e76616c6964207369676e6174757265000000000000000060448201526064016102c0565b6002816004811115610a6757610a67610f11565b1415610ab55760405162461bcd60e51b815260206004820152601f60248201527f45434453413a20696e76616c6964207369676e6174757265206c656e6774680060448201526064016102c0565b6003816004811115610ac957610ac9610f11565b1415610b225760405162461bcd60e51b815260206004820152602260248201527f45434453413a20696e76616c6964207369676e6174757265202773272076616c604482015261756560f01b60648201526084016102c0565b6004816004811115610b3657610b36610f11565b14156103c75760405162461bcd60e51b815260206004820152602260248201527f45434453413a20696e76616c6964207369676e6174757265202776272076616c604482015261756560f01b60648201526084016102c0565b6000807f7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0831115610bc65750600090506003610c73565b8460ff16601b14158015610bde57508460ff16601c14155b15610bef5750600090506004610c73565b6040805160008082526020820180845289905260ff881692820192909252606081018690526080810185905260019060a0016020604051602081039080840390855afa158015610c43573d6000803e3d6000fd5b5050604051601f1901519150506001600160a01b038116610c6c57600060019250925050610c73565b9150600090505b94509492505050565b6000806001600160ff1b03831681610c9960ff86901c601b610f27565b9050610ca787828885610b8f565b935093505050935093915050565b6001600160a01b03811681146103c757600080fd5b63ffffffff811681146103c757600080fd5b60008060408385031215610cef57600080fd5b8235610cfa81610cb5565b91506020830135610d0a81610cca565b809150509250929050565b600060208284031215610d2757600080fd5b8135610d3281610cb5565b9392505050565b600080600060608486031215610d4e57600080fd5b8335610d5981610cb5565b92506020840135610d6981610cca565b915060408401358015158114610d7e57600080fd5b809150509250925092565b600060208284031215610d9b57600080fd5b8135610d3281610cca565b634e487b7160e01b600052604160045260246000fd5b600080600060608486031215610dd157600080fd5b8335610ddc81610cca565b925060208401359150604084013567ffffffffffffffff80821115610e0057600080fd5b818601915086601f830112610e1457600080fd5b813581811115610e2657610e26610da6565b604051601f8201601f19908116603f01168101908382118183101715610e4e57610e4e610da6565b81604052828152896020848701011115610e6757600080fd5b8260208601602083013760006020848301015280955050505050509250925092565b6020808252818101527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572604082015260600190565b600060208284031215610ed057600080fd5b8151610d3281610cca565b600060208284031215610eed57600080fd5b8151610d3281610cb5565b600060208284031215610f0a57600080fd5b5051919050565b634e487b7160e01b600052602160045260246000fd5b60008219821115610f4857634e487b7160e01b600052601160045260246000fd5b50019056fea2646970667358221220b7f4022f4e0a8bdc5351bd7c4bf6c37399c22d8d21c0d02823dc5417e3959fdb64736f6c634300080b0033",
  "devdoc": {
    "author": "Illusory Systems Inc.",
    "events": {
      "ReplicaEnrolled(uint32,address)": {
        "params": {
          "domain": "the remote domain of the Home contract for the Replica",
          "replica": "the address of the Replica"
        }
      },
      "ReplicaUnenrolled(uint32,address)": {
        "params": {
          "domain": "the remote domain of the Home contract for the Replica",
          "replica": "the address of the Replica"
        }
      },
      "WatcherPermissionSet(uint32,address,bool)": {
        "params": {
          "access": "TRUE if the Watcher was given permissions, FALSE if permissions were removed",
          "domain": "the remote domain of the Home contract for the Replica",
          "watcher": "the address of the Watcher"
        }
      }
    },
    "kind": "dev",
    "methods": {
      "isReplica(address)": {
        "params": {
          "_replica": "the replica to check for enrollment"
        },
        "returns": {
          "_0": "TRUE iff _replica is enrolled"
        }
      },
      "localDomain()": {
        "returns": {
          "_0": "local domain"
        }
      },
      "owner()": {
        "details": "Returns the address of the current owner."
      },
      "ownerEnrollReplica(address,uint32)": {
        "params": {
          "_domain": "the remote domain of the Home contract for the Replica",
          "_replica": "the address of the Replica"
        }
      },
      "ownerUnenrollReplica(address)": {
        "params": {
          "_replica": "the address of the Replica"
        }
      },
      "renounceOwnership()": {
        "details": "Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner."
      },
      "setHome(address)": {
        "params": {
          "_home": "the address of the local Home contract"
        }
      },
      "setWatcherPermission(address,uint32,bool)": {
        "params": {
          "_access": "TRUE to give the Watcher permissions, FALSE to remove permissions",
          "_domain": "the remote domain of the Home contract for the Replica",
          "_watcher": "the address of the Watcher"
        }
      },
      "transferOwnership(address)": {
        "details": "Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."
      },
      "unenrollReplica(uint32,bytes32,bytes)": {
        "details": "in the future, if fraud occurs on the Home contract, the Watcher will submit their signature directly to the Home and it can be relayed to all remote chains to un-enroll the Replicas",
        "params": {
          "_domain": "the remote domain of the Home contract for the Replica",
          "_signature": "signature of watcher on (domain, replica address, updater address)",
          "_updater": "the address of the Updater for the Home contract (also stored on Replica)"
        }
      },
      "watcherPermission(address,uint32)": {
        "params": {
          "_domain": "the domain to check for watcher permissions",
          "_watcher": "the address of the watcher"
        },
        "returns": {
          "_0": "TRUE iff _watcher has permission to un-enroll replicas on _domain"
        }
      }
    },
    "title": "XAppConnectionManager",
    "version": 1
  },
  "userdoc": {
    "events": {
      "ReplicaEnrolled(uint32,address)": {
        "notice": "Emitted when a new Replica is enrolled / added"
      },
      "ReplicaUnenrolled(uint32,address)": {
        "notice": "Emitted when a new Replica is un-enrolled / removed"
      },
      "WatcherPermissionSet(uint32,address,bool)": {
        "notice": "Emitted when Watcher permissions are changed"
      }
    },
    "kind": "user",
    "methods": {
      "isReplica(address)": {
        "notice": "Check whether _replica is enrolled"
      },
      "localDomain()": {
        "notice": "Query local domain from Home"
      },
      "ownerEnrollReplica(address,uint32)": {
        "notice": "Allow Owner to enroll Replica contract"
      },
      "ownerUnenrollReplica(address)": {
        "notice": "Allow Owner to un-enroll Replica contract"
      },
      "setHome(address)": {
        "notice": "Set the address of the local Home contract"
      },
      "setWatcherPermission(address,uint32,bool)": {
        "notice": "Allow Owner to set Watcher permissions for a Replica"
      },
      "unenrollReplica(uint32,bytes32,bytes)": {
        "notice": "Un-Enroll a replica contract in the case that fraud was detected on the Home"
      },
      "watcherPermission(address,uint32)": {
        "notice": "Get access permissions for the watcher on the domain"
      }
    },
    "notice": "Manages a registry of local Replica contracts for remote Home domains. Accepts Watcher signatures to un-enroll Replicas attached to fraudulent remote Homes",
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 2586,
        "contract": "contracts/nomad-core/contracts/XAppConnectionManager.sol:XAppConnectionManager",
        "label": "_owner",
        "offset": 0,
        "slot": "0",
        "type": "t_address"
      },
      {
        "astId": 14519,
        "contract": "contracts/nomad-core/contracts/XAppConnectionManager.sol:XAppConnectionManager",
        "label": "home",
        "offset": 0,
        "slot": "1",
        "type": "t_contract(Home)13478"
      },
      {
        "astId": 14523,
        "contract": "contracts/nomad-core/contracts/XAppConnectionManager.sol:XAppConnectionManager",
        "label": "replicaToDomain",
        "offset": 0,
        "slot": "2",
        "type": "t_mapping(t_address,t_uint32)"
      },
      {
        "astId": 14527,
        "contract": "contracts/nomad-core/contracts/XAppConnectionManager.sol:XAppConnectionManager",
        "label": "domainToReplica",
        "offset": 0,
        "slot": "3",
        "type": "t_mapping(t_uint32,t_address)"
      },
      {
        "astId": 14533,
        "contract": "contracts/nomad-core/contracts/XAppConnectionManager.sol:XAppConnectionManager",
        "label": "watcherPermissions",
        "offset": 0,
        "slot": "4",
        "type": "t_mapping(t_address,t_mapping(t_uint32,t_bool))"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_contract(Home)13478": {
        "encoding": "inplace",
        "label": "contract Home",
        "numberOfBytes": "20"
      },
      "t_mapping(t_address,t_mapping(t_uint32,t_bool))": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => mapping(uint32 => bool))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_uint32,t_bool)"
      },
      "t_mapping(t_address,t_uint32)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => uint32)",
        "numberOfBytes": "32",
        "value": "t_uint32"
      },
      "t_mapping(t_uint32,t_address)": {
        "encoding": "mapping",
        "key": "t_uint32",
        "label": "mapping(uint32 => address)",
        "numberOfBytes": "32",
        "value": "t_address"
      },
      "t_mapping(t_uint32,t_bool)": {
        "encoding": "mapping",
        "key": "t_uint32",
        "label": "mapping(uint32 => bool)",
        "numberOfBytes": "32",
        "value": "t_bool"
      },
      "t_uint32": {
        "encoding": "inplace",
        "label": "uint32",
        "numberOfBytes": "4"
      }
    }
  }
}