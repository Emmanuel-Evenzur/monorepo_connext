type Asset @entity {
  id: ID!
  local: Bytes!
  adoptedAsset: Bytes!
  canonicalId: Bytes!
  canonicalDomain: BigInt!
  blockNumber: BigInt! # needed in case multiple locals are stored under the same canonicalId
}

type AssetBalance @entity {
  id: ID!
  amount: BigInt!
  router: Router!
  asset: Asset!
}

# Router represents a router and its associated liquidity
type Router @entity {
  id: ID!
  isActive: Boolean!
  owner: Bytes
  recipient: Bytes
  proposedOwner: Bytes
  proposedTimestamp: BigInt
  assetBalances: [AssetBalance!]! @derivedFrom(field: "router")
}

enum TransferStatus {
  Executed
  Reconciled
  Completed
}

type OriginTransfer @entity {
  id: ID!

  # MetaData
  originDomain: BigInt
  destinationDomain: BigInt
  chainId: BigInt

  # event Data
  transferId: Bytes
  to: Bytes
  nonce: BigInt
  callData: Bytes
  transactingAsset: Bytes
  bridgedAsset: Bytes
  amount: BigInt
  bridgedAmount: BigInt
  relayerFee: BigInt
  caller: Bytes
  message: Bytes

  # XCalled Transaction
  transactionHash: Bytes
  timestamp: BigInt
  gasPrice: BigInt
  gasLimit: BigInt
  blockNumber: BigInt
}

type DestinationTransfer @entity {
  id: ID!

  # MetaData
  originDomain: BigInt
  destinationDomain: BigInt
  chainId: BigInt
  status: TransferStatus

  # Executed event Data
  transferId: Bytes
  to: Bytes
  nonce: BigInt
  callData: Bytes
  localAsset: Bytes
  routers: [Router!]
  transactingAsset: Bytes
  transactingAmount: BigInt
  originSender: Bytes

  executedCaller: Bytes
  executedAmount: BigInt

  # Executed Transaction
  executedTransactionHash: Bytes
  executedTimestamp: BigInt
  executedGasPrice: BigInt
  executedGasLimit: BigInt
  executedBlockNumber: BigInt

  # Reconciled event Data
  reconciledAsset: Bytes
  reconciledAmount: BigInt
  reconciledCaller: Bytes

  # Reconciled Transaction
  reconciledTransactionHash: Bytes
  reconciledTimestamp: BigInt
  reconciledGasPrice: BigInt
  reconciledGasLimit: BigInt
  reconciledBlockNumber: BigInt
}
