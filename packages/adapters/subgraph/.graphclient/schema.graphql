schema {
  query: Query
  subscription: Subscription
}

"Marks the GraphQL type as indexable entity.  Each type that should be an entity is required to be annotated with this directive."
directive @entity on OBJECT

"Defined a Subgraph ID for an object type"
directive @subgraphId(id: String!) on OBJECT

"creates a virtual field on the entity that may be queried but cannot be set manually through the mappings API."
directive @derivedFrom(field: String!) on FIELD_DEFINITION

type Query {
  mode_swap_systemInfo(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mode_swap_SystemInfo
  mode_swap_systemInfos(
    skip: Int = 0
    first: Int = 100
    orderBy: mode_swap_SystemInfo_orderBy
    orderDirection: mode_swap_OrderDirection
    where: mode_swap_SystemInfo_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mode_swap_SystemInfo!]!
  mode_swap_pooledToken(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mode_swap_PooledToken
  mode_swap_pooledTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: mode_swap_PooledToken_orderBy
    orderDirection: mode_swap_OrderDirection
    where: mode_swap_PooledToken_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mode_swap_PooledToken!]!
  mode_swap_stableSwap(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mode_swap_StableSwap
  mode_swap_stableSwaps(
    skip: Int = 0
    first: Int = 100
    orderBy: mode_swap_StableSwap_orderBy
    orderDirection: mode_swap_OrderDirection
    where: mode_swap_StableSwap_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mode_swap_StableSwap!]!
  mode_swap_stableSwapAddLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mode_swap_StableSwapAddLiquidityEvent
  mode_swap_stableSwapAddLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: mode_swap_StableSwapAddLiquidityEvent_orderBy
    orderDirection: mode_swap_OrderDirection
    where: mode_swap_StableSwapAddLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mode_swap_StableSwapAddLiquidityEvent!]!
  mode_swap_stableSwapRemoveLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mode_swap_StableSwapRemoveLiquidityEvent
  mode_swap_stableSwapRemoveLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: mode_swap_StableSwapRemoveLiquidityEvent_orderBy
    orderDirection: mode_swap_OrderDirection
    where: mode_swap_StableSwapRemoveLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mode_swap_StableSwapRemoveLiquidityEvent!]!
  mode_swap_stableSwapExchange(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mode_swap_StableSwapExchange
  mode_swap_stableSwapExchanges(
    skip: Int = 0
    first: Int = 100
    orderBy: mode_swap_StableSwapExchange_orderBy
    orderDirection: mode_swap_OrderDirection
    where: mode_swap_StableSwapExchange_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mode_swap_StableSwapExchange!]!
  mode_swap_swapDailyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mode_swap_SwapDailyVolume
  mode_swap_swapDailyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: mode_swap_SwapDailyVolume_orderBy
    orderDirection: mode_swap_OrderDirection
    where: mode_swap_SwapDailyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mode_swap_SwapDailyVolume!]!
  mode_swap_swapHourlyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mode_swap_SwapHourlyVolume
  mode_swap_swapHourlyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: mode_swap_SwapHourlyVolume_orderBy
    orderDirection: mode_swap_OrderDirection
    where: mode_swap_SwapHourlyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mode_swap_SwapHourlyVolume!]!
  mode_swap_swapWeeklyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mode_swap_SwapWeeklyVolume
  mode_swap_swapWeeklyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: mode_swap_SwapWeeklyVolume_orderBy
    orderDirection: mode_swap_OrderDirection
    where: mode_swap_SwapWeeklyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mode_swap_SwapWeeklyVolume!]!
  mode_swap_lpAccount(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mode_swap_LpAccount
  mode_swap_lpAccounts(
    skip: Int = 0
    first: Int = 100
    orderBy: mode_swap_LpAccount_orderBy
    orderDirection: mode_swap_OrderDirection
    where: mode_swap_LpAccount_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mode_swap_LpAccount!]!
  mode_swap_lpAccountBalance(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mode_swap_LpAccountBalance
  mode_swap_lpAccountBalances(
    skip: Int = 0
    first: Int = 100
    orderBy: mode_swap_LpAccountBalance_orderBy
    orderDirection: mode_swap_OrderDirection
    where: mode_swap_LpAccountBalance_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mode_swap_LpAccountBalance!]!
  mode_swap_lpToken(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mode_swap_LpToken
  mode_swap_lpTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: mode_swap_LpToken_orderBy
    orderDirection: mode_swap_OrderDirection
    where: mode_swap_LpToken_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mode_swap_LpToken!]!
  mode_swap_lpTransferEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mode_swap_LpTransferEvent
  mode_swap_lpTransferEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: mode_swap_LpTransferEvent_orderBy
    orderDirection: mode_swap_OrderDirection
    where: mode_swap_LpTransferEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mode_swap_LpTransferEvent!]!
  mode_swap_stableSwapEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mode_swap_StableSwapEvent
  mode_swap_stableSwapEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: mode_swap_StableSwapEvent_orderBy
    orderDirection: mode_swap_OrderDirection
    where: mode_swap_StableSwapEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mode_swap_StableSwapEvent!]!
  mode_swap_swapTradeVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mode_swap_SwapTradeVolume
  mode_swap_swapTradeVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: mode_swap_SwapTradeVolume_orderBy
    orderDirection: mode_swap_OrderDirection
    where: mode_swap_SwapTradeVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mode_swap_SwapTradeVolume!]!
  mode_swap_lpTokenEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mode_swap_LpTokenEvent
  mode_swap_lpTokenEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: mode_swap_LpTokenEvent_orderBy
    orderDirection: mode_swap_OrderDirection
    where: mode_swap_LpTokenEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mode_swap_LpTokenEvent!]!
  """Access to subgraph metadata"""
  mode_swap__meta(block: mode_swap_Block_height): mode_swap__Meta_
  mantle_swap_systemInfo(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mantle_swap_SystemInfo
  mantle_swap_systemInfos(
    skip: Int = 0
    first: Int = 100
    orderBy: mantle_swap_SystemInfo_orderBy
    orderDirection: mantle_swap_OrderDirection
    where: mantle_swap_SystemInfo_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mantle_swap_SystemInfo!]!
  mantle_swap_pooledToken(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mantle_swap_PooledToken
  mantle_swap_pooledTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: mantle_swap_PooledToken_orderBy
    orderDirection: mantle_swap_OrderDirection
    where: mantle_swap_PooledToken_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mantle_swap_PooledToken!]!
  mantle_swap_stableSwap(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mantle_swap_StableSwap
  mantle_swap_stableSwaps(
    skip: Int = 0
    first: Int = 100
    orderBy: mantle_swap_StableSwap_orderBy
    orderDirection: mantle_swap_OrderDirection
    where: mantle_swap_StableSwap_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mantle_swap_StableSwap!]!
  mantle_swap_stableSwapAddLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mantle_swap_StableSwapAddLiquidityEvent
  mantle_swap_stableSwapAddLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: mantle_swap_StableSwapAddLiquidityEvent_orderBy
    orderDirection: mantle_swap_OrderDirection
    where: mantle_swap_StableSwapAddLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mantle_swap_StableSwapAddLiquidityEvent!]!
  mantle_swap_stableSwapRemoveLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mantle_swap_StableSwapRemoveLiquidityEvent
  mantle_swap_stableSwapRemoveLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: mantle_swap_StableSwapRemoveLiquidityEvent_orderBy
    orderDirection: mantle_swap_OrderDirection
    where: mantle_swap_StableSwapRemoveLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mantle_swap_StableSwapRemoveLiquidityEvent!]!
  mantle_swap_stableSwapExchange(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mantle_swap_StableSwapExchange
  mantle_swap_stableSwapExchanges(
    skip: Int = 0
    first: Int = 100
    orderBy: mantle_swap_StableSwapExchange_orderBy
    orderDirection: mantle_swap_OrderDirection
    where: mantle_swap_StableSwapExchange_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mantle_swap_StableSwapExchange!]!
  mantle_swap_swapDailyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mantle_swap_SwapDailyVolume
  mantle_swap_swapDailyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: mantle_swap_SwapDailyVolume_orderBy
    orderDirection: mantle_swap_OrderDirection
    where: mantle_swap_SwapDailyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mantle_swap_SwapDailyVolume!]!
  mantle_swap_swapHourlyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mantle_swap_SwapHourlyVolume
  mantle_swap_swapHourlyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: mantle_swap_SwapHourlyVolume_orderBy
    orderDirection: mantle_swap_OrderDirection
    where: mantle_swap_SwapHourlyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mantle_swap_SwapHourlyVolume!]!
  mantle_swap_swapWeeklyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mantle_swap_SwapWeeklyVolume
  mantle_swap_swapWeeklyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: mantle_swap_SwapWeeklyVolume_orderBy
    orderDirection: mantle_swap_OrderDirection
    where: mantle_swap_SwapWeeklyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mantle_swap_SwapWeeklyVolume!]!
  mantle_swap_lpAccount(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mantle_swap_LpAccount
  mantle_swap_lpAccounts(
    skip: Int = 0
    first: Int = 100
    orderBy: mantle_swap_LpAccount_orderBy
    orderDirection: mantle_swap_OrderDirection
    where: mantle_swap_LpAccount_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mantle_swap_LpAccount!]!
  mantle_swap_lpAccountBalance(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mantle_swap_LpAccountBalance
  mantle_swap_lpAccountBalances(
    skip: Int = 0
    first: Int = 100
    orderBy: mantle_swap_LpAccountBalance_orderBy
    orderDirection: mantle_swap_OrderDirection
    where: mantle_swap_LpAccountBalance_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mantle_swap_LpAccountBalance!]!
  mantle_swap_lpToken(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mantle_swap_LpToken
  mantle_swap_lpTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: mantle_swap_LpToken_orderBy
    orderDirection: mantle_swap_OrderDirection
    where: mantle_swap_LpToken_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mantle_swap_LpToken!]!
  mantle_swap_lpTransferEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mantle_swap_LpTransferEvent
  mantle_swap_lpTransferEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: mantle_swap_LpTransferEvent_orderBy
    orderDirection: mantle_swap_OrderDirection
    where: mantle_swap_LpTransferEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mantle_swap_LpTransferEvent!]!
  mantle_swap_stableSwapEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mantle_swap_StableSwapEvent
  mantle_swap_stableSwapEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: mantle_swap_StableSwapEvent_orderBy
    orderDirection: mantle_swap_OrderDirection
    where: mantle_swap_StableSwapEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mantle_swap_StableSwapEvent!]!
  mantle_swap_swapTradeVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mantle_swap_SwapTradeVolume
  mantle_swap_swapTradeVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: mantle_swap_SwapTradeVolume_orderBy
    orderDirection: mantle_swap_OrderDirection
    where: mantle_swap_SwapTradeVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mantle_swap_SwapTradeVolume!]!
  mantle_swap_lpTokenEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mantle_swap_LpTokenEvent
  mantle_swap_lpTokenEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: mantle_swap_LpTokenEvent_orderBy
    orderDirection: mantle_swap_OrderDirection
    where: mantle_swap_LpTokenEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mantle_swap_LpTokenEvent!]!
  """Access to subgraph metadata"""
  mantle_swap__meta(block: mantle_swap_Block_height): mantle_swap__Meta_
  bnb_asset(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): bnb_Asset
  bnb_assets(
    skip: Int = 0
    first: Int = 100
    orderBy: bnb_Asset_orderBy
    orderDirection: bnb_OrderDirection
    where: bnb_Asset_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [bnb_Asset!]!
  bnb_assetStatus(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): bnb_AssetStatus
  bnb_assetStatuses(
    skip: Int = 0
    first: Int = 100
    orderBy: bnb_AssetStatus_orderBy
    orderDirection: bnb_OrderDirection
    where: bnb_AssetStatus_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [bnb_AssetStatus!]!
  bnb_assetBalance(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): bnb_AssetBalance
  bnb_assetBalances(
    skip: Int = 0
    first: Int = 100
    orderBy: bnb_AssetBalance_orderBy
    orderDirection: bnb_OrderDirection
    where: bnb_AssetBalance_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [bnb_AssetBalance!]!
  bnb_router(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): bnb_Router
  bnb_routers(
    skip: Int = 0
    first: Int = 100
    orderBy: bnb_Router_orderBy
    orderDirection: bnb_OrderDirection
    where: bnb_Router_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [bnb_Router!]!
  bnb_routerDailyTVL(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): bnb_RouterDailyTVL
  bnb_routerDailyTVLs(
    skip: Int = 0
    first: Int = 100
    orderBy: bnb_RouterDailyTVL_orderBy
    orderDirection: bnb_OrderDirection
    where: bnb_RouterDailyTVL_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [bnb_RouterDailyTVL!]!
  bnb_routerLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): bnb_RouterLiquidityEvent
  bnb_routerLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: bnb_RouterLiquidityEvent_orderBy
    orderDirection: bnb_OrderDirection
    where: bnb_RouterLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [bnb_RouterLiquidityEvent!]!
  bnb_setting(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): bnb_Setting
  bnb_settings(
    skip: Int = 0
    first: Int = 100
    orderBy: bnb_Setting_orderBy
    orderDirection: bnb_OrderDirection
    where: bnb_Setting_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [bnb_Setting!]!
  bnb_relayer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): bnb_Relayer
  bnb_relayers(
    skip: Int = 0
    first: Int = 100
    orderBy: bnb_Relayer_orderBy
    orderDirection: bnb_OrderDirection
    where: bnb_Relayer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [bnb_Relayer!]!
  bnb_sequencer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): bnb_Sequencer
  bnb_sequencers(
    skip: Int = 0
    first: Int = 100
    orderBy: bnb_Sequencer_orderBy
    orderDirection: bnb_OrderDirection
    where: bnb_Sequencer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [bnb_Sequencer!]!
  bnb_relayerFee(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): bnb_RelayerFee
  bnb_relayerFees(
    skip: Int = 0
    first: Int = 100
    orderBy: bnb_RelayerFee_orderBy
    orderDirection: bnb_OrderDirection
    where: bnb_RelayerFee_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [bnb_RelayerFee!]!
  bnb_originTransfer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): bnb_OriginTransfer
  bnb_originTransfers(
    skip: Int = 0
    first: Int = 100
    orderBy: bnb_OriginTransfer_orderBy
    orderDirection: bnb_OrderDirection
    where: bnb_OriginTransfer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [bnb_OriginTransfer!]!
  bnb_destinationTransfer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): bnb_DestinationTransfer
  bnb_destinationTransfers(
    skip: Int = 0
    first: Int = 100
    orderBy: bnb_DestinationTransfer_orderBy
    orderDirection: bnb_OrderDirection
    where: bnb_DestinationTransfer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [bnb_DestinationTransfer!]!
  bnb_originMessage(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): bnb_OriginMessage
  bnb_originMessages(
    skip: Int = 0
    first: Int = 100
    orderBy: bnb_OriginMessage_orderBy
    orderDirection: bnb_OrderDirection
    where: bnb_OriginMessage_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [bnb_OriginMessage!]!
  bnb_aggregateRoot(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): bnb_AggregateRoot
  bnb_aggregateRoots(
    skip: Int = 0
    first: Int = 100
    orderBy: bnb_AggregateRoot_orderBy
    orderDirection: bnb_OrderDirection
    where: bnb_AggregateRoot_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [bnb_AggregateRoot!]!
  bnb_connectorMeta(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): bnb_ConnectorMeta
  bnb_connectorMetas(
    skip: Int = 0
    first: Int = 100
    orderBy: bnb_ConnectorMeta_orderBy
    orderDirection: bnb_OrderDirection
    where: bnb_ConnectorMeta_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [bnb_ConnectorMeta!]!
  bnb_rootCount(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): bnb_RootCount
  bnb_rootCounts(
    skip: Int = 0
    first: Int = 100
    orderBy: bnb_RootCount_orderBy
    orderDirection: bnb_OrderDirection
    where: bnb_RootCount_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [bnb_RootCount!]!
  bnb_rootMessageSent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): bnb_RootMessageSent
  bnb_rootMessageSents(
    skip: Int = 0
    first: Int = 100
    orderBy: bnb_RootMessageSent_orderBy
    orderDirection: bnb_OrderDirection
    where: bnb_RootMessageSent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [bnb_RootMessageSent!]!
  bnb_relayerFeesIncrease(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): bnb_RelayerFeesIncrease
  bnb_relayerFeesIncreases(
    skip: Int = 0
    first: Int = 100
    orderBy: bnb_RelayerFeesIncrease_orderBy
    orderDirection: bnb_OrderDirection
    where: bnb_RelayerFeesIncrease_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [bnb_RelayerFeesIncrease!]!
  bnb_slippageUpdate(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): bnb_SlippageUpdate
  bnb_slippageUpdates(
    skip: Int = 0
    first: Int = 100
    orderBy: bnb_SlippageUpdate_orderBy
    orderDirection: bnb_OrderDirection
    where: bnb_SlippageUpdate_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [bnb_SlippageUpdate!]!
  bnb_snapshotRoot(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): bnb_SnapshotRoot
  bnb_snapshotRoots(
    skip: Int = 0
    first: Int = 100
    orderBy: bnb_SnapshotRoot_orderBy
    orderDirection: bnb_OrderDirection
    where: bnb_SnapshotRoot_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [bnb_SnapshotRoot!]!
  bnb_spokeConnectorMode(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): bnb_SpokeConnectorMode
  bnb_spokeConnectorModes(
    skip: Int = 0
    first: Int = 100
    orderBy: bnb_SpokeConnectorMode_orderBy
    orderDirection: bnb_OrderDirection
    where: bnb_SpokeConnectorMode_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [bnb_SpokeConnectorMode!]!
  bnb_aggregateRootProposed(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): bnb_AggregateRootProposed
  bnb_aggregateRootProposeds(
    skip: Int = 0
    first: Int = 100
    orderBy: bnb_AggregateRootProposed_orderBy
    orderDirection: bnb_OrderDirection
    where: bnb_AggregateRootProposed_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [bnb_AggregateRootProposed!]!
  bnb_optimisticRootFinalized(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): bnb_OptimisticRootFinalized
  bnb_optimisticRootFinalizeds(
    skip: Int = 0
    first: Int = 100
    orderBy: bnb_OptimisticRootFinalized_orderBy
    orderDirection: bnb_OrderDirection
    where: bnb_OptimisticRootFinalized_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [bnb_OptimisticRootFinalized!]!
  """Access to subgraph metadata"""
  bnb__meta(block: bnb_Block_height): bnb__Meta_
  metis_swap_systemInfo(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): metis_swap_SystemInfo
  metis_swap_systemInfos(
    skip: Int = 0
    first: Int = 100
    orderBy: metis_swap_SystemInfo_orderBy
    orderDirection: metis_swap_OrderDirection
    where: metis_swap_SystemInfo_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [metis_swap_SystemInfo!]!
  metis_swap_pooledToken(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): metis_swap_PooledToken
  metis_swap_pooledTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: metis_swap_PooledToken_orderBy
    orderDirection: metis_swap_OrderDirection
    where: metis_swap_PooledToken_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [metis_swap_PooledToken!]!
  metis_swap_stableSwap(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): metis_swap_StableSwap
  metis_swap_stableSwaps(
    skip: Int = 0
    first: Int = 100
    orderBy: metis_swap_StableSwap_orderBy
    orderDirection: metis_swap_OrderDirection
    where: metis_swap_StableSwap_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [metis_swap_StableSwap!]!
  metis_swap_stableSwapAddLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): metis_swap_StableSwapAddLiquidityEvent
  metis_swap_stableSwapAddLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: metis_swap_StableSwapAddLiquidityEvent_orderBy
    orderDirection: metis_swap_OrderDirection
    where: metis_swap_StableSwapAddLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [metis_swap_StableSwapAddLiquidityEvent!]!
  metis_swap_stableSwapRemoveLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): metis_swap_StableSwapRemoveLiquidityEvent
  metis_swap_stableSwapRemoveLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: metis_swap_StableSwapRemoveLiquidityEvent_orderBy
    orderDirection: metis_swap_OrderDirection
    where: metis_swap_StableSwapRemoveLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [metis_swap_StableSwapRemoveLiquidityEvent!]!
  metis_swap_stableSwapExchange(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): metis_swap_StableSwapExchange
  metis_swap_stableSwapExchanges(
    skip: Int = 0
    first: Int = 100
    orderBy: metis_swap_StableSwapExchange_orderBy
    orderDirection: metis_swap_OrderDirection
    where: metis_swap_StableSwapExchange_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [metis_swap_StableSwapExchange!]!
  metis_swap_swapDailyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): metis_swap_SwapDailyVolume
  metis_swap_swapDailyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: metis_swap_SwapDailyVolume_orderBy
    orderDirection: metis_swap_OrderDirection
    where: metis_swap_SwapDailyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [metis_swap_SwapDailyVolume!]!
  metis_swap_swapHourlyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): metis_swap_SwapHourlyVolume
  metis_swap_swapHourlyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: metis_swap_SwapHourlyVolume_orderBy
    orderDirection: metis_swap_OrderDirection
    where: metis_swap_SwapHourlyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [metis_swap_SwapHourlyVolume!]!
  metis_swap_swapWeeklyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): metis_swap_SwapWeeklyVolume
  metis_swap_swapWeeklyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: metis_swap_SwapWeeklyVolume_orderBy
    orderDirection: metis_swap_OrderDirection
    where: metis_swap_SwapWeeklyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [metis_swap_SwapWeeklyVolume!]!
  metis_swap_lpAccount(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): metis_swap_LpAccount
  metis_swap_lpAccounts(
    skip: Int = 0
    first: Int = 100
    orderBy: metis_swap_LpAccount_orderBy
    orderDirection: metis_swap_OrderDirection
    where: metis_swap_LpAccount_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [metis_swap_LpAccount!]!
  metis_swap_lpAccountBalance(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): metis_swap_LpAccountBalance
  metis_swap_lpAccountBalances(
    skip: Int = 0
    first: Int = 100
    orderBy: metis_swap_LpAccountBalance_orderBy
    orderDirection: metis_swap_OrderDirection
    where: metis_swap_LpAccountBalance_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [metis_swap_LpAccountBalance!]!
  metis_swap_lpToken(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): metis_swap_LpToken
  metis_swap_lpTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: metis_swap_LpToken_orderBy
    orderDirection: metis_swap_OrderDirection
    where: metis_swap_LpToken_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [metis_swap_LpToken!]!
  metis_swap_lpTransferEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): metis_swap_LpTransferEvent
  metis_swap_lpTransferEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: metis_swap_LpTransferEvent_orderBy
    orderDirection: metis_swap_OrderDirection
    where: metis_swap_LpTransferEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [metis_swap_LpTransferEvent!]!
  metis_swap_stableSwapEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): metis_swap_StableSwapEvent
  metis_swap_stableSwapEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: metis_swap_StableSwapEvent_orderBy
    orderDirection: metis_swap_OrderDirection
    where: metis_swap_StableSwapEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [metis_swap_StableSwapEvent!]!
  metis_swap_swapTradeVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): metis_swap_SwapTradeVolume
  metis_swap_swapTradeVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: metis_swap_SwapTradeVolume_orderBy
    orderDirection: metis_swap_OrderDirection
    where: metis_swap_SwapTradeVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [metis_swap_SwapTradeVolume!]!
  metis_swap_lpTokenEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): metis_swap_LpTokenEvent
  metis_swap_lpTokenEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: metis_swap_LpTokenEvent_orderBy
    orderDirection: metis_swap_OrderDirection
    where: metis_swap_LpTokenEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [metis_swap_LpTokenEvent!]!
  """Access to subgraph metadata"""
  metis_swap__meta(block: metis_swap_Block_height): metis_swap__Meta_
  mainnet_rootAggregated(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mainnet_RootAggregated
  mainnet_rootAggregateds(
    skip: Int = 0
    first: Int = 100
    orderBy: mainnet_RootAggregated_orderBy
    orderDirection: mainnet_OrderDirection
    where: mainnet_RootAggregated_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mainnet_RootAggregated!]!
  mainnet_rootPropagated(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mainnet_RootPropagated
  mainnet_rootPropagateds(
    skip: Int = 0
    first: Int = 100
    orderBy: mainnet_RootPropagated_orderBy
    orderDirection: mainnet_OrderDirection
    where: mainnet_RootPropagated_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mainnet_RootPropagated!]!
  mainnet_aggregatedMessageRoot(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mainnet_AggregatedMessageRoot
  mainnet_aggregatedMessageRoots(
    skip: Int = 0
    first: Int = 100
    orderBy: mainnet_AggregatedMessageRoot_orderBy
    orderDirection: mainnet_OrderDirection
    where: mainnet_AggregatedMessageRoot_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mainnet_AggregatedMessageRoot!]!
  mainnet_rootManagerMeta(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mainnet_RootManagerMeta
  mainnet_rootManagerMetas(
    skip: Int = 0
    first: Int = 100
    orderBy: mainnet_RootManagerMeta_orderBy
    orderDirection: mainnet_OrderDirection
    where: mainnet_RootManagerMeta_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mainnet_RootManagerMeta!]!
  mainnet_rootManagerMode(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mainnet_RootManagerMode
  mainnet_rootManagerModes(
    skip: Int = 0
    first: Int = 100
    orderBy: mainnet_RootManagerMode_orderBy
    orderDirection: mainnet_OrderDirection
    where: mainnet_RootManagerMode_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mainnet_RootManagerMode!]!
  mainnet_optimisticRootProposed(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mainnet_OptimisticRootProposed
  mainnet_optimisticRootProposeds(
    skip: Int = 0
    first: Int = 100
    orderBy: mainnet_OptimisticRootProposed_orderBy
    orderDirection: mainnet_OrderDirection
    where: mainnet_OptimisticRootProposed_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mainnet_OptimisticRootProposed!]!
  mainnet_hubOptimisticRootFinalized(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mainnet_HubOptimisticRootFinalized
  mainnet_hubOptimisticRootFinalizeds(
    skip: Int = 0
    first: Int = 100
    orderBy: mainnet_HubOptimisticRootFinalized_orderBy
    orderDirection: mainnet_OrderDirection
    where: mainnet_HubOptimisticRootFinalized_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mainnet_HubOptimisticRootFinalized!]!
  mainnet_optimisticRootPropagated(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mainnet_OptimisticRootPropagated
  mainnet_optimisticRootPropagateds(
    skip: Int = 0
    first: Int = 100
    orderBy: mainnet_OptimisticRootPropagated_orderBy
    orderDirection: mainnet_OrderDirection
    where: mainnet_OptimisticRootPropagated_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mainnet_OptimisticRootPropagated!]!
  mainnet_polygonConnectorMeta(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mainnet_PolygonConnectorMeta
  mainnet_polygonConnectorMetas(
    skip: Int = 0
    first: Int = 100
    orderBy: mainnet_PolygonConnectorMeta_orderBy
    orderDirection: mainnet_OrderDirection
    where: mainnet_PolygonConnectorMeta_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mainnet_PolygonConnectorMeta!]!
  mainnet_optimismConnectorMeta(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mainnet_OptimismConnectorMeta
  mainnet_optimismConnectorMetas(
    skip: Int = 0
    first: Int = 100
    orderBy: mainnet_OptimismConnectorMeta_orderBy
    orderDirection: mainnet_OrderDirection
    where: mainnet_OptimismConnectorMeta_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mainnet_OptimismConnectorMeta!]!
  mainnet_bnbConnectorMeta(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mainnet_BnbConnectorMeta
  mainnet_bnbConnectorMetas(
    skip: Int = 0
    first: Int = 100
    orderBy: mainnet_BnbConnectorMeta_orderBy
    orderDirection: mainnet_OrderDirection
    where: mainnet_BnbConnectorMeta_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mainnet_BnbConnectorMeta!]!
  mainnet_arbitrumConnectorMeta(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mainnet_ArbitrumConnectorMeta
  mainnet_arbitrumConnectorMetas(
    skip: Int = 0
    first: Int = 100
    orderBy: mainnet_ArbitrumConnectorMeta_orderBy
    orderDirection: mainnet_OrderDirection
    where: mainnet_ArbitrumConnectorMeta_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mainnet_ArbitrumConnectorMeta!]!
  mainnet_gnosisConnectorMeta(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mainnet_GnosisConnectorMeta
  mainnet_gnosisConnectorMetas(
    skip: Int = 0
    first: Int = 100
    orderBy: mainnet_GnosisConnectorMeta_orderBy
    orderDirection: mainnet_OrderDirection
    where: mainnet_GnosisConnectorMeta_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mainnet_GnosisConnectorMeta!]!
  mainnet_lineaConnectorMeta(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mainnet_LineaConnectorMeta
  mainnet_lineaConnectorMetas(
    skip: Int = 0
    first: Int = 100
    orderBy: mainnet_LineaConnectorMeta_orderBy
    orderDirection: mainnet_OrderDirection
    where: mainnet_LineaConnectorMeta_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mainnet_LineaConnectorMeta!]!
  mainnet_metisConnectorMeta(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mainnet_MetisConnectorMeta
  mainnet_metisConnectorMetas(
    skip: Int = 0
    first: Int = 100
    orderBy: mainnet_MetisConnectorMeta_orderBy
    orderDirection: mainnet_OrderDirection
    where: mainnet_MetisConnectorMeta_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mainnet_MetisConnectorMeta!]!
  mainnet_mantleConnectorMeta(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mainnet_MantleConnectorMeta
  mainnet_mantleConnectorMetas(
    skip: Int = 0
    first: Int = 100
    orderBy: mainnet_MantleConnectorMeta_orderBy
    orderDirection: mainnet_OrderDirection
    where: mainnet_MantleConnectorMeta_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mainnet_MantleConnectorMeta!]!
  mainnet_avalancheConnectorMeta(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mainnet_AvalancheConnectorMeta
  mainnet_avalancheConnectorMetas(
    skip: Int = 0
    first: Int = 100
    orderBy: mainnet_AvalancheConnectorMeta_orderBy
    orderDirection: mainnet_OrderDirection
    where: mainnet_AvalancheConnectorMeta_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mainnet_AvalancheConnectorMeta!]!
  mainnet_baseConnectorMeta(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mainnet_BaseConnectorMeta
  mainnet_baseConnectorMetas(
    skip: Int = 0
    first: Int = 100
    orderBy: mainnet_BaseConnectorMeta_orderBy
    orderDirection: mainnet_OrderDirection
    where: mainnet_BaseConnectorMeta_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mainnet_BaseConnectorMeta!]!
  mainnet_polygonZkConnectorMeta(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mainnet_PolygonZkConnectorMeta
  mainnet_polygonZkConnectorMetas(
    skip: Int = 0
    first: Int = 100
    orderBy: mainnet_PolygonZkConnectorMeta_orderBy
    orderDirection: mainnet_OrderDirection
    where: mainnet_PolygonZkConnectorMeta_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mainnet_PolygonZkConnectorMeta!]!
  mainnet_zkSyncConnectorMeta(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mainnet_ZkSyncConnectorMeta
  mainnet_zkSyncConnectorMetas(
    skip: Int = 0
    first: Int = 100
    orderBy: mainnet_ZkSyncConnectorMeta_orderBy
    orderDirection: mainnet_OrderDirection
    where: mainnet_ZkSyncConnectorMeta_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mainnet_ZkSyncConnectorMeta!]!
  mainnet_modeConnectorMeta(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mainnet_ModeConnectorMeta
  mainnet_modeConnectorMetas(
    skip: Int = 0
    first: Int = 100
    orderBy: mainnet_ModeConnectorMeta_orderBy
    orderDirection: mainnet_OrderDirection
    where: mainnet_ModeConnectorMeta_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mainnet_ModeConnectorMeta!]!
  mainnet_scrollConnectorMeta(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mainnet_ScrollConnectorMeta
  mainnet_scrollConnectorMetas(
    skip: Int = 0
    first: Int = 100
    orderBy: mainnet_ScrollConnectorMeta_orderBy
    orderDirection: mainnet_OrderDirection
    where: mainnet_ScrollConnectorMeta_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mainnet_ScrollConnectorMeta!]!
  mainnet_xlayerConnectorMeta(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mainnet_XlayerConnectorMeta
  mainnet_xlayerConnectorMetas(
    skip: Int = 0
    first: Int = 100
    orderBy: mainnet_XlayerConnectorMeta_orderBy
    orderDirection: mainnet_OrderDirection
    where: mainnet_XlayerConnectorMeta_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mainnet_XlayerConnectorMeta!]!
  mainnet_rootMessageProcessed(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mainnet_RootMessageProcessed
  mainnet_rootMessageProcesseds(
    skip: Int = 0
    first: Int = 100
    orderBy: mainnet_RootMessageProcessed_orderBy
    orderDirection: mainnet_OrderDirection
    where: mainnet_RootMessageProcessed_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mainnet_RootMessageProcessed!]!
  mainnet_aggregateRootSavedSlow(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mainnet_AggregateRootSavedSlow
  mainnet_aggregateRootSavedSlows(
    skip: Int = 0
    first: Int = 100
    orderBy: mainnet_AggregateRootSavedSlow_orderBy
    orderDirection: mainnet_OrderDirection
    where: mainnet_AggregateRootSavedSlow_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mainnet_AggregateRootSavedSlow!]!
  mainnet_hubDomain(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mainnet_HubDomain
  mainnet_hubDomains(
    skip: Int = 0
    first: Int = 100
    orderBy: mainnet_HubDomain_orderBy
    orderDirection: mainnet_OrderDirection
    where: mainnet_HubDomain_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mainnet_HubDomain!]!
  """Access to subgraph metadata"""
  mainnet__meta(block: mainnet_Block_height): mainnet__Meta_
  polygonzkevm_asset(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygonzkevm_Asset
  polygonzkevm_assets(
    skip: Int = 0
    first: Int = 100
    orderBy: polygonzkevm_Asset_orderBy
    orderDirection: polygonzkevm_OrderDirection
    where: polygonzkevm_Asset_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygonzkevm_Asset!]!
  polygonzkevm_assetStatus(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygonzkevm_AssetStatus
  polygonzkevm_assetStatuses(
    skip: Int = 0
    first: Int = 100
    orderBy: polygonzkevm_AssetStatus_orderBy
    orderDirection: polygonzkevm_OrderDirection
    where: polygonzkevm_AssetStatus_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygonzkevm_AssetStatus!]!
  polygonzkevm_assetBalance(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygonzkevm_AssetBalance
  polygonzkevm_assetBalances(
    skip: Int = 0
    first: Int = 100
    orderBy: polygonzkevm_AssetBalance_orderBy
    orderDirection: polygonzkevm_OrderDirection
    where: polygonzkevm_AssetBalance_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygonzkevm_AssetBalance!]!
  polygonzkevm_router(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygonzkevm_Router
  polygonzkevm_routers(
    skip: Int = 0
    first: Int = 100
    orderBy: polygonzkevm_Router_orderBy
    orderDirection: polygonzkevm_OrderDirection
    where: polygonzkevm_Router_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygonzkevm_Router!]!
  polygonzkevm_routerDailyTVL(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygonzkevm_RouterDailyTVL
  polygonzkevm_routerDailyTVLs(
    skip: Int = 0
    first: Int = 100
    orderBy: polygonzkevm_RouterDailyTVL_orderBy
    orderDirection: polygonzkevm_OrderDirection
    where: polygonzkevm_RouterDailyTVL_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygonzkevm_RouterDailyTVL!]!
  polygonzkevm_routerLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygonzkevm_RouterLiquidityEvent
  polygonzkevm_routerLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: polygonzkevm_RouterLiquidityEvent_orderBy
    orderDirection: polygonzkevm_OrderDirection
    where: polygonzkevm_RouterLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygonzkevm_RouterLiquidityEvent!]!
  polygonzkevm_setting(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygonzkevm_Setting
  polygonzkevm_settings(
    skip: Int = 0
    first: Int = 100
    orderBy: polygonzkevm_Setting_orderBy
    orderDirection: polygonzkevm_OrderDirection
    where: polygonzkevm_Setting_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygonzkevm_Setting!]!
  polygonzkevm_relayer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygonzkevm_Relayer
  polygonzkevm_relayers(
    skip: Int = 0
    first: Int = 100
    orderBy: polygonzkevm_Relayer_orderBy
    orderDirection: polygonzkevm_OrderDirection
    where: polygonzkevm_Relayer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygonzkevm_Relayer!]!
  polygonzkevm_sequencer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygonzkevm_Sequencer
  polygonzkevm_sequencers(
    skip: Int = 0
    first: Int = 100
    orderBy: polygonzkevm_Sequencer_orderBy
    orderDirection: polygonzkevm_OrderDirection
    where: polygonzkevm_Sequencer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygonzkevm_Sequencer!]!
  polygonzkevm_relayerFee(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygonzkevm_RelayerFee
  polygonzkevm_relayerFees(
    skip: Int = 0
    first: Int = 100
    orderBy: polygonzkevm_RelayerFee_orderBy
    orderDirection: polygonzkevm_OrderDirection
    where: polygonzkevm_RelayerFee_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygonzkevm_RelayerFee!]!
  polygonzkevm_originTransfer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygonzkevm_OriginTransfer
  polygonzkevm_originTransfers(
    skip: Int = 0
    first: Int = 100
    orderBy: polygonzkevm_OriginTransfer_orderBy
    orderDirection: polygonzkevm_OrderDirection
    where: polygonzkevm_OriginTransfer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygonzkevm_OriginTransfer!]!
  polygonzkevm_destinationTransfer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygonzkevm_DestinationTransfer
  polygonzkevm_destinationTransfers(
    skip: Int = 0
    first: Int = 100
    orderBy: polygonzkevm_DestinationTransfer_orderBy
    orderDirection: polygonzkevm_OrderDirection
    where: polygonzkevm_DestinationTransfer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygonzkevm_DestinationTransfer!]!
  polygonzkevm_originMessage(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygonzkevm_OriginMessage
  polygonzkevm_originMessages(
    skip: Int = 0
    first: Int = 100
    orderBy: polygonzkevm_OriginMessage_orderBy
    orderDirection: polygonzkevm_OrderDirection
    where: polygonzkevm_OriginMessage_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygonzkevm_OriginMessage!]!
  polygonzkevm_aggregateRoot(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygonzkevm_AggregateRoot
  polygonzkevm_aggregateRoots(
    skip: Int = 0
    first: Int = 100
    orderBy: polygonzkevm_AggregateRoot_orderBy
    orderDirection: polygonzkevm_OrderDirection
    where: polygonzkevm_AggregateRoot_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygonzkevm_AggregateRoot!]!
  polygonzkevm_connectorMeta(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygonzkevm_ConnectorMeta
  polygonzkevm_connectorMetas(
    skip: Int = 0
    first: Int = 100
    orderBy: polygonzkevm_ConnectorMeta_orderBy
    orderDirection: polygonzkevm_OrderDirection
    where: polygonzkevm_ConnectorMeta_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygonzkevm_ConnectorMeta!]!
  polygonzkevm_rootCount(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygonzkevm_RootCount
  polygonzkevm_rootCounts(
    skip: Int = 0
    first: Int = 100
    orderBy: polygonzkevm_RootCount_orderBy
    orderDirection: polygonzkevm_OrderDirection
    where: polygonzkevm_RootCount_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygonzkevm_RootCount!]!
  polygonzkevm_rootMessageSent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygonzkevm_RootMessageSent
  polygonzkevm_rootMessageSents(
    skip: Int = 0
    first: Int = 100
    orderBy: polygonzkevm_RootMessageSent_orderBy
    orderDirection: polygonzkevm_OrderDirection
    where: polygonzkevm_RootMessageSent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygonzkevm_RootMessageSent!]!
  polygonzkevm_relayerFeesIncrease(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygonzkevm_RelayerFeesIncrease
  polygonzkevm_relayerFeesIncreases(
    skip: Int = 0
    first: Int = 100
    orderBy: polygonzkevm_RelayerFeesIncrease_orderBy
    orderDirection: polygonzkevm_OrderDirection
    where: polygonzkevm_RelayerFeesIncrease_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygonzkevm_RelayerFeesIncrease!]!
  polygonzkevm_slippageUpdate(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygonzkevm_SlippageUpdate
  polygonzkevm_slippageUpdates(
    skip: Int = 0
    first: Int = 100
    orderBy: polygonzkevm_SlippageUpdate_orderBy
    orderDirection: polygonzkevm_OrderDirection
    where: polygonzkevm_SlippageUpdate_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygonzkevm_SlippageUpdate!]!
  polygonzkevm_snapshotRoot(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygonzkevm_SnapshotRoot
  polygonzkevm_snapshotRoots(
    skip: Int = 0
    first: Int = 100
    orderBy: polygonzkevm_SnapshotRoot_orderBy
    orderDirection: polygonzkevm_OrderDirection
    where: polygonzkevm_SnapshotRoot_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygonzkevm_SnapshotRoot!]!
  polygonzkevm_spokeConnectorMode(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygonzkevm_SpokeConnectorMode
  polygonzkevm_spokeConnectorModes(
    skip: Int = 0
    first: Int = 100
    orderBy: polygonzkevm_SpokeConnectorMode_orderBy
    orderDirection: polygonzkevm_OrderDirection
    where: polygonzkevm_SpokeConnectorMode_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygonzkevm_SpokeConnectorMode!]!
  polygonzkevm_aggregateRootProposed(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygonzkevm_AggregateRootProposed
  polygonzkevm_aggregateRootProposeds(
    skip: Int = 0
    first: Int = 100
    orderBy: polygonzkevm_AggregateRootProposed_orderBy
    orderDirection: polygonzkevm_OrderDirection
    where: polygonzkevm_AggregateRootProposed_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygonzkevm_AggregateRootProposed!]!
  polygonzkevm_optimisticRootFinalized(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygonzkevm_OptimisticRootFinalized
  polygonzkevm_optimisticRootFinalizeds(
    skip: Int = 0
    first: Int = 100
    orderBy: polygonzkevm_OptimisticRootFinalized_orderBy
    orderDirection: polygonzkevm_OrderDirection
    where: polygonzkevm_OptimisticRootFinalized_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygonzkevm_OptimisticRootFinalized!]!
  """Access to subgraph metadata"""
  polygonzkevm__meta(block: polygonzkevm_Block_height): polygonzkevm__Meta_
  zksync_swap_systemInfo(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): zksync_swap_SystemInfo
  zksync_swap_systemInfos(
    skip: Int = 0
    first: Int = 100
    orderBy: zksync_swap_SystemInfo_orderBy
    orderDirection: zksync_swap_OrderDirection
    where: zksync_swap_SystemInfo_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [zksync_swap_SystemInfo!]!
  zksync_swap_pooledToken(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): zksync_swap_PooledToken
  zksync_swap_pooledTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: zksync_swap_PooledToken_orderBy
    orderDirection: zksync_swap_OrderDirection
    where: zksync_swap_PooledToken_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [zksync_swap_PooledToken!]!
  zksync_swap_stableSwap(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): zksync_swap_StableSwap
  zksync_swap_stableSwaps(
    skip: Int = 0
    first: Int = 100
    orderBy: zksync_swap_StableSwap_orderBy
    orderDirection: zksync_swap_OrderDirection
    where: zksync_swap_StableSwap_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [zksync_swap_StableSwap!]!
  zksync_swap_stableSwapAddLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): zksync_swap_StableSwapAddLiquidityEvent
  zksync_swap_stableSwapAddLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: zksync_swap_StableSwapAddLiquidityEvent_orderBy
    orderDirection: zksync_swap_OrderDirection
    where: zksync_swap_StableSwapAddLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [zksync_swap_StableSwapAddLiquidityEvent!]!
  zksync_swap_stableSwapRemoveLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): zksync_swap_StableSwapRemoveLiquidityEvent
  zksync_swap_stableSwapRemoveLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: zksync_swap_StableSwapRemoveLiquidityEvent_orderBy
    orderDirection: zksync_swap_OrderDirection
    where: zksync_swap_StableSwapRemoveLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [zksync_swap_StableSwapRemoveLiquidityEvent!]!
  zksync_swap_stableSwapExchange(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): zksync_swap_StableSwapExchange
  zksync_swap_stableSwapExchanges(
    skip: Int = 0
    first: Int = 100
    orderBy: zksync_swap_StableSwapExchange_orderBy
    orderDirection: zksync_swap_OrderDirection
    where: zksync_swap_StableSwapExchange_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [zksync_swap_StableSwapExchange!]!
  zksync_swap_swapDailyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): zksync_swap_SwapDailyVolume
  zksync_swap_swapDailyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: zksync_swap_SwapDailyVolume_orderBy
    orderDirection: zksync_swap_OrderDirection
    where: zksync_swap_SwapDailyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [zksync_swap_SwapDailyVolume!]!
  zksync_swap_swapHourlyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): zksync_swap_SwapHourlyVolume
  zksync_swap_swapHourlyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: zksync_swap_SwapHourlyVolume_orderBy
    orderDirection: zksync_swap_OrderDirection
    where: zksync_swap_SwapHourlyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [zksync_swap_SwapHourlyVolume!]!
  zksync_swap_swapWeeklyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): zksync_swap_SwapWeeklyVolume
  zksync_swap_swapWeeklyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: zksync_swap_SwapWeeklyVolume_orderBy
    orderDirection: zksync_swap_OrderDirection
    where: zksync_swap_SwapWeeklyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [zksync_swap_SwapWeeklyVolume!]!
  zksync_swap_lpAccount(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): zksync_swap_LpAccount
  zksync_swap_lpAccounts(
    skip: Int = 0
    first: Int = 100
    orderBy: zksync_swap_LpAccount_orderBy
    orderDirection: zksync_swap_OrderDirection
    where: zksync_swap_LpAccount_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [zksync_swap_LpAccount!]!
  zksync_swap_lpAccountBalance(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): zksync_swap_LpAccountBalance
  zksync_swap_lpAccountBalances(
    skip: Int = 0
    first: Int = 100
    orderBy: zksync_swap_LpAccountBalance_orderBy
    orderDirection: zksync_swap_OrderDirection
    where: zksync_swap_LpAccountBalance_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [zksync_swap_LpAccountBalance!]!
  zksync_swap_lpToken(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): zksync_swap_LpToken
  zksync_swap_lpTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: zksync_swap_LpToken_orderBy
    orderDirection: zksync_swap_OrderDirection
    where: zksync_swap_LpToken_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [zksync_swap_LpToken!]!
  zksync_swap_lpTransferEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): zksync_swap_LpTransferEvent
  zksync_swap_lpTransferEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: zksync_swap_LpTransferEvent_orderBy
    orderDirection: zksync_swap_OrderDirection
    where: zksync_swap_LpTransferEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [zksync_swap_LpTransferEvent!]!
  zksync_swap_stableSwapEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): zksync_swap_StableSwapEvent
  zksync_swap_stableSwapEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: zksync_swap_StableSwapEvent_orderBy
    orderDirection: zksync_swap_OrderDirection
    where: zksync_swap_StableSwapEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [zksync_swap_StableSwapEvent!]!
  zksync_swap_swapTradeVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): zksync_swap_SwapTradeVolume
  zksync_swap_swapTradeVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: zksync_swap_SwapTradeVolume_orderBy
    orderDirection: zksync_swap_OrderDirection
    where: zksync_swap_SwapTradeVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [zksync_swap_SwapTradeVolume!]!
  zksync_swap_lpTokenEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): zksync_swap_LpTokenEvent
  zksync_swap_lpTokenEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: zksync_swap_LpTokenEvent_orderBy
    orderDirection: zksync_swap_OrderDirection
    where: zksync_swap_LpTokenEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [zksync_swap_LpTokenEvent!]!
  """Access to subgraph metadata"""
  zksync_swap__meta(block: zksync_swap_Block_height): zksync_swap__Meta_
  linea_swap_systemInfo(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): linea_swap_SystemInfo
  linea_swap_systemInfos(
    skip: Int = 0
    first: Int = 100
    orderBy: linea_swap_SystemInfo_orderBy
    orderDirection: linea_swap_OrderDirection
    where: linea_swap_SystemInfo_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [linea_swap_SystemInfo!]!
  linea_swap_pooledToken(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): linea_swap_PooledToken
  linea_swap_pooledTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: linea_swap_PooledToken_orderBy
    orderDirection: linea_swap_OrderDirection
    where: linea_swap_PooledToken_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [linea_swap_PooledToken!]!
  linea_swap_stableSwap(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): linea_swap_StableSwap
  linea_swap_stableSwaps(
    skip: Int = 0
    first: Int = 100
    orderBy: linea_swap_StableSwap_orderBy
    orderDirection: linea_swap_OrderDirection
    where: linea_swap_StableSwap_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [linea_swap_StableSwap!]!
  linea_swap_stableSwapAddLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): linea_swap_StableSwapAddLiquidityEvent
  linea_swap_stableSwapAddLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: linea_swap_StableSwapAddLiquidityEvent_orderBy
    orderDirection: linea_swap_OrderDirection
    where: linea_swap_StableSwapAddLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [linea_swap_StableSwapAddLiquidityEvent!]!
  linea_swap_stableSwapRemoveLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): linea_swap_StableSwapRemoveLiquidityEvent
  linea_swap_stableSwapRemoveLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: linea_swap_StableSwapRemoveLiquidityEvent_orderBy
    orderDirection: linea_swap_OrderDirection
    where: linea_swap_StableSwapRemoveLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [linea_swap_StableSwapRemoveLiquidityEvent!]!
  linea_swap_stableSwapExchange(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): linea_swap_StableSwapExchange
  linea_swap_stableSwapExchanges(
    skip: Int = 0
    first: Int = 100
    orderBy: linea_swap_StableSwapExchange_orderBy
    orderDirection: linea_swap_OrderDirection
    where: linea_swap_StableSwapExchange_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [linea_swap_StableSwapExchange!]!
  linea_swap_swapDailyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): linea_swap_SwapDailyVolume
  linea_swap_swapDailyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: linea_swap_SwapDailyVolume_orderBy
    orderDirection: linea_swap_OrderDirection
    where: linea_swap_SwapDailyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [linea_swap_SwapDailyVolume!]!
  linea_swap_swapHourlyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): linea_swap_SwapHourlyVolume
  linea_swap_swapHourlyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: linea_swap_SwapHourlyVolume_orderBy
    orderDirection: linea_swap_OrderDirection
    where: linea_swap_SwapHourlyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [linea_swap_SwapHourlyVolume!]!
  linea_swap_swapWeeklyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): linea_swap_SwapWeeklyVolume
  linea_swap_swapWeeklyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: linea_swap_SwapWeeklyVolume_orderBy
    orderDirection: linea_swap_OrderDirection
    where: linea_swap_SwapWeeklyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [linea_swap_SwapWeeklyVolume!]!
  linea_swap_lpAccount(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): linea_swap_LpAccount
  linea_swap_lpAccounts(
    skip: Int = 0
    first: Int = 100
    orderBy: linea_swap_LpAccount_orderBy
    orderDirection: linea_swap_OrderDirection
    where: linea_swap_LpAccount_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [linea_swap_LpAccount!]!
  linea_swap_lpAccountBalance(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): linea_swap_LpAccountBalance
  linea_swap_lpAccountBalances(
    skip: Int = 0
    first: Int = 100
    orderBy: linea_swap_LpAccountBalance_orderBy
    orderDirection: linea_swap_OrderDirection
    where: linea_swap_LpAccountBalance_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [linea_swap_LpAccountBalance!]!
  linea_swap_lpToken(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): linea_swap_LpToken
  linea_swap_lpTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: linea_swap_LpToken_orderBy
    orderDirection: linea_swap_OrderDirection
    where: linea_swap_LpToken_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [linea_swap_LpToken!]!
  linea_swap_lpTransferEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): linea_swap_LpTransferEvent
  linea_swap_lpTransferEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: linea_swap_LpTransferEvent_orderBy
    orderDirection: linea_swap_OrderDirection
    where: linea_swap_LpTransferEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [linea_swap_LpTransferEvent!]!
  linea_swap_stableSwapEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): linea_swap_StableSwapEvent
  linea_swap_stableSwapEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: linea_swap_StableSwapEvent_orderBy
    orderDirection: linea_swap_OrderDirection
    where: linea_swap_StableSwapEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [linea_swap_StableSwapEvent!]!
  linea_swap_swapTradeVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): linea_swap_SwapTradeVolume
  linea_swap_swapTradeVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: linea_swap_SwapTradeVolume_orderBy
    orderDirection: linea_swap_OrderDirection
    where: linea_swap_SwapTradeVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [linea_swap_SwapTradeVolume!]!
  linea_swap_lpTokenEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): linea_swap_LpTokenEvent
  linea_swap_lpTokenEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: linea_swap_LpTokenEvent_orderBy
    orderDirection: linea_swap_OrderDirection
    where: linea_swap_LpTokenEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [linea_swap_LpTokenEvent!]!
  """Access to subgraph metadata"""
  linea_swap__meta(block: linea_swap_Block_height): linea_swap__Meta_
  base_swap_systemInfo(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: base_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): base_swap_SystemInfo
  base_swap_systemInfos(
    skip: Int = 0
    first: Int = 100
    orderBy: base_swap_SystemInfo_orderBy
    orderDirection: base_swap_OrderDirection
    where: base_swap_SystemInfo_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: base_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [base_swap_SystemInfo!]!
  base_swap_pooledToken(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: base_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): base_swap_PooledToken
  base_swap_pooledTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: base_swap_PooledToken_orderBy
    orderDirection: base_swap_OrderDirection
    where: base_swap_PooledToken_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: base_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [base_swap_PooledToken!]!
  base_swap_stableSwap(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: base_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): base_swap_StableSwap
  base_swap_stableSwaps(
    skip: Int = 0
    first: Int = 100
    orderBy: base_swap_StableSwap_orderBy
    orderDirection: base_swap_OrderDirection
    where: base_swap_StableSwap_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: base_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [base_swap_StableSwap!]!
  base_swap_stableSwapAddLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: base_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): base_swap_StableSwapAddLiquidityEvent
  base_swap_stableSwapAddLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: base_swap_StableSwapAddLiquidityEvent_orderBy
    orderDirection: base_swap_OrderDirection
    where: base_swap_StableSwapAddLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: base_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [base_swap_StableSwapAddLiquidityEvent!]!
  base_swap_stableSwapRemoveLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: base_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): base_swap_StableSwapRemoveLiquidityEvent
  base_swap_stableSwapRemoveLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: base_swap_StableSwapRemoveLiquidityEvent_orderBy
    orderDirection: base_swap_OrderDirection
    where: base_swap_StableSwapRemoveLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: base_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [base_swap_StableSwapRemoveLiquidityEvent!]!
  base_swap_stableSwapExchange(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: base_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): base_swap_StableSwapExchange
  base_swap_stableSwapExchanges(
    skip: Int = 0
    first: Int = 100
    orderBy: base_swap_StableSwapExchange_orderBy
    orderDirection: base_swap_OrderDirection
    where: base_swap_StableSwapExchange_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: base_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [base_swap_StableSwapExchange!]!
  base_swap_swapDailyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: base_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): base_swap_SwapDailyVolume
  base_swap_swapDailyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: base_swap_SwapDailyVolume_orderBy
    orderDirection: base_swap_OrderDirection
    where: base_swap_SwapDailyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: base_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [base_swap_SwapDailyVolume!]!
  base_swap_swapHourlyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: base_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): base_swap_SwapHourlyVolume
  base_swap_swapHourlyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: base_swap_SwapHourlyVolume_orderBy
    orderDirection: base_swap_OrderDirection
    where: base_swap_SwapHourlyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: base_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [base_swap_SwapHourlyVolume!]!
  base_swap_swapWeeklyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: base_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): base_swap_SwapWeeklyVolume
  base_swap_swapWeeklyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: base_swap_SwapWeeklyVolume_orderBy
    orderDirection: base_swap_OrderDirection
    where: base_swap_SwapWeeklyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: base_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [base_swap_SwapWeeklyVolume!]!
  base_swap_lpAccount(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: base_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): base_swap_LpAccount
  base_swap_lpAccounts(
    skip: Int = 0
    first: Int = 100
    orderBy: base_swap_LpAccount_orderBy
    orderDirection: base_swap_OrderDirection
    where: base_swap_LpAccount_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: base_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [base_swap_LpAccount!]!
  base_swap_lpAccountBalance(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: base_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): base_swap_LpAccountBalance
  base_swap_lpAccountBalances(
    skip: Int = 0
    first: Int = 100
    orderBy: base_swap_LpAccountBalance_orderBy
    orderDirection: base_swap_OrderDirection
    where: base_swap_LpAccountBalance_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: base_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [base_swap_LpAccountBalance!]!
  base_swap_lpToken(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: base_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): base_swap_LpToken
  base_swap_lpTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: base_swap_LpToken_orderBy
    orderDirection: base_swap_OrderDirection
    where: base_swap_LpToken_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: base_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [base_swap_LpToken!]!
  base_swap_lpTransferEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: base_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): base_swap_LpTransferEvent
  base_swap_lpTransferEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: base_swap_LpTransferEvent_orderBy
    orderDirection: base_swap_OrderDirection
    where: base_swap_LpTransferEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: base_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [base_swap_LpTransferEvent!]!
  base_swap_stableSwapEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: base_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): base_swap_StableSwapEvent
  base_swap_stableSwapEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: base_swap_StableSwapEvent_orderBy
    orderDirection: base_swap_OrderDirection
    where: base_swap_StableSwapEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: base_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [base_swap_StableSwapEvent!]!
  base_swap_swapTradeVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: base_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): base_swap_SwapTradeVolume
  base_swap_swapTradeVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: base_swap_SwapTradeVolume_orderBy
    orderDirection: base_swap_OrderDirection
    where: base_swap_SwapTradeVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: base_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [base_swap_SwapTradeVolume!]!
  base_swap_lpTokenEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: base_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): base_swap_LpTokenEvent
  base_swap_lpTokenEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: base_swap_LpTokenEvent_orderBy
    orderDirection: base_swap_OrderDirection
    where: base_swap_LpTokenEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: base_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [base_swap_LpTokenEvent!]!
  """Access to subgraph metadata"""
  base_swap__meta(block: base_swap_Block_height): base_swap__Meta_
  polygon_asset(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygon_Asset
  polygon_assets(
    skip: Int = 0
    first: Int = 100
    orderBy: polygon_Asset_orderBy
    orderDirection: polygon_OrderDirection
    where: polygon_Asset_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygon_Asset!]!
  polygon_assetStatus(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygon_AssetStatus
  polygon_assetStatuses(
    skip: Int = 0
    first: Int = 100
    orderBy: polygon_AssetStatus_orderBy
    orderDirection: polygon_OrderDirection
    where: polygon_AssetStatus_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygon_AssetStatus!]!
  polygon_assetBalance(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygon_AssetBalance
  polygon_assetBalances(
    skip: Int = 0
    first: Int = 100
    orderBy: polygon_AssetBalance_orderBy
    orderDirection: polygon_OrderDirection
    where: polygon_AssetBalance_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygon_AssetBalance!]!
  polygon_router(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygon_Router
  polygon_routers(
    skip: Int = 0
    first: Int = 100
    orderBy: polygon_Router_orderBy
    orderDirection: polygon_OrderDirection
    where: polygon_Router_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygon_Router!]!
  polygon_routerDailyTVL(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygon_RouterDailyTVL
  polygon_routerDailyTVLs(
    skip: Int = 0
    first: Int = 100
    orderBy: polygon_RouterDailyTVL_orderBy
    orderDirection: polygon_OrderDirection
    where: polygon_RouterDailyTVL_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygon_RouterDailyTVL!]!
  polygon_routerLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygon_RouterLiquidityEvent
  polygon_routerLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: polygon_RouterLiquidityEvent_orderBy
    orderDirection: polygon_OrderDirection
    where: polygon_RouterLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygon_RouterLiquidityEvent!]!
  polygon_setting(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygon_Setting
  polygon_settings(
    skip: Int = 0
    first: Int = 100
    orderBy: polygon_Setting_orderBy
    orderDirection: polygon_OrderDirection
    where: polygon_Setting_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygon_Setting!]!
  polygon_relayer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygon_Relayer
  polygon_relayers(
    skip: Int = 0
    first: Int = 100
    orderBy: polygon_Relayer_orderBy
    orderDirection: polygon_OrderDirection
    where: polygon_Relayer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygon_Relayer!]!
  polygon_sequencer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygon_Sequencer
  polygon_sequencers(
    skip: Int = 0
    first: Int = 100
    orderBy: polygon_Sequencer_orderBy
    orderDirection: polygon_OrderDirection
    where: polygon_Sequencer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygon_Sequencer!]!
  polygon_relayerFee(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygon_RelayerFee
  polygon_relayerFees(
    skip: Int = 0
    first: Int = 100
    orderBy: polygon_RelayerFee_orderBy
    orderDirection: polygon_OrderDirection
    where: polygon_RelayerFee_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygon_RelayerFee!]!
  polygon_originTransfer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygon_OriginTransfer
  polygon_originTransfers(
    skip: Int = 0
    first: Int = 100
    orderBy: polygon_OriginTransfer_orderBy
    orderDirection: polygon_OrderDirection
    where: polygon_OriginTransfer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygon_OriginTransfer!]!
  polygon_destinationTransfer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygon_DestinationTransfer
  polygon_destinationTransfers(
    skip: Int = 0
    first: Int = 100
    orderBy: polygon_DestinationTransfer_orderBy
    orderDirection: polygon_OrderDirection
    where: polygon_DestinationTransfer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygon_DestinationTransfer!]!
  polygon_originMessage(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygon_OriginMessage
  polygon_originMessages(
    skip: Int = 0
    first: Int = 100
    orderBy: polygon_OriginMessage_orderBy
    orderDirection: polygon_OrderDirection
    where: polygon_OriginMessage_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygon_OriginMessage!]!
  polygon_aggregateRoot(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygon_AggregateRoot
  polygon_aggregateRoots(
    skip: Int = 0
    first: Int = 100
    orderBy: polygon_AggregateRoot_orderBy
    orderDirection: polygon_OrderDirection
    where: polygon_AggregateRoot_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygon_AggregateRoot!]!
  polygon_connectorMeta(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygon_ConnectorMeta
  polygon_connectorMetas(
    skip: Int = 0
    first: Int = 100
    orderBy: polygon_ConnectorMeta_orderBy
    orderDirection: polygon_OrderDirection
    where: polygon_ConnectorMeta_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygon_ConnectorMeta!]!
  polygon_rootCount(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygon_RootCount
  polygon_rootCounts(
    skip: Int = 0
    first: Int = 100
    orderBy: polygon_RootCount_orderBy
    orderDirection: polygon_OrderDirection
    where: polygon_RootCount_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygon_RootCount!]!
  polygon_rootMessageSent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygon_RootMessageSent
  polygon_rootMessageSents(
    skip: Int = 0
    first: Int = 100
    orderBy: polygon_RootMessageSent_orderBy
    orderDirection: polygon_OrderDirection
    where: polygon_RootMessageSent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygon_RootMessageSent!]!
  polygon_relayerFeesIncrease(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygon_RelayerFeesIncrease
  polygon_relayerFeesIncreases(
    skip: Int = 0
    first: Int = 100
    orderBy: polygon_RelayerFeesIncrease_orderBy
    orderDirection: polygon_OrderDirection
    where: polygon_RelayerFeesIncrease_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygon_RelayerFeesIncrease!]!
  polygon_slippageUpdate(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygon_SlippageUpdate
  polygon_slippageUpdates(
    skip: Int = 0
    first: Int = 100
    orderBy: polygon_SlippageUpdate_orderBy
    orderDirection: polygon_OrderDirection
    where: polygon_SlippageUpdate_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygon_SlippageUpdate!]!
  polygon_snapshotRoot(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygon_SnapshotRoot
  polygon_snapshotRoots(
    skip: Int = 0
    first: Int = 100
    orderBy: polygon_SnapshotRoot_orderBy
    orderDirection: polygon_OrderDirection
    where: polygon_SnapshotRoot_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygon_SnapshotRoot!]!
  polygon_spokeConnectorMode(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygon_SpokeConnectorMode
  polygon_spokeConnectorModes(
    skip: Int = 0
    first: Int = 100
    orderBy: polygon_SpokeConnectorMode_orderBy
    orderDirection: polygon_OrderDirection
    where: polygon_SpokeConnectorMode_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygon_SpokeConnectorMode!]!
  polygon_aggregateRootProposed(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygon_AggregateRootProposed
  polygon_aggregateRootProposeds(
    skip: Int = 0
    first: Int = 100
    orderBy: polygon_AggregateRootProposed_orderBy
    orderDirection: polygon_OrderDirection
    where: polygon_AggregateRootProposed_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygon_AggregateRootProposed!]!
  polygon_optimisticRootFinalized(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygon_OptimisticRootFinalized
  polygon_optimisticRootFinalizeds(
    skip: Int = 0
    first: Int = 100
    orderBy: polygon_OptimisticRootFinalized_orderBy
    orderDirection: polygon_OrderDirection
    where: polygon_OptimisticRootFinalized_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygon_OptimisticRootFinalized!]!
  """Access to subgraph metadata"""
  polygon__meta(block: polygon_Block_height): polygon__Meta_
  polygonzkevm_swap_asset(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygonzkevm_swap_Asset
  polygonzkevm_swap_assets(
    skip: Int = 0
    first: Int = 100
    orderBy: polygonzkevm_swap_Asset_orderBy
    orderDirection: polygonzkevm_swap_OrderDirection
    where: polygonzkevm_swap_Asset_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygonzkevm_swap_Asset!]!
  polygonzkevm_swap_assetStatus(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygonzkevm_swap_AssetStatus
  polygonzkevm_swap_assetStatuses(
    skip: Int = 0
    first: Int = 100
    orderBy: polygonzkevm_swap_AssetStatus_orderBy
    orderDirection: polygonzkevm_swap_OrderDirection
    where: polygonzkevm_swap_AssetStatus_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygonzkevm_swap_AssetStatus!]!
  polygonzkevm_swap_assetBalance(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygonzkevm_swap_AssetBalance
  polygonzkevm_swap_assetBalances(
    skip: Int = 0
    first: Int = 100
    orderBy: polygonzkevm_swap_AssetBalance_orderBy
    orderDirection: polygonzkevm_swap_OrderDirection
    where: polygonzkevm_swap_AssetBalance_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygonzkevm_swap_AssetBalance!]!
  polygonzkevm_swap_router(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygonzkevm_swap_Router
  polygonzkevm_swap_routers(
    skip: Int = 0
    first: Int = 100
    orderBy: polygonzkevm_swap_Router_orderBy
    orderDirection: polygonzkevm_swap_OrderDirection
    where: polygonzkevm_swap_Router_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygonzkevm_swap_Router!]!
  polygonzkevm_swap_routerDailyTVL(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygonzkevm_swap_RouterDailyTVL
  polygonzkevm_swap_routerDailyTVLs(
    skip: Int = 0
    first: Int = 100
    orderBy: polygonzkevm_swap_RouterDailyTVL_orderBy
    orderDirection: polygonzkevm_swap_OrderDirection
    where: polygonzkevm_swap_RouterDailyTVL_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygonzkevm_swap_RouterDailyTVL!]!
  polygonzkevm_swap_routerLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygonzkevm_swap_RouterLiquidityEvent
  polygonzkevm_swap_routerLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: polygonzkevm_swap_RouterLiquidityEvent_orderBy
    orderDirection: polygonzkevm_swap_OrderDirection
    where: polygonzkevm_swap_RouterLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygonzkevm_swap_RouterLiquidityEvent!]!
  polygonzkevm_swap_setting(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygonzkevm_swap_Setting
  polygonzkevm_swap_settings(
    skip: Int = 0
    first: Int = 100
    orderBy: polygonzkevm_swap_Setting_orderBy
    orderDirection: polygonzkevm_swap_OrderDirection
    where: polygonzkevm_swap_Setting_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygonzkevm_swap_Setting!]!
  polygonzkevm_swap_relayer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygonzkevm_swap_Relayer
  polygonzkevm_swap_relayers(
    skip: Int = 0
    first: Int = 100
    orderBy: polygonzkevm_swap_Relayer_orderBy
    orderDirection: polygonzkevm_swap_OrderDirection
    where: polygonzkevm_swap_Relayer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygonzkevm_swap_Relayer!]!
  polygonzkevm_swap_sequencer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygonzkevm_swap_Sequencer
  polygonzkevm_swap_sequencers(
    skip: Int = 0
    first: Int = 100
    orderBy: polygonzkevm_swap_Sequencer_orderBy
    orderDirection: polygonzkevm_swap_OrderDirection
    where: polygonzkevm_swap_Sequencer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygonzkevm_swap_Sequencer!]!
  polygonzkevm_swap_relayerFee(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygonzkevm_swap_RelayerFee
  polygonzkevm_swap_relayerFees(
    skip: Int = 0
    first: Int = 100
    orderBy: polygonzkevm_swap_RelayerFee_orderBy
    orderDirection: polygonzkevm_swap_OrderDirection
    where: polygonzkevm_swap_RelayerFee_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygonzkevm_swap_RelayerFee!]!
  polygonzkevm_swap_originTransfer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygonzkevm_swap_OriginTransfer
  polygonzkevm_swap_originTransfers(
    skip: Int = 0
    first: Int = 100
    orderBy: polygonzkevm_swap_OriginTransfer_orderBy
    orderDirection: polygonzkevm_swap_OrderDirection
    where: polygonzkevm_swap_OriginTransfer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygonzkevm_swap_OriginTransfer!]!
  polygonzkevm_swap_destinationTransfer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygonzkevm_swap_DestinationTransfer
  polygonzkevm_swap_destinationTransfers(
    skip: Int = 0
    first: Int = 100
    orderBy: polygonzkevm_swap_DestinationTransfer_orderBy
    orderDirection: polygonzkevm_swap_OrderDirection
    where: polygonzkevm_swap_DestinationTransfer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygonzkevm_swap_DestinationTransfer!]!
  polygonzkevm_swap_originMessage(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygonzkevm_swap_OriginMessage
  polygonzkevm_swap_originMessages(
    skip: Int = 0
    first: Int = 100
    orderBy: polygonzkevm_swap_OriginMessage_orderBy
    orderDirection: polygonzkevm_swap_OrderDirection
    where: polygonzkevm_swap_OriginMessage_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygonzkevm_swap_OriginMessage!]!
  polygonzkevm_swap_aggregateRoot(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygonzkevm_swap_AggregateRoot
  polygonzkevm_swap_aggregateRoots(
    skip: Int = 0
    first: Int = 100
    orderBy: polygonzkevm_swap_AggregateRoot_orderBy
    orderDirection: polygonzkevm_swap_OrderDirection
    where: polygonzkevm_swap_AggregateRoot_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygonzkevm_swap_AggregateRoot!]!
  polygonzkevm_swap_connectorMeta(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygonzkevm_swap_ConnectorMeta
  polygonzkevm_swap_connectorMetas(
    skip: Int = 0
    first: Int = 100
    orderBy: polygonzkevm_swap_ConnectorMeta_orderBy
    orderDirection: polygonzkevm_swap_OrderDirection
    where: polygonzkevm_swap_ConnectorMeta_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygonzkevm_swap_ConnectorMeta!]!
  polygonzkevm_swap_rootCount(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygonzkevm_swap_RootCount
  polygonzkevm_swap_rootCounts(
    skip: Int = 0
    first: Int = 100
    orderBy: polygonzkevm_swap_RootCount_orderBy
    orderDirection: polygonzkevm_swap_OrderDirection
    where: polygonzkevm_swap_RootCount_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygonzkevm_swap_RootCount!]!
  polygonzkevm_swap_rootMessageSent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygonzkevm_swap_RootMessageSent
  polygonzkevm_swap_rootMessageSents(
    skip: Int = 0
    first: Int = 100
    orderBy: polygonzkevm_swap_RootMessageSent_orderBy
    orderDirection: polygonzkevm_swap_OrderDirection
    where: polygonzkevm_swap_RootMessageSent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygonzkevm_swap_RootMessageSent!]!
  polygonzkevm_swap_relayerFeesIncrease(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygonzkevm_swap_RelayerFeesIncrease
  polygonzkevm_swap_relayerFeesIncreases(
    skip: Int = 0
    first: Int = 100
    orderBy: polygonzkevm_swap_RelayerFeesIncrease_orderBy
    orderDirection: polygonzkevm_swap_OrderDirection
    where: polygonzkevm_swap_RelayerFeesIncrease_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygonzkevm_swap_RelayerFeesIncrease!]!
  polygonzkevm_swap_slippageUpdate(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygonzkevm_swap_SlippageUpdate
  polygonzkevm_swap_slippageUpdates(
    skip: Int = 0
    first: Int = 100
    orderBy: polygonzkevm_swap_SlippageUpdate_orderBy
    orderDirection: polygonzkevm_swap_OrderDirection
    where: polygonzkevm_swap_SlippageUpdate_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygonzkevm_swap_SlippageUpdate!]!
  polygonzkevm_swap_snapshotRoot(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygonzkevm_swap_SnapshotRoot
  polygonzkevm_swap_snapshotRoots(
    skip: Int = 0
    first: Int = 100
    orderBy: polygonzkevm_swap_SnapshotRoot_orderBy
    orderDirection: polygonzkevm_swap_OrderDirection
    where: polygonzkevm_swap_SnapshotRoot_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygonzkevm_swap_SnapshotRoot!]!
  polygonzkevm_swap_spokeConnectorMode(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygonzkevm_swap_SpokeConnectorMode
  polygonzkevm_swap_spokeConnectorModes(
    skip: Int = 0
    first: Int = 100
    orderBy: polygonzkevm_swap_SpokeConnectorMode_orderBy
    orderDirection: polygonzkevm_swap_OrderDirection
    where: polygonzkevm_swap_SpokeConnectorMode_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygonzkevm_swap_SpokeConnectorMode!]!
  polygonzkevm_swap_aggregateRootProposed(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygonzkevm_swap_AggregateRootProposed
  polygonzkevm_swap_aggregateRootProposeds(
    skip: Int = 0
    first: Int = 100
    orderBy: polygonzkevm_swap_AggregateRootProposed_orderBy
    orderDirection: polygonzkevm_swap_OrderDirection
    where: polygonzkevm_swap_AggregateRootProposed_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygonzkevm_swap_AggregateRootProposed!]!
  polygonzkevm_swap_optimisticRootFinalized(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygonzkevm_swap_OptimisticRootFinalized
  polygonzkevm_swap_optimisticRootFinalizeds(
    skip: Int = 0
    first: Int = 100
    orderBy: polygonzkevm_swap_OptimisticRootFinalized_orderBy
    orderDirection: polygonzkevm_swap_OrderDirection
    where: polygonzkevm_swap_OptimisticRootFinalized_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygonzkevm_swap_OptimisticRootFinalized!]!
  """Access to subgraph metadata"""
  polygonzkevm_swap__meta(block: polygonzkevm_swap_Block_height): polygonzkevm_swap__Meta_
  zksync_asset(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): zksync_Asset
  zksync_assets(
    skip: Int = 0
    first: Int = 100
    orderBy: zksync_Asset_orderBy
    orderDirection: zksync_OrderDirection
    where: zksync_Asset_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [zksync_Asset!]!
  zksync_assetStatus(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): zksync_AssetStatus
  zksync_assetStatuses(
    skip: Int = 0
    first: Int = 100
    orderBy: zksync_AssetStatus_orderBy
    orderDirection: zksync_OrderDirection
    where: zksync_AssetStatus_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [zksync_AssetStatus!]!
  zksync_assetBalance(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): zksync_AssetBalance
  zksync_assetBalances(
    skip: Int = 0
    first: Int = 100
    orderBy: zksync_AssetBalance_orderBy
    orderDirection: zksync_OrderDirection
    where: zksync_AssetBalance_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [zksync_AssetBalance!]!
  zksync_router(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): zksync_Router
  zksync_routers(
    skip: Int = 0
    first: Int = 100
    orderBy: zksync_Router_orderBy
    orderDirection: zksync_OrderDirection
    where: zksync_Router_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [zksync_Router!]!
  zksync_routerDailyTVL(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): zksync_RouterDailyTVL
  zksync_routerDailyTVLs(
    skip: Int = 0
    first: Int = 100
    orderBy: zksync_RouterDailyTVL_orderBy
    orderDirection: zksync_OrderDirection
    where: zksync_RouterDailyTVL_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [zksync_RouterDailyTVL!]!
  zksync_routerLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): zksync_RouterLiquidityEvent
  zksync_routerLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: zksync_RouterLiquidityEvent_orderBy
    orderDirection: zksync_OrderDirection
    where: zksync_RouterLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [zksync_RouterLiquidityEvent!]!
  zksync_setting(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): zksync_Setting
  zksync_settings(
    skip: Int = 0
    first: Int = 100
    orderBy: zksync_Setting_orderBy
    orderDirection: zksync_OrderDirection
    where: zksync_Setting_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [zksync_Setting!]!
  zksync_relayer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): zksync_Relayer
  zksync_relayers(
    skip: Int = 0
    first: Int = 100
    orderBy: zksync_Relayer_orderBy
    orderDirection: zksync_OrderDirection
    where: zksync_Relayer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [zksync_Relayer!]!
  zksync_sequencer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): zksync_Sequencer
  zksync_sequencers(
    skip: Int = 0
    first: Int = 100
    orderBy: zksync_Sequencer_orderBy
    orderDirection: zksync_OrderDirection
    where: zksync_Sequencer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [zksync_Sequencer!]!
  zksync_relayerFee(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): zksync_RelayerFee
  zksync_relayerFees(
    skip: Int = 0
    first: Int = 100
    orderBy: zksync_RelayerFee_orderBy
    orderDirection: zksync_OrderDirection
    where: zksync_RelayerFee_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [zksync_RelayerFee!]!
  zksync_originTransfer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): zksync_OriginTransfer
  zksync_originTransfers(
    skip: Int = 0
    first: Int = 100
    orderBy: zksync_OriginTransfer_orderBy
    orderDirection: zksync_OrderDirection
    where: zksync_OriginTransfer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [zksync_OriginTransfer!]!
  zksync_destinationTransfer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): zksync_DestinationTransfer
  zksync_destinationTransfers(
    skip: Int = 0
    first: Int = 100
    orderBy: zksync_DestinationTransfer_orderBy
    orderDirection: zksync_OrderDirection
    where: zksync_DestinationTransfer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [zksync_DestinationTransfer!]!
  zksync_originMessage(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): zksync_OriginMessage
  zksync_originMessages(
    skip: Int = 0
    first: Int = 100
    orderBy: zksync_OriginMessage_orderBy
    orderDirection: zksync_OrderDirection
    where: zksync_OriginMessage_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [zksync_OriginMessage!]!
  zksync_aggregateRoot(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): zksync_AggregateRoot
  zksync_aggregateRoots(
    skip: Int = 0
    first: Int = 100
    orderBy: zksync_AggregateRoot_orderBy
    orderDirection: zksync_OrderDirection
    where: zksync_AggregateRoot_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [zksync_AggregateRoot!]!
  zksync_connectorMeta(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): zksync_ConnectorMeta
  zksync_connectorMetas(
    skip: Int = 0
    first: Int = 100
    orderBy: zksync_ConnectorMeta_orderBy
    orderDirection: zksync_OrderDirection
    where: zksync_ConnectorMeta_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [zksync_ConnectorMeta!]!
  zksync_rootCount(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): zksync_RootCount
  zksync_rootCounts(
    skip: Int = 0
    first: Int = 100
    orderBy: zksync_RootCount_orderBy
    orderDirection: zksync_OrderDirection
    where: zksync_RootCount_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [zksync_RootCount!]!
  zksync_rootMessageSent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): zksync_RootMessageSent
  zksync_rootMessageSents(
    skip: Int = 0
    first: Int = 100
    orderBy: zksync_RootMessageSent_orderBy
    orderDirection: zksync_OrderDirection
    where: zksync_RootMessageSent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [zksync_RootMessageSent!]!
  zksync_relayerFeesIncrease(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): zksync_RelayerFeesIncrease
  zksync_relayerFeesIncreases(
    skip: Int = 0
    first: Int = 100
    orderBy: zksync_RelayerFeesIncrease_orderBy
    orderDirection: zksync_OrderDirection
    where: zksync_RelayerFeesIncrease_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [zksync_RelayerFeesIncrease!]!
  zksync_slippageUpdate(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): zksync_SlippageUpdate
  zksync_slippageUpdates(
    skip: Int = 0
    first: Int = 100
    orderBy: zksync_SlippageUpdate_orderBy
    orderDirection: zksync_OrderDirection
    where: zksync_SlippageUpdate_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [zksync_SlippageUpdate!]!
  zksync_snapshotRoot(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): zksync_SnapshotRoot
  zksync_snapshotRoots(
    skip: Int = 0
    first: Int = 100
    orderBy: zksync_SnapshotRoot_orderBy
    orderDirection: zksync_OrderDirection
    where: zksync_SnapshotRoot_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [zksync_SnapshotRoot!]!
  zksync_spokeConnectorMode(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): zksync_SpokeConnectorMode
  zksync_spokeConnectorModes(
    skip: Int = 0
    first: Int = 100
    orderBy: zksync_SpokeConnectorMode_orderBy
    orderDirection: zksync_OrderDirection
    where: zksync_SpokeConnectorMode_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [zksync_SpokeConnectorMode!]!
  zksync_aggregateRootProposed(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): zksync_AggregateRootProposed
  zksync_aggregateRootProposeds(
    skip: Int = 0
    first: Int = 100
    orderBy: zksync_AggregateRootProposed_orderBy
    orderDirection: zksync_OrderDirection
    where: zksync_AggregateRootProposed_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [zksync_AggregateRootProposed!]!
  zksync_optimisticRootFinalized(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): zksync_OptimisticRootFinalized
  zksync_optimisticRootFinalizeds(
    skip: Int = 0
    first: Int = 100
    orderBy: zksync_OptimisticRootFinalized_orderBy
    orderDirection: zksync_OrderDirection
    where: zksync_OptimisticRootFinalized_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [zksync_OptimisticRootFinalized!]!
  """Access to subgraph metadata"""
  zksync__meta(block: zksync_Block_height): zksync__Meta_
  linea_asset(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): linea_Asset
  linea_assets(
    skip: Int = 0
    first: Int = 100
    orderBy: linea_Asset_orderBy
    orderDirection: linea_OrderDirection
    where: linea_Asset_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [linea_Asset!]!
  linea_assetStatus(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): linea_AssetStatus
  linea_assetStatuses(
    skip: Int = 0
    first: Int = 100
    orderBy: linea_AssetStatus_orderBy
    orderDirection: linea_OrderDirection
    where: linea_AssetStatus_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [linea_AssetStatus!]!
  linea_assetBalance(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): linea_AssetBalance
  linea_assetBalances(
    skip: Int = 0
    first: Int = 100
    orderBy: linea_AssetBalance_orderBy
    orderDirection: linea_OrderDirection
    where: linea_AssetBalance_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [linea_AssetBalance!]!
  linea_router(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): linea_Router
  linea_routers(
    skip: Int = 0
    first: Int = 100
    orderBy: linea_Router_orderBy
    orderDirection: linea_OrderDirection
    where: linea_Router_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [linea_Router!]!
  linea_routerDailyTVL(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): linea_RouterDailyTVL
  linea_routerDailyTVLs(
    skip: Int = 0
    first: Int = 100
    orderBy: linea_RouterDailyTVL_orderBy
    orderDirection: linea_OrderDirection
    where: linea_RouterDailyTVL_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [linea_RouterDailyTVL!]!
  linea_routerLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): linea_RouterLiquidityEvent
  linea_routerLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: linea_RouterLiquidityEvent_orderBy
    orderDirection: linea_OrderDirection
    where: linea_RouterLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [linea_RouterLiquidityEvent!]!
  linea_setting(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): linea_Setting
  linea_settings(
    skip: Int = 0
    first: Int = 100
    orderBy: linea_Setting_orderBy
    orderDirection: linea_OrderDirection
    where: linea_Setting_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [linea_Setting!]!
  linea_relayer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): linea_Relayer
  linea_relayers(
    skip: Int = 0
    first: Int = 100
    orderBy: linea_Relayer_orderBy
    orderDirection: linea_OrderDirection
    where: linea_Relayer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [linea_Relayer!]!
  linea_sequencer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): linea_Sequencer
  linea_sequencers(
    skip: Int = 0
    first: Int = 100
    orderBy: linea_Sequencer_orderBy
    orderDirection: linea_OrderDirection
    where: linea_Sequencer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [linea_Sequencer!]!
  linea_relayerFee(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): linea_RelayerFee
  linea_relayerFees(
    skip: Int = 0
    first: Int = 100
    orderBy: linea_RelayerFee_orderBy
    orderDirection: linea_OrderDirection
    where: linea_RelayerFee_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [linea_RelayerFee!]!
  linea_originTransfer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): linea_OriginTransfer
  linea_originTransfers(
    skip: Int = 0
    first: Int = 100
    orderBy: linea_OriginTransfer_orderBy
    orderDirection: linea_OrderDirection
    where: linea_OriginTransfer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [linea_OriginTransfer!]!
  linea_destinationTransfer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): linea_DestinationTransfer
  linea_destinationTransfers(
    skip: Int = 0
    first: Int = 100
    orderBy: linea_DestinationTransfer_orderBy
    orderDirection: linea_OrderDirection
    where: linea_DestinationTransfer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [linea_DestinationTransfer!]!
  linea_originMessage(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): linea_OriginMessage
  linea_originMessages(
    skip: Int = 0
    first: Int = 100
    orderBy: linea_OriginMessage_orderBy
    orderDirection: linea_OrderDirection
    where: linea_OriginMessage_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [linea_OriginMessage!]!
  linea_aggregateRoot(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): linea_AggregateRoot
  linea_aggregateRoots(
    skip: Int = 0
    first: Int = 100
    orderBy: linea_AggregateRoot_orderBy
    orderDirection: linea_OrderDirection
    where: linea_AggregateRoot_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [linea_AggregateRoot!]!
  linea_connectorMeta(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): linea_ConnectorMeta
  linea_connectorMetas(
    skip: Int = 0
    first: Int = 100
    orderBy: linea_ConnectorMeta_orderBy
    orderDirection: linea_OrderDirection
    where: linea_ConnectorMeta_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [linea_ConnectorMeta!]!
  linea_rootCount(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): linea_RootCount
  linea_rootCounts(
    skip: Int = 0
    first: Int = 100
    orderBy: linea_RootCount_orderBy
    orderDirection: linea_OrderDirection
    where: linea_RootCount_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [linea_RootCount!]!
  linea_rootMessageSent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): linea_RootMessageSent
  linea_rootMessageSents(
    skip: Int = 0
    first: Int = 100
    orderBy: linea_RootMessageSent_orderBy
    orderDirection: linea_OrderDirection
    where: linea_RootMessageSent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [linea_RootMessageSent!]!
  linea_relayerFeesIncrease(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): linea_RelayerFeesIncrease
  linea_relayerFeesIncreases(
    skip: Int = 0
    first: Int = 100
    orderBy: linea_RelayerFeesIncrease_orderBy
    orderDirection: linea_OrderDirection
    where: linea_RelayerFeesIncrease_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [linea_RelayerFeesIncrease!]!
  linea_slippageUpdate(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): linea_SlippageUpdate
  linea_slippageUpdates(
    skip: Int = 0
    first: Int = 100
    orderBy: linea_SlippageUpdate_orderBy
    orderDirection: linea_OrderDirection
    where: linea_SlippageUpdate_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [linea_SlippageUpdate!]!
  linea_snapshotRoot(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): linea_SnapshotRoot
  linea_snapshotRoots(
    skip: Int = 0
    first: Int = 100
    orderBy: linea_SnapshotRoot_orderBy
    orderDirection: linea_OrderDirection
    where: linea_SnapshotRoot_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [linea_SnapshotRoot!]!
  linea_spokeConnectorMode(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): linea_SpokeConnectorMode
  linea_spokeConnectorModes(
    skip: Int = 0
    first: Int = 100
    orderBy: linea_SpokeConnectorMode_orderBy
    orderDirection: linea_OrderDirection
    where: linea_SpokeConnectorMode_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [linea_SpokeConnectorMode!]!
  linea_aggregateRootProposed(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): linea_AggregateRootProposed
  linea_aggregateRootProposeds(
    skip: Int = 0
    first: Int = 100
    orderBy: linea_AggregateRootProposed_orderBy
    orderDirection: linea_OrderDirection
    where: linea_AggregateRootProposed_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [linea_AggregateRootProposed!]!
  linea_optimisticRootFinalized(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): linea_OptimisticRootFinalized
  linea_optimisticRootFinalizeds(
    skip: Int = 0
    first: Int = 100
    orderBy: linea_OptimisticRootFinalized_orderBy
    orderDirection: linea_OrderDirection
    where: linea_OptimisticRootFinalized_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [linea_OptimisticRootFinalized!]!
  """Access to subgraph metadata"""
  linea__meta(block: linea_Block_height): linea__Meta_
  metis_asset(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): metis_Asset
  metis_assets(
    skip: Int = 0
    first: Int = 100
    orderBy: metis_Asset_orderBy
    orderDirection: metis_OrderDirection
    where: metis_Asset_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [metis_Asset!]!
  metis_assetStatus(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): metis_AssetStatus
  metis_assetStatuses(
    skip: Int = 0
    first: Int = 100
    orderBy: metis_AssetStatus_orderBy
    orderDirection: metis_OrderDirection
    where: metis_AssetStatus_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [metis_AssetStatus!]!
  metis_assetBalance(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): metis_AssetBalance
  metis_assetBalances(
    skip: Int = 0
    first: Int = 100
    orderBy: metis_AssetBalance_orderBy
    orderDirection: metis_OrderDirection
    where: metis_AssetBalance_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [metis_AssetBalance!]!
  metis_router(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): metis_Router
  metis_routers(
    skip: Int = 0
    first: Int = 100
    orderBy: metis_Router_orderBy
    orderDirection: metis_OrderDirection
    where: metis_Router_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [metis_Router!]!
  metis_routerDailyTVL(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): metis_RouterDailyTVL
  metis_routerDailyTVLs(
    skip: Int = 0
    first: Int = 100
    orderBy: metis_RouterDailyTVL_orderBy
    orderDirection: metis_OrderDirection
    where: metis_RouterDailyTVL_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [metis_RouterDailyTVL!]!
  metis_routerLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): metis_RouterLiquidityEvent
  metis_routerLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: metis_RouterLiquidityEvent_orderBy
    orderDirection: metis_OrderDirection
    where: metis_RouterLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [metis_RouterLiquidityEvent!]!
  metis_setting(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): metis_Setting
  metis_settings(
    skip: Int = 0
    first: Int = 100
    orderBy: metis_Setting_orderBy
    orderDirection: metis_OrderDirection
    where: metis_Setting_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [metis_Setting!]!
  metis_relayer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): metis_Relayer
  metis_relayers(
    skip: Int = 0
    first: Int = 100
    orderBy: metis_Relayer_orderBy
    orderDirection: metis_OrderDirection
    where: metis_Relayer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [metis_Relayer!]!
  metis_sequencer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): metis_Sequencer
  metis_sequencers(
    skip: Int = 0
    first: Int = 100
    orderBy: metis_Sequencer_orderBy
    orderDirection: metis_OrderDirection
    where: metis_Sequencer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [metis_Sequencer!]!
  metis_relayerFee(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): metis_RelayerFee
  metis_relayerFees(
    skip: Int = 0
    first: Int = 100
    orderBy: metis_RelayerFee_orderBy
    orderDirection: metis_OrderDirection
    where: metis_RelayerFee_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [metis_RelayerFee!]!
  metis_originTransfer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): metis_OriginTransfer
  metis_originTransfers(
    skip: Int = 0
    first: Int = 100
    orderBy: metis_OriginTransfer_orderBy
    orderDirection: metis_OrderDirection
    where: metis_OriginTransfer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [metis_OriginTransfer!]!
  metis_destinationTransfer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): metis_DestinationTransfer
  metis_destinationTransfers(
    skip: Int = 0
    first: Int = 100
    orderBy: metis_DestinationTransfer_orderBy
    orderDirection: metis_OrderDirection
    where: metis_DestinationTransfer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [metis_DestinationTransfer!]!
  metis_originMessage(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): metis_OriginMessage
  metis_originMessages(
    skip: Int = 0
    first: Int = 100
    orderBy: metis_OriginMessage_orderBy
    orderDirection: metis_OrderDirection
    where: metis_OriginMessage_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [metis_OriginMessage!]!
  metis_aggregateRoot(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): metis_AggregateRoot
  metis_aggregateRoots(
    skip: Int = 0
    first: Int = 100
    orderBy: metis_AggregateRoot_orderBy
    orderDirection: metis_OrderDirection
    where: metis_AggregateRoot_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [metis_AggregateRoot!]!
  metis_connectorMeta(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): metis_ConnectorMeta
  metis_connectorMetas(
    skip: Int = 0
    first: Int = 100
    orderBy: metis_ConnectorMeta_orderBy
    orderDirection: metis_OrderDirection
    where: metis_ConnectorMeta_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [metis_ConnectorMeta!]!
  metis_rootCount(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): metis_RootCount
  metis_rootCounts(
    skip: Int = 0
    first: Int = 100
    orderBy: metis_RootCount_orderBy
    orderDirection: metis_OrderDirection
    where: metis_RootCount_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [metis_RootCount!]!
  metis_rootMessageSent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): metis_RootMessageSent
  metis_rootMessageSents(
    skip: Int = 0
    first: Int = 100
    orderBy: metis_RootMessageSent_orderBy
    orderDirection: metis_OrderDirection
    where: metis_RootMessageSent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [metis_RootMessageSent!]!
  metis_relayerFeesIncrease(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): metis_RelayerFeesIncrease
  metis_relayerFeesIncreases(
    skip: Int = 0
    first: Int = 100
    orderBy: metis_RelayerFeesIncrease_orderBy
    orderDirection: metis_OrderDirection
    where: metis_RelayerFeesIncrease_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [metis_RelayerFeesIncrease!]!
  metis_slippageUpdate(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): metis_SlippageUpdate
  metis_slippageUpdates(
    skip: Int = 0
    first: Int = 100
    orderBy: metis_SlippageUpdate_orderBy
    orderDirection: metis_OrderDirection
    where: metis_SlippageUpdate_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [metis_SlippageUpdate!]!
  metis_snapshotRoot(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): metis_SnapshotRoot
  metis_snapshotRoots(
    skip: Int = 0
    first: Int = 100
    orderBy: metis_SnapshotRoot_orderBy
    orderDirection: metis_OrderDirection
    where: metis_SnapshotRoot_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [metis_SnapshotRoot!]!
  metis_spokeConnectorMode(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): metis_SpokeConnectorMode
  metis_spokeConnectorModes(
    skip: Int = 0
    first: Int = 100
    orderBy: metis_SpokeConnectorMode_orderBy
    orderDirection: metis_OrderDirection
    where: metis_SpokeConnectorMode_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [metis_SpokeConnectorMode!]!
  metis_aggregateRootProposed(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): metis_AggregateRootProposed
  metis_aggregateRootProposeds(
    skip: Int = 0
    first: Int = 100
    orderBy: metis_AggregateRootProposed_orderBy
    orderDirection: metis_OrderDirection
    where: metis_AggregateRootProposed_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [metis_AggregateRootProposed!]!
  metis_optimisticRootFinalized(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): metis_OptimisticRootFinalized
  metis_optimisticRootFinalizeds(
    skip: Int = 0
    first: Int = 100
    orderBy: metis_OptimisticRootFinalized_orderBy
    orderDirection: metis_OrderDirection
    where: metis_OptimisticRootFinalized_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [metis_OptimisticRootFinalized!]!
  """Access to subgraph metadata"""
  metis__meta(block: metis_Block_height): metis__Meta_
  optimism_asset(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): optimism_Asset
  optimism_assets(
    skip: Int = 0
    first: Int = 100
    orderBy: optimism_Asset_orderBy
    orderDirection: optimism_OrderDirection
    where: optimism_Asset_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [optimism_Asset!]!
  optimism_assetStatus(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): optimism_AssetStatus
  optimism_assetStatuses(
    skip: Int = 0
    first: Int = 100
    orderBy: optimism_AssetStatus_orderBy
    orderDirection: optimism_OrderDirection
    where: optimism_AssetStatus_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [optimism_AssetStatus!]!
  optimism_assetBalance(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): optimism_AssetBalance
  optimism_assetBalances(
    skip: Int = 0
    first: Int = 100
    orderBy: optimism_AssetBalance_orderBy
    orderDirection: optimism_OrderDirection
    where: optimism_AssetBalance_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [optimism_AssetBalance!]!
  optimism_router(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): optimism_Router
  optimism_routers(
    skip: Int = 0
    first: Int = 100
    orderBy: optimism_Router_orderBy
    orderDirection: optimism_OrderDirection
    where: optimism_Router_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [optimism_Router!]!
  optimism_routerDailyTVL(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): optimism_RouterDailyTVL
  optimism_routerDailyTVLs(
    skip: Int = 0
    first: Int = 100
    orderBy: optimism_RouterDailyTVL_orderBy
    orderDirection: optimism_OrderDirection
    where: optimism_RouterDailyTVL_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [optimism_RouterDailyTVL!]!
  optimism_routerLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): optimism_RouterLiquidityEvent
  optimism_routerLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: optimism_RouterLiquidityEvent_orderBy
    orderDirection: optimism_OrderDirection
    where: optimism_RouterLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [optimism_RouterLiquidityEvent!]!
  optimism_setting(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): optimism_Setting
  optimism_settings(
    skip: Int = 0
    first: Int = 100
    orderBy: optimism_Setting_orderBy
    orderDirection: optimism_OrderDirection
    where: optimism_Setting_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [optimism_Setting!]!
  optimism_relayer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): optimism_Relayer
  optimism_relayers(
    skip: Int = 0
    first: Int = 100
    orderBy: optimism_Relayer_orderBy
    orderDirection: optimism_OrderDirection
    where: optimism_Relayer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [optimism_Relayer!]!
  optimism_sequencer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): optimism_Sequencer
  optimism_sequencers(
    skip: Int = 0
    first: Int = 100
    orderBy: optimism_Sequencer_orderBy
    orderDirection: optimism_OrderDirection
    where: optimism_Sequencer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [optimism_Sequencer!]!
  optimism_relayerFee(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): optimism_RelayerFee
  optimism_relayerFees(
    skip: Int = 0
    first: Int = 100
    orderBy: optimism_RelayerFee_orderBy
    orderDirection: optimism_OrderDirection
    where: optimism_RelayerFee_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [optimism_RelayerFee!]!
  optimism_originTransfer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): optimism_OriginTransfer
  optimism_originTransfers(
    skip: Int = 0
    first: Int = 100
    orderBy: optimism_OriginTransfer_orderBy
    orderDirection: optimism_OrderDirection
    where: optimism_OriginTransfer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [optimism_OriginTransfer!]!
  optimism_destinationTransfer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): optimism_DestinationTransfer
  optimism_destinationTransfers(
    skip: Int = 0
    first: Int = 100
    orderBy: optimism_DestinationTransfer_orderBy
    orderDirection: optimism_OrderDirection
    where: optimism_DestinationTransfer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [optimism_DestinationTransfer!]!
  optimism_originMessage(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): optimism_OriginMessage
  optimism_originMessages(
    skip: Int = 0
    first: Int = 100
    orderBy: optimism_OriginMessage_orderBy
    orderDirection: optimism_OrderDirection
    where: optimism_OriginMessage_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [optimism_OriginMessage!]!
  optimism_aggregateRoot(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): optimism_AggregateRoot
  optimism_aggregateRoots(
    skip: Int = 0
    first: Int = 100
    orderBy: optimism_AggregateRoot_orderBy
    orderDirection: optimism_OrderDirection
    where: optimism_AggregateRoot_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [optimism_AggregateRoot!]!
  optimism_connectorMeta(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): optimism_ConnectorMeta
  optimism_connectorMetas(
    skip: Int = 0
    first: Int = 100
    orderBy: optimism_ConnectorMeta_orderBy
    orderDirection: optimism_OrderDirection
    where: optimism_ConnectorMeta_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [optimism_ConnectorMeta!]!
  optimism_rootCount(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): optimism_RootCount
  optimism_rootCounts(
    skip: Int = 0
    first: Int = 100
    orderBy: optimism_RootCount_orderBy
    orderDirection: optimism_OrderDirection
    where: optimism_RootCount_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [optimism_RootCount!]!
  optimism_rootMessageSent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): optimism_RootMessageSent
  optimism_rootMessageSents(
    skip: Int = 0
    first: Int = 100
    orderBy: optimism_RootMessageSent_orderBy
    orderDirection: optimism_OrderDirection
    where: optimism_RootMessageSent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [optimism_RootMessageSent!]!
  optimism_relayerFeesIncrease(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): optimism_RelayerFeesIncrease
  optimism_relayerFeesIncreases(
    skip: Int = 0
    first: Int = 100
    orderBy: optimism_RelayerFeesIncrease_orderBy
    orderDirection: optimism_OrderDirection
    where: optimism_RelayerFeesIncrease_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [optimism_RelayerFeesIncrease!]!
  optimism_slippageUpdate(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): optimism_SlippageUpdate
  optimism_slippageUpdates(
    skip: Int = 0
    first: Int = 100
    orderBy: optimism_SlippageUpdate_orderBy
    orderDirection: optimism_OrderDirection
    where: optimism_SlippageUpdate_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [optimism_SlippageUpdate!]!
  optimism_snapshotRoot(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): optimism_SnapshotRoot
  optimism_snapshotRoots(
    skip: Int = 0
    first: Int = 100
    orderBy: optimism_SnapshotRoot_orderBy
    orderDirection: optimism_OrderDirection
    where: optimism_SnapshotRoot_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [optimism_SnapshotRoot!]!
  optimism_spokeConnectorMode(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): optimism_SpokeConnectorMode
  optimism_spokeConnectorModes(
    skip: Int = 0
    first: Int = 100
    orderBy: optimism_SpokeConnectorMode_orderBy
    orderDirection: optimism_OrderDirection
    where: optimism_SpokeConnectorMode_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [optimism_SpokeConnectorMode!]!
  optimism_aggregateRootProposed(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): optimism_AggregateRootProposed
  optimism_aggregateRootProposeds(
    skip: Int = 0
    first: Int = 100
    orderBy: optimism_AggregateRootProposed_orderBy
    orderDirection: optimism_OrderDirection
    where: optimism_AggregateRootProposed_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [optimism_AggregateRootProposed!]!
  optimism_optimisticRootFinalized(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): optimism_OptimisticRootFinalized
  optimism_optimisticRootFinalizeds(
    skip: Int = 0
    first: Int = 100
    orderBy: optimism_OptimisticRootFinalized_orderBy
    orderDirection: optimism_OrderDirection
    where: optimism_OptimisticRootFinalized_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [optimism_OptimisticRootFinalized!]!
  """Access to subgraph metadata"""
  optimism__meta(block: optimism_Block_height): optimism__Meta_
  avalanche_asset(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): avalanche_Asset
  avalanche_assets(
    skip: Int = 0
    first: Int = 100
    orderBy: avalanche_Asset_orderBy
    orderDirection: avalanche_OrderDirection
    where: avalanche_Asset_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [avalanche_Asset!]!
  avalanche_assetStatus(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): avalanche_AssetStatus
  avalanche_assetStatuses(
    skip: Int = 0
    first: Int = 100
    orderBy: avalanche_AssetStatus_orderBy
    orderDirection: avalanche_OrderDirection
    where: avalanche_AssetStatus_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [avalanche_AssetStatus!]!
  avalanche_assetBalance(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): avalanche_AssetBalance
  avalanche_assetBalances(
    skip: Int = 0
    first: Int = 100
    orderBy: avalanche_AssetBalance_orderBy
    orderDirection: avalanche_OrderDirection
    where: avalanche_AssetBalance_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [avalanche_AssetBalance!]!
  avalanche_router(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): avalanche_Router
  avalanche_routers(
    skip: Int = 0
    first: Int = 100
    orderBy: avalanche_Router_orderBy
    orderDirection: avalanche_OrderDirection
    where: avalanche_Router_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [avalanche_Router!]!
  avalanche_routerDailyTVL(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): avalanche_RouterDailyTVL
  avalanche_routerDailyTVLs(
    skip: Int = 0
    first: Int = 100
    orderBy: avalanche_RouterDailyTVL_orderBy
    orderDirection: avalanche_OrderDirection
    where: avalanche_RouterDailyTVL_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [avalanche_RouterDailyTVL!]!
  avalanche_routerLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): avalanche_RouterLiquidityEvent
  avalanche_routerLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: avalanche_RouterLiquidityEvent_orderBy
    orderDirection: avalanche_OrderDirection
    where: avalanche_RouterLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [avalanche_RouterLiquidityEvent!]!
  avalanche_setting(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): avalanche_Setting
  avalanche_settings(
    skip: Int = 0
    first: Int = 100
    orderBy: avalanche_Setting_orderBy
    orderDirection: avalanche_OrderDirection
    where: avalanche_Setting_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [avalanche_Setting!]!
  avalanche_relayer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): avalanche_Relayer
  avalanche_relayers(
    skip: Int = 0
    first: Int = 100
    orderBy: avalanche_Relayer_orderBy
    orderDirection: avalanche_OrderDirection
    where: avalanche_Relayer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [avalanche_Relayer!]!
  avalanche_sequencer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): avalanche_Sequencer
  avalanche_sequencers(
    skip: Int = 0
    first: Int = 100
    orderBy: avalanche_Sequencer_orderBy
    orderDirection: avalanche_OrderDirection
    where: avalanche_Sequencer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [avalanche_Sequencer!]!
  avalanche_relayerFee(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): avalanche_RelayerFee
  avalanche_relayerFees(
    skip: Int = 0
    first: Int = 100
    orderBy: avalanche_RelayerFee_orderBy
    orderDirection: avalanche_OrderDirection
    where: avalanche_RelayerFee_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [avalanche_RelayerFee!]!
  avalanche_originTransfer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): avalanche_OriginTransfer
  avalanche_originTransfers(
    skip: Int = 0
    first: Int = 100
    orderBy: avalanche_OriginTransfer_orderBy
    orderDirection: avalanche_OrderDirection
    where: avalanche_OriginTransfer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [avalanche_OriginTransfer!]!
  avalanche_destinationTransfer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): avalanche_DestinationTransfer
  avalanche_destinationTransfers(
    skip: Int = 0
    first: Int = 100
    orderBy: avalanche_DestinationTransfer_orderBy
    orderDirection: avalanche_OrderDirection
    where: avalanche_DestinationTransfer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [avalanche_DestinationTransfer!]!
  avalanche_originMessage(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): avalanche_OriginMessage
  avalanche_originMessages(
    skip: Int = 0
    first: Int = 100
    orderBy: avalanche_OriginMessage_orderBy
    orderDirection: avalanche_OrderDirection
    where: avalanche_OriginMessage_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [avalanche_OriginMessage!]!
  avalanche_aggregateRoot(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): avalanche_AggregateRoot
  avalanche_aggregateRoots(
    skip: Int = 0
    first: Int = 100
    orderBy: avalanche_AggregateRoot_orderBy
    orderDirection: avalanche_OrderDirection
    where: avalanche_AggregateRoot_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [avalanche_AggregateRoot!]!
  avalanche_connectorMeta(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): avalanche_ConnectorMeta
  avalanche_connectorMetas(
    skip: Int = 0
    first: Int = 100
    orderBy: avalanche_ConnectorMeta_orderBy
    orderDirection: avalanche_OrderDirection
    where: avalanche_ConnectorMeta_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [avalanche_ConnectorMeta!]!
  avalanche_rootCount(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): avalanche_RootCount
  avalanche_rootCounts(
    skip: Int = 0
    first: Int = 100
    orderBy: avalanche_RootCount_orderBy
    orderDirection: avalanche_OrderDirection
    where: avalanche_RootCount_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [avalanche_RootCount!]!
  avalanche_rootMessageSent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): avalanche_RootMessageSent
  avalanche_rootMessageSents(
    skip: Int = 0
    first: Int = 100
    orderBy: avalanche_RootMessageSent_orderBy
    orderDirection: avalanche_OrderDirection
    where: avalanche_RootMessageSent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [avalanche_RootMessageSent!]!
  avalanche_relayerFeesIncrease(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): avalanche_RelayerFeesIncrease
  avalanche_relayerFeesIncreases(
    skip: Int = 0
    first: Int = 100
    orderBy: avalanche_RelayerFeesIncrease_orderBy
    orderDirection: avalanche_OrderDirection
    where: avalanche_RelayerFeesIncrease_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [avalanche_RelayerFeesIncrease!]!
  avalanche_slippageUpdate(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): avalanche_SlippageUpdate
  avalanche_slippageUpdates(
    skip: Int = 0
    first: Int = 100
    orderBy: avalanche_SlippageUpdate_orderBy
    orderDirection: avalanche_OrderDirection
    where: avalanche_SlippageUpdate_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [avalanche_SlippageUpdate!]!
  avalanche_snapshotRoot(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): avalanche_SnapshotRoot
  avalanche_snapshotRoots(
    skip: Int = 0
    first: Int = 100
    orderBy: avalanche_SnapshotRoot_orderBy
    orderDirection: avalanche_OrderDirection
    where: avalanche_SnapshotRoot_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [avalanche_SnapshotRoot!]!
  avalanche_spokeConnectorMode(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): avalanche_SpokeConnectorMode
  avalanche_spokeConnectorModes(
    skip: Int = 0
    first: Int = 100
    orderBy: avalanche_SpokeConnectorMode_orderBy
    orderDirection: avalanche_OrderDirection
    where: avalanche_SpokeConnectorMode_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [avalanche_SpokeConnectorMode!]!
  avalanche_aggregateRootProposed(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): avalanche_AggregateRootProposed
  avalanche_aggregateRootProposeds(
    skip: Int = 0
    first: Int = 100
    orderBy: avalanche_AggregateRootProposed_orderBy
    orderDirection: avalanche_OrderDirection
    where: avalanche_AggregateRootProposed_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [avalanche_AggregateRootProposed!]!
  avalanche_optimisticRootFinalized(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): avalanche_OptimisticRootFinalized
  avalanche_optimisticRootFinalizeds(
    skip: Int = 0
    first: Int = 100
    orderBy: avalanche_OptimisticRootFinalized_orderBy
    orderDirection: avalanche_OrderDirection
    where: avalanche_OptimisticRootFinalized_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [avalanche_OptimisticRootFinalized!]!
  """Access to subgraph metadata"""
  avalanche__meta(block: avalanche_Block_height): avalanche__Meta_
  mantle_asset(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mantle_Asset
  mantle_assets(
    skip: Int = 0
    first: Int = 100
    orderBy: mantle_Asset_orderBy
    orderDirection: mantle_OrderDirection
    where: mantle_Asset_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mantle_Asset!]!
  mantle_assetStatus(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mantle_AssetStatus
  mantle_assetStatuses(
    skip: Int = 0
    first: Int = 100
    orderBy: mantle_AssetStatus_orderBy
    orderDirection: mantle_OrderDirection
    where: mantle_AssetStatus_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mantle_AssetStatus!]!
  mantle_assetBalance(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mantle_AssetBalance
  mantle_assetBalances(
    skip: Int = 0
    first: Int = 100
    orderBy: mantle_AssetBalance_orderBy
    orderDirection: mantle_OrderDirection
    where: mantle_AssetBalance_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mantle_AssetBalance!]!
  mantle_router(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mantle_Router
  mantle_routers(
    skip: Int = 0
    first: Int = 100
    orderBy: mantle_Router_orderBy
    orderDirection: mantle_OrderDirection
    where: mantle_Router_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mantle_Router!]!
  mantle_routerDailyTVL(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mantle_RouterDailyTVL
  mantle_routerDailyTVLs(
    skip: Int = 0
    first: Int = 100
    orderBy: mantle_RouterDailyTVL_orderBy
    orderDirection: mantle_OrderDirection
    where: mantle_RouterDailyTVL_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mantle_RouterDailyTVL!]!
  mantle_routerLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mantle_RouterLiquidityEvent
  mantle_routerLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: mantle_RouterLiquidityEvent_orderBy
    orderDirection: mantle_OrderDirection
    where: mantle_RouterLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mantle_RouterLiquidityEvent!]!
  mantle_setting(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mantle_Setting
  mantle_settings(
    skip: Int = 0
    first: Int = 100
    orderBy: mantle_Setting_orderBy
    orderDirection: mantle_OrderDirection
    where: mantle_Setting_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mantle_Setting!]!
  mantle_relayer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mantle_Relayer
  mantle_relayers(
    skip: Int = 0
    first: Int = 100
    orderBy: mantle_Relayer_orderBy
    orderDirection: mantle_OrderDirection
    where: mantle_Relayer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mantle_Relayer!]!
  mantle_sequencer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mantle_Sequencer
  mantle_sequencers(
    skip: Int = 0
    first: Int = 100
    orderBy: mantle_Sequencer_orderBy
    orderDirection: mantle_OrderDirection
    where: mantle_Sequencer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mantle_Sequencer!]!
  mantle_relayerFee(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mantle_RelayerFee
  mantle_relayerFees(
    skip: Int = 0
    first: Int = 100
    orderBy: mantle_RelayerFee_orderBy
    orderDirection: mantle_OrderDirection
    where: mantle_RelayerFee_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mantle_RelayerFee!]!
  mantle_originTransfer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mantle_OriginTransfer
  mantle_originTransfers(
    skip: Int = 0
    first: Int = 100
    orderBy: mantle_OriginTransfer_orderBy
    orderDirection: mantle_OrderDirection
    where: mantle_OriginTransfer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mantle_OriginTransfer!]!
  mantle_destinationTransfer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mantle_DestinationTransfer
  mantle_destinationTransfers(
    skip: Int = 0
    first: Int = 100
    orderBy: mantle_DestinationTransfer_orderBy
    orderDirection: mantle_OrderDirection
    where: mantle_DestinationTransfer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mantle_DestinationTransfer!]!
  mantle_originMessage(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mantle_OriginMessage
  mantle_originMessages(
    skip: Int = 0
    first: Int = 100
    orderBy: mantle_OriginMessage_orderBy
    orderDirection: mantle_OrderDirection
    where: mantle_OriginMessage_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mantle_OriginMessage!]!
  mantle_aggregateRoot(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mantle_AggregateRoot
  mantle_aggregateRoots(
    skip: Int = 0
    first: Int = 100
    orderBy: mantle_AggregateRoot_orderBy
    orderDirection: mantle_OrderDirection
    where: mantle_AggregateRoot_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mantle_AggregateRoot!]!
  mantle_connectorMeta(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mantle_ConnectorMeta
  mantle_connectorMetas(
    skip: Int = 0
    first: Int = 100
    orderBy: mantle_ConnectorMeta_orderBy
    orderDirection: mantle_OrderDirection
    where: mantle_ConnectorMeta_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mantle_ConnectorMeta!]!
  mantle_rootCount(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mantle_RootCount
  mantle_rootCounts(
    skip: Int = 0
    first: Int = 100
    orderBy: mantle_RootCount_orderBy
    orderDirection: mantle_OrderDirection
    where: mantle_RootCount_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mantle_RootCount!]!
  mantle_rootMessageSent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mantle_RootMessageSent
  mantle_rootMessageSents(
    skip: Int = 0
    first: Int = 100
    orderBy: mantle_RootMessageSent_orderBy
    orderDirection: mantle_OrderDirection
    where: mantle_RootMessageSent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mantle_RootMessageSent!]!
  mantle_relayerFeesIncrease(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mantle_RelayerFeesIncrease
  mantle_relayerFeesIncreases(
    skip: Int = 0
    first: Int = 100
    orderBy: mantle_RelayerFeesIncrease_orderBy
    orderDirection: mantle_OrderDirection
    where: mantle_RelayerFeesIncrease_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mantle_RelayerFeesIncrease!]!
  mantle_slippageUpdate(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mantle_SlippageUpdate
  mantle_slippageUpdates(
    skip: Int = 0
    first: Int = 100
    orderBy: mantle_SlippageUpdate_orderBy
    orderDirection: mantle_OrderDirection
    where: mantle_SlippageUpdate_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mantle_SlippageUpdate!]!
  mantle_snapshotRoot(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mantle_SnapshotRoot
  mantle_snapshotRoots(
    skip: Int = 0
    first: Int = 100
    orderBy: mantle_SnapshotRoot_orderBy
    orderDirection: mantle_OrderDirection
    where: mantle_SnapshotRoot_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mantle_SnapshotRoot!]!
  mantle_spokeConnectorMode(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mantle_SpokeConnectorMode
  mantle_spokeConnectorModes(
    skip: Int = 0
    first: Int = 100
    orderBy: mantle_SpokeConnectorMode_orderBy
    orderDirection: mantle_OrderDirection
    where: mantle_SpokeConnectorMode_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mantle_SpokeConnectorMode!]!
  mantle_aggregateRootProposed(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mantle_AggregateRootProposed
  mantle_aggregateRootProposeds(
    skip: Int = 0
    first: Int = 100
    orderBy: mantle_AggregateRootProposed_orderBy
    orderDirection: mantle_OrderDirection
    where: mantle_AggregateRootProposed_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mantle_AggregateRootProposed!]!
  mantle_optimisticRootFinalized(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mantle_OptimisticRootFinalized
  mantle_optimisticRootFinalizeds(
    skip: Int = 0
    first: Int = 100
    orderBy: mantle_OptimisticRootFinalized_orderBy
    orderDirection: mantle_OrderDirection
    where: mantle_OptimisticRootFinalized_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mantle_OptimisticRootFinalized!]!
  """Access to subgraph metadata"""
  mantle__meta(block: mantle_Block_height): mantle__Meta_
  xlayer_asset(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xlayer_Asset
  xlayer_assets(
    skip: Int = 0
    first: Int = 100
    orderBy: xlayer_Asset_orderBy
    orderDirection: xlayer_OrderDirection
    where: xlayer_Asset_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xlayer_Asset!]!
  xlayer_assetStatus(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xlayer_AssetStatus
  xlayer_assetStatuses(
    skip: Int = 0
    first: Int = 100
    orderBy: xlayer_AssetStatus_orderBy
    orderDirection: xlayer_OrderDirection
    where: xlayer_AssetStatus_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xlayer_AssetStatus!]!
  xlayer_assetBalance(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xlayer_AssetBalance
  xlayer_assetBalances(
    skip: Int = 0
    first: Int = 100
    orderBy: xlayer_AssetBalance_orderBy
    orderDirection: xlayer_OrderDirection
    where: xlayer_AssetBalance_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xlayer_AssetBalance!]!
  xlayer_router(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xlayer_Router
  xlayer_routers(
    skip: Int = 0
    first: Int = 100
    orderBy: xlayer_Router_orderBy
    orderDirection: xlayer_OrderDirection
    where: xlayer_Router_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xlayer_Router!]!
  xlayer_routerDailyTVL(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xlayer_RouterDailyTVL
  xlayer_routerDailyTVLs(
    skip: Int = 0
    first: Int = 100
    orderBy: xlayer_RouterDailyTVL_orderBy
    orderDirection: xlayer_OrderDirection
    where: xlayer_RouterDailyTVL_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xlayer_RouterDailyTVL!]!
  xlayer_routerLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xlayer_RouterLiquidityEvent
  xlayer_routerLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: xlayer_RouterLiquidityEvent_orderBy
    orderDirection: xlayer_OrderDirection
    where: xlayer_RouterLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xlayer_RouterLiquidityEvent!]!
  xlayer_setting(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xlayer_Setting
  xlayer_settings(
    skip: Int = 0
    first: Int = 100
    orderBy: xlayer_Setting_orderBy
    orderDirection: xlayer_OrderDirection
    where: xlayer_Setting_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xlayer_Setting!]!
  xlayer_relayer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xlayer_Relayer
  xlayer_relayers(
    skip: Int = 0
    first: Int = 100
    orderBy: xlayer_Relayer_orderBy
    orderDirection: xlayer_OrderDirection
    where: xlayer_Relayer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xlayer_Relayer!]!
  xlayer_sequencer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xlayer_Sequencer
  xlayer_sequencers(
    skip: Int = 0
    first: Int = 100
    orderBy: xlayer_Sequencer_orderBy
    orderDirection: xlayer_OrderDirection
    where: xlayer_Sequencer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xlayer_Sequencer!]!
  xlayer_relayerFee(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xlayer_RelayerFee
  xlayer_relayerFees(
    skip: Int = 0
    first: Int = 100
    orderBy: xlayer_RelayerFee_orderBy
    orderDirection: xlayer_OrderDirection
    where: xlayer_RelayerFee_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xlayer_RelayerFee!]!
  xlayer_originTransfer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xlayer_OriginTransfer
  xlayer_originTransfers(
    skip: Int = 0
    first: Int = 100
    orderBy: xlayer_OriginTransfer_orderBy
    orderDirection: xlayer_OrderDirection
    where: xlayer_OriginTransfer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xlayer_OriginTransfer!]!
  xlayer_destinationTransfer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xlayer_DestinationTransfer
  xlayer_destinationTransfers(
    skip: Int = 0
    first: Int = 100
    orderBy: xlayer_DestinationTransfer_orderBy
    orderDirection: xlayer_OrderDirection
    where: xlayer_DestinationTransfer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xlayer_DestinationTransfer!]!
  xlayer_originMessage(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xlayer_OriginMessage
  xlayer_originMessages(
    skip: Int = 0
    first: Int = 100
    orderBy: xlayer_OriginMessage_orderBy
    orderDirection: xlayer_OrderDirection
    where: xlayer_OriginMessage_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xlayer_OriginMessage!]!
  xlayer_aggregateRoot(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xlayer_AggregateRoot
  xlayer_aggregateRoots(
    skip: Int = 0
    first: Int = 100
    orderBy: xlayer_AggregateRoot_orderBy
    orderDirection: xlayer_OrderDirection
    where: xlayer_AggregateRoot_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xlayer_AggregateRoot!]!
  xlayer_connectorMeta(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xlayer_ConnectorMeta
  xlayer_connectorMetas(
    skip: Int = 0
    first: Int = 100
    orderBy: xlayer_ConnectorMeta_orderBy
    orderDirection: xlayer_OrderDirection
    where: xlayer_ConnectorMeta_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xlayer_ConnectorMeta!]!
  xlayer_rootCount(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xlayer_RootCount
  xlayer_rootCounts(
    skip: Int = 0
    first: Int = 100
    orderBy: xlayer_RootCount_orderBy
    orderDirection: xlayer_OrderDirection
    where: xlayer_RootCount_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xlayer_RootCount!]!
  xlayer_rootMessageSent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xlayer_RootMessageSent
  xlayer_rootMessageSents(
    skip: Int = 0
    first: Int = 100
    orderBy: xlayer_RootMessageSent_orderBy
    orderDirection: xlayer_OrderDirection
    where: xlayer_RootMessageSent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xlayer_RootMessageSent!]!
  xlayer_relayerFeesIncrease(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xlayer_RelayerFeesIncrease
  xlayer_relayerFeesIncreases(
    skip: Int = 0
    first: Int = 100
    orderBy: xlayer_RelayerFeesIncrease_orderBy
    orderDirection: xlayer_OrderDirection
    where: xlayer_RelayerFeesIncrease_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xlayer_RelayerFeesIncrease!]!
  xlayer_slippageUpdate(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xlayer_SlippageUpdate
  xlayer_slippageUpdates(
    skip: Int = 0
    first: Int = 100
    orderBy: xlayer_SlippageUpdate_orderBy
    orderDirection: xlayer_OrderDirection
    where: xlayer_SlippageUpdate_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xlayer_SlippageUpdate!]!
  xlayer_snapshotRoot(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xlayer_SnapshotRoot
  xlayer_snapshotRoots(
    skip: Int = 0
    first: Int = 100
    orderBy: xlayer_SnapshotRoot_orderBy
    orderDirection: xlayer_OrderDirection
    where: xlayer_SnapshotRoot_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xlayer_SnapshotRoot!]!
  xlayer_spokeConnectorMode(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xlayer_SpokeConnectorMode
  xlayer_spokeConnectorModes(
    skip: Int = 0
    first: Int = 100
    orderBy: xlayer_SpokeConnectorMode_orderBy
    orderDirection: xlayer_OrderDirection
    where: xlayer_SpokeConnectorMode_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xlayer_SpokeConnectorMode!]!
  xlayer_aggregateRootProposed(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xlayer_AggregateRootProposed
  xlayer_aggregateRootProposeds(
    skip: Int = 0
    first: Int = 100
    orderBy: xlayer_AggregateRootProposed_orderBy
    orderDirection: xlayer_OrderDirection
    where: xlayer_AggregateRootProposed_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xlayer_AggregateRootProposed!]!
  xlayer_optimisticRootFinalized(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xlayer_OptimisticRootFinalized
  xlayer_optimisticRootFinalizeds(
    skip: Int = 0
    first: Int = 100
    orderBy: xlayer_OptimisticRootFinalized_orderBy
    orderDirection: xlayer_OrderDirection
    where: xlayer_OptimisticRootFinalized_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xlayer_OptimisticRootFinalized!]!
  """Access to subgraph metadata"""
  xlayer__meta(block: xlayer_Block_height): xlayer__Meta_
  mode_asset(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mode_Asset
  mode_assets(
    skip: Int = 0
    first: Int = 100
    orderBy: mode_Asset_orderBy
    orderDirection: mode_OrderDirection
    where: mode_Asset_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mode_Asset!]!
  mode_assetStatus(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mode_AssetStatus
  mode_assetStatuses(
    skip: Int = 0
    first: Int = 100
    orderBy: mode_AssetStatus_orderBy
    orderDirection: mode_OrderDirection
    where: mode_AssetStatus_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mode_AssetStatus!]!
  mode_assetBalance(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mode_AssetBalance
  mode_assetBalances(
    skip: Int = 0
    first: Int = 100
    orderBy: mode_AssetBalance_orderBy
    orderDirection: mode_OrderDirection
    where: mode_AssetBalance_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mode_AssetBalance!]!
  mode_router(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mode_Router
  mode_routers(
    skip: Int = 0
    first: Int = 100
    orderBy: mode_Router_orderBy
    orderDirection: mode_OrderDirection
    where: mode_Router_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mode_Router!]!
  mode_routerDailyTVL(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mode_RouterDailyTVL
  mode_routerDailyTVLs(
    skip: Int = 0
    first: Int = 100
    orderBy: mode_RouterDailyTVL_orderBy
    orderDirection: mode_OrderDirection
    where: mode_RouterDailyTVL_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mode_RouterDailyTVL!]!
  mode_routerLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mode_RouterLiquidityEvent
  mode_routerLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: mode_RouterLiquidityEvent_orderBy
    orderDirection: mode_OrderDirection
    where: mode_RouterLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mode_RouterLiquidityEvent!]!
  mode_setting(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mode_Setting
  mode_settings(
    skip: Int = 0
    first: Int = 100
    orderBy: mode_Setting_orderBy
    orderDirection: mode_OrderDirection
    where: mode_Setting_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mode_Setting!]!
  mode_relayer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mode_Relayer
  mode_relayers(
    skip: Int = 0
    first: Int = 100
    orderBy: mode_Relayer_orderBy
    orderDirection: mode_OrderDirection
    where: mode_Relayer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mode_Relayer!]!
  mode_sequencer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mode_Sequencer
  mode_sequencers(
    skip: Int = 0
    first: Int = 100
    orderBy: mode_Sequencer_orderBy
    orderDirection: mode_OrderDirection
    where: mode_Sequencer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mode_Sequencer!]!
  mode_relayerFee(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mode_RelayerFee
  mode_relayerFees(
    skip: Int = 0
    first: Int = 100
    orderBy: mode_RelayerFee_orderBy
    orderDirection: mode_OrderDirection
    where: mode_RelayerFee_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mode_RelayerFee!]!
  mode_originTransfer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mode_OriginTransfer
  mode_originTransfers(
    skip: Int = 0
    first: Int = 100
    orderBy: mode_OriginTransfer_orderBy
    orderDirection: mode_OrderDirection
    where: mode_OriginTransfer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mode_OriginTransfer!]!
  mode_destinationTransfer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mode_DestinationTransfer
  mode_destinationTransfers(
    skip: Int = 0
    first: Int = 100
    orderBy: mode_DestinationTransfer_orderBy
    orderDirection: mode_OrderDirection
    where: mode_DestinationTransfer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mode_DestinationTransfer!]!
  mode_originMessage(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mode_OriginMessage
  mode_originMessages(
    skip: Int = 0
    first: Int = 100
    orderBy: mode_OriginMessage_orderBy
    orderDirection: mode_OrderDirection
    where: mode_OriginMessage_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mode_OriginMessage!]!
  mode_aggregateRoot(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mode_AggregateRoot
  mode_aggregateRoots(
    skip: Int = 0
    first: Int = 100
    orderBy: mode_AggregateRoot_orderBy
    orderDirection: mode_OrderDirection
    where: mode_AggregateRoot_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mode_AggregateRoot!]!
  mode_connectorMeta(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mode_ConnectorMeta
  mode_connectorMetas(
    skip: Int = 0
    first: Int = 100
    orderBy: mode_ConnectorMeta_orderBy
    orderDirection: mode_OrderDirection
    where: mode_ConnectorMeta_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mode_ConnectorMeta!]!
  mode_rootCount(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mode_RootCount
  mode_rootCounts(
    skip: Int = 0
    first: Int = 100
    orderBy: mode_RootCount_orderBy
    orderDirection: mode_OrderDirection
    where: mode_RootCount_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mode_RootCount!]!
  mode_rootMessageSent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mode_RootMessageSent
  mode_rootMessageSents(
    skip: Int = 0
    first: Int = 100
    orderBy: mode_RootMessageSent_orderBy
    orderDirection: mode_OrderDirection
    where: mode_RootMessageSent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mode_RootMessageSent!]!
  mode_relayerFeesIncrease(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mode_RelayerFeesIncrease
  mode_relayerFeesIncreases(
    skip: Int = 0
    first: Int = 100
    orderBy: mode_RelayerFeesIncrease_orderBy
    orderDirection: mode_OrderDirection
    where: mode_RelayerFeesIncrease_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mode_RelayerFeesIncrease!]!
  mode_slippageUpdate(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mode_SlippageUpdate
  mode_slippageUpdates(
    skip: Int = 0
    first: Int = 100
    orderBy: mode_SlippageUpdate_orderBy
    orderDirection: mode_OrderDirection
    where: mode_SlippageUpdate_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mode_SlippageUpdate!]!
  mode_snapshotRoot(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mode_SnapshotRoot
  mode_snapshotRoots(
    skip: Int = 0
    first: Int = 100
    orderBy: mode_SnapshotRoot_orderBy
    orderDirection: mode_OrderDirection
    where: mode_SnapshotRoot_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mode_SnapshotRoot!]!
  mode_spokeConnectorMode(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mode_SpokeConnectorMode
  mode_spokeConnectorModes(
    skip: Int = 0
    first: Int = 100
    orderBy: mode_SpokeConnectorMode_orderBy
    orderDirection: mode_OrderDirection
    where: mode_SpokeConnectorMode_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mode_SpokeConnectorMode!]!
  mode_aggregateRootProposed(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mode_AggregateRootProposed
  mode_aggregateRootProposeds(
    skip: Int = 0
    first: Int = 100
    orderBy: mode_AggregateRootProposed_orderBy
    orderDirection: mode_OrderDirection
    where: mode_AggregateRootProposed_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mode_AggregateRootProposed!]!
  mode_optimisticRootFinalized(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mode_OptimisticRootFinalized
  mode_optimisticRootFinalizeds(
    skip: Int = 0
    first: Int = 100
    orderBy: mode_OptimisticRootFinalized_orderBy
    orderDirection: mode_OrderDirection
    where: mode_OptimisticRootFinalized_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mode_OptimisticRootFinalized!]!
  """Access to subgraph metadata"""
  mode__meta(block: mode_Block_height): mode__Meta_
  arbitrumone_asset(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): arbitrumone_Asset
  arbitrumone_assets(
    skip: Int = 0
    first: Int = 100
    orderBy: arbitrumone_Asset_orderBy
    orderDirection: arbitrumone_OrderDirection
    where: arbitrumone_Asset_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [arbitrumone_Asset!]!
  arbitrumone_assetStatus(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): arbitrumone_AssetStatus
  arbitrumone_assetStatuses(
    skip: Int = 0
    first: Int = 100
    orderBy: arbitrumone_AssetStatus_orderBy
    orderDirection: arbitrumone_OrderDirection
    where: arbitrumone_AssetStatus_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [arbitrumone_AssetStatus!]!
  arbitrumone_assetBalance(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): arbitrumone_AssetBalance
  arbitrumone_assetBalances(
    skip: Int = 0
    first: Int = 100
    orderBy: arbitrumone_AssetBalance_orderBy
    orderDirection: arbitrumone_OrderDirection
    where: arbitrumone_AssetBalance_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [arbitrumone_AssetBalance!]!
  arbitrumone_router(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): arbitrumone_Router
  arbitrumone_routers(
    skip: Int = 0
    first: Int = 100
    orderBy: arbitrumone_Router_orderBy
    orderDirection: arbitrumone_OrderDirection
    where: arbitrumone_Router_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [arbitrumone_Router!]!
  arbitrumone_routerDailyTVL(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): arbitrumone_RouterDailyTVL
  arbitrumone_routerDailyTVLs(
    skip: Int = 0
    first: Int = 100
    orderBy: arbitrumone_RouterDailyTVL_orderBy
    orderDirection: arbitrumone_OrderDirection
    where: arbitrumone_RouterDailyTVL_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [arbitrumone_RouterDailyTVL!]!
  arbitrumone_routerLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): arbitrumone_RouterLiquidityEvent
  arbitrumone_routerLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: arbitrumone_RouterLiquidityEvent_orderBy
    orderDirection: arbitrumone_OrderDirection
    where: arbitrumone_RouterLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [arbitrumone_RouterLiquidityEvent!]!
  arbitrumone_setting(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): arbitrumone_Setting
  arbitrumone_settings(
    skip: Int = 0
    first: Int = 100
    orderBy: arbitrumone_Setting_orderBy
    orderDirection: arbitrumone_OrderDirection
    where: arbitrumone_Setting_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [arbitrumone_Setting!]!
  arbitrumone_relayer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): arbitrumone_Relayer
  arbitrumone_relayers(
    skip: Int = 0
    first: Int = 100
    orderBy: arbitrumone_Relayer_orderBy
    orderDirection: arbitrumone_OrderDirection
    where: arbitrumone_Relayer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [arbitrumone_Relayer!]!
  arbitrumone_sequencer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): arbitrumone_Sequencer
  arbitrumone_sequencers(
    skip: Int = 0
    first: Int = 100
    orderBy: arbitrumone_Sequencer_orderBy
    orderDirection: arbitrumone_OrderDirection
    where: arbitrumone_Sequencer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [arbitrumone_Sequencer!]!
  arbitrumone_relayerFee(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): arbitrumone_RelayerFee
  arbitrumone_relayerFees(
    skip: Int = 0
    first: Int = 100
    orderBy: arbitrumone_RelayerFee_orderBy
    orderDirection: arbitrumone_OrderDirection
    where: arbitrumone_RelayerFee_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [arbitrumone_RelayerFee!]!
  arbitrumone_originTransfer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): arbitrumone_OriginTransfer
  arbitrumone_originTransfers(
    skip: Int = 0
    first: Int = 100
    orderBy: arbitrumone_OriginTransfer_orderBy
    orderDirection: arbitrumone_OrderDirection
    where: arbitrumone_OriginTransfer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [arbitrumone_OriginTransfer!]!
  arbitrumone_destinationTransfer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): arbitrumone_DestinationTransfer
  arbitrumone_destinationTransfers(
    skip: Int = 0
    first: Int = 100
    orderBy: arbitrumone_DestinationTransfer_orderBy
    orderDirection: arbitrumone_OrderDirection
    where: arbitrumone_DestinationTransfer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [arbitrumone_DestinationTransfer!]!
  arbitrumone_originMessage(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): arbitrumone_OriginMessage
  arbitrumone_originMessages(
    skip: Int = 0
    first: Int = 100
    orderBy: arbitrumone_OriginMessage_orderBy
    orderDirection: arbitrumone_OrderDirection
    where: arbitrumone_OriginMessage_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [arbitrumone_OriginMessage!]!
  arbitrumone_aggregateRoot(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): arbitrumone_AggregateRoot
  arbitrumone_aggregateRoots(
    skip: Int = 0
    first: Int = 100
    orderBy: arbitrumone_AggregateRoot_orderBy
    orderDirection: arbitrumone_OrderDirection
    where: arbitrumone_AggregateRoot_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [arbitrumone_AggregateRoot!]!
  arbitrumone_connectorMeta(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): arbitrumone_ConnectorMeta
  arbitrumone_connectorMetas(
    skip: Int = 0
    first: Int = 100
    orderBy: arbitrumone_ConnectorMeta_orderBy
    orderDirection: arbitrumone_OrderDirection
    where: arbitrumone_ConnectorMeta_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [arbitrumone_ConnectorMeta!]!
  arbitrumone_rootCount(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): arbitrumone_RootCount
  arbitrumone_rootCounts(
    skip: Int = 0
    first: Int = 100
    orderBy: arbitrumone_RootCount_orderBy
    orderDirection: arbitrumone_OrderDirection
    where: arbitrumone_RootCount_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [arbitrumone_RootCount!]!
  arbitrumone_rootMessageSent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): arbitrumone_RootMessageSent
  arbitrumone_rootMessageSents(
    skip: Int = 0
    first: Int = 100
    orderBy: arbitrumone_RootMessageSent_orderBy
    orderDirection: arbitrumone_OrderDirection
    where: arbitrumone_RootMessageSent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [arbitrumone_RootMessageSent!]!
  arbitrumone_relayerFeesIncrease(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): arbitrumone_RelayerFeesIncrease
  arbitrumone_relayerFeesIncreases(
    skip: Int = 0
    first: Int = 100
    orderBy: arbitrumone_RelayerFeesIncrease_orderBy
    orderDirection: arbitrumone_OrderDirection
    where: arbitrumone_RelayerFeesIncrease_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [arbitrumone_RelayerFeesIncrease!]!
  arbitrumone_slippageUpdate(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): arbitrumone_SlippageUpdate
  arbitrumone_slippageUpdates(
    skip: Int = 0
    first: Int = 100
    orderBy: arbitrumone_SlippageUpdate_orderBy
    orderDirection: arbitrumone_OrderDirection
    where: arbitrumone_SlippageUpdate_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [arbitrumone_SlippageUpdate!]!
  arbitrumone_snapshotRoot(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): arbitrumone_SnapshotRoot
  arbitrumone_snapshotRoots(
    skip: Int = 0
    first: Int = 100
    orderBy: arbitrumone_SnapshotRoot_orderBy
    orderDirection: arbitrumone_OrderDirection
    where: arbitrumone_SnapshotRoot_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [arbitrumone_SnapshotRoot!]!
  arbitrumone_spokeConnectorMode(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): arbitrumone_SpokeConnectorMode
  arbitrumone_spokeConnectorModes(
    skip: Int = 0
    first: Int = 100
    orderBy: arbitrumone_SpokeConnectorMode_orderBy
    orderDirection: arbitrumone_OrderDirection
    where: arbitrumone_SpokeConnectorMode_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [arbitrumone_SpokeConnectorMode!]!
  arbitrumone_aggregateRootProposed(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): arbitrumone_AggregateRootProposed
  arbitrumone_aggregateRootProposeds(
    skip: Int = 0
    first: Int = 100
    orderBy: arbitrumone_AggregateRootProposed_orderBy
    orderDirection: arbitrumone_OrderDirection
    where: arbitrumone_AggregateRootProposed_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [arbitrumone_AggregateRootProposed!]!
  arbitrumone_optimisticRootFinalized(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): arbitrumone_OptimisticRootFinalized
  arbitrumone_optimisticRootFinalizeds(
    skip: Int = 0
    first: Int = 100
    orderBy: arbitrumone_OptimisticRootFinalized_orderBy
    orderDirection: arbitrumone_OrderDirection
    where: arbitrumone_OptimisticRootFinalized_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [arbitrumone_OptimisticRootFinalized!]!
  """Access to subgraph metadata"""
  arbitrumone__meta(block: arbitrumone_Block_height): arbitrumone__Meta_
  mainnet_asset(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mainnet_Asset
  mainnet_assets(
    skip: Int = 0
    first: Int = 100
    orderBy: mainnet_Asset_orderBy
    orderDirection: mainnet_OrderDirection
    where: mainnet_Asset_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mainnet_Asset!]!
  mainnet_assetStatus(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mainnet_AssetStatus
  mainnet_assetStatuses(
    skip: Int = 0
    first: Int = 100
    orderBy: mainnet_AssetStatus_orderBy
    orderDirection: mainnet_OrderDirection
    where: mainnet_AssetStatus_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mainnet_AssetStatus!]!
  mainnet_assetBalance(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mainnet_AssetBalance
  mainnet_assetBalances(
    skip: Int = 0
    first: Int = 100
    orderBy: mainnet_AssetBalance_orderBy
    orderDirection: mainnet_OrderDirection
    where: mainnet_AssetBalance_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mainnet_AssetBalance!]!
  mainnet_router(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mainnet_Router
  mainnet_routers(
    skip: Int = 0
    first: Int = 100
    orderBy: mainnet_Router_orderBy
    orderDirection: mainnet_OrderDirection
    where: mainnet_Router_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mainnet_Router!]!
  mainnet_routerDailyTVL(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mainnet_RouterDailyTVL
  mainnet_routerDailyTVLs(
    skip: Int = 0
    first: Int = 100
    orderBy: mainnet_RouterDailyTVL_orderBy
    orderDirection: mainnet_OrderDirection
    where: mainnet_RouterDailyTVL_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mainnet_RouterDailyTVL!]!
  mainnet_routerLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mainnet_RouterLiquidityEvent
  mainnet_routerLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: mainnet_RouterLiquidityEvent_orderBy
    orderDirection: mainnet_OrderDirection
    where: mainnet_RouterLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mainnet_RouterLiquidityEvent!]!
  mainnet_setting(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mainnet_Setting
  mainnet_settings(
    skip: Int = 0
    first: Int = 100
    orderBy: mainnet_Setting_orderBy
    orderDirection: mainnet_OrderDirection
    where: mainnet_Setting_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mainnet_Setting!]!
  mainnet_relayer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mainnet_Relayer
  mainnet_relayers(
    skip: Int = 0
    first: Int = 100
    orderBy: mainnet_Relayer_orderBy
    orderDirection: mainnet_OrderDirection
    where: mainnet_Relayer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mainnet_Relayer!]!
  mainnet_sequencer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mainnet_Sequencer
  mainnet_sequencers(
    skip: Int = 0
    first: Int = 100
    orderBy: mainnet_Sequencer_orderBy
    orderDirection: mainnet_OrderDirection
    where: mainnet_Sequencer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mainnet_Sequencer!]!
  mainnet_relayerFee(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mainnet_RelayerFee
  mainnet_relayerFees(
    skip: Int = 0
    first: Int = 100
    orderBy: mainnet_RelayerFee_orderBy
    orderDirection: mainnet_OrderDirection
    where: mainnet_RelayerFee_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mainnet_RelayerFee!]!
  mainnet_originTransfer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mainnet_OriginTransfer
  mainnet_originTransfers(
    skip: Int = 0
    first: Int = 100
    orderBy: mainnet_OriginTransfer_orderBy
    orderDirection: mainnet_OrderDirection
    where: mainnet_OriginTransfer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mainnet_OriginTransfer!]!
  mainnet_destinationTransfer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mainnet_DestinationTransfer
  mainnet_destinationTransfers(
    skip: Int = 0
    first: Int = 100
    orderBy: mainnet_DestinationTransfer_orderBy
    orderDirection: mainnet_OrderDirection
    where: mainnet_DestinationTransfer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mainnet_DestinationTransfer!]!
  mainnet_originMessage(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mainnet_OriginMessage
  mainnet_originMessages(
    skip: Int = 0
    first: Int = 100
    orderBy: mainnet_OriginMessage_orderBy
    orderDirection: mainnet_OrderDirection
    where: mainnet_OriginMessage_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mainnet_OriginMessage!]!
  mainnet_aggregateRoot(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mainnet_AggregateRoot
  mainnet_aggregateRoots(
    skip: Int = 0
    first: Int = 100
    orderBy: mainnet_AggregateRoot_orderBy
    orderDirection: mainnet_OrderDirection
    where: mainnet_AggregateRoot_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mainnet_AggregateRoot!]!
  mainnet_connectorMeta(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mainnet_ConnectorMeta
  mainnet_connectorMetas(
    skip: Int = 0
    first: Int = 100
    orderBy: mainnet_ConnectorMeta_orderBy
    orderDirection: mainnet_OrderDirection
    where: mainnet_ConnectorMeta_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mainnet_ConnectorMeta!]!
  mainnet_rootCount(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mainnet_RootCount
  mainnet_rootCounts(
    skip: Int = 0
    first: Int = 100
    orderBy: mainnet_RootCount_orderBy
    orderDirection: mainnet_OrderDirection
    where: mainnet_RootCount_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mainnet_RootCount!]!
  mainnet_rootMessageSent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mainnet_RootMessageSent
  mainnet_rootMessageSents(
    skip: Int = 0
    first: Int = 100
    orderBy: mainnet_RootMessageSent_orderBy
    orderDirection: mainnet_OrderDirection
    where: mainnet_RootMessageSent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mainnet_RootMessageSent!]!
  mainnet_relayerFeesIncrease(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mainnet_RelayerFeesIncrease
  mainnet_relayerFeesIncreases(
    skip: Int = 0
    first: Int = 100
    orderBy: mainnet_RelayerFeesIncrease_orderBy
    orderDirection: mainnet_OrderDirection
    where: mainnet_RelayerFeesIncrease_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mainnet_RelayerFeesIncrease!]!
  mainnet_slippageUpdate(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mainnet_SlippageUpdate
  mainnet_slippageUpdates(
    skip: Int = 0
    first: Int = 100
    orderBy: mainnet_SlippageUpdate_orderBy
    orderDirection: mainnet_OrderDirection
    where: mainnet_SlippageUpdate_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mainnet_SlippageUpdate!]!
  mainnet_snapshotRoot(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mainnet_SnapshotRoot
  mainnet_snapshotRoots(
    skip: Int = 0
    first: Int = 100
    orderBy: mainnet_SnapshotRoot_orderBy
    orderDirection: mainnet_OrderDirection
    where: mainnet_SnapshotRoot_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mainnet_SnapshotRoot!]!
  mainnet_spokeConnectorMode(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mainnet_SpokeConnectorMode
  mainnet_spokeConnectorModes(
    skip: Int = 0
    first: Int = 100
    orderBy: mainnet_SpokeConnectorMode_orderBy
    orderDirection: mainnet_OrderDirection
    where: mainnet_SpokeConnectorMode_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mainnet_SpokeConnectorMode!]!
  mainnet_aggregateRootProposed(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mainnet_AggregateRootProposed
  mainnet_aggregateRootProposeds(
    skip: Int = 0
    first: Int = 100
    orderBy: mainnet_AggregateRootProposed_orderBy
    orderDirection: mainnet_OrderDirection
    where: mainnet_AggregateRootProposed_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mainnet_AggregateRootProposed!]!
  mainnet_optimisticRootFinalized(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mainnet_OptimisticRootFinalized
  mainnet_optimisticRootFinalizeds(
    skip: Int = 0
    first: Int = 100
    orderBy: mainnet_OptimisticRootFinalized_orderBy
    orderDirection: mainnet_OrderDirection
    where: mainnet_OptimisticRootFinalized_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mainnet_OptimisticRootFinalized!]!
  base_asset(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: base_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): base_Asset
  base_assets(
    skip: Int = 0
    first: Int = 100
    orderBy: base_Asset_orderBy
    orderDirection: base_OrderDirection
    where: base_Asset_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: base_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [base_Asset!]!
  base_assetStatus(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: base_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): base_AssetStatus
  base_assetStatuses(
    skip: Int = 0
    first: Int = 100
    orderBy: base_AssetStatus_orderBy
    orderDirection: base_OrderDirection
    where: base_AssetStatus_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: base_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [base_AssetStatus!]!
  base_assetBalance(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: base_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): base_AssetBalance
  base_assetBalances(
    skip: Int = 0
    first: Int = 100
    orderBy: base_AssetBalance_orderBy
    orderDirection: base_OrderDirection
    where: base_AssetBalance_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: base_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [base_AssetBalance!]!
  base_router(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: base_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): base_Router
  base_routers(
    skip: Int = 0
    first: Int = 100
    orderBy: base_Router_orderBy
    orderDirection: base_OrderDirection
    where: base_Router_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: base_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [base_Router!]!
  base_routerDailyTVL(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: base_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): base_RouterDailyTVL
  base_routerDailyTVLs(
    skip: Int = 0
    first: Int = 100
    orderBy: base_RouterDailyTVL_orderBy
    orderDirection: base_OrderDirection
    where: base_RouterDailyTVL_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: base_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [base_RouterDailyTVL!]!
  base_routerLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: base_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): base_RouterLiquidityEvent
  base_routerLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: base_RouterLiquidityEvent_orderBy
    orderDirection: base_OrderDirection
    where: base_RouterLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: base_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [base_RouterLiquidityEvent!]!
  base_setting(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: base_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): base_Setting
  base_settings(
    skip: Int = 0
    first: Int = 100
    orderBy: base_Setting_orderBy
    orderDirection: base_OrderDirection
    where: base_Setting_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: base_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [base_Setting!]!
  base_relayer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: base_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): base_Relayer
  base_relayers(
    skip: Int = 0
    first: Int = 100
    orderBy: base_Relayer_orderBy
    orderDirection: base_OrderDirection
    where: base_Relayer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: base_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [base_Relayer!]!
  base_sequencer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: base_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): base_Sequencer
  base_sequencers(
    skip: Int = 0
    first: Int = 100
    orderBy: base_Sequencer_orderBy
    orderDirection: base_OrderDirection
    where: base_Sequencer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: base_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [base_Sequencer!]!
  base_relayerFee(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: base_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): base_RelayerFee
  base_relayerFees(
    skip: Int = 0
    first: Int = 100
    orderBy: base_RelayerFee_orderBy
    orderDirection: base_OrderDirection
    where: base_RelayerFee_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: base_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [base_RelayerFee!]!
  base_originTransfer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: base_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): base_OriginTransfer
  base_originTransfers(
    skip: Int = 0
    first: Int = 100
    orderBy: base_OriginTransfer_orderBy
    orderDirection: base_OrderDirection
    where: base_OriginTransfer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: base_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [base_OriginTransfer!]!
  base_destinationTransfer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: base_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): base_DestinationTransfer
  base_destinationTransfers(
    skip: Int = 0
    first: Int = 100
    orderBy: base_DestinationTransfer_orderBy
    orderDirection: base_OrderDirection
    where: base_DestinationTransfer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: base_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [base_DestinationTransfer!]!
  base_originMessage(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: base_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): base_OriginMessage
  base_originMessages(
    skip: Int = 0
    first: Int = 100
    orderBy: base_OriginMessage_orderBy
    orderDirection: base_OrderDirection
    where: base_OriginMessage_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: base_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [base_OriginMessage!]!
  base_aggregateRoot(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: base_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): base_AggregateRoot
  base_aggregateRoots(
    skip: Int = 0
    first: Int = 100
    orderBy: base_AggregateRoot_orderBy
    orderDirection: base_OrderDirection
    where: base_AggregateRoot_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: base_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [base_AggregateRoot!]!
  base_connectorMeta(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: base_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): base_ConnectorMeta
  base_connectorMetas(
    skip: Int = 0
    first: Int = 100
    orderBy: base_ConnectorMeta_orderBy
    orderDirection: base_OrderDirection
    where: base_ConnectorMeta_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: base_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [base_ConnectorMeta!]!
  base_rootCount(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: base_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): base_RootCount
  base_rootCounts(
    skip: Int = 0
    first: Int = 100
    orderBy: base_RootCount_orderBy
    orderDirection: base_OrderDirection
    where: base_RootCount_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: base_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [base_RootCount!]!
  base_rootMessageSent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: base_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): base_RootMessageSent
  base_rootMessageSents(
    skip: Int = 0
    first: Int = 100
    orderBy: base_RootMessageSent_orderBy
    orderDirection: base_OrderDirection
    where: base_RootMessageSent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: base_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [base_RootMessageSent!]!
  base_relayerFeesIncrease(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: base_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): base_RelayerFeesIncrease
  base_relayerFeesIncreases(
    skip: Int = 0
    first: Int = 100
    orderBy: base_RelayerFeesIncrease_orderBy
    orderDirection: base_OrderDirection
    where: base_RelayerFeesIncrease_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: base_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [base_RelayerFeesIncrease!]!
  base_slippageUpdate(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: base_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): base_SlippageUpdate
  base_slippageUpdates(
    skip: Int = 0
    first: Int = 100
    orderBy: base_SlippageUpdate_orderBy
    orderDirection: base_OrderDirection
    where: base_SlippageUpdate_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: base_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [base_SlippageUpdate!]!
  base_snapshotRoot(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: base_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): base_SnapshotRoot
  base_snapshotRoots(
    skip: Int = 0
    first: Int = 100
    orderBy: base_SnapshotRoot_orderBy
    orderDirection: base_OrderDirection
    where: base_SnapshotRoot_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: base_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [base_SnapshotRoot!]!
  base_spokeConnectorMode(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: base_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): base_SpokeConnectorMode
  base_spokeConnectorModes(
    skip: Int = 0
    first: Int = 100
    orderBy: base_SpokeConnectorMode_orderBy
    orderDirection: base_OrderDirection
    where: base_SpokeConnectorMode_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: base_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [base_SpokeConnectorMode!]!
  base_aggregateRootProposed(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: base_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): base_AggregateRootProposed
  base_aggregateRootProposeds(
    skip: Int = 0
    first: Int = 100
    orderBy: base_AggregateRootProposed_orderBy
    orderDirection: base_OrderDirection
    where: base_AggregateRootProposed_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: base_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [base_AggregateRootProposed!]!
  base_optimisticRootFinalized(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: base_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): base_OptimisticRootFinalized
  base_optimisticRootFinalizeds(
    skip: Int = 0
    first: Int = 100
    orderBy: base_OptimisticRootFinalized_orderBy
    orderDirection: base_OrderDirection
    where: base_OptimisticRootFinalized_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: base_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [base_OptimisticRootFinalized!]!
  """Access to subgraph metadata"""
  base__meta(block: base_Block_height): base__Meta_
  xdai_asset(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xdai_Asset
  xdai_assets(
    skip: Int = 0
    first: Int = 100
    orderBy: xdai_Asset_orderBy
    orderDirection: xdai_OrderDirection
    where: xdai_Asset_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xdai_Asset!]!
  xdai_assetStatus(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xdai_AssetStatus
  xdai_assetStatuses(
    skip: Int = 0
    first: Int = 100
    orderBy: xdai_AssetStatus_orderBy
    orderDirection: xdai_OrderDirection
    where: xdai_AssetStatus_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xdai_AssetStatus!]!
  xdai_assetBalance(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xdai_AssetBalance
  xdai_assetBalances(
    skip: Int = 0
    first: Int = 100
    orderBy: xdai_AssetBalance_orderBy
    orderDirection: xdai_OrderDirection
    where: xdai_AssetBalance_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xdai_AssetBalance!]!
  xdai_router(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xdai_Router
  xdai_routers(
    skip: Int = 0
    first: Int = 100
    orderBy: xdai_Router_orderBy
    orderDirection: xdai_OrderDirection
    where: xdai_Router_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xdai_Router!]!
  xdai_routerDailyTVL(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xdai_RouterDailyTVL
  xdai_routerDailyTVLs(
    skip: Int = 0
    first: Int = 100
    orderBy: xdai_RouterDailyTVL_orderBy
    orderDirection: xdai_OrderDirection
    where: xdai_RouterDailyTVL_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xdai_RouterDailyTVL!]!
  xdai_routerLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xdai_RouterLiquidityEvent
  xdai_routerLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: xdai_RouterLiquidityEvent_orderBy
    orderDirection: xdai_OrderDirection
    where: xdai_RouterLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xdai_RouterLiquidityEvent!]!
  xdai_setting(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xdai_Setting
  xdai_settings(
    skip: Int = 0
    first: Int = 100
    orderBy: xdai_Setting_orderBy
    orderDirection: xdai_OrderDirection
    where: xdai_Setting_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xdai_Setting!]!
  xdai_relayer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xdai_Relayer
  xdai_relayers(
    skip: Int = 0
    first: Int = 100
    orderBy: xdai_Relayer_orderBy
    orderDirection: xdai_OrderDirection
    where: xdai_Relayer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xdai_Relayer!]!
  xdai_sequencer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xdai_Sequencer
  xdai_sequencers(
    skip: Int = 0
    first: Int = 100
    orderBy: xdai_Sequencer_orderBy
    orderDirection: xdai_OrderDirection
    where: xdai_Sequencer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xdai_Sequencer!]!
  xdai_relayerFee(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xdai_RelayerFee
  xdai_relayerFees(
    skip: Int = 0
    first: Int = 100
    orderBy: xdai_RelayerFee_orderBy
    orderDirection: xdai_OrderDirection
    where: xdai_RelayerFee_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xdai_RelayerFee!]!
  xdai_originTransfer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xdai_OriginTransfer
  xdai_originTransfers(
    skip: Int = 0
    first: Int = 100
    orderBy: xdai_OriginTransfer_orderBy
    orderDirection: xdai_OrderDirection
    where: xdai_OriginTransfer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xdai_OriginTransfer!]!
  xdai_destinationTransfer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xdai_DestinationTransfer
  xdai_destinationTransfers(
    skip: Int = 0
    first: Int = 100
    orderBy: xdai_DestinationTransfer_orderBy
    orderDirection: xdai_OrderDirection
    where: xdai_DestinationTransfer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xdai_DestinationTransfer!]!
  xdai_originMessage(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xdai_OriginMessage
  xdai_originMessages(
    skip: Int = 0
    first: Int = 100
    orderBy: xdai_OriginMessage_orderBy
    orderDirection: xdai_OrderDirection
    where: xdai_OriginMessage_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xdai_OriginMessage!]!
  xdai_aggregateRoot(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xdai_AggregateRoot
  xdai_aggregateRoots(
    skip: Int = 0
    first: Int = 100
    orderBy: xdai_AggregateRoot_orderBy
    orderDirection: xdai_OrderDirection
    where: xdai_AggregateRoot_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xdai_AggregateRoot!]!
  xdai_connectorMeta(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xdai_ConnectorMeta
  xdai_connectorMetas(
    skip: Int = 0
    first: Int = 100
    orderBy: xdai_ConnectorMeta_orderBy
    orderDirection: xdai_OrderDirection
    where: xdai_ConnectorMeta_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xdai_ConnectorMeta!]!
  xdai_rootCount(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xdai_RootCount
  xdai_rootCounts(
    skip: Int = 0
    first: Int = 100
    orderBy: xdai_RootCount_orderBy
    orderDirection: xdai_OrderDirection
    where: xdai_RootCount_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xdai_RootCount!]!
  xdai_rootMessageSent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xdai_RootMessageSent
  xdai_rootMessageSents(
    skip: Int = 0
    first: Int = 100
    orderBy: xdai_RootMessageSent_orderBy
    orderDirection: xdai_OrderDirection
    where: xdai_RootMessageSent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xdai_RootMessageSent!]!
  xdai_relayerFeesIncrease(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xdai_RelayerFeesIncrease
  xdai_relayerFeesIncreases(
    skip: Int = 0
    first: Int = 100
    orderBy: xdai_RelayerFeesIncrease_orderBy
    orderDirection: xdai_OrderDirection
    where: xdai_RelayerFeesIncrease_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xdai_RelayerFeesIncrease!]!
  xdai_slippageUpdate(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xdai_SlippageUpdate
  xdai_slippageUpdates(
    skip: Int = 0
    first: Int = 100
    orderBy: xdai_SlippageUpdate_orderBy
    orderDirection: xdai_OrderDirection
    where: xdai_SlippageUpdate_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xdai_SlippageUpdate!]!
  xdai_snapshotRoot(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xdai_SnapshotRoot
  xdai_snapshotRoots(
    skip: Int = 0
    first: Int = 100
    orderBy: xdai_SnapshotRoot_orderBy
    orderDirection: xdai_OrderDirection
    where: xdai_SnapshotRoot_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xdai_SnapshotRoot!]!
  xdai_spokeConnectorMode(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xdai_SpokeConnectorMode
  xdai_spokeConnectorModes(
    skip: Int = 0
    first: Int = 100
    orderBy: xdai_SpokeConnectorMode_orderBy
    orderDirection: xdai_OrderDirection
    where: xdai_SpokeConnectorMode_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xdai_SpokeConnectorMode!]!
  xdai_aggregateRootProposed(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xdai_AggregateRootProposed
  xdai_aggregateRootProposeds(
    skip: Int = 0
    first: Int = 100
    orderBy: xdai_AggregateRootProposed_orderBy
    orderDirection: xdai_OrderDirection
    where: xdai_AggregateRootProposed_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xdai_AggregateRootProposed!]!
  xdai_optimisticRootFinalized(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xdai_OptimisticRootFinalized
  xdai_optimisticRootFinalizeds(
    skip: Int = 0
    first: Int = 100
    orderBy: xdai_OptimisticRootFinalized_orderBy
    orderDirection: xdai_OrderDirection
    where: xdai_OptimisticRootFinalized_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xdai_OptimisticRootFinalized!]!
  """Access to subgraph metadata"""
  xdai__meta(block: xdai_Block_height): xdai__Meta_
  avalanche_swap_systemInfo(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): avalanche_swap_SystemInfo
  avalanche_swap_systemInfos(
    skip: Int = 0
    first: Int = 100
    orderBy: avalanche_swap_SystemInfo_orderBy
    orderDirection: avalanche_swap_OrderDirection
    where: avalanche_swap_SystemInfo_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [avalanche_swap_SystemInfo!]!
  avalanche_swap_pooledToken(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): avalanche_swap_PooledToken
  avalanche_swap_pooledTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: avalanche_swap_PooledToken_orderBy
    orderDirection: avalanche_swap_OrderDirection
    where: avalanche_swap_PooledToken_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [avalanche_swap_PooledToken!]!
  avalanche_swap_stableSwap(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): avalanche_swap_StableSwap
  avalanche_swap_stableSwaps(
    skip: Int = 0
    first: Int = 100
    orderBy: avalanche_swap_StableSwap_orderBy
    orderDirection: avalanche_swap_OrderDirection
    where: avalanche_swap_StableSwap_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [avalanche_swap_StableSwap!]!
  avalanche_swap_stableSwapAddLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): avalanche_swap_StableSwapAddLiquidityEvent
  avalanche_swap_stableSwapAddLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: avalanche_swap_StableSwapAddLiquidityEvent_orderBy
    orderDirection: avalanche_swap_OrderDirection
    where: avalanche_swap_StableSwapAddLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [avalanche_swap_StableSwapAddLiquidityEvent!]!
  avalanche_swap_stableSwapRemoveLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): avalanche_swap_StableSwapRemoveLiquidityEvent
  avalanche_swap_stableSwapRemoveLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: avalanche_swap_StableSwapRemoveLiquidityEvent_orderBy
    orderDirection: avalanche_swap_OrderDirection
    where: avalanche_swap_StableSwapRemoveLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [avalanche_swap_StableSwapRemoveLiquidityEvent!]!
  avalanche_swap_stableSwapExchange(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): avalanche_swap_StableSwapExchange
  avalanche_swap_stableSwapExchanges(
    skip: Int = 0
    first: Int = 100
    orderBy: avalanche_swap_StableSwapExchange_orderBy
    orderDirection: avalanche_swap_OrderDirection
    where: avalanche_swap_StableSwapExchange_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [avalanche_swap_StableSwapExchange!]!
  avalanche_swap_swapDailyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): avalanche_swap_SwapDailyVolume
  avalanche_swap_swapDailyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: avalanche_swap_SwapDailyVolume_orderBy
    orderDirection: avalanche_swap_OrderDirection
    where: avalanche_swap_SwapDailyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [avalanche_swap_SwapDailyVolume!]!
  avalanche_swap_swapHourlyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): avalanche_swap_SwapHourlyVolume
  avalanche_swap_swapHourlyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: avalanche_swap_SwapHourlyVolume_orderBy
    orderDirection: avalanche_swap_OrderDirection
    where: avalanche_swap_SwapHourlyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [avalanche_swap_SwapHourlyVolume!]!
  avalanche_swap_swapWeeklyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): avalanche_swap_SwapWeeklyVolume
  avalanche_swap_swapWeeklyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: avalanche_swap_SwapWeeklyVolume_orderBy
    orderDirection: avalanche_swap_OrderDirection
    where: avalanche_swap_SwapWeeklyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [avalanche_swap_SwapWeeklyVolume!]!
  avalanche_swap_lpAccount(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): avalanche_swap_LpAccount
  avalanche_swap_lpAccounts(
    skip: Int = 0
    first: Int = 100
    orderBy: avalanche_swap_LpAccount_orderBy
    orderDirection: avalanche_swap_OrderDirection
    where: avalanche_swap_LpAccount_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [avalanche_swap_LpAccount!]!
  avalanche_swap_lpAccountBalance(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): avalanche_swap_LpAccountBalance
  avalanche_swap_lpAccountBalances(
    skip: Int = 0
    first: Int = 100
    orderBy: avalanche_swap_LpAccountBalance_orderBy
    orderDirection: avalanche_swap_OrderDirection
    where: avalanche_swap_LpAccountBalance_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [avalanche_swap_LpAccountBalance!]!
  avalanche_swap_lpToken(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): avalanche_swap_LpToken
  avalanche_swap_lpTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: avalanche_swap_LpToken_orderBy
    orderDirection: avalanche_swap_OrderDirection
    where: avalanche_swap_LpToken_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [avalanche_swap_LpToken!]!
  avalanche_swap_lpTransferEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): avalanche_swap_LpTransferEvent
  avalanche_swap_lpTransferEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: avalanche_swap_LpTransferEvent_orderBy
    orderDirection: avalanche_swap_OrderDirection
    where: avalanche_swap_LpTransferEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [avalanche_swap_LpTransferEvent!]!
  avalanche_swap_stableSwapEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): avalanche_swap_StableSwapEvent
  avalanche_swap_stableSwapEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: avalanche_swap_StableSwapEvent_orderBy
    orderDirection: avalanche_swap_OrderDirection
    where: avalanche_swap_StableSwapEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [avalanche_swap_StableSwapEvent!]!
  avalanche_swap_swapTradeVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): avalanche_swap_SwapTradeVolume
  avalanche_swap_swapTradeVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: avalanche_swap_SwapTradeVolume_orderBy
    orderDirection: avalanche_swap_OrderDirection
    where: avalanche_swap_SwapTradeVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [avalanche_swap_SwapTradeVolume!]!
  avalanche_swap_lpTokenEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): avalanche_swap_LpTokenEvent
  avalanche_swap_lpTokenEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: avalanche_swap_LpTokenEvent_orderBy
    orderDirection: avalanche_swap_OrderDirection
    where: avalanche_swap_LpTokenEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [avalanche_swap_LpTokenEvent!]!
  """Access to subgraph metadata"""
  avalanche_swap__meta(block: avalanche_swap_Block_height): avalanche_swap__Meta_
  polygon_swap_systemInfo(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygon_swap_SystemInfo
  polygon_swap_systemInfos(
    skip: Int = 0
    first: Int = 100
    orderBy: polygon_swap_SystemInfo_orderBy
    orderDirection: polygon_swap_OrderDirection
    where: polygon_swap_SystemInfo_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygon_swap_SystemInfo!]!
  polygon_swap_pooledToken(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygon_swap_PooledToken
  polygon_swap_pooledTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: polygon_swap_PooledToken_orderBy
    orderDirection: polygon_swap_OrderDirection
    where: polygon_swap_PooledToken_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygon_swap_PooledToken!]!
  polygon_swap_stableSwap(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygon_swap_StableSwap
  polygon_swap_stableSwaps(
    skip: Int = 0
    first: Int = 100
    orderBy: polygon_swap_StableSwap_orderBy
    orderDirection: polygon_swap_OrderDirection
    where: polygon_swap_StableSwap_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygon_swap_StableSwap!]!
  polygon_swap_stableSwapAddLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygon_swap_StableSwapAddLiquidityEvent
  polygon_swap_stableSwapAddLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: polygon_swap_StableSwapAddLiquidityEvent_orderBy
    orderDirection: polygon_swap_OrderDirection
    where: polygon_swap_StableSwapAddLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygon_swap_StableSwapAddLiquidityEvent!]!
  polygon_swap_stableSwapRemoveLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygon_swap_StableSwapRemoveLiquidityEvent
  polygon_swap_stableSwapRemoveLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: polygon_swap_StableSwapRemoveLiquidityEvent_orderBy
    orderDirection: polygon_swap_OrderDirection
    where: polygon_swap_StableSwapRemoveLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygon_swap_StableSwapRemoveLiquidityEvent!]!
  polygon_swap_stableSwapExchange(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygon_swap_StableSwapExchange
  polygon_swap_stableSwapExchanges(
    skip: Int = 0
    first: Int = 100
    orderBy: polygon_swap_StableSwapExchange_orderBy
    orderDirection: polygon_swap_OrderDirection
    where: polygon_swap_StableSwapExchange_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygon_swap_StableSwapExchange!]!
  polygon_swap_swapDailyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygon_swap_SwapDailyVolume
  polygon_swap_swapDailyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: polygon_swap_SwapDailyVolume_orderBy
    orderDirection: polygon_swap_OrderDirection
    where: polygon_swap_SwapDailyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygon_swap_SwapDailyVolume!]!
  polygon_swap_swapHourlyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygon_swap_SwapHourlyVolume
  polygon_swap_swapHourlyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: polygon_swap_SwapHourlyVolume_orderBy
    orderDirection: polygon_swap_OrderDirection
    where: polygon_swap_SwapHourlyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygon_swap_SwapHourlyVolume!]!
  polygon_swap_swapWeeklyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygon_swap_SwapWeeklyVolume
  polygon_swap_swapWeeklyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: polygon_swap_SwapWeeklyVolume_orderBy
    orderDirection: polygon_swap_OrderDirection
    where: polygon_swap_SwapWeeklyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygon_swap_SwapWeeklyVolume!]!
  polygon_swap_lpAccount(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygon_swap_LpAccount
  polygon_swap_lpAccounts(
    skip: Int = 0
    first: Int = 100
    orderBy: polygon_swap_LpAccount_orderBy
    orderDirection: polygon_swap_OrderDirection
    where: polygon_swap_LpAccount_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygon_swap_LpAccount!]!
  polygon_swap_lpAccountBalance(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygon_swap_LpAccountBalance
  polygon_swap_lpAccountBalances(
    skip: Int = 0
    first: Int = 100
    orderBy: polygon_swap_LpAccountBalance_orderBy
    orderDirection: polygon_swap_OrderDirection
    where: polygon_swap_LpAccountBalance_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygon_swap_LpAccountBalance!]!
  polygon_swap_lpToken(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygon_swap_LpToken
  polygon_swap_lpTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: polygon_swap_LpToken_orderBy
    orderDirection: polygon_swap_OrderDirection
    where: polygon_swap_LpToken_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygon_swap_LpToken!]!
  polygon_swap_lpTransferEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygon_swap_LpTransferEvent
  polygon_swap_lpTransferEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: polygon_swap_LpTransferEvent_orderBy
    orderDirection: polygon_swap_OrderDirection
    where: polygon_swap_LpTransferEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygon_swap_LpTransferEvent!]!
  polygon_swap_stableSwapEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygon_swap_StableSwapEvent
  polygon_swap_stableSwapEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: polygon_swap_StableSwapEvent_orderBy
    orderDirection: polygon_swap_OrderDirection
    where: polygon_swap_StableSwapEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygon_swap_StableSwapEvent!]!
  polygon_swap_swapTradeVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygon_swap_SwapTradeVolume
  polygon_swap_swapTradeVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: polygon_swap_SwapTradeVolume_orderBy
    orderDirection: polygon_swap_OrderDirection
    where: polygon_swap_SwapTradeVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygon_swap_SwapTradeVolume!]!
  polygon_swap_lpTokenEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygon_swap_LpTokenEvent
  polygon_swap_lpTokenEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: polygon_swap_LpTokenEvent_orderBy
    orderDirection: polygon_swap_OrderDirection
    where: polygon_swap_LpTokenEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygon_swap_LpTokenEvent!]!
  """Access to subgraph metadata"""
  polygon_swap__meta(block: polygon_swap_Block_height): polygon_swap__Meta_
  optimism_swap_systemInfo(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): optimism_swap_SystemInfo
  optimism_swap_systemInfos(
    skip: Int = 0
    first: Int = 100
    orderBy: optimism_swap_SystemInfo_orderBy
    orderDirection: optimism_swap_OrderDirection
    where: optimism_swap_SystemInfo_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [optimism_swap_SystemInfo!]!
  optimism_swap_pooledToken(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): optimism_swap_PooledToken
  optimism_swap_pooledTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: optimism_swap_PooledToken_orderBy
    orderDirection: optimism_swap_OrderDirection
    where: optimism_swap_PooledToken_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [optimism_swap_PooledToken!]!
  optimism_swap_stableSwap(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): optimism_swap_StableSwap
  optimism_swap_stableSwaps(
    skip: Int = 0
    first: Int = 100
    orderBy: optimism_swap_StableSwap_orderBy
    orderDirection: optimism_swap_OrderDirection
    where: optimism_swap_StableSwap_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [optimism_swap_StableSwap!]!
  optimism_swap_stableSwapAddLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): optimism_swap_StableSwapAddLiquidityEvent
  optimism_swap_stableSwapAddLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: optimism_swap_StableSwapAddLiquidityEvent_orderBy
    orderDirection: optimism_swap_OrderDirection
    where: optimism_swap_StableSwapAddLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [optimism_swap_StableSwapAddLiquidityEvent!]!
  optimism_swap_stableSwapRemoveLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): optimism_swap_StableSwapRemoveLiquidityEvent
  optimism_swap_stableSwapRemoveLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: optimism_swap_StableSwapRemoveLiquidityEvent_orderBy
    orderDirection: optimism_swap_OrderDirection
    where: optimism_swap_StableSwapRemoveLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [optimism_swap_StableSwapRemoveLiquidityEvent!]!
  optimism_swap_stableSwapExchange(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): optimism_swap_StableSwapExchange
  optimism_swap_stableSwapExchanges(
    skip: Int = 0
    first: Int = 100
    orderBy: optimism_swap_StableSwapExchange_orderBy
    orderDirection: optimism_swap_OrderDirection
    where: optimism_swap_StableSwapExchange_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [optimism_swap_StableSwapExchange!]!
  optimism_swap_swapDailyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): optimism_swap_SwapDailyVolume
  optimism_swap_swapDailyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: optimism_swap_SwapDailyVolume_orderBy
    orderDirection: optimism_swap_OrderDirection
    where: optimism_swap_SwapDailyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [optimism_swap_SwapDailyVolume!]!
  optimism_swap_swapHourlyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): optimism_swap_SwapHourlyVolume
  optimism_swap_swapHourlyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: optimism_swap_SwapHourlyVolume_orderBy
    orderDirection: optimism_swap_OrderDirection
    where: optimism_swap_SwapHourlyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [optimism_swap_SwapHourlyVolume!]!
  optimism_swap_swapWeeklyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): optimism_swap_SwapWeeklyVolume
  optimism_swap_swapWeeklyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: optimism_swap_SwapWeeklyVolume_orderBy
    orderDirection: optimism_swap_OrderDirection
    where: optimism_swap_SwapWeeklyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [optimism_swap_SwapWeeklyVolume!]!
  optimism_swap_lpAccount(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): optimism_swap_LpAccount
  optimism_swap_lpAccounts(
    skip: Int = 0
    first: Int = 100
    orderBy: optimism_swap_LpAccount_orderBy
    orderDirection: optimism_swap_OrderDirection
    where: optimism_swap_LpAccount_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [optimism_swap_LpAccount!]!
  optimism_swap_lpAccountBalance(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): optimism_swap_LpAccountBalance
  optimism_swap_lpAccountBalances(
    skip: Int = 0
    first: Int = 100
    orderBy: optimism_swap_LpAccountBalance_orderBy
    orderDirection: optimism_swap_OrderDirection
    where: optimism_swap_LpAccountBalance_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [optimism_swap_LpAccountBalance!]!
  optimism_swap_lpToken(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): optimism_swap_LpToken
  optimism_swap_lpTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: optimism_swap_LpToken_orderBy
    orderDirection: optimism_swap_OrderDirection
    where: optimism_swap_LpToken_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [optimism_swap_LpToken!]!
  optimism_swap_lpTransferEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): optimism_swap_LpTransferEvent
  optimism_swap_lpTransferEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: optimism_swap_LpTransferEvent_orderBy
    orderDirection: optimism_swap_OrderDirection
    where: optimism_swap_LpTransferEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [optimism_swap_LpTransferEvent!]!
  optimism_swap_stableSwapEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): optimism_swap_StableSwapEvent
  optimism_swap_stableSwapEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: optimism_swap_StableSwapEvent_orderBy
    orderDirection: optimism_swap_OrderDirection
    where: optimism_swap_StableSwapEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [optimism_swap_StableSwapEvent!]!
  optimism_swap_swapTradeVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): optimism_swap_SwapTradeVolume
  optimism_swap_swapTradeVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: optimism_swap_SwapTradeVolume_orderBy
    orderDirection: optimism_swap_OrderDirection
    where: optimism_swap_SwapTradeVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [optimism_swap_SwapTradeVolume!]!
  optimism_swap_lpTokenEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): optimism_swap_LpTokenEvent
  optimism_swap_lpTokenEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: optimism_swap_LpTokenEvent_orderBy
    orderDirection: optimism_swap_OrderDirection
    where: optimism_swap_LpTokenEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [optimism_swap_LpTokenEvent!]!
  """Access to subgraph metadata"""
  optimism_swap__meta(block: optimism_swap_Block_height): optimism_swap__Meta_
  xdai_swap_systemInfo(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xdai_swap_SystemInfo
  xdai_swap_systemInfos(
    skip: Int = 0
    first: Int = 100
    orderBy: xdai_swap_SystemInfo_orderBy
    orderDirection: xdai_swap_OrderDirection
    where: xdai_swap_SystemInfo_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xdai_swap_SystemInfo!]!
  xdai_swap_pooledToken(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xdai_swap_PooledToken
  xdai_swap_pooledTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: xdai_swap_PooledToken_orderBy
    orderDirection: xdai_swap_OrderDirection
    where: xdai_swap_PooledToken_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xdai_swap_PooledToken!]!
  xdai_swap_stableSwap(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xdai_swap_StableSwap
  xdai_swap_stableSwaps(
    skip: Int = 0
    first: Int = 100
    orderBy: xdai_swap_StableSwap_orderBy
    orderDirection: xdai_swap_OrderDirection
    where: xdai_swap_StableSwap_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xdai_swap_StableSwap!]!
  xdai_swap_stableSwapAddLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xdai_swap_StableSwapAddLiquidityEvent
  xdai_swap_stableSwapAddLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: xdai_swap_StableSwapAddLiquidityEvent_orderBy
    orderDirection: xdai_swap_OrderDirection
    where: xdai_swap_StableSwapAddLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xdai_swap_StableSwapAddLiquidityEvent!]!
  xdai_swap_stableSwapRemoveLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xdai_swap_StableSwapRemoveLiquidityEvent
  xdai_swap_stableSwapRemoveLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: xdai_swap_StableSwapRemoveLiquidityEvent_orderBy
    orderDirection: xdai_swap_OrderDirection
    where: xdai_swap_StableSwapRemoveLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xdai_swap_StableSwapRemoveLiquidityEvent!]!
  xdai_swap_stableSwapExchange(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xdai_swap_StableSwapExchange
  xdai_swap_stableSwapExchanges(
    skip: Int = 0
    first: Int = 100
    orderBy: xdai_swap_StableSwapExchange_orderBy
    orderDirection: xdai_swap_OrderDirection
    where: xdai_swap_StableSwapExchange_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xdai_swap_StableSwapExchange!]!
  xdai_swap_swapDailyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xdai_swap_SwapDailyVolume
  xdai_swap_swapDailyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: xdai_swap_SwapDailyVolume_orderBy
    orderDirection: xdai_swap_OrderDirection
    where: xdai_swap_SwapDailyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xdai_swap_SwapDailyVolume!]!
  xdai_swap_swapHourlyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xdai_swap_SwapHourlyVolume
  xdai_swap_swapHourlyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: xdai_swap_SwapHourlyVolume_orderBy
    orderDirection: xdai_swap_OrderDirection
    where: xdai_swap_SwapHourlyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xdai_swap_SwapHourlyVolume!]!
  xdai_swap_swapWeeklyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xdai_swap_SwapWeeklyVolume
  xdai_swap_swapWeeklyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: xdai_swap_SwapWeeklyVolume_orderBy
    orderDirection: xdai_swap_OrderDirection
    where: xdai_swap_SwapWeeklyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xdai_swap_SwapWeeklyVolume!]!
  xdai_swap_lpAccount(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xdai_swap_LpAccount
  xdai_swap_lpAccounts(
    skip: Int = 0
    first: Int = 100
    orderBy: xdai_swap_LpAccount_orderBy
    orderDirection: xdai_swap_OrderDirection
    where: xdai_swap_LpAccount_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xdai_swap_LpAccount!]!
  xdai_swap_lpAccountBalance(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xdai_swap_LpAccountBalance
  xdai_swap_lpAccountBalances(
    skip: Int = 0
    first: Int = 100
    orderBy: xdai_swap_LpAccountBalance_orderBy
    orderDirection: xdai_swap_OrderDirection
    where: xdai_swap_LpAccountBalance_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xdai_swap_LpAccountBalance!]!
  xdai_swap_lpToken(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xdai_swap_LpToken
  xdai_swap_lpTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: xdai_swap_LpToken_orderBy
    orderDirection: xdai_swap_OrderDirection
    where: xdai_swap_LpToken_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xdai_swap_LpToken!]!
  xdai_swap_lpTransferEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xdai_swap_LpTransferEvent
  xdai_swap_lpTransferEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: xdai_swap_LpTransferEvent_orderBy
    orderDirection: xdai_swap_OrderDirection
    where: xdai_swap_LpTransferEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xdai_swap_LpTransferEvent!]!
  xdai_swap_stableSwapEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xdai_swap_StableSwapEvent
  xdai_swap_stableSwapEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: xdai_swap_StableSwapEvent_orderBy
    orderDirection: xdai_swap_OrderDirection
    where: xdai_swap_StableSwapEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xdai_swap_StableSwapEvent!]!
  xdai_swap_swapTradeVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xdai_swap_SwapTradeVolume
  xdai_swap_swapTradeVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: xdai_swap_SwapTradeVolume_orderBy
    orderDirection: xdai_swap_OrderDirection
    where: xdai_swap_SwapTradeVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xdai_swap_SwapTradeVolume!]!
  xdai_swap_lpTokenEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xdai_swap_LpTokenEvent
  xdai_swap_lpTokenEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: xdai_swap_LpTokenEvent_orderBy
    orderDirection: xdai_swap_OrderDirection
    where: xdai_swap_LpTokenEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xdai_swap_LpTokenEvent!]!
  """Access to subgraph metadata"""
  xdai_swap__meta(block: xdai_swap_Block_height): xdai_swap__Meta_
  arbitrumone_swap_systemInfo(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): arbitrumone_swap_SystemInfo
  arbitrumone_swap_systemInfos(
    skip: Int = 0
    first: Int = 100
    orderBy: arbitrumone_swap_SystemInfo_orderBy
    orderDirection: arbitrumone_swap_OrderDirection
    where: arbitrumone_swap_SystemInfo_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [arbitrumone_swap_SystemInfo!]!
  arbitrumone_swap_pooledToken(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): arbitrumone_swap_PooledToken
  arbitrumone_swap_pooledTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: arbitrumone_swap_PooledToken_orderBy
    orderDirection: arbitrumone_swap_OrderDirection
    where: arbitrumone_swap_PooledToken_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [arbitrumone_swap_PooledToken!]!
  arbitrumone_swap_stableSwap(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): arbitrumone_swap_StableSwap
  arbitrumone_swap_stableSwaps(
    skip: Int = 0
    first: Int = 100
    orderBy: arbitrumone_swap_StableSwap_orderBy
    orderDirection: arbitrumone_swap_OrderDirection
    where: arbitrumone_swap_StableSwap_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [arbitrumone_swap_StableSwap!]!
  arbitrumone_swap_stableSwapAddLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): arbitrumone_swap_StableSwapAddLiquidityEvent
  arbitrumone_swap_stableSwapAddLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: arbitrumone_swap_StableSwapAddLiquidityEvent_orderBy
    orderDirection: arbitrumone_swap_OrderDirection
    where: arbitrumone_swap_StableSwapAddLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [arbitrumone_swap_StableSwapAddLiquidityEvent!]!
  arbitrumone_swap_stableSwapRemoveLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): arbitrumone_swap_StableSwapRemoveLiquidityEvent
  arbitrumone_swap_stableSwapRemoveLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: arbitrumone_swap_StableSwapRemoveLiquidityEvent_orderBy
    orderDirection: arbitrumone_swap_OrderDirection
    where: arbitrumone_swap_StableSwapRemoveLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [arbitrumone_swap_StableSwapRemoveLiquidityEvent!]!
  arbitrumone_swap_stableSwapExchange(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): arbitrumone_swap_StableSwapExchange
  arbitrumone_swap_stableSwapExchanges(
    skip: Int = 0
    first: Int = 100
    orderBy: arbitrumone_swap_StableSwapExchange_orderBy
    orderDirection: arbitrumone_swap_OrderDirection
    where: arbitrumone_swap_StableSwapExchange_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [arbitrumone_swap_StableSwapExchange!]!
  arbitrumone_swap_swapDailyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): arbitrumone_swap_SwapDailyVolume
  arbitrumone_swap_swapDailyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: arbitrumone_swap_SwapDailyVolume_orderBy
    orderDirection: arbitrumone_swap_OrderDirection
    where: arbitrumone_swap_SwapDailyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [arbitrumone_swap_SwapDailyVolume!]!
  arbitrumone_swap_swapHourlyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): arbitrumone_swap_SwapHourlyVolume
  arbitrumone_swap_swapHourlyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: arbitrumone_swap_SwapHourlyVolume_orderBy
    orderDirection: arbitrumone_swap_OrderDirection
    where: arbitrumone_swap_SwapHourlyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [arbitrumone_swap_SwapHourlyVolume!]!
  arbitrumone_swap_swapWeeklyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): arbitrumone_swap_SwapWeeklyVolume
  arbitrumone_swap_swapWeeklyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: arbitrumone_swap_SwapWeeklyVolume_orderBy
    orderDirection: arbitrumone_swap_OrderDirection
    where: arbitrumone_swap_SwapWeeklyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [arbitrumone_swap_SwapWeeklyVolume!]!
  arbitrumone_swap_lpAccount(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): arbitrumone_swap_LpAccount
  arbitrumone_swap_lpAccounts(
    skip: Int = 0
    first: Int = 100
    orderBy: arbitrumone_swap_LpAccount_orderBy
    orderDirection: arbitrumone_swap_OrderDirection
    where: arbitrumone_swap_LpAccount_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [arbitrumone_swap_LpAccount!]!
  arbitrumone_swap_lpAccountBalance(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): arbitrumone_swap_LpAccountBalance
  arbitrumone_swap_lpAccountBalances(
    skip: Int = 0
    first: Int = 100
    orderBy: arbitrumone_swap_LpAccountBalance_orderBy
    orderDirection: arbitrumone_swap_OrderDirection
    where: arbitrumone_swap_LpAccountBalance_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [arbitrumone_swap_LpAccountBalance!]!
  arbitrumone_swap_lpToken(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): arbitrumone_swap_LpToken
  arbitrumone_swap_lpTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: arbitrumone_swap_LpToken_orderBy
    orderDirection: arbitrumone_swap_OrderDirection
    where: arbitrumone_swap_LpToken_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [arbitrumone_swap_LpToken!]!
  arbitrumone_swap_lpTransferEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): arbitrumone_swap_LpTransferEvent
  arbitrumone_swap_lpTransferEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: arbitrumone_swap_LpTransferEvent_orderBy
    orderDirection: arbitrumone_swap_OrderDirection
    where: arbitrumone_swap_LpTransferEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [arbitrumone_swap_LpTransferEvent!]!
  arbitrumone_swap_stableSwapEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): arbitrumone_swap_StableSwapEvent
  arbitrumone_swap_stableSwapEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: arbitrumone_swap_StableSwapEvent_orderBy
    orderDirection: arbitrumone_swap_OrderDirection
    where: arbitrumone_swap_StableSwapEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [arbitrumone_swap_StableSwapEvent!]!
  arbitrumone_swap_swapTradeVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): arbitrumone_swap_SwapTradeVolume
  arbitrumone_swap_swapTradeVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: arbitrumone_swap_SwapTradeVolume_orderBy
    orderDirection: arbitrumone_swap_OrderDirection
    where: arbitrumone_swap_SwapTradeVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [arbitrumone_swap_SwapTradeVolume!]!
  arbitrumone_swap_lpTokenEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): arbitrumone_swap_LpTokenEvent
  arbitrumone_swap_lpTokenEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: arbitrumone_swap_LpTokenEvent_orderBy
    orderDirection: arbitrumone_swap_OrderDirection
    where: arbitrumone_swap_LpTokenEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [arbitrumone_swap_LpTokenEvent!]!
  """Access to subgraph metadata"""
  arbitrumone_swap__meta(block: arbitrumone_swap_Block_height): arbitrumone_swap__Meta_
  bnb_swap_systemInfo(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): bnb_swap_SystemInfo
  bnb_swap_systemInfos(
    skip: Int = 0
    first: Int = 100
    orderBy: bnb_swap_SystemInfo_orderBy
    orderDirection: bnb_swap_OrderDirection
    where: bnb_swap_SystemInfo_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [bnb_swap_SystemInfo!]!
  bnb_swap_pooledToken(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): bnb_swap_PooledToken
  bnb_swap_pooledTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: bnb_swap_PooledToken_orderBy
    orderDirection: bnb_swap_OrderDirection
    where: bnb_swap_PooledToken_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [bnb_swap_PooledToken!]!
  bnb_swap_stableSwap(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): bnb_swap_StableSwap
  bnb_swap_stableSwaps(
    skip: Int = 0
    first: Int = 100
    orderBy: bnb_swap_StableSwap_orderBy
    orderDirection: bnb_swap_OrderDirection
    where: bnb_swap_StableSwap_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [bnb_swap_StableSwap!]!
  bnb_swap_stableSwapAddLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): bnb_swap_StableSwapAddLiquidityEvent
  bnb_swap_stableSwapAddLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: bnb_swap_StableSwapAddLiquidityEvent_orderBy
    orderDirection: bnb_swap_OrderDirection
    where: bnb_swap_StableSwapAddLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [bnb_swap_StableSwapAddLiquidityEvent!]!
  bnb_swap_stableSwapRemoveLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): bnb_swap_StableSwapRemoveLiquidityEvent
  bnb_swap_stableSwapRemoveLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: bnb_swap_StableSwapRemoveLiquidityEvent_orderBy
    orderDirection: bnb_swap_OrderDirection
    where: bnb_swap_StableSwapRemoveLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [bnb_swap_StableSwapRemoveLiquidityEvent!]!
  bnb_swap_stableSwapExchange(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): bnb_swap_StableSwapExchange
  bnb_swap_stableSwapExchanges(
    skip: Int = 0
    first: Int = 100
    orderBy: bnb_swap_StableSwapExchange_orderBy
    orderDirection: bnb_swap_OrderDirection
    where: bnb_swap_StableSwapExchange_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [bnb_swap_StableSwapExchange!]!
  bnb_swap_swapDailyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): bnb_swap_SwapDailyVolume
  bnb_swap_swapDailyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: bnb_swap_SwapDailyVolume_orderBy
    orderDirection: bnb_swap_OrderDirection
    where: bnb_swap_SwapDailyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [bnb_swap_SwapDailyVolume!]!
  bnb_swap_swapHourlyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): bnb_swap_SwapHourlyVolume
  bnb_swap_swapHourlyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: bnb_swap_SwapHourlyVolume_orderBy
    orderDirection: bnb_swap_OrderDirection
    where: bnb_swap_SwapHourlyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [bnb_swap_SwapHourlyVolume!]!
  bnb_swap_swapWeeklyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): bnb_swap_SwapWeeklyVolume
  bnb_swap_swapWeeklyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: bnb_swap_SwapWeeklyVolume_orderBy
    orderDirection: bnb_swap_OrderDirection
    where: bnb_swap_SwapWeeklyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [bnb_swap_SwapWeeklyVolume!]!
  bnb_swap_lpAccount(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): bnb_swap_LpAccount
  bnb_swap_lpAccounts(
    skip: Int = 0
    first: Int = 100
    orderBy: bnb_swap_LpAccount_orderBy
    orderDirection: bnb_swap_OrderDirection
    where: bnb_swap_LpAccount_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [bnb_swap_LpAccount!]!
  bnb_swap_lpAccountBalance(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): bnb_swap_LpAccountBalance
  bnb_swap_lpAccountBalances(
    skip: Int = 0
    first: Int = 100
    orderBy: bnb_swap_LpAccountBalance_orderBy
    orderDirection: bnb_swap_OrderDirection
    where: bnb_swap_LpAccountBalance_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [bnb_swap_LpAccountBalance!]!
  bnb_swap_lpToken(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): bnb_swap_LpToken
  bnb_swap_lpTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: bnb_swap_LpToken_orderBy
    orderDirection: bnb_swap_OrderDirection
    where: bnb_swap_LpToken_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [bnb_swap_LpToken!]!
  bnb_swap_lpTransferEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): bnb_swap_LpTransferEvent
  bnb_swap_lpTransferEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: bnb_swap_LpTransferEvent_orderBy
    orderDirection: bnb_swap_OrderDirection
    where: bnb_swap_LpTransferEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [bnb_swap_LpTransferEvent!]!
  bnb_swap_stableSwapEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): bnb_swap_StableSwapEvent
  bnb_swap_stableSwapEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: bnb_swap_StableSwapEvent_orderBy
    orderDirection: bnb_swap_OrderDirection
    where: bnb_swap_StableSwapEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [bnb_swap_StableSwapEvent!]!
  bnb_swap_swapTradeVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): bnb_swap_SwapTradeVolume
  bnb_swap_swapTradeVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: bnb_swap_SwapTradeVolume_orderBy
    orderDirection: bnb_swap_OrderDirection
    where: bnb_swap_SwapTradeVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [bnb_swap_SwapTradeVolume!]!
  bnb_swap_lpTokenEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): bnb_swap_LpTokenEvent
  bnb_swap_lpTokenEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: bnb_swap_LpTokenEvent_orderBy
    orderDirection: bnb_swap_OrderDirection
    where: bnb_swap_LpTokenEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [bnb_swap_LpTokenEvent!]!
  """Access to subgraph metadata"""
  bnb_swap__meta(block: bnb_swap_Block_height): bnb_swap__Meta_
  xlayer_swap_systemInfo(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xlayer_swap_SystemInfo
  xlayer_swap_systemInfos(
    skip: Int = 0
    first: Int = 100
    orderBy: xlayer_swap_SystemInfo_orderBy
    orderDirection: xlayer_swap_OrderDirection
    where: xlayer_swap_SystemInfo_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xlayer_swap_SystemInfo!]!
  xlayer_swap_pooledToken(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xlayer_swap_PooledToken
  xlayer_swap_pooledTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: xlayer_swap_PooledToken_orderBy
    orderDirection: xlayer_swap_OrderDirection
    where: xlayer_swap_PooledToken_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xlayer_swap_PooledToken!]!
  xlayer_swap_stableSwap(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xlayer_swap_StableSwap
  xlayer_swap_stableSwaps(
    skip: Int = 0
    first: Int = 100
    orderBy: xlayer_swap_StableSwap_orderBy
    orderDirection: xlayer_swap_OrderDirection
    where: xlayer_swap_StableSwap_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xlayer_swap_StableSwap!]!
  xlayer_swap_stableSwapAddLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xlayer_swap_StableSwapAddLiquidityEvent
  xlayer_swap_stableSwapAddLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: xlayer_swap_StableSwapAddLiquidityEvent_orderBy
    orderDirection: xlayer_swap_OrderDirection
    where: xlayer_swap_StableSwapAddLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xlayer_swap_StableSwapAddLiquidityEvent!]!
  xlayer_swap_stableSwapRemoveLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xlayer_swap_StableSwapRemoveLiquidityEvent
  xlayer_swap_stableSwapRemoveLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: xlayer_swap_StableSwapRemoveLiquidityEvent_orderBy
    orderDirection: xlayer_swap_OrderDirection
    where: xlayer_swap_StableSwapRemoveLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xlayer_swap_StableSwapRemoveLiquidityEvent!]!
  xlayer_swap_stableSwapExchange(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xlayer_swap_StableSwapExchange
  xlayer_swap_stableSwapExchanges(
    skip: Int = 0
    first: Int = 100
    orderBy: xlayer_swap_StableSwapExchange_orderBy
    orderDirection: xlayer_swap_OrderDirection
    where: xlayer_swap_StableSwapExchange_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xlayer_swap_StableSwapExchange!]!
  xlayer_swap_swapDailyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xlayer_swap_SwapDailyVolume
  xlayer_swap_swapDailyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: xlayer_swap_SwapDailyVolume_orderBy
    orderDirection: xlayer_swap_OrderDirection
    where: xlayer_swap_SwapDailyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xlayer_swap_SwapDailyVolume!]!
  xlayer_swap_swapHourlyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xlayer_swap_SwapHourlyVolume
  xlayer_swap_swapHourlyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: xlayer_swap_SwapHourlyVolume_orderBy
    orderDirection: xlayer_swap_OrderDirection
    where: xlayer_swap_SwapHourlyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xlayer_swap_SwapHourlyVolume!]!
  xlayer_swap_swapWeeklyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xlayer_swap_SwapWeeklyVolume
  xlayer_swap_swapWeeklyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: xlayer_swap_SwapWeeklyVolume_orderBy
    orderDirection: xlayer_swap_OrderDirection
    where: xlayer_swap_SwapWeeklyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xlayer_swap_SwapWeeklyVolume!]!
  xlayer_swap_lpAccount(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xlayer_swap_LpAccount
  xlayer_swap_lpAccounts(
    skip: Int = 0
    first: Int = 100
    orderBy: xlayer_swap_LpAccount_orderBy
    orderDirection: xlayer_swap_OrderDirection
    where: xlayer_swap_LpAccount_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xlayer_swap_LpAccount!]!
  xlayer_swap_lpAccountBalance(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xlayer_swap_LpAccountBalance
  xlayer_swap_lpAccountBalances(
    skip: Int = 0
    first: Int = 100
    orderBy: xlayer_swap_LpAccountBalance_orderBy
    orderDirection: xlayer_swap_OrderDirection
    where: xlayer_swap_LpAccountBalance_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xlayer_swap_LpAccountBalance!]!
  xlayer_swap_lpToken(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xlayer_swap_LpToken
  xlayer_swap_lpTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: xlayer_swap_LpToken_orderBy
    orderDirection: xlayer_swap_OrderDirection
    where: xlayer_swap_LpToken_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xlayer_swap_LpToken!]!
  xlayer_swap_lpTransferEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xlayer_swap_LpTransferEvent
  xlayer_swap_lpTransferEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: xlayer_swap_LpTransferEvent_orderBy
    orderDirection: xlayer_swap_OrderDirection
    where: xlayer_swap_LpTransferEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xlayer_swap_LpTransferEvent!]!
  xlayer_swap_stableSwapEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xlayer_swap_StableSwapEvent
  xlayer_swap_stableSwapEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: xlayer_swap_StableSwapEvent_orderBy
    orderDirection: xlayer_swap_OrderDirection
    where: xlayer_swap_StableSwapEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xlayer_swap_StableSwapEvent!]!
  xlayer_swap_swapTradeVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xlayer_swap_SwapTradeVolume
  xlayer_swap_swapTradeVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: xlayer_swap_SwapTradeVolume_orderBy
    orderDirection: xlayer_swap_OrderDirection
    where: xlayer_swap_SwapTradeVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xlayer_swap_SwapTradeVolume!]!
  xlayer_swap_lpTokenEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xlayer_swap_LpTokenEvent
  xlayer_swap_lpTokenEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: xlayer_swap_LpTokenEvent_orderBy
    orderDirection: xlayer_swap_OrderDirection
    where: xlayer_swap_LpTokenEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xlayer_swap_LpTokenEvent!]!
  """Access to subgraph metadata"""
  xlayer_swap__meta(block: xlayer_swap_Block_height): xlayer_swap__Meta_
}

type Subscription {
  mode_swap_systemInfo(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mode_swap_SystemInfo
  mode_swap_systemInfos(
    skip: Int = 0
    first: Int = 100
    orderBy: mode_swap_SystemInfo_orderBy
    orderDirection: mode_swap_OrderDirection
    where: mode_swap_SystemInfo_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mode_swap_SystemInfo!]!
  mode_swap_pooledToken(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mode_swap_PooledToken
  mode_swap_pooledTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: mode_swap_PooledToken_orderBy
    orderDirection: mode_swap_OrderDirection
    where: mode_swap_PooledToken_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mode_swap_PooledToken!]!
  mode_swap_stableSwap(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mode_swap_StableSwap
  mode_swap_stableSwaps(
    skip: Int = 0
    first: Int = 100
    orderBy: mode_swap_StableSwap_orderBy
    orderDirection: mode_swap_OrderDirection
    where: mode_swap_StableSwap_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mode_swap_StableSwap!]!
  mode_swap_stableSwapAddLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mode_swap_StableSwapAddLiquidityEvent
  mode_swap_stableSwapAddLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: mode_swap_StableSwapAddLiquidityEvent_orderBy
    orderDirection: mode_swap_OrderDirection
    where: mode_swap_StableSwapAddLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mode_swap_StableSwapAddLiquidityEvent!]!
  mode_swap_stableSwapRemoveLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mode_swap_StableSwapRemoveLiquidityEvent
  mode_swap_stableSwapRemoveLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: mode_swap_StableSwapRemoveLiquidityEvent_orderBy
    orderDirection: mode_swap_OrderDirection
    where: mode_swap_StableSwapRemoveLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mode_swap_StableSwapRemoveLiquidityEvent!]!
  mode_swap_stableSwapExchange(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mode_swap_StableSwapExchange
  mode_swap_stableSwapExchanges(
    skip: Int = 0
    first: Int = 100
    orderBy: mode_swap_StableSwapExchange_orderBy
    orderDirection: mode_swap_OrderDirection
    where: mode_swap_StableSwapExchange_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mode_swap_StableSwapExchange!]!
  mode_swap_swapDailyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mode_swap_SwapDailyVolume
  mode_swap_swapDailyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: mode_swap_SwapDailyVolume_orderBy
    orderDirection: mode_swap_OrderDirection
    where: mode_swap_SwapDailyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mode_swap_SwapDailyVolume!]!
  mode_swap_swapHourlyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mode_swap_SwapHourlyVolume
  mode_swap_swapHourlyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: mode_swap_SwapHourlyVolume_orderBy
    orderDirection: mode_swap_OrderDirection
    where: mode_swap_SwapHourlyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mode_swap_SwapHourlyVolume!]!
  mode_swap_swapWeeklyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mode_swap_SwapWeeklyVolume
  mode_swap_swapWeeklyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: mode_swap_SwapWeeklyVolume_orderBy
    orderDirection: mode_swap_OrderDirection
    where: mode_swap_SwapWeeklyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mode_swap_SwapWeeklyVolume!]!
  mode_swap_lpAccount(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mode_swap_LpAccount
  mode_swap_lpAccounts(
    skip: Int = 0
    first: Int = 100
    orderBy: mode_swap_LpAccount_orderBy
    orderDirection: mode_swap_OrderDirection
    where: mode_swap_LpAccount_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mode_swap_LpAccount!]!
  mode_swap_lpAccountBalance(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mode_swap_LpAccountBalance
  mode_swap_lpAccountBalances(
    skip: Int = 0
    first: Int = 100
    orderBy: mode_swap_LpAccountBalance_orderBy
    orderDirection: mode_swap_OrderDirection
    where: mode_swap_LpAccountBalance_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mode_swap_LpAccountBalance!]!
  mode_swap_lpToken(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mode_swap_LpToken
  mode_swap_lpTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: mode_swap_LpToken_orderBy
    orderDirection: mode_swap_OrderDirection
    where: mode_swap_LpToken_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mode_swap_LpToken!]!
  mode_swap_lpTransferEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mode_swap_LpTransferEvent
  mode_swap_lpTransferEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: mode_swap_LpTransferEvent_orderBy
    orderDirection: mode_swap_OrderDirection
    where: mode_swap_LpTransferEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mode_swap_LpTransferEvent!]!
  mode_swap_stableSwapEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mode_swap_StableSwapEvent
  mode_swap_stableSwapEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: mode_swap_StableSwapEvent_orderBy
    orderDirection: mode_swap_OrderDirection
    where: mode_swap_StableSwapEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mode_swap_StableSwapEvent!]!
  mode_swap_swapTradeVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mode_swap_SwapTradeVolume
  mode_swap_swapTradeVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: mode_swap_SwapTradeVolume_orderBy
    orderDirection: mode_swap_OrderDirection
    where: mode_swap_SwapTradeVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mode_swap_SwapTradeVolume!]!
  mode_swap_lpTokenEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mode_swap_LpTokenEvent
  mode_swap_lpTokenEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: mode_swap_LpTokenEvent_orderBy
    orderDirection: mode_swap_OrderDirection
    where: mode_swap_LpTokenEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mode_swap_LpTokenEvent!]!
  """Access to subgraph metadata"""
  mode_swap__meta(block: mode_swap_Block_height): mode_swap__Meta_
  mantle_swap_systemInfo(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mantle_swap_SystemInfo
  mantle_swap_systemInfos(
    skip: Int = 0
    first: Int = 100
    orderBy: mantle_swap_SystemInfo_orderBy
    orderDirection: mantle_swap_OrderDirection
    where: mantle_swap_SystemInfo_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mantle_swap_SystemInfo!]!
  mantle_swap_pooledToken(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mantle_swap_PooledToken
  mantle_swap_pooledTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: mantle_swap_PooledToken_orderBy
    orderDirection: mantle_swap_OrderDirection
    where: mantle_swap_PooledToken_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mantle_swap_PooledToken!]!
  mantle_swap_stableSwap(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mantle_swap_StableSwap
  mantle_swap_stableSwaps(
    skip: Int = 0
    first: Int = 100
    orderBy: mantle_swap_StableSwap_orderBy
    orderDirection: mantle_swap_OrderDirection
    where: mantle_swap_StableSwap_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mantle_swap_StableSwap!]!
  mantle_swap_stableSwapAddLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mantle_swap_StableSwapAddLiquidityEvent
  mantle_swap_stableSwapAddLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: mantle_swap_StableSwapAddLiquidityEvent_orderBy
    orderDirection: mantle_swap_OrderDirection
    where: mantle_swap_StableSwapAddLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mantle_swap_StableSwapAddLiquidityEvent!]!
  mantle_swap_stableSwapRemoveLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mantle_swap_StableSwapRemoveLiquidityEvent
  mantle_swap_stableSwapRemoveLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: mantle_swap_StableSwapRemoveLiquidityEvent_orderBy
    orderDirection: mantle_swap_OrderDirection
    where: mantle_swap_StableSwapRemoveLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mantle_swap_StableSwapRemoveLiquidityEvent!]!
  mantle_swap_stableSwapExchange(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mantle_swap_StableSwapExchange
  mantle_swap_stableSwapExchanges(
    skip: Int = 0
    first: Int = 100
    orderBy: mantle_swap_StableSwapExchange_orderBy
    orderDirection: mantle_swap_OrderDirection
    where: mantle_swap_StableSwapExchange_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mantle_swap_StableSwapExchange!]!
  mantle_swap_swapDailyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mantle_swap_SwapDailyVolume
  mantle_swap_swapDailyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: mantle_swap_SwapDailyVolume_orderBy
    orderDirection: mantle_swap_OrderDirection
    where: mantle_swap_SwapDailyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mantle_swap_SwapDailyVolume!]!
  mantle_swap_swapHourlyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mantle_swap_SwapHourlyVolume
  mantle_swap_swapHourlyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: mantle_swap_SwapHourlyVolume_orderBy
    orderDirection: mantle_swap_OrderDirection
    where: mantle_swap_SwapHourlyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mantle_swap_SwapHourlyVolume!]!
  mantle_swap_swapWeeklyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mantle_swap_SwapWeeklyVolume
  mantle_swap_swapWeeklyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: mantle_swap_SwapWeeklyVolume_orderBy
    orderDirection: mantle_swap_OrderDirection
    where: mantle_swap_SwapWeeklyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mantle_swap_SwapWeeklyVolume!]!
  mantle_swap_lpAccount(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mantle_swap_LpAccount
  mantle_swap_lpAccounts(
    skip: Int = 0
    first: Int = 100
    orderBy: mantle_swap_LpAccount_orderBy
    orderDirection: mantle_swap_OrderDirection
    where: mantle_swap_LpAccount_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mantle_swap_LpAccount!]!
  mantle_swap_lpAccountBalance(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mantle_swap_LpAccountBalance
  mantle_swap_lpAccountBalances(
    skip: Int = 0
    first: Int = 100
    orderBy: mantle_swap_LpAccountBalance_orderBy
    orderDirection: mantle_swap_OrderDirection
    where: mantle_swap_LpAccountBalance_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mantle_swap_LpAccountBalance!]!
  mantle_swap_lpToken(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mantle_swap_LpToken
  mantle_swap_lpTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: mantle_swap_LpToken_orderBy
    orderDirection: mantle_swap_OrderDirection
    where: mantle_swap_LpToken_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mantle_swap_LpToken!]!
  mantle_swap_lpTransferEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mantle_swap_LpTransferEvent
  mantle_swap_lpTransferEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: mantle_swap_LpTransferEvent_orderBy
    orderDirection: mantle_swap_OrderDirection
    where: mantle_swap_LpTransferEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mantle_swap_LpTransferEvent!]!
  mantle_swap_stableSwapEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mantle_swap_StableSwapEvent
  mantle_swap_stableSwapEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: mantle_swap_StableSwapEvent_orderBy
    orderDirection: mantle_swap_OrderDirection
    where: mantle_swap_StableSwapEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mantle_swap_StableSwapEvent!]!
  mantle_swap_swapTradeVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mantle_swap_SwapTradeVolume
  mantle_swap_swapTradeVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: mantle_swap_SwapTradeVolume_orderBy
    orderDirection: mantle_swap_OrderDirection
    where: mantle_swap_SwapTradeVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mantle_swap_SwapTradeVolume!]!
  mantle_swap_lpTokenEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mantle_swap_LpTokenEvent
  mantle_swap_lpTokenEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: mantle_swap_LpTokenEvent_orderBy
    orderDirection: mantle_swap_OrderDirection
    where: mantle_swap_LpTokenEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mantle_swap_LpTokenEvent!]!
  """Access to subgraph metadata"""
  mantle_swap__meta(block: mantle_swap_Block_height): mantle_swap__Meta_
  bnb_asset(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): bnb_Asset
  bnb_assets(
    skip: Int = 0
    first: Int = 100
    orderBy: bnb_Asset_orderBy
    orderDirection: bnb_OrderDirection
    where: bnb_Asset_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [bnb_Asset!]!
  bnb_assetStatus(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): bnb_AssetStatus
  bnb_assetStatuses(
    skip: Int = 0
    first: Int = 100
    orderBy: bnb_AssetStatus_orderBy
    orderDirection: bnb_OrderDirection
    where: bnb_AssetStatus_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [bnb_AssetStatus!]!
  bnb_assetBalance(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): bnb_AssetBalance
  bnb_assetBalances(
    skip: Int = 0
    first: Int = 100
    orderBy: bnb_AssetBalance_orderBy
    orderDirection: bnb_OrderDirection
    where: bnb_AssetBalance_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [bnb_AssetBalance!]!
  bnb_router(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): bnb_Router
  bnb_routers(
    skip: Int = 0
    first: Int = 100
    orderBy: bnb_Router_orderBy
    orderDirection: bnb_OrderDirection
    where: bnb_Router_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [bnb_Router!]!
  bnb_routerDailyTVL(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): bnb_RouterDailyTVL
  bnb_routerDailyTVLs(
    skip: Int = 0
    first: Int = 100
    orderBy: bnb_RouterDailyTVL_orderBy
    orderDirection: bnb_OrderDirection
    where: bnb_RouterDailyTVL_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [bnb_RouterDailyTVL!]!
  bnb_routerLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): bnb_RouterLiquidityEvent
  bnb_routerLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: bnb_RouterLiquidityEvent_orderBy
    orderDirection: bnb_OrderDirection
    where: bnb_RouterLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [bnb_RouterLiquidityEvent!]!
  bnb_setting(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): bnb_Setting
  bnb_settings(
    skip: Int = 0
    first: Int = 100
    orderBy: bnb_Setting_orderBy
    orderDirection: bnb_OrderDirection
    where: bnb_Setting_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [bnb_Setting!]!
  bnb_relayer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): bnb_Relayer
  bnb_relayers(
    skip: Int = 0
    first: Int = 100
    orderBy: bnb_Relayer_orderBy
    orderDirection: bnb_OrderDirection
    where: bnb_Relayer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [bnb_Relayer!]!
  bnb_sequencer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): bnb_Sequencer
  bnb_sequencers(
    skip: Int = 0
    first: Int = 100
    orderBy: bnb_Sequencer_orderBy
    orderDirection: bnb_OrderDirection
    where: bnb_Sequencer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [bnb_Sequencer!]!
  bnb_relayerFee(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): bnb_RelayerFee
  bnb_relayerFees(
    skip: Int = 0
    first: Int = 100
    orderBy: bnb_RelayerFee_orderBy
    orderDirection: bnb_OrderDirection
    where: bnb_RelayerFee_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [bnb_RelayerFee!]!
  bnb_originTransfer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): bnb_OriginTransfer
  bnb_originTransfers(
    skip: Int = 0
    first: Int = 100
    orderBy: bnb_OriginTransfer_orderBy
    orderDirection: bnb_OrderDirection
    where: bnb_OriginTransfer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [bnb_OriginTransfer!]!
  bnb_destinationTransfer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): bnb_DestinationTransfer
  bnb_destinationTransfers(
    skip: Int = 0
    first: Int = 100
    orderBy: bnb_DestinationTransfer_orderBy
    orderDirection: bnb_OrderDirection
    where: bnb_DestinationTransfer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [bnb_DestinationTransfer!]!
  bnb_originMessage(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): bnb_OriginMessage
  bnb_originMessages(
    skip: Int = 0
    first: Int = 100
    orderBy: bnb_OriginMessage_orderBy
    orderDirection: bnb_OrderDirection
    where: bnb_OriginMessage_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [bnb_OriginMessage!]!
  bnb_aggregateRoot(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): bnb_AggregateRoot
  bnb_aggregateRoots(
    skip: Int = 0
    first: Int = 100
    orderBy: bnb_AggregateRoot_orderBy
    orderDirection: bnb_OrderDirection
    where: bnb_AggregateRoot_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [bnb_AggregateRoot!]!
  bnb_connectorMeta(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): bnb_ConnectorMeta
  bnb_connectorMetas(
    skip: Int = 0
    first: Int = 100
    orderBy: bnb_ConnectorMeta_orderBy
    orderDirection: bnb_OrderDirection
    where: bnb_ConnectorMeta_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [bnb_ConnectorMeta!]!
  bnb_rootCount(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): bnb_RootCount
  bnb_rootCounts(
    skip: Int = 0
    first: Int = 100
    orderBy: bnb_RootCount_orderBy
    orderDirection: bnb_OrderDirection
    where: bnb_RootCount_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [bnb_RootCount!]!
  bnb_rootMessageSent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): bnb_RootMessageSent
  bnb_rootMessageSents(
    skip: Int = 0
    first: Int = 100
    orderBy: bnb_RootMessageSent_orderBy
    orderDirection: bnb_OrderDirection
    where: bnb_RootMessageSent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [bnb_RootMessageSent!]!
  bnb_relayerFeesIncrease(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): bnb_RelayerFeesIncrease
  bnb_relayerFeesIncreases(
    skip: Int = 0
    first: Int = 100
    orderBy: bnb_RelayerFeesIncrease_orderBy
    orderDirection: bnb_OrderDirection
    where: bnb_RelayerFeesIncrease_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [bnb_RelayerFeesIncrease!]!
  bnb_slippageUpdate(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): bnb_SlippageUpdate
  bnb_slippageUpdates(
    skip: Int = 0
    first: Int = 100
    orderBy: bnb_SlippageUpdate_orderBy
    orderDirection: bnb_OrderDirection
    where: bnb_SlippageUpdate_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [bnb_SlippageUpdate!]!
  bnb_snapshotRoot(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): bnb_SnapshotRoot
  bnb_snapshotRoots(
    skip: Int = 0
    first: Int = 100
    orderBy: bnb_SnapshotRoot_orderBy
    orderDirection: bnb_OrderDirection
    where: bnb_SnapshotRoot_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [bnb_SnapshotRoot!]!
  bnb_spokeConnectorMode(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): bnb_SpokeConnectorMode
  bnb_spokeConnectorModes(
    skip: Int = 0
    first: Int = 100
    orderBy: bnb_SpokeConnectorMode_orderBy
    orderDirection: bnb_OrderDirection
    where: bnb_SpokeConnectorMode_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [bnb_SpokeConnectorMode!]!
  bnb_aggregateRootProposed(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): bnb_AggregateRootProposed
  bnb_aggregateRootProposeds(
    skip: Int = 0
    first: Int = 100
    orderBy: bnb_AggregateRootProposed_orderBy
    orderDirection: bnb_OrderDirection
    where: bnb_AggregateRootProposed_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [bnb_AggregateRootProposed!]!
  bnb_optimisticRootFinalized(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): bnb_OptimisticRootFinalized
  bnb_optimisticRootFinalizeds(
    skip: Int = 0
    first: Int = 100
    orderBy: bnb_OptimisticRootFinalized_orderBy
    orderDirection: bnb_OrderDirection
    where: bnb_OptimisticRootFinalized_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [bnb_OptimisticRootFinalized!]!
  """Access to subgraph metadata"""
  bnb__meta(block: bnb_Block_height): bnb__Meta_
  metis_swap_systemInfo(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): metis_swap_SystemInfo
  metis_swap_systemInfos(
    skip: Int = 0
    first: Int = 100
    orderBy: metis_swap_SystemInfo_orderBy
    orderDirection: metis_swap_OrderDirection
    where: metis_swap_SystemInfo_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [metis_swap_SystemInfo!]!
  metis_swap_pooledToken(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): metis_swap_PooledToken
  metis_swap_pooledTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: metis_swap_PooledToken_orderBy
    orderDirection: metis_swap_OrderDirection
    where: metis_swap_PooledToken_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [metis_swap_PooledToken!]!
  metis_swap_stableSwap(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): metis_swap_StableSwap
  metis_swap_stableSwaps(
    skip: Int = 0
    first: Int = 100
    orderBy: metis_swap_StableSwap_orderBy
    orderDirection: metis_swap_OrderDirection
    where: metis_swap_StableSwap_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [metis_swap_StableSwap!]!
  metis_swap_stableSwapAddLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): metis_swap_StableSwapAddLiquidityEvent
  metis_swap_stableSwapAddLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: metis_swap_StableSwapAddLiquidityEvent_orderBy
    orderDirection: metis_swap_OrderDirection
    where: metis_swap_StableSwapAddLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [metis_swap_StableSwapAddLiquidityEvent!]!
  metis_swap_stableSwapRemoveLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): metis_swap_StableSwapRemoveLiquidityEvent
  metis_swap_stableSwapRemoveLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: metis_swap_StableSwapRemoveLiquidityEvent_orderBy
    orderDirection: metis_swap_OrderDirection
    where: metis_swap_StableSwapRemoveLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [metis_swap_StableSwapRemoveLiquidityEvent!]!
  metis_swap_stableSwapExchange(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): metis_swap_StableSwapExchange
  metis_swap_stableSwapExchanges(
    skip: Int = 0
    first: Int = 100
    orderBy: metis_swap_StableSwapExchange_orderBy
    orderDirection: metis_swap_OrderDirection
    where: metis_swap_StableSwapExchange_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [metis_swap_StableSwapExchange!]!
  metis_swap_swapDailyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): metis_swap_SwapDailyVolume
  metis_swap_swapDailyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: metis_swap_SwapDailyVolume_orderBy
    orderDirection: metis_swap_OrderDirection
    where: metis_swap_SwapDailyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [metis_swap_SwapDailyVolume!]!
  metis_swap_swapHourlyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): metis_swap_SwapHourlyVolume
  metis_swap_swapHourlyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: metis_swap_SwapHourlyVolume_orderBy
    orderDirection: metis_swap_OrderDirection
    where: metis_swap_SwapHourlyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [metis_swap_SwapHourlyVolume!]!
  metis_swap_swapWeeklyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): metis_swap_SwapWeeklyVolume
  metis_swap_swapWeeklyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: metis_swap_SwapWeeklyVolume_orderBy
    orderDirection: metis_swap_OrderDirection
    where: metis_swap_SwapWeeklyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [metis_swap_SwapWeeklyVolume!]!
  metis_swap_lpAccount(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): metis_swap_LpAccount
  metis_swap_lpAccounts(
    skip: Int = 0
    first: Int = 100
    orderBy: metis_swap_LpAccount_orderBy
    orderDirection: metis_swap_OrderDirection
    where: metis_swap_LpAccount_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [metis_swap_LpAccount!]!
  metis_swap_lpAccountBalance(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): metis_swap_LpAccountBalance
  metis_swap_lpAccountBalances(
    skip: Int = 0
    first: Int = 100
    orderBy: metis_swap_LpAccountBalance_orderBy
    orderDirection: metis_swap_OrderDirection
    where: metis_swap_LpAccountBalance_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [metis_swap_LpAccountBalance!]!
  metis_swap_lpToken(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): metis_swap_LpToken
  metis_swap_lpTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: metis_swap_LpToken_orderBy
    orderDirection: metis_swap_OrderDirection
    where: metis_swap_LpToken_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [metis_swap_LpToken!]!
  metis_swap_lpTransferEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): metis_swap_LpTransferEvent
  metis_swap_lpTransferEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: metis_swap_LpTransferEvent_orderBy
    orderDirection: metis_swap_OrderDirection
    where: metis_swap_LpTransferEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [metis_swap_LpTransferEvent!]!
  metis_swap_stableSwapEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): metis_swap_StableSwapEvent
  metis_swap_stableSwapEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: metis_swap_StableSwapEvent_orderBy
    orderDirection: metis_swap_OrderDirection
    where: metis_swap_StableSwapEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [metis_swap_StableSwapEvent!]!
  metis_swap_swapTradeVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): metis_swap_SwapTradeVolume
  metis_swap_swapTradeVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: metis_swap_SwapTradeVolume_orderBy
    orderDirection: metis_swap_OrderDirection
    where: metis_swap_SwapTradeVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [metis_swap_SwapTradeVolume!]!
  metis_swap_lpTokenEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): metis_swap_LpTokenEvent
  metis_swap_lpTokenEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: metis_swap_LpTokenEvent_orderBy
    orderDirection: metis_swap_OrderDirection
    where: metis_swap_LpTokenEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [metis_swap_LpTokenEvent!]!
  """Access to subgraph metadata"""
  metis_swap__meta(block: metis_swap_Block_height): metis_swap__Meta_
  mainnet_rootAggregated(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mainnet_RootAggregated
  mainnet_rootAggregateds(
    skip: Int = 0
    first: Int = 100
    orderBy: mainnet_RootAggregated_orderBy
    orderDirection: mainnet_OrderDirection
    where: mainnet_RootAggregated_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mainnet_RootAggregated!]!
  mainnet_rootPropagated(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mainnet_RootPropagated
  mainnet_rootPropagateds(
    skip: Int = 0
    first: Int = 100
    orderBy: mainnet_RootPropagated_orderBy
    orderDirection: mainnet_OrderDirection
    where: mainnet_RootPropagated_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mainnet_RootPropagated!]!
  mainnet_aggregatedMessageRoot(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mainnet_AggregatedMessageRoot
  mainnet_aggregatedMessageRoots(
    skip: Int = 0
    first: Int = 100
    orderBy: mainnet_AggregatedMessageRoot_orderBy
    orderDirection: mainnet_OrderDirection
    where: mainnet_AggregatedMessageRoot_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mainnet_AggregatedMessageRoot!]!
  mainnet_rootManagerMeta(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mainnet_RootManagerMeta
  mainnet_rootManagerMetas(
    skip: Int = 0
    first: Int = 100
    orderBy: mainnet_RootManagerMeta_orderBy
    orderDirection: mainnet_OrderDirection
    where: mainnet_RootManagerMeta_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mainnet_RootManagerMeta!]!
  mainnet_rootManagerMode(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mainnet_RootManagerMode
  mainnet_rootManagerModes(
    skip: Int = 0
    first: Int = 100
    orderBy: mainnet_RootManagerMode_orderBy
    orderDirection: mainnet_OrderDirection
    where: mainnet_RootManagerMode_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mainnet_RootManagerMode!]!
  mainnet_optimisticRootProposed(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mainnet_OptimisticRootProposed
  mainnet_optimisticRootProposeds(
    skip: Int = 0
    first: Int = 100
    orderBy: mainnet_OptimisticRootProposed_orderBy
    orderDirection: mainnet_OrderDirection
    where: mainnet_OptimisticRootProposed_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mainnet_OptimisticRootProposed!]!
  mainnet_hubOptimisticRootFinalized(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mainnet_HubOptimisticRootFinalized
  mainnet_hubOptimisticRootFinalizeds(
    skip: Int = 0
    first: Int = 100
    orderBy: mainnet_HubOptimisticRootFinalized_orderBy
    orderDirection: mainnet_OrderDirection
    where: mainnet_HubOptimisticRootFinalized_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mainnet_HubOptimisticRootFinalized!]!
  mainnet_optimisticRootPropagated(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mainnet_OptimisticRootPropagated
  mainnet_optimisticRootPropagateds(
    skip: Int = 0
    first: Int = 100
    orderBy: mainnet_OptimisticRootPropagated_orderBy
    orderDirection: mainnet_OrderDirection
    where: mainnet_OptimisticRootPropagated_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mainnet_OptimisticRootPropagated!]!
  mainnet_polygonConnectorMeta(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mainnet_PolygonConnectorMeta
  mainnet_polygonConnectorMetas(
    skip: Int = 0
    first: Int = 100
    orderBy: mainnet_PolygonConnectorMeta_orderBy
    orderDirection: mainnet_OrderDirection
    where: mainnet_PolygonConnectorMeta_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mainnet_PolygonConnectorMeta!]!
  mainnet_optimismConnectorMeta(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mainnet_OptimismConnectorMeta
  mainnet_optimismConnectorMetas(
    skip: Int = 0
    first: Int = 100
    orderBy: mainnet_OptimismConnectorMeta_orderBy
    orderDirection: mainnet_OrderDirection
    where: mainnet_OptimismConnectorMeta_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mainnet_OptimismConnectorMeta!]!
  mainnet_bnbConnectorMeta(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mainnet_BnbConnectorMeta
  mainnet_bnbConnectorMetas(
    skip: Int = 0
    first: Int = 100
    orderBy: mainnet_BnbConnectorMeta_orderBy
    orderDirection: mainnet_OrderDirection
    where: mainnet_BnbConnectorMeta_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mainnet_BnbConnectorMeta!]!
  mainnet_arbitrumConnectorMeta(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mainnet_ArbitrumConnectorMeta
  mainnet_arbitrumConnectorMetas(
    skip: Int = 0
    first: Int = 100
    orderBy: mainnet_ArbitrumConnectorMeta_orderBy
    orderDirection: mainnet_OrderDirection
    where: mainnet_ArbitrumConnectorMeta_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mainnet_ArbitrumConnectorMeta!]!
  mainnet_gnosisConnectorMeta(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mainnet_GnosisConnectorMeta
  mainnet_gnosisConnectorMetas(
    skip: Int = 0
    first: Int = 100
    orderBy: mainnet_GnosisConnectorMeta_orderBy
    orderDirection: mainnet_OrderDirection
    where: mainnet_GnosisConnectorMeta_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mainnet_GnosisConnectorMeta!]!
  mainnet_lineaConnectorMeta(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mainnet_LineaConnectorMeta
  mainnet_lineaConnectorMetas(
    skip: Int = 0
    first: Int = 100
    orderBy: mainnet_LineaConnectorMeta_orderBy
    orderDirection: mainnet_OrderDirection
    where: mainnet_LineaConnectorMeta_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mainnet_LineaConnectorMeta!]!
  mainnet_metisConnectorMeta(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mainnet_MetisConnectorMeta
  mainnet_metisConnectorMetas(
    skip: Int = 0
    first: Int = 100
    orderBy: mainnet_MetisConnectorMeta_orderBy
    orderDirection: mainnet_OrderDirection
    where: mainnet_MetisConnectorMeta_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mainnet_MetisConnectorMeta!]!
  mainnet_mantleConnectorMeta(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mainnet_MantleConnectorMeta
  mainnet_mantleConnectorMetas(
    skip: Int = 0
    first: Int = 100
    orderBy: mainnet_MantleConnectorMeta_orderBy
    orderDirection: mainnet_OrderDirection
    where: mainnet_MantleConnectorMeta_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mainnet_MantleConnectorMeta!]!
  mainnet_avalancheConnectorMeta(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mainnet_AvalancheConnectorMeta
  mainnet_avalancheConnectorMetas(
    skip: Int = 0
    first: Int = 100
    orderBy: mainnet_AvalancheConnectorMeta_orderBy
    orderDirection: mainnet_OrderDirection
    where: mainnet_AvalancheConnectorMeta_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mainnet_AvalancheConnectorMeta!]!
  mainnet_baseConnectorMeta(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mainnet_BaseConnectorMeta
  mainnet_baseConnectorMetas(
    skip: Int = 0
    first: Int = 100
    orderBy: mainnet_BaseConnectorMeta_orderBy
    orderDirection: mainnet_OrderDirection
    where: mainnet_BaseConnectorMeta_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mainnet_BaseConnectorMeta!]!
  mainnet_polygonZkConnectorMeta(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mainnet_PolygonZkConnectorMeta
  mainnet_polygonZkConnectorMetas(
    skip: Int = 0
    first: Int = 100
    orderBy: mainnet_PolygonZkConnectorMeta_orderBy
    orderDirection: mainnet_OrderDirection
    where: mainnet_PolygonZkConnectorMeta_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mainnet_PolygonZkConnectorMeta!]!
  mainnet_zkSyncConnectorMeta(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mainnet_ZkSyncConnectorMeta
  mainnet_zkSyncConnectorMetas(
    skip: Int = 0
    first: Int = 100
    orderBy: mainnet_ZkSyncConnectorMeta_orderBy
    orderDirection: mainnet_OrderDirection
    where: mainnet_ZkSyncConnectorMeta_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mainnet_ZkSyncConnectorMeta!]!
  mainnet_modeConnectorMeta(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mainnet_ModeConnectorMeta
  mainnet_modeConnectorMetas(
    skip: Int = 0
    first: Int = 100
    orderBy: mainnet_ModeConnectorMeta_orderBy
    orderDirection: mainnet_OrderDirection
    where: mainnet_ModeConnectorMeta_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mainnet_ModeConnectorMeta!]!
  mainnet_scrollConnectorMeta(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mainnet_ScrollConnectorMeta
  mainnet_scrollConnectorMetas(
    skip: Int = 0
    first: Int = 100
    orderBy: mainnet_ScrollConnectorMeta_orderBy
    orderDirection: mainnet_OrderDirection
    where: mainnet_ScrollConnectorMeta_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mainnet_ScrollConnectorMeta!]!
  mainnet_xlayerConnectorMeta(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mainnet_XlayerConnectorMeta
  mainnet_xlayerConnectorMetas(
    skip: Int = 0
    first: Int = 100
    orderBy: mainnet_XlayerConnectorMeta_orderBy
    orderDirection: mainnet_OrderDirection
    where: mainnet_XlayerConnectorMeta_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mainnet_XlayerConnectorMeta!]!
  mainnet_rootMessageProcessed(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mainnet_RootMessageProcessed
  mainnet_rootMessageProcesseds(
    skip: Int = 0
    first: Int = 100
    orderBy: mainnet_RootMessageProcessed_orderBy
    orderDirection: mainnet_OrderDirection
    where: mainnet_RootMessageProcessed_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mainnet_RootMessageProcessed!]!
  mainnet_aggregateRootSavedSlow(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mainnet_AggregateRootSavedSlow
  mainnet_aggregateRootSavedSlows(
    skip: Int = 0
    first: Int = 100
    orderBy: mainnet_AggregateRootSavedSlow_orderBy
    orderDirection: mainnet_OrderDirection
    where: mainnet_AggregateRootSavedSlow_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mainnet_AggregateRootSavedSlow!]!
  mainnet_hubDomain(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mainnet_HubDomain
  mainnet_hubDomains(
    skip: Int = 0
    first: Int = 100
    orderBy: mainnet_HubDomain_orderBy
    orderDirection: mainnet_OrderDirection
    where: mainnet_HubDomain_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mainnet_HubDomain!]!
  """Access to subgraph metadata"""
  mainnet__meta(block: mainnet_Block_height): mainnet__Meta_
  polygonzkevm_asset(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygonzkevm_Asset
  polygonzkevm_assets(
    skip: Int = 0
    first: Int = 100
    orderBy: polygonzkevm_Asset_orderBy
    orderDirection: polygonzkevm_OrderDirection
    where: polygonzkevm_Asset_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygonzkevm_Asset!]!
  polygonzkevm_assetStatus(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygonzkevm_AssetStatus
  polygonzkevm_assetStatuses(
    skip: Int = 0
    first: Int = 100
    orderBy: polygonzkevm_AssetStatus_orderBy
    orderDirection: polygonzkevm_OrderDirection
    where: polygonzkevm_AssetStatus_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygonzkevm_AssetStatus!]!
  polygonzkevm_assetBalance(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygonzkevm_AssetBalance
  polygonzkevm_assetBalances(
    skip: Int = 0
    first: Int = 100
    orderBy: polygonzkevm_AssetBalance_orderBy
    orderDirection: polygonzkevm_OrderDirection
    where: polygonzkevm_AssetBalance_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygonzkevm_AssetBalance!]!
  polygonzkevm_router(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygonzkevm_Router
  polygonzkevm_routers(
    skip: Int = 0
    first: Int = 100
    orderBy: polygonzkevm_Router_orderBy
    orderDirection: polygonzkevm_OrderDirection
    where: polygonzkevm_Router_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygonzkevm_Router!]!
  polygonzkevm_routerDailyTVL(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygonzkevm_RouterDailyTVL
  polygonzkevm_routerDailyTVLs(
    skip: Int = 0
    first: Int = 100
    orderBy: polygonzkevm_RouterDailyTVL_orderBy
    orderDirection: polygonzkevm_OrderDirection
    where: polygonzkevm_RouterDailyTVL_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygonzkevm_RouterDailyTVL!]!
  polygonzkevm_routerLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygonzkevm_RouterLiquidityEvent
  polygonzkevm_routerLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: polygonzkevm_RouterLiquidityEvent_orderBy
    orderDirection: polygonzkevm_OrderDirection
    where: polygonzkevm_RouterLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygonzkevm_RouterLiquidityEvent!]!
  polygonzkevm_setting(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygonzkevm_Setting
  polygonzkevm_settings(
    skip: Int = 0
    first: Int = 100
    orderBy: polygonzkevm_Setting_orderBy
    orderDirection: polygonzkevm_OrderDirection
    where: polygonzkevm_Setting_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygonzkevm_Setting!]!
  polygonzkevm_relayer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygonzkevm_Relayer
  polygonzkevm_relayers(
    skip: Int = 0
    first: Int = 100
    orderBy: polygonzkevm_Relayer_orderBy
    orderDirection: polygonzkevm_OrderDirection
    where: polygonzkevm_Relayer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygonzkevm_Relayer!]!
  polygonzkevm_sequencer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygonzkevm_Sequencer
  polygonzkevm_sequencers(
    skip: Int = 0
    first: Int = 100
    orderBy: polygonzkevm_Sequencer_orderBy
    orderDirection: polygonzkevm_OrderDirection
    where: polygonzkevm_Sequencer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygonzkevm_Sequencer!]!
  polygonzkevm_relayerFee(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygonzkevm_RelayerFee
  polygonzkevm_relayerFees(
    skip: Int = 0
    first: Int = 100
    orderBy: polygonzkevm_RelayerFee_orderBy
    orderDirection: polygonzkevm_OrderDirection
    where: polygonzkevm_RelayerFee_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygonzkevm_RelayerFee!]!
  polygonzkevm_originTransfer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygonzkevm_OriginTransfer
  polygonzkevm_originTransfers(
    skip: Int = 0
    first: Int = 100
    orderBy: polygonzkevm_OriginTransfer_orderBy
    orderDirection: polygonzkevm_OrderDirection
    where: polygonzkevm_OriginTransfer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygonzkevm_OriginTransfer!]!
  polygonzkevm_destinationTransfer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygonzkevm_DestinationTransfer
  polygonzkevm_destinationTransfers(
    skip: Int = 0
    first: Int = 100
    orderBy: polygonzkevm_DestinationTransfer_orderBy
    orderDirection: polygonzkevm_OrderDirection
    where: polygonzkevm_DestinationTransfer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygonzkevm_DestinationTransfer!]!
  polygonzkevm_originMessage(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygonzkevm_OriginMessage
  polygonzkevm_originMessages(
    skip: Int = 0
    first: Int = 100
    orderBy: polygonzkevm_OriginMessage_orderBy
    orderDirection: polygonzkevm_OrderDirection
    where: polygonzkevm_OriginMessage_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygonzkevm_OriginMessage!]!
  polygonzkevm_aggregateRoot(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygonzkevm_AggregateRoot
  polygonzkevm_aggregateRoots(
    skip: Int = 0
    first: Int = 100
    orderBy: polygonzkevm_AggregateRoot_orderBy
    orderDirection: polygonzkevm_OrderDirection
    where: polygonzkevm_AggregateRoot_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygonzkevm_AggregateRoot!]!
  polygonzkevm_connectorMeta(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygonzkevm_ConnectorMeta
  polygonzkevm_connectorMetas(
    skip: Int = 0
    first: Int = 100
    orderBy: polygonzkevm_ConnectorMeta_orderBy
    orderDirection: polygonzkevm_OrderDirection
    where: polygonzkevm_ConnectorMeta_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygonzkevm_ConnectorMeta!]!
  polygonzkevm_rootCount(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygonzkevm_RootCount
  polygonzkevm_rootCounts(
    skip: Int = 0
    first: Int = 100
    orderBy: polygonzkevm_RootCount_orderBy
    orderDirection: polygonzkevm_OrderDirection
    where: polygonzkevm_RootCount_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygonzkevm_RootCount!]!
  polygonzkevm_rootMessageSent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygonzkevm_RootMessageSent
  polygonzkevm_rootMessageSents(
    skip: Int = 0
    first: Int = 100
    orderBy: polygonzkevm_RootMessageSent_orderBy
    orderDirection: polygonzkevm_OrderDirection
    where: polygonzkevm_RootMessageSent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygonzkevm_RootMessageSent!]!
  polygonzkevm_relayerFeesIncrease(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygonzkevm_RelayerFeesIncrease
  polygonzkevm_relayerFeesIncreases(
    skip: Int = 0
    first: Int = 100
    orderBy: polygonzkevm_RelayerFeesIncrease_orderBy
    orderDirection: polygonzkevm_OrderDirection
    where: polygonzkevm_RelayerFeesIncrease_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygonzkevm_RelayerFeesIncrease!]!
  polygonzkevm_slippageUpdate(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygonzkevm_SlippageUpdate
  polygonzkevm_slippageUpdates(
    skip: Int = 0
    first: Int = 100
    orderBy: polygonzkevm_SlippageUpdate_orderBy
    orderDirection: polygonzkevm_OrderDirection
    where: polygonzkevm_SlippageUpdate_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygonzkevm_SlippageUpdate!]!
  polygonzkevm_snapshotRoot(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygonzkevm_SnapshotRoot
  polygonzkevm_snapshotRoots(
    skip: Int = 0
    first: Int = 100
    orderBy: polygonzkevm_SnapshotRoot_orderBy
    orderDirection: polygonzkevm_OrderDirection
    where: polygonzkevm_SnapshotRoot_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygonzkevm_SnapshotRoot!]!
  polygonzkevm_spokeConnectorMode(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygonzkevm_SpokeConnectorMode
  polygonzkevm_spokeConnectorModes(
    skip: Int = 0
    first: Int = 100
    orderBy: polygonzkevm_SpokeConnectorMode_orderBy
    orderDirection: polygonzkevm_OrderDirection
    where: polygonzkevm_SpokeConnectorMode_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygonzkevm_SpokeConnectorMode!]!
  polygonzkevm_aggregateRootProposed(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygonzkevm_AggregateRootProposed
  polygonzkevm_aggregateRootProposeds(
    skip: Int = 0
    first: Int = 100
    orderBy: polygonzkevm_AggregateRootProposed_orderBy
    orderDirection: polygonzkevm_OrderDirection
    where: polygonzkevm_AggregateRootProposed_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygonzkevm_AggregateRootProposed!]!
  polygonzkevm_optimisticRootFinalized(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygonzkevm_OptimisticRootFinalized
  polygonzkevm_optimisticRootFinalizeds(
    skip: Int = 0
    first: Int = 100
    orderBy: polygonzkevm_OptimisticRootFinalized_orderBy
    orderDirection: polygonzkevm_OrderDirection
    where: polygonzkevm_OptimisticRootFinalized_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygonzkevm_OptimisticRootFinalized!]!
  """Access to subgraph metadata"""
  polygonzkevm__meta(block: polygonzkevm_Block_height): polygonzkevm__Meta_
  zksync_swap_systemInfo(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): zksync_swap_SystemInfo
  zksync_swap_systemInfos(
    skip: Int = 0
    first: Int = 100
    orderBy: zksync_swap_SystemInfo_orderBy
    orderDirection: zksync_swap_OrderDirection
    where: zksync_swap_SystemInfo_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [zksync_swap_SystemInfo!]!
  zksync_swap_pooledToken(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): zksync_swap_PooledToken
  zksync_swap_pooledTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: zksync_swap_PooledToken_orderBy
    orderDirection: zksync_swap_OrderDirection
    where: zksync_swap_PooledToken_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [zksync_swap_PooledToken!]!
  zksync_swap_stableSwap(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): zksync_swap_StableSwap
  zksync_swap_stableSwaps(
    skip: Int = 0
    first: Int = 100
    orderBy: zksync_swap_StableSwap_orderBy
    orderDirection: zksync_swap_OrderDirection
    where: zksync_swap_StableSwap_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [zksync_swap_StableSwap!]!
  zksync_swap_stableSwapAddLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): zksync_swap_StableSwapAddLiquidityEvent
  zksync_swap_stableSwapAddLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: zksync_swap_StableSwapAddLiquidityEvent_orderBy
    orderDirection: zksync_swap_OrderDirection
    where: zksync_swap_StableSwapAddLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [zksync_swap_StableSwapAddLiquidityEvent!]!
  zksync_swap_stableSwapRemoveLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): zksync_swap_StableSwapRemoveLiquidityEvent
  zksync_swap_stableSwapRemoveLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: zksync_swap_StableSwapRemoveLiquidityEvent_orderBy
    orderDirection: zksync_swap_OrderDirection
    where: zksync_swap_StableSwapRemoveLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [zksync_swap_StableSwapRemoveLiquidityEvent!]!
  zksync_swap_stableSwapExchange(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): zksync_swap_StableSwapExchange
  zksync_swap_stableSwapExchanges(
    skip: Int = 0
    first: Int = 100
    orderBy: zksync_swap_StableSwapExchange_orderBy
    orderDirection: zksync_swap_OrderDirection
    where: zksync_swap_StableSwapExchange_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [zksync_swap_StableSwapExchange!]!
  zksync_swap_swapDailyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): zksync_swap_SwapDailyVolume
  zksync_swap_swapDailyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: zksync_swap_SwapDailyVolume_orderBy
    orderDirection: zksync_swap_OrderDirection
    where: zksync_swap_SwapDailyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [zksync_swap_SwapDailyVolume!]!
  zksync_swap_swapHourlyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): zksync_swap_SwapHourlyVolume
  zksync_swap_swapHourlyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: zksync_swap_SwapHourlyVolume_orderBy
    orderDirection: zksync_swap_OrderDirection
    where: zksync_swap_SwapHourlyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [zksync_swap_SwapHourlyVolume!]!
  zksync_swap_swapWeeklyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): zksync_swap_SwapWeeklyVolume
  zksync_swap_swapWeeklyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: zksync_swap_SwapWeeklyVolume_orderBy
    orderDirection: zksync_swap_OrderDirection
    where: zksync_swap_SwapWeeklyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [zksync_swap_SwapWeeklyVolume!]!
  zksync_swap_lpAccount(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): zksync_swap_LpAccount
  zksync_swap_lpAccounts(
    skip: Int = 0
    first: Int = 100
    orderBy: zksync_swap_LpAccount_orderBy
    orderDirection: zksync_swap_OrderDirection
    where: zksync_swap_LpAccount_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [zksync_swap_LpAccount!]!
  zksync_swap_lpAccountBalance(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): zksync_swap_LpAccountBalance
  zksync_swap_lpAccountBalances(
    skip: Int = 0
    first: Int = 100
    orderBy: zksync_swap_LpAccountBalance_orderBy
    orderDirection: zksync_swap_OrderDirection
    where: zksync_swap_LpAccountBalance_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [zksync_swap_LpAccountBalance!]!
  zksync_swap_lpToken(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): zksync_swap_LpToken
  zksync_swap_lpTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: zksync_swap_LpToken_orderBy
    orderDirection: zksync_swap_OrderDirection
    where: zksync_swap_LpToken_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [zksync_swap_LpToken!]!
  zksync_swap_lpTransferEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): zksync_swap_LpTransferEvent
  zksync_swap_lpTransferEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: zksync_swap_LpTransferEvent_orderBy
    orderDirection: zksync_swap_OrderDirection
    where: zksync_swap_LpTransferEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [zksync_swap_LpTransferEvent!]!
  zksync_swap_stableSwapEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): zksync_swap_StableSwapEvent
  zksync_swap_stableSwapEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: zksync_swap_StableSwapEvent_orderBy
    orderDirection: zksync_swap_OrderDirection
    where: zksync_swap_StableSwapEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [zksync_swap_StableSwapEvent!]!
  zksync_swap_swapTradeVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): zksync_swap_SwapTradeVolume
  zksync_swap_swapTradeVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: zksync_swap_SwapTradeVolume_orderBy
    orderDirection: zksync_swap_OrderDirection
    where: zksync_swap_SwapTradeVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [zksync_swap_SwapTradeVolume!]!
  zksync_swap_lpTokenEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): zksync_swap_LpTokenEvent
  zksync_swap_lpTokenEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: zksync_swap_LpTokenEvent_orderBy
    orderDirection: zksync_swap_OrderDirection
    where: zksync_swap_LpTokenEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [zksync_swap_LpTokenEvent!]!
  """Access to subgraph metadata"""
  zksync_swap__meta(block: zksync_swap_Block_height): zksync_swap__Meta_
  linea_swap_systemInfo(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): linea_swap_SystemInfo
  linea_swap_systemInfos(
    skip: Int = 0
    first: Int = 100
    orderBy: linea_swap_SystemInfo_orderBy
    orderDirection: linea_swap_OrderDirection
    where: linea_swap_SystemInfo_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [linea_swap_SystemInfo!]!
  linea_swap_pooledToken(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): linea_swap_PooledToken
  linea_swap_pooledTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: linea_swap_PooledToken_orderBy
    orderDirection: linea_swap_OrderDirection
    where: linea_swap_PooledToken_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [linea_swap_PooledToken!]!
  linea_swap_stableSwap(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): linea_swap_StableSwap
  linea_swap_stableSwaps(
    skip: Int = 0
    first: Int = 100
    orderBy: linea_swap_StableSwap_orderBy
    orderDirection: linea_swap_OrderDirection
    where: linea_swap_StableSwap_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [linea_swap_StableSwap!]!
  linea_swap_stableSwapAddLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): linea_swap_StableSwapAddLiquidityEvent
  linea_swap_stableSwapAddLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: linea_swap_StableSwapAddLiquidityEvent_orderBy
    orderDirection: linea_swap_OrderDirection
    where: linea_swap_StableSwapAddLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [linea_swap_StableSwapAddLiquidityEvent!]!
  linea_swap_stableSwapRemoveLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): linea_swap_StableSwapRemoveLiquidityEvent
  linea_swap_stableSwapRemoveLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: linea_swap_StableSwapRemoveLiquidityEvent_orderBy
    orderDirection: linea_swap_OrderDirection
    where: linea_swap_StableSwapRemoveLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [linea_swap_StableSwapRemoveLiquidityEvent!]!
  linea_swap_stableSwapExchange(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): linea_swap_StableSwapExchange
  linea_swap_stableSwapExchanges(
    skip: Int = 0
    first: Int = 100
    orderBy: linea_swap_StableSwapExchange_orderBy
    orderDirection: linea_swap_OrderDirection
    where: linea_swap_StableSwapExchange_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [linea_swap_StableSwapExchange!]!
  linea_swap_swapDailyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): linea_swap_SwapDailyVolume
  linea_swap_swapDailyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: linea_swap_SwapDailyVolume_orderBy
    orderDirection: linea_swap_OrderDirection
    where: linea_swap_SwapDailyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [linea_swap_SwapDailyVolume!]!
  linea_swap_swapHourlyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): linea_swap_SwapHourlyVolume
  linea_swap_swapHourlyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: linea_swap_SwapHourlyVolume_orderBy
    orderDirection: linea_swap_OrderDirection
    where: linea_swap_SwapHourlyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [linea_swap_SwapHourlyVolume!]!
  linea_swap_swapWeeklyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): linea_swap_SwapWeeklyVolume
  linea_swap_swapWeeklyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: linea_swap_SwapWeeklyVolume_orderBy
    orderDirection: linea_swap_OrderDirection
    where: linea_swap_SwapWeeklyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [linea_swap_SwapWeeklyVolume!]!
  linea_swap_lpAccount(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): linea_swap_LpAccount
  linea_swap_lpAccounts(
    skip: Int = 0
    first: Int = 100
    orderBy: linea_swap_LpAccount_orderBy
    orderDirection: linea_swap_OrderDirection
    where: linea_swap_LpAccount_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [linea_swap_LpAccount!]!
  linea_swap_lpAccountBalance(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): linea_swap_LpAccountBalance
  linea_swap_lpAccountBalances(
    skip: Int = 0
    first: Int = 100
    orderBy: linea_swap_LpAccountBalance_orderBy
    orderDirection: linea_swap_OrderDirection
    where: linea_swap_LpAccountBalance_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [linea_swap_LpAccountBalance!]!
  linea_swap_lpToken(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): linea_swap_LpToken
  linea_swap_lpTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: linea_swap_LpToken_orderBy
    orderDirection: linea_swap_OrderDirection
    where: linea_swap_LpToken_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [linea_swap_LpToken!]!
  linea_swap_lpTransferEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): linea_swap_LpTransferEvent
  linea_swap_lpTransferEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: linea_swap_LpTransferEvent_orderBy
    orderDirection: linea_swap_OrderDirection
    where: linea_swap_LpTransferEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [linea_swap_LpTransferEvent!]!
  linea_swap_stableSwapEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): linea_swap_StableSwapEvent
  linea_swap_stableSwapEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: linea_swap_StableSwapEvent_orderBy
    orderDirection: linea_swap_OrderDirection
    where: linea_swap_StableSwapEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [linea_swap_StableSwapEvent!]!
  linea_swap_swapTradeVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): linea_swap_SwapTradeVolume
  linea_swap_swapTradeVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: linea_swap_SwapTradeVolume_orderBy
    orderDirection: linea_swap_OrderDirection
    where: linea_swap_SwapTradeVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [linea_swap_SwapTradeVolume!]!
  linea_swap_lpTokenEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): linea_swap_LpTokenEvent
  linea_swap_lpTokenEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: linea_swap_LpTokenEvent_orderBy
    orderDirection: linea_swap_OrderDirection
    where: linea_swap_LpTokenEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [linea_swap_LpTokenEvent!]!
  """Access to subgraph metadata"""
  linea_swap__meta(block: linea_swap_Block_height): linea_swap__Meta_
  polygon_asset(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygon_Asset
  polygon_assets(
    skip: Int = 0
    first: Int = 100
    orderBy: polygon_Asset_orderBy
    orderDirection: polygon_OrderDirection
    where: polygon_Asset_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygon_Asset!]!
  polygon_assetStatus(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygon_AssetStatus
  polygon_assetStatuses(
    skip: Int = 0
    first: Int = 100
    orderBy: polygon_AssetStatus_orderBy
    orderDirection: polygon_OrderDirection
    where: polygon_AssetStatus_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygon_AssetStatus!]!
  polygon_assetBalance(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygon_AssetBalance
  polygon_assetBalances(
    skip: Int = 0
    first: Int = 100
    orderBy: polygon_AssetBalance_orderBy
    orderDirection: polygon_OrderDirection
    where: polygon_AssetBalance_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygon_AssetBalance!]!
  polygon_router(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygon_Router
  polygon_routers(
    skip: Int = 0
    first: Int = 100
    orderBy: polygon_Router_orderBy
    orderDirection: polygon_OrderDirection
    where: polygon_Router_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygon_Router!]!
  polygon_routerDailyTVL(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygon_RouterDailyTVL
  polygon_routerDailyTVLs(
    skip: Int = 0
    first: Int = 100
    orderBy: polygon_RouterDailyTVL_orderBy
    orderDirection: polygon_OrderDirection
    where: polygon_RouterDailyTVL_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygon_RouterDailyTVL!]!
  polygon_routerLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygon_RouterLiquidityEvent
  polygon_routerLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: polygon_RouterLiquidityEvent_orderBy
    orderDirection: polygon_OrderDirection
    where: polygon_RouterLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygon_RouterLiquidityEvent!]!
  polygon_setting(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygon_Setting
  polygon_settings(
    skip: Int = 0
    first: Int = 100
    orderBy: polygon_Setting_orderBy
    orderDirection: polygon_OrderDirection
    where: polygon_Setting_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygon_Setting!]!
  polygon_relayer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygon_Relayer
  polygon_relayers(
    skip: Int = 0
    first: Int = 100
    orderBy: polygon_Relayer_orderBy
    orderDirection: polygon_OrderDirection
    where: polygon_Relayer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygon_Relayer!]!
  polygon_sequencer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygon_Sequencer
  polygon_sequencers(
    skip: Int = 0
    first: Int = 100
    orderBy: polygon_Sequencer_orderBy
    orderDirection: polygon_OrderDirection
    where: polygon_Sequencer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygon_Sequencer!]!
  polygon_relayerFee(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygon_RelayerFee
  polygon_relayerFees(
    skip: Int = 0
    first: Int = 100
    orderBy: polygon_RelayerFee_orderBy
    orderDirection: polygon_OrderDirection
    where: polygon_RelayerFee_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygon_RelayerFee!]!
  polygon_originTransfer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygon_OriginTransfer
  polygon_originTransfers(
    skip: Int = 0
    first: Int = 100
    orderBy: polygon_OriginTransfer_orderBy
    orderDirection: polygon_OrderDirection
    where: polygon_OriginTransfer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygon_OriginTransfer!]!
  polygon_destinationTransfer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygon_DestinationTransfer
  polygon_destinationTransfers(
    skip: Int = 0
    first: Int = 100
    orderBy: polygon_DestinationTransfer_orderBy
    orderDirection: polygon_OrderDirection
    where: polygon_DestinationTransfer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygon_DestinationTransfer!]!
  polygon_originMessage(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygon_OriginMessage
  polygon_originMessages(
    skip: Int = 0
    first: Int = 100
    orderBy: polygon_OriginMessage_orderBy
    orderDirection: polygon_OrderDirection
    where: polygon_OriginMessage_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygon_OriginMessage!]!
  polygon_aggregateRoot(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygon_AggregateRoot
  polygon_aggregateRoots(
    skip: Int = 0
    first: Int = 100
    orderBy: polygon_AggregateRoot_orderBy
    orderDirection: polygon_OrderDirection
    where: polygon_AggregateRoot_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygon_AggregateRoot!]!
  polygon_connectorMeta(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygon_ConnectorMeta
  polygon_connectorMetas(
    skip: Int = 0
    first: Int = 100
    orderBy: polygon_ConnectorMeta_orderBy
    orderDirection: polygon_OrderDirection
    where: polygon_ConnectorMeta_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygon_ConnectorMeta!]!
  polygon_rootCount(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygon_RootCount
  polygon_rootCounts(
    skip: Int = 0
    first: Int = 100
    orderBy: polygon_RootCount_orderBy
    orderDirection: polygon_OrderDirection
    where: polygon_RootCount_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygon_RootCount!]!
  polygon_rootMessageSent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygon_RootMessageSent
  polygon_rootMessageSents(
    skip: Int = 0
    first: Int = 100
    orderBy: polygon_RootMessageSent_orderBy
    orderDirection: polygon_OrderDirection
    where: polygon_RootMessageSent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygon_RootMessageSent!]!
  polygon_relayerFeesIncrease(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygon_RelayerFeesIncrease
  polygon_relayerFeesIncreases(
    skip: Int = 0
    first: Int = 100
    orderBy: polygon_RelayerFeesIncrease_orderBy
    orderDirection: polygon_OrderDirection
    where: polygon_RelayerFeesIncrease_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygon_RelayerFeesIncrease!]!
  polygon_slippageUpdate(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygon_SlippageUpdate
  polygon_slippageUpdates(
    skip: Int = 0
    first: Int = 100
    orderBy: polygon_SlippageUpdate_orderBy
    orderDirection: polygon_OrderDirection
    where: polygon_SlippageUpdate_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygon_SlippageUpdate!]!
  polygon_snapshotRoot(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygon_SnapshotRoot
  polygon_snapshotRoots(
    skip: Int = 0
    first: Int = 100
    orderBy: polygon_SnapshotRoot_orderBy
    orderDirection: polygon_OrderDirection
    where: polygon_SnapshotRoot_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygon_SnapshotRoot!]!
  polygon_spokeConnectorMode(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygon_SpokeConnectorMode
  polygon_spokeConnectorModes(
    skip: Int = 0
    first: Int = 100
    orderBy: polygon_SpokeConnectorMode_orderBy
    orderDirection: polygon_OrderDirection
    where: polygon_SpokeConnectorMode_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygon_SpokeConnectorMode!]!
  polygon_aggregateRootProposed(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygon_AggregateRootProposed
  polygon_aggregateRootProposeds(
    skip: Int = 0
    first: Int = 100
    orderBy: polygon_AggregateRootProposed_orderBy
    orderDirection: polygon_OrderDirection
    where: polygon_AggregateRootProposed_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygon_AggregateRootProposed!]!
  polygon_optimisticRootFinalized(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygon_OptimisticRootFinalized
  polygon_optimisticRootFinalizeds(
    skip: Int = 0
    first: Int = 100
    orderBy: polygon_OptimisticRootFinalized_orderBy
    orderDirection: polygon_OrderDirection
    where: polygon_OptimisticRootFinalized_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygon_OptimisticRootFinalized!]!
  """Access to subgraph metadata"""
  polygon__meta(block: polygon_Block_height): polygon__Meta_
  polygonzkevm_swap_asset(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygonzkevm_swap_Asset
  polygonzkevm_swap_assets(
    skip: Int = 0
    first: Int = 100
    orderBy: polygonzkevm_swap_Asset_orderBy
    orderDirection: polygonzkevm_swap_OrderDirection
    where: polygonzkevm_swap_Asset_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygonzkevm_swap_Asset!]!
  polygonzkevm_swap_assetStatus(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygonzkevm_swap_AssetStatus
  polygonzkevm_swap_assetStatuses(
    skip: Int = 0
    first: Int = 100
    orderBy: polygonzkevm_swap_AssetStatus_orderBy
    orderDirection: polygonzkevm_swap_OrderDirection
    where: polygonzkevm_swap_AssetStatus_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygonzkevm_swap_AssetStatus!]!
  polygonzkevm_swap_assetBalance(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygonzkevm_swap_AssetBalance
  polygonzkevm_swap_assetBalances(
    skip: Int = 0
    first: Int = 100
    orderBy: polygonzkevm_swap_AssetBalance_orderBy
    orderDirection: polygonzkevm_swap_OrderDirection
    where: polygonzkevm_swap_AssetBalance_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygonzkevm_swap_AssetBalance!]!
  polygonzkevm_swap_router(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygonzkevm_swap_Router
  polygonzkevm_swap_routers(
    skip: Int = 0
    first: Int = 100
    orderBy: polygonzkevm_swap_Router_orderBy
    orderDirection: polygonzkevm_swap_OrderDirection
    where: polygonzkevm_swap_Router_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygonzkevm_swap_Router!]!
  polygonzkevm_swap_routerDailyTVL(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygonzkevm_swap_RouterDailyTVL
  polygonzkevm_swap_routerDailyTVLs(
    skip: Int = 0
    first: Int = 100
    orderBy: polygonzkevm_swap_RouterDailyTVL_orderBy
    orderDirection: polygonzkevm_swap_OrderDirection
    where: polygonzkevm_swap_RouterDailyTVL_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygonzkevm_swap_RouterDailyTVL!]!
  polygonzkevm_swap_routerLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygonzkevm_swap_RouterLiquidityEvent
  polygonzkevm_swap_routerLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: polygonzkevm_swap_RouterLiquidityEvent_orderBy
    orderDirection: polygonzkevm_swap_OrderDirection
    where: polygonzkevm_swap_RouterLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygonzkevm_swap_RouterLiquidityEvent!]!
  polygonzkevm_swap_setting(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygonzkevm_swap_Setting
  polygonzkevm_swap_settings(
    skip: Int = 0
    first: Int = 100
    orderBy: polygonzkevm_swap_Setting_orderBy
    orderDirection: polygonzkevm_swap_OrderDirection
    where: polygonzkevm_swap_Setting_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygonzkevm_swap_Setting!]!
  polygonzkevm_swap_relayer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygonzkevm_swap_Relayer
  polygonzkevm_swap_relayers(
    skip: Int = 0
    first: Int = 100
    orderBy: polygonzkevm_swap_Relayer_orderBy
    orderDirection: polygonzkevm_swap_OrderDirection
    where: polygonzkevm_swap_Relayer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygonzkevm_swap_Relayer!]!
  polygonzkevm_swap_sequencer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygonzkevm_swap_Sequencer
  polygonzkevm_swap_sequencers(
    skip: Int = 0
    first: Int = 100
    orderBy: polygonzkevm_swap_Sequencer_orderBy
    orderDirection: polygonzkevm_swap_OrderDirection
    where: polygonzkevm_swap_Sequencer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygonzkevm_swap_Sequencer!]!
  polygonzkevm_swap_relayerFee(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygonzkevm_swap_RelayerFee
  polygonzkevm_swap_relayerFees(
    skip: Int = 0
    first: Int = 100
    orderBy: polygonzkevm_swap_RelayerFee_orderBy
    orderDirection: polygonzkevm_swap_OrderDirection
    where: polygonzkevm_swap_RelayerFee_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygonzkevm_swap_RelayerFee!]!
  polygonzkevm_swap_originTransfer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygonzkevm_swap_OriginTransfer
  polygonzkevm_swap_originTransfers(
    skip: Int = 0
    first: Int = 100
    orderBy: polygonzkevm_swap_OriginTransfer_orderBy
    orderDirection: polygonzkevm_swap_OrderDirection
    where: polygonzkevm_swap_OriginTransfer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygonzkevm_swap_OriginTransfer!]!
  polygonzkevm_swap_destinationTransfer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygonzkevm_swap_DestinationTransfer
  polygonzkevm_swap_destinationTransfers(
    skip: Int = 0
    first: Int = 100
    orderBy: polygonzkevm_swap_DestinationTransfer_orderBy
    orderDirection: polygonzkevm_swap_OrderDirection
    where: polygonzkevm_swap_DestinationTransfer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygonzkevm_swap_DestinationTransfer!]!
  polygonzkevm_swap_originMessage(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygonzkevm_swap_OriginMessage
  polygonzkevm_swap_originMessages(
    skip: Int = 0
    first: Int = 100
    orderBy: polygonzkevm_swap_OriginMessage_orderBy
    orderDirection: polygonzkevm_swap_OrderDirection
    where: polygonzkevm_swap_OriginMessage_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygonzkevm_swap_OriginMessage!]!
  polygonzkevm_swap_aggregateRoot(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygonzkevm_swap_AggregateRoot
  polygonzkevm_swap_aggregateRoots(
    skip: Int = 0
    first: Int = 100
    orderBy: polygonzkevm_swap_AggregateRoot_orderBy
    orderDirection: polygonzkevm_swap_OrderDirection
    where: polygonzkevm_swap_AggregateRoot_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygonzkevm_swap_AggregateRoot!]!
  polygonzkevm_swap_connectorMeta(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygonzkevm_swap_ConnectorMeta
  polygonzkevm_swap_connectorMetas(
    skip: Int = 0
    first: Int = 100
    orderBy: polygonzkevm_swap_ConnectorMeta_orderBy
    orderDirection: polygonzkevm_swap_OrderDirection
    where: polygonzkevm_swap_ConnectorMeta_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygonzkevm_swap_ConnectorMeta!]!
  polygonzkevm_swap_rootCount(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygonzkevm_swap_RootCount
  polygonzkevm_swap_rootCounts(
    skip: Int = 0
    first: Int = 100
    orderBy: polygonzkevm_swap_RootCount_orderBy
    orderDirection: polygonzkevm_swap_OrderDirection
    where: polygonzkevm_swap_RootCount_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygonzkevm_swap_RootCount!]!
  polygonzkevm_swap_rootMessageSent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygonzkevm_swap_RootMessageSent
  polygonzkevm_swap_rootMessageSents(
    skip: Int = 0
    first: Int = 100
    orderBy: polygonzkevm_swap_RootMessageSent_orderBy
    orderDirection: polygonzkevm_swap_OrderDirection
    where: polygonzkevm_swap_RootMessageSent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygonzkevm_swap_RootMessageSent!]!
  polygonzkevm_swap_relayerFeesIncrease(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygonzkevm_swap_RelayerFeesIncrease
  polygonzkevm_swap_relayerFeesIncreases(
    skip: Int = 0
    first: Int = 100
    orderBy: polygonzkevm_swap_RelayerFeesIncrease_orderBy
    orderDirection: polygonzkevm_swap_OrderDirection
    where: polygonzkevm_swap_RelayerFeesIncrease_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygonzkevm_swap_RelayerFeesIncrease!]!
  polygonzkevm_swap_slippageUpdate(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygonzkevm_swap_SlippageUpdate
  polygonzkevm_swap_slippageUpdates(
    skip: Int = 0
    first: Int = 100
    orderBy: polygonzkevm_swap_SlippageUpdate_orderBy
    orderDirection: polygonzkevm_swap_OrderDirection
    where: polygonzkevm_swap_SlippageUpdate_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygonzkevm_swap_SlippageUpdate!]!
  polygonzkevm_swap_snapshotRoot(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygonzkevm_swap_SnapshotRoot
  polygonzkevm_swap_snapshotRoots(
    skip: Int = 0
    first: Int = 100
    orderBy: polygonzkevm_swap_SnapshotRoot_orderBy
    orderDirection: polygonzkevm_swap_OrderDirection
    where: polygonzkevm_swap_SnapshotRoot_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygonzkevm_swap_SnapshotRoot!]!
  polygonzkevm_swap_spokeConnectorMode(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygonzkevm_swap_SpokeConnectorMode
  polygonzkevm_swap_spokeConnectorModes(
    skip: Int = 0
    first: Int = 100
    orderBy: polygonzkevm_swap_SpokeConnectorMode_orderBy
    orderDirection: polygonzkevm_swap_OrderDirection
    where: polygonzkevm_swap_SpokeConnectorMode_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygonzkevm_swap_SpokeConnectorMode!]!
  polygonzkevm_swap_aggregateRootProposed(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygonzkevm_swap_AggregateRootProposed
  polygonzkevm_swap_aggregateRootProposeds(
    skip: Int = 0
    first: Int = 100
    orderBy: polygonzkevm_swap_AggregateRootProposed_orderBy
    orderDirection: polygonzkevm_swap_OrderDirection
    where: polygonzkevm_swap_AggregateRootProposed_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygonzkevm_swap_AggregateRootProposed!]!
  polygonzkevm_swap_optimisticRootFinalized(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygonzkevm_swap_OptimisticRootFinalized
  polygonzkevm_swap_optimisticRootFinalizeds(
    skip: Int = 0
    first: Int = 100
    orderBy: polygonzkevm_swap_OptimisticRootFinalized_orderBy
    orderDirection: polygonzkevm_swap_OrderDirection
    where: polygonzkevm_swap_OptimisticRootFinalized_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygonzkevm_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygonzkevm_swap_OptimisticRootFinalized!]!
  """Access to subgraph metadata"""
  polygonzkevm_swap__meta(block: polygonzkevm_swap_Block_height): polygonzkevm_swap__Meta_
  zksync_asset(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): zksync_Asset
  zksync_assets(
    skip: Int = 0
    first: Int = 100
    orderBy: zksync_Asset_orderBy
    orderDirection: zksync_OrderDirection
    where: zksync_Asset_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [zksync_Asset!]!
  zksync_assetStatus(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): zksync_AssetStatus
  zksync_assetStatuses(
    skip: Int = 0
    first: Int = 100
    orderBy: zksync_AssetStatus_orderBy
    orderDirection: zksync_OrderDirection
    where: zksync_AssetStatus_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [zksync_AssetStatus!]!
  zksync_assetBalance(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): zksync_AssetBalance
  zksync_assetBalances(
    skip: Int = 0
    first: Int = 100
    orderBy: zksync_AssetBalance_orderBy
    orderDirection: zksync_OrderDirection
    where: zksync_AssetBalance_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [zksync_AssetBalance!]!
  zksync_router(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): zksync_Router
  zksync_routers(
    skip: Int = 0
    first: Int = 100
    orderBy: zksync_Router_orderBy
    orderDirection: zksync_OrderDirection
    where: zksync_Router_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [zksync_Router!]!
  zksync_routerDailyTVL(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): zksync_RouterDailyTVL
  zksync_routerDailyTVLs(
    skip: Int = 0
    first: Int = 100
    orderBy: zksync_RouterDailyTVL_orderBy
    orderDirection: zksync_OrderDirection
    where: zksync_RouterDailyTVL_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [zksync_RouterDailyTVL!]!
  zksync_routerLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): zksync_RouterLiquidityEvent
  zksync_routerLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: zksync_RouterLiquidityEvent_orderBy
    orderDirection: zksync_OrderDirection
    where: zksync_RouterLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [zksync_RouterLiquidityEvent!]!
  zksync_setting(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): zksync_Setting
  zksync_settings(
    skip: Int = 0
    first: Int = 100
    orderBy: zksync_Setting_orderBy
    orderDirection: zksync_OrderDirection
    where: zksync_Setting_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [zksync_Setting!]!
  zksync_relayer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): zksync_Relayer
  zksync_relayers(
    skip: Int = 0
    first: Int = 100
    orderBy: zksync_Relayer_orderBy
    orderDirection: zksync_OrderDirection
    where: zksync_Relayer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [zksync_Relayer!]!
  zksync_sequencer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): zksync_Sequencer
  zksync_sequencers(
    skip: Int = 0
    first: Int = 100
    orderBy: zksync_Sequencer_orderBy
    orderDirection: zksync_OrderDirection
    where: zksync_Sequencer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [zksync_Sequencer!]!
  zksync_relayerFee(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): zksync_RelayerFee
  zksync_relayerFees(
    skip: Int = 0
    first: Int = 100
    orderBy: zksync_RelayerFee_orderBy
    orderDirection: zksync_OrderDirection
    where: zksync_RelayerFee_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [zksync_RelayerFee!]!
  zksync_originTransfer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): zksync_OriginTransfer
  zksync_originTransfers(
    skip: Int = 0
    first: Int = 100
    orderBy: zksync_OriginTransfer_orderBy
    orderDirection: zksync_OrderDirection
    where: zksync_OriginTransfer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [zksync_OriginTransfer!]!
  zksync_destinationTransfer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): zksync_DestinationTransfer
  zksync_destinationTransfers(
    skip: Int = 0
    first: Int = 100
    orderBy: zksync_DestinationTransfer_orderBy
    orderDirection: zksync_OrderDirection
    where: zksync_DestinationTransfer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [zksync_DestinationTransfer!]!
  zksync_originMessage(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): zksync_OriginMessage
  zksync_originMessages(
    skip: Int = 0
    first: Int = 100
    orderBy: zksync_OriginMessage_orderBy
    orderDirection: zksync_OrderDirection
    where: zksync_OriginMessage_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [zksync_OriginMessage!]!
  zksync_aggregateRoot(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): zksync_AggregateRoot
  zksync_aggregateRoots(
    skip: Int = 0
    first: Int = 100
    orderBy: zksync_AggregateRoot_orderBy
    orderDirection: zksync_OrderDirection
    where: zksync_AggregateRoot_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [zksync_AggregateRoot!]!
  zksync_connectorMeta(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): zksync_ConnectorMeta
  zksync_connectorMetas(
    skip: Int = 0
    first: Int = 100
    orderBy: zksync_ConnectorMeta_orderBy
    orderDirection: zksync_OrderDirection
    where: zksync_ConnectorMeta_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [zksync_ConnectorMeta!]!
  zksync_rootCount(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): zksync_RootCount
  zksync_rootCounts(
    skip: Int = 0
    first: Int = 100
    orderBy: zksync_RootCount_orderBy
    orderDirection: zksync_OrderDirection
    where: zksync_RootCount_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [zksync_RootCount!]!
  zksync_rootMessageSent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): zksync_RootMessageSent
  zksync_rootMessageSents(
    skip: Int = 0
    first: Int = 100
    orderBy: zksync_RootMessageSent_orderBy
    orderDirection: zksync_OrderDirection
    where: zksync_RootMessageSent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [zksync_RootMessageSent!]!
  zksync_relayerFeesIncrease(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): zksync_RelayerFeesIncrease
  zksync_relayerFeesIncreases(
    skip: Int = 0
    first: Int = 100
    orderBy: zksync_RelayerFeesIncrease_orderBy
    orderDirection: zksync_OrderDirection
    where: zksync_RelayerFeesIncrease_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [zksync_RelayerFeesIncrease!]!
  zksync_slippageUpdate(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): zksync_SlippageUpdate
  zksync_slippageUpdates(
    skip: Int = 0
    first: Int = 100
    orderBy: zksync_SlippageUpdate_orderBy
    orderDirection: zksync_OrderDirection
    where: zksync_SlippageUpdate_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [zksync_SlippageUpdate!]!
  zksync_snapshotRoot(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): zksync_SnapshotRoot
  zksync_snapshotRoots(
    skip: Int = 0
    first: Int = 100
    orderBy: zksync_SnapshotRoot_orderBy
    orderDirection: zksync_OrderDirection
    where: zksync_SnapshotRoot_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [zksync_SnapshotRoot!]!
  zksync_spokeConnectorMode(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): zksync_SpokeConnectorMode
  zksync_spokeConnectorModes(
    skip: Int = 0
    first: Int = 100
    orderBy: zksync_SpokeConnectorMode_orderBy
    orderDirection: zksync_OrderDirection
    where: zksync_SpokeConnectorMode_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [zksync_SpokeConnectorMode!]!
  zksync_aggregateRootProposed(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): zksync_AggregateRootProposed
  zksync_aggregateRootProposeds(
    skip: Int = 0
    first: Int = 100
    orderBy: zksync_AggregateRootProposed_orderBy
    orderDirection: zksync_OrderDirection
    where: zksync_AggregateRootProposed_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [zksync_AggregateRootProposed!]!
  zksync_optimisticRootFinalized(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): zksync_OptimisticRootFinalized
  zksync_optimisticRootFinalizeds(
    skip: Int = 0
    first: Int = 100
    orderBy: zksync_OptimisticRootFinalized_orderBy
    orderDirection: zksync_OrderDirection
    where: zksync_OptimisticRootFinalized_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: zksync_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [zksync_OptimisticRootFinalized!]!
  """Access to subgraph metadata"""
  zksync__meta(block: zksync_Block_height): zksync__Meta_
  linea_asset(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): linea_Asset
  linea_assets(
    skip: Int = 0
    first: Int = 100
    orderBy: linea_Asset_orderBy
    orderDirection: linea_OrderDirection
    where: linea_Asset_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [linea_Asset!]!
  linea_assetStatus(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): linea_AssetStatus
  linea_assetStatuses(
    skip: Int = 0
    first: Int = 100
    orderBy: linea_AssetStatus_orderBy
    orderDirection: linea_OrderDirection
    where: linea_AssetStatus_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [linea_AssetStatus!]!
  linea_assetBalance(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): linea_AssetBalance
  linea_assetBalances(
    skip: Int = 0
    first: Int = 100
    orderBy: linea_AssetBalance_orderBy
    orderDirection: linea_OrderDirection
    where: linea_AssetBalance_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [linea_AssetBalance!]!
  linea_router(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): linea_Router
  linea_routers(
    skip: Int = 0
    first: Int = 100
    orderBy: linea_Router_orderBy
    orderDirection: linea_OrderDirection
    where: linea_Router_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [linea_Router!]!
  linea_routerDailyTVL(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): linea_RouterDailyTVL
  linea_routerDailyTVLs(
    skip: Int = 0
    first: Int = 100
    orderBy: linea_RouterDailyTVL_orderBy
    orderDirection: linea_OrderDirection
    where: linea_RouterDailyTVL_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [linea_RouterDailyTVL!]!
  linea_routerLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): linea_RouterLiquidityEvent
  linea_routerLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: linea_RouterLiquidityEvent_orderBy
    orderDirection: linea_OrderDirection
    where: linea_RouterLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [linea_RouterLiquidityEvent!]!
  linea_setting(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): linea_Setting
  linea_settings(
    skip: Int = 0
    first: Int = 100
    orderBy: linea_Setting_orderBy
    orderDirection: linea_OrderDirection
    where: linea_Setting_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [linea_Setting!]!
  linea_relayer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): linea_Relayer
  linea_relayers(
    skip: Int = 0
    first: Int = 100
    orderBy: linea_Relayer_orderBy
    orderDirection: linea_OrderDirection
    where: linea_Relayer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [linea_Relayer!]!
  linea_sequencer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): linea_Sequencer
  linea_sequencers(
    skip: Int = 0
    first: Int = 100
    orderBy: linea_Sequencer_orderBy
    orderDirection: linea_OrderDirection
    where: linea_Sequencer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [linea_Sequencer!]!
  linea_relayerFee(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): linea_RelayerFee
  linea_relayerFees(
    skip: Int = 0
    first: Int = 100
    orderBy: linea_RelayerFee_orderBy
    orderDirection: linea_OrderDirection
    where: linea_RelayerFee_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [linea_RelayerFee!]!
  linea_originTransfer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): linea_OriginTransfer
  linea_originTransfers(
    skip: Int = 0
    first: Int = 100
    orderBy: linea_OriginTransfer_orderBy
    orderDirection: linea_OrderDirection
    where: linea_OriginTransfer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [linea_OriginTransfer!]!
  linea_destinationTransfer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): linea_DestinationTransfer
  linea_destinationTransfers(
    skip: Int = 0
    first: Int = 100
    orderBy: linea_DestinationTransfer_orderBy
    orderDirection: linea_OrderDirection
    where: linea_DestinationTransfer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [linea_DestinationTransfer!]!
  linea_originMessage(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): linea_OriginMessage
  linea_originMessages(
    skip: Int = 0
    first: Int = 100
    orderBy: linea_OriginMessage_orderBy
    orderDirection: linea_OrderDirection
    where: linea_OriginMessage_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [linea_OriginMessage!]!
  linea_aggregateRoot(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): linea_AggregateRoot
  linea_aggregateRoots(
    skip: Int = 0
    first: Int = 100
    orderBy: linea_AggregateRoot_orderBy
    orderDirection: linea_OrderDirection
    where: linea_AggregateRoot_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [linea_AggregateRoot!]!
  linea_connectorMeta(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): linea_ConnectorMeta
  linea_connectorMetas(
    skip: Int = 0
    first: Int = 100
    orderBy: linea_ConnectorMeta_orderBy
    orderDirection: linea_OrderDirection
    where: linea_ConnectorMeta_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [linea_ConnectorMeta!]!
  linea_rootCount(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): linea_RootCount
  linea_rootCounts(
    skip: Int = 0
    first: Int = 100
    orderBy: linea_RootCount_orderBy
    orderDirection: linea_OrderDirection
    where: linea_RootCount_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [linea_RootCount!]!
  linea_rootMessageSent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): linea_RootMessageSent
  linea_rootMessageSents(
    skip: Int = 0
    first: Int = 100
    orderBy: linea_RootMessageSent_orderBy
    orderDirection: linea_OrderDirection
    where: linea_RootMessageSent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [linea_RootMessageSent!]!
  linea_relayerFeesIncrease(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): linea_RelayerFeesIncrease
  linea_relayerFeesIncreases(
    skip: Int = 0
    first: Int = 100
    orderBy: linea_RelayerFeesIncrease_orderBy
    orderDirection: linea_OrderDirection
    where: linea_RelayerFeesIncrease_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [linea_RelayerFeesIncrease!]!
  linea_slippageUpdate(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): linea_SlippageUpdate
  linea_slippageUpdates(
    skip: Int = 0
    first: Int = 100
    orderBy: linea_SlippageUpdate_orderBy
    orderDirection: linea_OrderDirection
    where: linea_SlippageUpdate_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [linea_SlippageUpdate!]!
  linea_snapshotRoot(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): linea_SnapshotRoot
  linea_snapshotRoots(
    skip: Int = 0
    first: Int = 100
    orderBy: linea_SnapshotRoot_orderBy
    orderDirection: linea_OrderDirection
    where: linea_SnapshotRoot_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [linea_SnapshotRoot!]!
  linea_spokeConnectorMode(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): linea_SpokeConnectorMode
  linea_spokeConnectorModes(
    skip: Int = 0
    first: Int = 100
    orderBy: linea_SpokeConnectorMode_orderBy
    orderDirection: linea_OrderDirection
    where: linea_SpokeConnectorMode_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [linea_SpokeConnectorMode!]!
  linea_aggregateRootProposed(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): linea_AggregateRootProposed
  linea_aggregateRootProposeds(
    skip: Int = 0
    first: Int = 100
    orderBy: linea_AggregateRootProposed_orderBy
    orderDirection: linea_OrderDirection
    where: linea_AggregateRootProposed_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [linea_AggregateRootProposed!]!
  linea_optimisticRootFinalized(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): linea_OptimisticRootFinalized
  linea_optimisticRootFinalizeds(
    skip: Int = 0
    first: Int = 100
    orderBy: linea_OptimisticRootFinalized_orderBy
    orderDirection: linea_OrderDirection
    where: linea_OptimisticRootFinalized_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: linea_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [linea_OptimisticRootFinalized!]!
  """Access to subgraph metadata"""
  linea__meta(block: linea_Block_height): linea__Meta_
  metis_asset(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): metis_Asset
  metis_assets(
    skip: Int = 0
    first: Int = 100
    orderBy: metis_Asset_orderBy
    orderDirection: metis_OrderDirection
    where: metis_Asset_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [metis_Asset!]!
  metis_assetStatus(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): metis_AssetStatus
  metis_assetStatuses(
    skip: Int = 0
    first: Int = 100
    orderBy: metis_AssetStatus_orderBy
    orderDirection: metis_OrderDirection
    where: metis_AssetStatus_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [metis_AssetStatus!]!
  metis_assetBalance(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): metis_AssetBalance
  metis_assetBalances(
    skip: Int = 0
    first: Int = 100
    orderBy: metis_AssetBalance_orderBy
    orderDirection: metis_OrderDirection
    where: metis_AssetBalance_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [metis_AssetBalance!]!
  metis_router(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): metis_Router
  metis_routers(
    skip: Int = 0
    first: Int = 100
    orderBy: metis_Router_orderBy
    orderDirection: metis_OrderDirection
    where: metis_Router_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [metis_Router!]!
  metis_routerDailyTVL(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): metis_RouterDailyTVL
  metis_routerDailyTVLs(
    skip: Int = 0
    first: Int = 100
    orderBy: metis_RouterDailyTVL_orderBy
    orderDirection: metis_OrderDirection
    where: metis_RouterDailyTVL_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [metis_RouterDailyTVL!]!
  metis_routerLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): metis_RouterLiquidityEvent
  metis_routerLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: metis_RouterLiquidityEvent_orderBy
    orderDirection: metis_OrderDirection
    where: metis_RouterLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [metis_RouterLiquidityEvent!]!
  metis_setting(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): metis_Setting
  metis_settings(
    skip: Int = 0
    first: Int = 100
    orderBy: metis_Setting_orderBy
    orderDirection: metis_OrderDirection
    where: metis_Setting_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [metis_Setting!]!
  metis_relayer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): metis_Relayer
  metis_relayers(
    skip: Int = 0
    first: Int = 100
    orderBy: metis_Relayer_orderBy
    orderDirection: metis_OrderDirection
    where: metis_Relayer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [metis_Relayer!]!
  metis_sequencer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): metis_Sequencer
  metis_sequencers(
    skip: Int = 0
    first: Int = 100
    orderBy: metis_Sequencer_orderBy
    orderDirection: metis_OrderDirection
    where: metis_Sequencer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [metis_Sequencer!]!
  metis_relayerFee(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): metis_RelayerFee
  metis_relayerFees(
    skip: Int = 0
    first: Int = 100
    orderBy: metis_RelayerFee_orderBy
    orderDirection: metis_OrderDirection
    where: metis_RelayerFee_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [metis_RelayerFee!]!
  metis_originTransfer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): metis_OriginTransfer
  metis_originTransfers(
    skip: Int = 0
    first: Int = 100
    orderBy: metis_OriginTransfer_orderBy
    orderDirection: metis_OrderDirection
    where: metis_OriginTransfer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [metis_OriginTransfer!]!
  metis_destinationTransfer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): metis_DestinationTransfer
  metis_destinationTransfers(
    skip: Int = 0
    first: Int = 100
    orderBy: metis_DestinationTransfer_orderBy
    orderDirection: metis_OrderDirection
    where: metis_DestinationTransfer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [metis_DestinationTransfer!]!
  metis_originMessage(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): metis_OriginMessage
  metis_originMessages(
    skip: Int = 0
    first: Int = 100
    orderBy: metis_OriginMessage_orderBy
    orderDirection: metis_OrderDirection
    where: metis_OriginMessage_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [metis_OriginMessage!]!
  metis_aggregateRoot(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): metis_AggregateRoot
  metis_aggregateRoots(
    skip: Int = 0
    first: Int = 100
    orderBy: metis_AggregateRoot_orderBy
    orderDirection: metis_OrderDirection
    where: metis_AggregateRoot_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [metis_AggregateRoot!]!
  metis_connectorMeta(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): metis_ConnectorMeta
  metis_connectorMetas(
    skip: Int = 0
    first: Int = 100
    orderBy: metis_ConnectorMeta_orderBy
    orderDirection: metis_OrderDirection
    where: metis_ConnectorMeta_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [metis_ConnectorMeta!]!
  metis_rootCount(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): metis_RootCount
  metis_rootCounts(
    skip: Int = 0
    first: Int = 100
    orderBy: metis_RootCount_orderBy
    orderDirection: metis_OrderDirection
    where: metis_RootCount_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [metis_RootCount!]!
  metis_rootMessageSent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): metis_RootMessageSent
  metis_rootMessageSents(
    skip: Int = 0
    first: Int = 100
    orderBy: metis_RootMessageSent_orderBy
    orderDirection: metis_OrderDirection
    where: metis_RootMessageSent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [metis_RootMessageSent!]!
  metis_relayerFeesIncrease(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): metis_RelayerFeesIncrease
  metis_relayerFeesIncreases(
    skip: Int = 0
    first: Int = 100
    orderBy: metis_RelayerFeesIncrease_orderBy
    orderDirection: metis_OrderDirection
    where: metis_RelayerFeesIncrease_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [metis_RelayerFeesIncrease!]!
  metis_slippageUpdate(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): metis_SlippageUpdate
  metis_slippageUpdates(
    skip: Int = 0
    first: Int = 100
    orderBy: metis_SlippageUpdate_orderBy
    orderDirection: metis_OrderDirection
    where: metis_SlippageUpdate_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [metis_SlippageUpdate!]!
  metis_snapshotRoot(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): metis_SnapshotRoot
  metis_snapshotRoots(
    skip: Int = 0
    first: Int = 100
    orderBy: metis_SnapshotRoot_orderBy
    orderDirection: metis_OrderDirection
    where: metis_SnapshotRoot_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [metis_SnapshotRoot!]!
  metis_spokeConnectorMode(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): metis_SpokeConnectorMode
  metis_spokeConnectorModes(
    skip: Int = 0
    first: Int = 100
    orderBy: metis_SpokeConnectorMode_orderBy
    orderDirection: metis_OrderDirection
    where: metis_SpokeConnectorMode_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [metis_SpokeConnectorMode!]!
  metis_aggregateRootProposed(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): metis_AggregateRootProposed
  metis_aggregateRootProposeds(
    skip: Int = 0
    first: Int = 100
    orderBy: metis_AggregateRootProposed_orderBy
    orderDirection: metis_OrderDirection
    where: metis_AggregateRootProposed_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [metis_AggregateRootProposed!]!
  metis_optimisticRootFinalized(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): metis_OptimisticRootFinalized
  metis_optimisticRootFinalizeds(
    skip: Int = 0
    first: Int = 100
    orderBy: metis_OptimisticRootFinalized_orderBy
    orderDirection: metis_OrderDirection
    where: metis_OptimisticRootFinalized_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: metis_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [metis_OptimisticRootFinalized!]!
  """Access to subgraph metadata"""
  metis__meta(block: metis_Block_height): metis__Meta_
  optimism_asset(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): optimism_Asset
  optimism_assets(
    skip: Int = 0
    first: Int = 100
    orderBy: optimism_Asset_orderBy
    orderDirection: optimism_OrderDirection
    where: optimism_Asset_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [optimism_Asset!]!
  optimism_assetStatus(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): optimism_AssetStatus
  optimism_assetStatuses(
    skip: Int = 0
    first: Int = 100
    orderBy: optimism_AssetStatus_orderBy
    orderDirection: optimism_OrderDirection
    where: optimism_AssetStatus_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [optimism_AssetStatus!]!
  optimism_assetBalance(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): optimism_AssetBalance
  optimism_assetBalances(
    skip: Int = 0
    first: Int = 100
    orderBy: optimism_AssetBalance_orderBy
    orderDirection: optimism_OrderDirection
    where: optimism_AssetBalance_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [optimism_AssetBalance!]!
  optimism_router(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): optimism_Router
  optimism_routers(
    skip: Int = 0
    first: Int = 100
    orderBy: optimism_Router_orderBy
    orderDirection: optimism_OrderDirection
    where: optimism_Router_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [optimism_Router!]!
  optimism_routerDailyTVL(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): optimism_RouterDailyTVL
  optimism_routerDailyTVLs(
    skip: Int = 0
    first: Int = 100
    orderBy: optimism_RouterDailyTVL_orderBy
    orderDirection: optimism_OrderDirection
    where: optimism_RouterDailyTVL_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [optimism_RouterDailyTVL!]!
  optimism_routerLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): optimism_RouterLiquidityEvent
  optimism_routerLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: optimism_RouterLiquidityEvent_orderBy
    orderDirection: optimism_OrderDirection
    where: optimism_RouterLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [optimism_RouterLiquidityEvent!]!
  optimism_setting(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): optimism_Setting
  optimism_settings(
    skip: Int = 0
    first: Int = 100
    orderBy: optimism_Setting_orderBy
    orderDirection: optimism_OrderDirection
    where: optimism_Setting_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [optimism_Setting!]!
  optimism_relayer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): optimism_Relayer
  optimism_relayers(
    skip: Int = 0
    first: Int = 100
    orderBy: optimism_Relayer_orderBy
    orderDirection: optimism_OrderDirection
    where: optimism_Relayer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [optimism_Relayer!]!
  optimism_sequencer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): optimism_Sequencer
  optimism_sequencers(
    skip: Int = 0
    first: Int = 100
    orderBy: optimism_Sequencer_orderBy
    orderDirection: optimism_OrderDirection
    where: optimism_Sequencer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [optimism_Sequencer!]!
  optimism_relayerFee(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): optimism_RelayerFee
  optimism_relayerFees(
    skip: Int = 0
    first: Int = 100
    orderBy: optimism_RelayerFee_orderBy
    orderDirection: optimism_OrderDirection
    where: optimism_RelayerFee_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [optimism_RelayerFee!]!
  optimism_originTransfer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): optimism_OriginTransfer
  optimism_originTransfers(
    skip: Int = 0
    first: Int = 100
    orderBy: optimism_OriginTransfer_orderBy
    orderDirection: optimism_OrderDirection
    where: optimism_OriginTransfer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [optimism_OriginTransfer!]!
  optimism_destinationTransfer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): optimism_DestinationTransfer
  optimism_destinationTransfers(
    skip: Int = 0
    first: Int = 100
    orderBy: optimism_DestinationTransfer_orderBy
    orderDirection: optimism_OrderDirection
    where: optimism_DestinationTransfer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [optimism_DestinationTransfer!]!
  optimism_originMessage(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): optimism_OriginMessage
  optimism_originMessages(
    skip: Int = 0
    first: Int = 100
    orderBy: optimism_OriginMessage_orderBy
    orderDirection: optimism_OrderDirection
    where: optimism_OriginMessage_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [optimism_OriginMessage!]!
  optimism_aggregateRoot(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): optimism_AggregateRoot
  optimism_aggregateRoots(
    skip: Int = 0
    first: Int = 100
    orderBy: optimism_AggregateRoot_orderBy
    orderDirection: optimism_OrderDirection
    where: optimism_AggregateRoot_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [optimism_AggregateRoot!]!
  optimism_connectorMeta(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): optimism_ConnectorMeta
  optimism_connectorMetas(
    skip: Int = 0
    first: Int = 100
    orderBy: optimism_ConnectorMeta_orderBy
    orderDirection: optimism_OrderDirection
    where: optimism_ConnectorMeta_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [optimism_ConnectorMeta!]!
  optimism_rootCount(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): optimism_RootCount
  optimism_rootCounts(
    skip: Int = 0
    first: Int = 100
    orderBy: optimism_RootCount_orderBy
    orderDirection: optimism_OrderDirection
    where: optimism_RootCount_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [optimism_RootCount!]!
  optimism_rootMessageSent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): optimism_RootMessageSent
  optimism_rootMessageSents(
    skip: Int = 0
    first: Int = 100
    orderBy: optimism_RootMessageSent_orderBy
    orderDirection: optimism_OrderDirection
    where: optimism_RootMessageSent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [optimism_RootMessageSent!]!
  optimism_relayerFeesIncrease(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): optimism_RelayerFeesIncrease
  optimism_relayerFeesIncreases(
    skip: Int = 0
    first: Int = 100
    orderBy: optimism_RelayerFeesIncrease_orderBy
    orderDirection: optimism_OrderDirection
    where: optimism_RelayerFeesIncrease_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [optimism_RelayerFeesIncrease!]!
  optimism_slippageUpdate(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): optimism_SlippageUpdate
  optimism_slippageUpdates(
    skip: Int = 0
    first: Int = 100
    orderBy: optimism_SlippageUpdate_orderBy
    orderDirection: optimism_OrderDirection
    where: optimism_SlippageUpdate_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [optimism_SlippageUpdate!]!
  optimism_snapshotRoot(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): optimism_SnapshotRoot
  optimism_snapshotRoots(
    skip: Int = 0
    first: Int = 100
    orderBy: optimism_SnapshotRoot_orderBy
    orderDirection: optimism_OrderDirection
    where: optimism_SnapshotRoot_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [optimism_SnapshotRoot!]!
  optimism_spokeConnectorMode(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): optimism_SpokeConnectorMode
  optimism_spokeConnectorModes(
    skip: Int = 0
    first: Int = 100
    orderBy: optimism_SpokeConnectorMode_orderBy
    orderDirection: optimism_OrderDirection
    where: optimism_SpokeConnectorMode_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [optimism_SpokeConnectorMode!]!
  optimism_aggregateRootProposed(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): optimism_AggregateRootProposed
  optimism_aggregateRootProposeds(
    skip: Int = 0
    first: Int = 100
    orderBy: optimism_AggregateRootProposed_orderBy
    orderDirection: optimism_OrderDirection
    where: optimism_AggregateRootProposed_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [optimism_AggregateRootProposed!]!
  optimism_optimisticRootFinalized(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): optimism_OptimisticRootFinalized
  optimism_optimisticRootFinalizeds(
    skip: Int = 0
    first: Int = 100
    orderBy: optimism_OptimisticRootFinalized_orderBy
    orderDirection: optimism_OrderDirection
    where: optimism_OptimisticRootFinalized_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [optimism_OptimisticRootFinalized!]!
  """Access to subgraph metadata"""
  optimism__meta(block: optimism_Block_height): optimism__Meta_
  avalanche_asset(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): avalanche_Asset
  avalanche_assets(
    skip: Int = 0
    first: Int = 100
    orderBy: avalanche_Asset_orderBy
    orderDirection: avalanche_OrderDirection
    where: avalanche_Asset_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [avalanche_Asset!]!
  avalanche_assetStatus(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): avalanche_AssetStatus
  avalanche_assetStatuses(
    skip: Int = 0
    first: Int = 100
    orderBy: avalanche_AssetStatus_orderBy
    orderDirection: avalanche_OrderDirection
    where: avalanche_AssetStatus_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [avalanche_AssetStatus!]!
  avalanche_assetBalance(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): avalanche_AssetBalance
  avalanche_assetBalances(
    skip: Int = 0
    first: Int = 100
    orderBy: avalanche_AssetBalance_orderBy
    orderDirection: avalanche_OrderDirection
    where: avalanche_AssetBalance_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [avalanche_AssetBalance!]!
  avalanche_router(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): avalanche_Router
  avalanche_routers(
    skip: Int = 0
    first: Int = 100
    orderBy: avalanche_Router_orderBy
    orderDirection: avalanche_OrderDirection
    where: avalanche_Router_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [avalanche_Router!]!
  avalanche_routerDailyTVL(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): avalanche_RouterDailyTVL
  avalanche_routerDailyTVLs(
    skip: Int = 0
    first: Int = 100
    orderBy: avalanche_RouterDailyTVL_orderBy
    orderDirection: avalanche_OrderDirection
    where: avalanche_RouterDailyTVL_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [avalanche_RouterDailyTVL!]!
  avalanche_routerLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): avalanche_RouterLiquidityEvent
  avalanche_routerLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: avalanche_RouterLiquidityEvent_orderBy
    orderDirection: avalanche_OrderDirection
    where: avalanche_RouterLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [avalanche_RouterLiquidityEvent!]!
  avalanche_setting(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): avalanche_Setting
  avalanche_settings(
    skip: Int = 0
    first: Int = 100
    orderBy: avalanche_Setting_orderBy
    orderDirection: avalanche_OrderDirection
    where: avalanche_Setting_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [avalanche_Setting!]!
  avalanche_relayer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): avalanche_Relayer
  avalanche_relayers(
    skip: Int = 0
    first: Int = 100
    orderBy: avalanche_Relayer_orderBy
    orderDirection: avalanche_OrderDirection
    where: avalanche_Relayer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [avalanche_Relayer!]!
  avalanche_sequencer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): avalanche_Sequencer
  avalanche_sequencers(
    skip: Int = 0
    first: Int = 100
    orderBy: avalanche_Sequencer_orderBy
    orderDirection: avalanche_OrderDirection
    where: avalanche_Sequencer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [avalanche_Sequencer!]!
  avalanche_relayerFee(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): avalanche_RelayerFee
  avalanche_relayerFees(
    skip: Int = 0
    first: Int = 100
    orderBy: avalanche_RelayerFee_orderBy
    orderDirection: avalanche_OrderDirection
    where: avalanche_RelayerFee_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [avalanche_RelayerFee!]!
  avalanche_originTransfer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): avalanche_OriginTransfer
  avalanche_originTransfers(
    skip: Int = 0
    first: Int = 100
    orderBy: avalanche_OriginTransfer_orderBy
    orderDirection: avalanche_OrderDirection
    where: avalanche_OriginTransfer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [avalanche_OriginTransfer!]!
  avalanche_destinationTransfer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): avalanche_DestinationTransfer
  avalanche_destinationTransfers(
    skip: Int = 0
    first: Int = 100
    orderBy: avalanche_DestinationTransfer_orderBy
    orderDirection: avalanche_OrderDirection
    where: avalanche_DestinationTransfer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [avalanche_DestinationTransfer!]!
  avalanche_originMessage(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): avalanche_OriginMessage
  avalanche_originMessages(
    skip: Int = 0
    first: Int = 100
    orderBy: avalanche_OriginMessage_orderBy
    orderDirection: avalanche_OrderDirection
    where: avalanche_OriginMessage_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [avalanche_OriginMessage!]!
  avalanche_aggregateRoot(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): avalanche_AggregateRoot
  avalanche_aggregateRoots(
    skip: Int = 0
    first: Int = 100
    orderBy: avalanche_AggregateRoot_orderBy
    orderDirection: avalanche_OrderDirection
    where: avalanche_AggregateRoot_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [avalanche_AggregateRoot!]!
  avalanche_connectorMeta(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): avalanche_ConnectorMeta
  avalanche_connectorMetas(
    skip: Int = 0
    first: Int = 100
    orderBy: avalanche_ConnectorMeta_orderBy
    orderDirection: avalanche_OrderDirection
    where: avalanche_ConnectorMeta_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [avalanche_ConnectorMeta!]!
  avalanche_rootCount(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): avalanche_RootCount
  avalanche_rootCounts(
    skip: Int = 0
    first: Int = 100
    orderBy: avalanche_RootCount_orderBy
    orderDirection: avalanche_OrderDirection
    where: avalanche_RootCount_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [avalanche_RootCount!]!
  avalanche_rootMessageSent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): avalanche_RootMessageSent
  avalanche_rootMessageSents(
    skip: Int = 0
    first: Int = 100
    orderBy: avalanche_RootMessageSent_orderBy
    orderDirection: avalanche_OrderDirection
    where: avalanche_RootMessageSent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [avalanche_RootMessageSent!]!
  avalanche_relayerFeesIncrease(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): avalanche_RelayerFeesIncrease
  avalanche_relayerFeesIncreases(
    skip: Int = 0
    first: Int = 100
    orderBy: avalanche_RelayerFeesIncrease_orderBy
    orderDirection: avalanche_OrderDirection
    where: avalanche_RelayerFeesIncrease_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [avalanche_RelayerFeesIncrease!]!
  avalanche_slippageUpdate(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): avalanche_SlippageUpdate
  avalanche_slippageUpdates(
    skip: Int = 0
    first: Int = 100
    orderBy: avalanche_SlippageUpdate_orderBy
    orderDirection: avalanche_OrderDirection
    where: avalanche_SlippageUpdate_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [avalanche_SlippageUpdate!]!
  avalanche_snapshotRoot(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): avalanche_SnapshotRoot
  avalanche_snapshotRoots(
    skip: Int = 0
    first: Int = 100
    orderBy: avalanche_SnapshotRoot_orderBy
    orderDirection: avalanche_OrderDirection
    where: avalanche_SnapshotRoot_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [avalanche_SnapshotRoot!]!
  avalanche_spokeConnectorMode(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): avalanche_SpokeConnectorMode
  avalanche_spokeConnectorModes(
    skip: Int = 0
    first: Int = 100
    orderBy: avalanche_SpokeConnectorMode_orderBy
    orderDirection: avalanche_OrderDirection
    where: avalanche_SpokeConnectorMode_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [avalanche_SpokeConnectorMode!]!
  avalanche_aggregateRootProposed(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): avalanche_AggregateRootProposed
  avalanche_aggregateRootProposeds(
    skip: Int = 0
    first: Int = 100
    orderBy: avalanche_AggregateRootProposed_orderBy
    orderDirection: avalanche_OrderDirection
    where: avalanche_AggregateRootProposed_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [avalanche_AggregateRootProposed!]!
  avalanche_optimisticRootFinalized(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): avalanche_OptimisticRootFinalized
  avalanche_optimisticRootFinalizeds(
    skip: Int = 0
    first: Int = 100
    orderBy: avalanche_OptimisticRootFinalized_orderBy
    orderDirection: avalanche_OrderDirection
    where: avalanche_OptimisticRootFinalized_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [avalanche_OptimisticRootFinalized!]!
  """Access to subgraph metadata"""
  avalanche__meta(block: avalanche_Block_height): avalanche__Meta_
  mantle_asset(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mantle_Asset
  mantle_assets(
    skip: Int = 0
    first: Int = 100
    orderBy: mantle_Asset_orderBy
    orderDirection: mantle_OrderDirection
    where: mantle_Asset_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mantle_Asset!]!
  mantle_assetStatus(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mantle_AssetStatus
  mantle_assetStatuses(
    skip: Int = 0
    first: Int = 100
    orderBy: mantle_AssetStatus_orderBy
    orderDirection: mantle_OrderDirection
    where: mantle_AssetStatus_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mantle_AssetStatus!]!
  mantle_assetBalance(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mantle_AssetBalance
  mantle_assetBalances(
    skip: Int = 0
    first: Int = 100
    orderBy: mantle_AssetBalance_orderBy
    orderDirection: mantle_OrderDirection
    where: mantle_AssetBalance_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mantle_AssetBalance!]!
  mantle_router(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mantle_Router
  mantle_routers(
    skip: Int = 0
    first: Int = 100
    orderBy: mantle_Router_orderBy
    orderDirection: mantle_OrderDirection
    where: mantle_Router_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mantle_Router!]!
  mantle_routerDailyTVL(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mantle_RouterDailyTVL
  mantle_routerDailyTVLs(
    skip: Int = 0
    first: Int = 100
    orderBy: mantle_RouterDailyTVL_orderBy
    orderDirection: mantle_OrderDirection
    where: mantle_RouterDailyTVL_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mantle_RouterDailyTVL!]!
  mantle_routerLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mantle_RouterLiquidityEvent
  mantle_routerLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: mantle_RouterLiquidityEvent_orderBy
    orderDirection: mantle_OrderDirection
    where: mantle_RouterLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mantle_RouterLiquidityEvent!]!
  mantle_setting(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mantle_Setting
  mantle_settings(
    skip: Int = 0
    first: Int = 100
    orderBy: mantle_Setting_orderBy
    orderDirection: mantle_OrderDirection
    where: mantle_Setting_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mantle_Setting!]!
  mantle_relayer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mantle_Relayer
  mantle_relayers(
    skip: Int = 0
    first: Int = 100
    orderBy: mantle_Relayer_orderBy
    orderDirection: mantle_OrderDirection
    where: mantle_Relayer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mantle_Relayer!]!
  mantle_sequencer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mantle_Sequencer
  mantle_sequencers(
    skip: Int = 0
    first: Int = 100
    orderBy: mantle_Sequencer_orderBy
    orderDirection: mantle_OrderDirection
    where: mantle_Sequencer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mantle_Sequencer!]!
  mantle_relayerFee(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mantle_RelayerFee
  mantle_relayerFees(
    skip: Int = 0
    first: Int = 100
    orderBy: mantle_RelayerFee_orderBy
    orderDirection: mantle_OrderDirection
    where: mantle_RelayerFee_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mantle_RelayerFee!]!
  mantle_originTransfer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mantle_OriginTransfer
  mantle_originTransfers(
    skip: Int = 0
    first: Int = 100
    orderBy: mantle_OriginTransfer_orderBy
    orderDirection: mantle_OrderDirection
    where: mantle_OriginTransfer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mantle_OriginTransfer!]!
  mantle_destinationTransfer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mantle_DestinationTransfer
  mantle_destinationTransfers(
    skip: Int = 0
    first: Int = 100
    orderBy: mantle_DestinationTransfer_orderBy
    orderDirection: mantle_OrderDirection
    where: mantle_DestinationTransfer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mantle_DestinationTransfer!]!
  mantle_originMessage(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mantle_OriginMessage
  mantle_originMessages(
    skip: Int = 0
    first: Int = 100
    orderBy: mantle_OriginMessage_orderBy
    orderDirection: mantle_OrderDirection
    where: mantle_OriginMessage_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mantle_OriginMessage!]!
  mantle_aggregateRoot(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mantle_AggregateRoot
  mantle_aggregateRoots(
    skip: Int = 0
    first: Int = 100
    orderBy: mantle_AggregateRoot_orderBy
    orderDirection: mantle_OrderDirection
    where: mantle_AggregateRoot_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mantle_AggregateRoot!]!
  mantle_connectorMeta(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mantle_ConnectorMeta
  mantle_connectorMetas(
    skip: Int = 0
    first: Int = 100
    orderBy: mantle_ConnectorMeta_orderBy
    orderDirection: mantle_OrderDirection
    where: mantle_ConnectorMeta_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mantle_ConnectorMeta!]!
  mantle_rootCount(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mantle_RootCount
  mantle_rootCounts(
    skip: Int = 0
    first: Int = 100
    orderBy: mantle_RootCount_orderBy
    orderDirection: mantle_OrderDirection
    where: mantle_RootCount_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mantle_RootCount!]!
  mantle_rootMessageSent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mantle_RootMessageSent
  mantle_rootMessageSents(
    skip: Int = 0
    first: Int = 100
    orderBy: mantle_RootMessageSent_orderBy
    orderDirection: mantle_OrderDirection
    where: mantle_RootMessageSent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mantle_RootMessageSent!]!
  mantle_relayerFeesIncrease(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mantle_RelayerFeesIncrease
  mantle_relayerFeesIncreases(
    skip: Int = 0
    first: Int = 100
    orderBy: mantle_RelayerFeesIncrease_orderBy
    orderDirection: mantle_OrderDirection
    where: mantle_RelayerFeesIncrease_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mantle_RelayerFeesIncrease!]!
  mantle_slippageUpdate(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mantle_SlippageUpdate
  mantle_slippageUpdates(
    skip: Int = 0
    first: Int = 100
    orderBy: mantle_SlippageUpdate_orderBy
    orderDirection: mantle_OrderDirection
    where: mantle_SlippageUpdate_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mantle_SlippageUpdate!]!
  mantle_snapshotRoot(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mantle_SnapshotRoot
  mantle_snapshotRoots(
    skip: Int = 0
    first: Int = 100
    orderBy: mantle_SnapshotRoot_orderBy
    orderDirection: mantle_OrderDirection
    where: mantle_SnapshotRoot_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mantle_SnapshotRoot!]!
  mantle_spokeConnectorMode(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mantle_SpokeConnectorMode
  mantle_spokeConnectorModes(
    skip: Int = 0
    first: Int = 100
    orderBy: mantle_SpokeConnectorMode_orderBy
    orderDirection: mantle_OrderDirection
    where: mantle_SpokeConnectorMode_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mantle_SpokeConnectorMode!]!
  mantle_aggregateRootProposed(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mantle_AggregateRootProposed
  mantle_aggregateRootProposeds(
    skip: Int = 0
    first: Int = 100
    orderBy: mantle_AggregateRootProposed_orderBy
    orderDirection: mantle_OrderDirection
    where: mantle_AggregateRootProposed_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mantle_AggregateRootProposed!]!
  mantle_optimisticRootFinalized(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mantle_OptimisticRootFinalized
  mantle_optimisticRootFinalizeds(
    skip: Int = 0
    first: Int = 100
    orderBy: mantle_OptimisticRootFinalized_orderBy
    orderDirection: mantle_OrderDirection
    where: mantle_OptimisticRootFinalized_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mantle_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mantle_OptimisticRootFinalized!]!
  """Access to subgraph metadata"""
  mantle__meta(block: mantle_Block_height): mantle__Meta_
  xlayer_asset(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xlayer_Asset
  xlayer_assets(
    skip: Int = 0
    first: Int = 100
    orderBy: xlayer_Asset_orderBy
    orderDirection: xlayer_OrderDirection
    where: xlayer_Asset_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xlayer_Asset!]!
  xlayer_assetStatus(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xlayer_AssetStatus
  xlayer_assetStatuses(
    skip: Int = 0
    first: Int = 100
    orderBy: xlayer_AssetStatus_orderBy
    orderDirection: xlayer_OrderDirection
    where: xlayer_AssetStatus_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xlayer_AssetStatus!]!
  xlayer_assetBalance(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xlayer_AssetBalance
  xlayer_assetBalances(
    skip: Int = 0
    first: Int = 100
    orderBy: xlayer_AssetBalance_orderBy
    orderDirection: xlayer_OrderDirection
    where: xlayer_AssetBalance_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xlayer_AssetBalance!]!
  xlayer_router(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xlayer_Router
  xlayer_routers(
    skip: Int = 0
    first: Int = 100
    orderBy: xlayer_Router_orderBy
    orderDirection: xlayer_OrderDirection
    where: xlayer_Router_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xlayer_Router!]!
  xlayer_routerDailyTVL(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xlayer_RouterDailyTVL
  xlayer_routerDailyTVLs(
    skip: Int = 0
    first: Int = 100
    orderBy: xlayer_RouterDailyTVL_orderBy
    orderDirection: xlayer_OrderDirection
    where: xlayer_RouterDailyTVL_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xlayer_RouterDailyTVL!]!
  xlayer_routerLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xlayer_RouterLiquidityEvent
  xlayer_routerLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: xlayer_RouterLiquidityEvent_orderBy
    orderDirection: xlayer_OrderDirection
    where: xlayer_RouterLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xlayer_RouterLiquidityEvent!]!
  xlayer_setting(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xlayer_Setting
  xlayer_settings(
    skip: Int = 0
    first: Int = 100
    orderBy: xlayer_Setting_orderBy
    orderDirection: xlayer_OrderDirection
    where: xlayer_Setting_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xlayer_Setting!]!
  xlayer_relayer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xlayer_Relayer
  xlayer_relayers(
    skip: Int = 0
    first: Int = 100
    orderBy: xlayer_Relayer_orderBy
    orderDirection: xlayer_OrderDirection
    where: xlayer_Relayer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xlayer_Relayer!]!
  xlayer_sequencer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xlayer_Sequencer
  xlayer_sequencers(
    skip: Int = 0
    first: Int = 100
    orderBy: xlayer_Sequencer_orderBy
    orderDirection: xlayer_OrderDirection
    where: xlayer_Sequencer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xlayer_Sequencer!]!
  xlayer_relayerFee(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xlayer_RelayerFee
  xlayer_relayerFees(
    skip: Int = 0
    first: Int = 100
    orderBy: xlayer_RelayerFee_orderBy
    orderDirection: xlayer_OrderDirection
    where: xlayer_RelayerFee_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xlayer_RelayerFee!]!
  xlayer_originTransfer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xlayer_OriginTransfer
  xlayer_originTransfers(
    skip: Int = 0
    first: Int = 100
    orderBy: xlayer_OriginTransfer_orderBy
    orderDirection: xlayer_OrderDirection
    where: xlayer_OriginTransfer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xlayer_OriginTransfer!]!
  xlayer_destinationTransfer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xlayer_DestinationTransfer
  xlayer_destinationTransfers(
    skip: Int = 0
    first: Int = 100
    orderBy: xlayer_DestinationTransfer_orderBy
    orderDirection: xlayer_OrderDirection
    where: xlayer_DestinationTransfer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xlayer_DestinationTransfer!]!
  xlayer_originMessage(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xlayer_OriginMessage
  xlayer_originMessages(
    skip: Int = 0
    first: Int = 100
    orderBy: xlayer_OriginMessage_orderBy
    orderDirection: xlayer_OrderDirection
    where: xlayer_OriginMessage_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xlayer_OriginMessage!]!
  xlayer_aggregateRoot(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xlayer_AggregateRoot
  xlayer_aggregateRoots(
    skip: Int = 0
    first: Int = 100
    orderBy: xlayer_AggregateRoot_orderBy
    orderDirection: xlayer_OrderDirection
    where: xlayer_AggregateRoot_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xlayer_AggregateRoot!]!
  xlayer_connectorMeta(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xlayer_ConnectorMeta
  xlayer_connectorMetas(
    skip: Int = 0
    first: Int = 100
    orderBy: xlayer_ConnectorMeta_orderBy
    orderDirection: xlayer_OrderDirection
    where: xlayer_ConnectorMeta_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xlayer_ConnectorMeta!]!
  xlayer_rootCount(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xlayer_RootCount
  xlayer_rootCounts(
    skip: Int = 0
    first: Int = 100
    orderBy: xlayer_RootCount_orderBy
    orderDirection: xlayer_OrderDirection
    where: xlayer_RootCount_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xlayer_RootCount!]!
  xlayer_rootMessageSent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xlayer_RootMessageSent
  xlayer_rootMessageSents(
    skip: Int = 0
    first: Int = 100
    orderBy: xlayer_RootMessageSent_orderBy
    orderDirection: xlayer_OrderDirection
    where: xlayer_RootMessageSent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xlayer_RootMessageSent!]!
  xlayer_relayerFeesIncrease(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xlayer_RelayerFeesIncrease
  xlayer_relayerFeesIncreases(
    skip: Int = 0
    first: Int = 100
    orderBy: xlayer_RelayerFeesIncrease_orderBy
    orderDirection: xlayer_OrderDirection
    where: xlayer_RelayerFeesIncrease_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xlayer_RelayerFeesIncrease!]!
  xlayer_slippageUpdate(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xlayer_SlippageUpdate
  xlayer_slippageUpdates(
    skip: Int = 0
    first: Int = 100
    orderBy: xlayer_SlippageUpdate_orderBy
    orderDirection: xlayer_OrderDirection
    where: xlayer_SlippageUpdate_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xlayer_SlippageUpdate!]!
  xlayer_snapshotRoot(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xlayer_SnapshotRoot
  xlayer_snapshotRoots(
    skip: Int = 0
    first: Int = 100
    orderBy: xlayer_SnapshotRoot_orderBy
    orderDirection: xlayer_OrderDirection
    where: xlayer_SnapshotRoot_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xlayer_SnapshotRoot!]!
  xlayer_spokeConnectorMode(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xlayer_SpokeConnectorMode
  xlayer_spokeConnectorModes(
    skip: Int = 0
    first: Int = 100
    orderBy: xlayer_SpokeConnectorMode_orderBy
    orderDirection: xlayer_OrderDirection
    where: xlayer_SpokeConnectorMode_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xlayer_SpokeConnectorMode!]!
  xlayer_aggregateRootProposed(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xlayer_AggregateRootProposed
  xlayer_aggregateRootProposeds(
    skip: Int = 0
    first: Int = 100
    orderBy: xlayer_AggregateRootProposed_orderBy
    orderDirection: xlayer_OrderDirection
    where: xlayer_AggregateRootProposed_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xlayer_AggregateRootProposed!]!
  xlayer_optimisticRootFinalized(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xlayer_OptimisticRootFinalized
  xlayer_optimisticRootFinalizeds(
    skip: Int = 0
    first: Int = 100
    orderBy: xlayer_OptimisticRootFinalized_orderBy
    orderDirection: xlayer_OrderDirection
    where: xlayer_OptimisticRootFinalized_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xlayer_OptimisticRootFinalized!]!
  """Access to subgraph metadata"""
  xlayer__meta(block: xlayer_Block_height): xlayer__Meta_
  mode_asset(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mode_Asset
  mode_assets(
    skip: Int = 0
    first: Int = 100
    orderBy: mode_Asset_orderBy
    orderDirection: mode_OrderDirection
    where: mode_Asset_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mode_Asset!]!
  mode_assetStatus(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mode_AssetStatus
  mode_assetStatuses(
    skip: Int = 0
    first: Int = 100
    orderBy: mode_AssetStatus_orderBy
    orderDirection: mode_OrderDirection
    where: mode_AssetStatus_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mode_AssetStatus!]!
  mode_assetBalance(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mode_AssetBalance
  mode_assetBalances(
    skip: Int = 0
    first: Int = 100
    orderBy: mode_AssetBalance_orderBy
    orderDirection: mode_OrderDirection
    where: mode_AssetBalance_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mode_AssetBalance!]!
  mode_router(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mode_Router
  mode_routers(
    skip: Int = 0
    first: Int = 100
    orderBy: mode_Router_orderBy
    orderDirection: mode_OrderDirection
    where: mode_Router_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mode_Router!]!
  mode_routerDailyTVL(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mode_RouterDailyTVL
  mode_routerDailyTVLs(
    skip: Int = 0
    first: Int = 100
    orderBy: mode_RouterDailyTVL_orderBy
    orderDirection: mode_OrderDirection
    where: mode_RouterDailyTVL_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mode_RouterDailyTVL!]!
  mode_routerLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mode_RouterLiquidityEvent
  mode_routerLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: mode_RouterLiquidityEvent_orderBy
    orderDirection: mode_OrderDirection
    where: mode_RouterLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mode_RouterLiquidityEvent!]!
  mode_setting(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mode_Setting
  mode_settings(
    skip: Int = 0
    first: Int = 100
    orderBy: mode_Setting_orderBy
    orderDirection: mode_OrderDirection
    where: mode_Setting_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mode_Setting!]!
  mode_relayer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mode_Relayer
  mode_relayers(
    skip: Int = 0
    first: Int = 100
    orderBy: mode_Relayer_orderBy
    orderDirection: mode_OrderDirection
    where: mode_Relayer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mode_Relayer!]!
  mode_sequencer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mode_Sequencer
  mode_sequencers(
    skip: Int = 0
    first: Int = 100
    orderBy: mode_Sequencer_orderBy
    orderDirection: mode_OrderDirection
    where: mode_Sequencer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mode_Sequencer!]!
  mode_relayerFee(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mode_RelayerFee
  mode_relayerFees(
    skip: Int = 0
    first: Int = 100
    orderBy: mode_RelayerFee_orderBy
    orderDirection: mode_OrderDirection
    where: mode_RelayerFee_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mode_RelayerFee!]!
  mode_originTransfer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mode_OriginTransfer
  mode_originTransfers(
    skip: Int = 0
    first: Int = 100
    orderBy: mode_OriginTransfer_orderBy
    orderDirection: mode_OrderDirection
    where: mode_OriginTransfer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mode_OriginTransfer!]!
  mode_destinationTransfer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mode_DestinationTransfer
  mode_destinationTransfers(
    skip: Int = 0
    first: Int = 100
    orderBy: mode_DestinationTransfer_orderBy
    orderDirection: mode_OrderDirection
    where: mode_DestinationTransfer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mode_DestinationTransfer!]!
  mode_originMessage(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mode_OriginMessage
  mode_originMessages(
    skip: Int = 0
    first: Int = 100
    orderBy: mode_OriginMessage_orderBy
    orderDirection: mode_OrderDirection
    where: mode_OriginMessage_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mode_OriginMessage!]!
  mode_aggregateRoot(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mode_AggregateRoot
  mode_aggregateRoots(
    skip: Int = 0
    first: Int = 100
    orderBy: mode_AggregateRoot_orderBy
    orderDirection: mode_OrderDirection
    where: mode_AggregateRoot_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mode_AggregateRoot!]!
  mode_connectorMeta(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mode_ConnectorMeta
  mode_connectorMetas(
    skip: Int = 0
    first: Int = 100
    orderBy: mode_ConnectorMeta_orderBy
    orderDirection: mode_OrderDirection
    where: mode_ConnectorMeta_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mode_ConnectorMeta!]!
  mode_rootCount(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mode_RootCount
  mode_rootCounts(
    skip: Int = 0
    first: Int = 100
    orderBy: mode_RootCount_orderBy
    orderDirection: mode_OrderDirection
    where: mode_RootCount_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mode_RootCount!]!
  mode_rootMessageSent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mode_RootMessageSent
  mode_rootMessageSents(
    skip: Int = 0
    first: Int = 100
    orderBy: mode_RootMessageSent_orderBy
    orderDirection: mode_OrderDirection
    where: mode_RootMessageSent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mode_RootMessageSent!]!
  mode_relayerFeesIncrease(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mode_RelayerFeesIncrease
  mode_relayerFeesIncreases(
    skip: Int = 0
    first: Int = 100
    orderBy: mode_RelayerFeesIncrease_orderBy
    orderDirection: mode_OrderDirection
    where: mode_RelayerFeesIncrease_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mode_RelayerFeesIncrease!]!
  mode_slippageUpdate(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mode_SlippageUpdate
  mode_slippageUpdates(
    skip: Int = 0
    first: Int = 100
    orderBy: mode_SlippageUpdate_orderBy
    orderDirection: mode_OrderDirection
    where: mode_SlippageUpdate_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mode_SlippageUpdate!]!
  mode_snapshotRoot(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mode_SnapshotRoot
  mode_snapshotRoots(
    skip: Int = 0
    first: Int = 100
    orderBy: mode_SnapshotRoot_orderBy
    orderDirection: mode_OrderDirection
    where: mode_SnapshotRoot_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mode_SnapshotRoot!]!
  mode_spokeConnectorMode(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mode_SpokeConnectorMode
  mode_spokeConnectorModes(
    skip: Int = 0
    first: Int = 100
    orderBy: mode_SpokeConnectorMode_orderBy
    orderDirection: mode_OrderDirection
    where: mode_SpokeConnectorMode_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mode_SpokeConnectorMode!]!
  mode_aggregateRootProposed(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mode_AggregateRootProposed
  mode_aggregateRootProposeds(
    skip: Int = 0
    first: Int = 100
    orderBy: mode_AggregateRootProposed_orderBy
    orderDirection: mode_OrderDirection
    where: mode_AggregateRootProposed_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mode_AggregateRootProposed!]!
  mode_optimisticRootFinalized(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mode_OptimisticRootFinalized
  mode_optimisticRootFinalizeds(
    skip: Int = 0
    first: Int = 100
    orderBy: mode_OptimisticRootFinalized_orderBy
    orderDirection: mode_OrderDirection
    where: mode_OptimisticRootFinalized_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mode_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mode_OptimisticRootFinalized!]!
  """Access to subgraph metadata"""
  mode__meta(block: mode_Block_height): mode__Meta_
  mainnet_asset(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mainnet_Asset
  mainnet_assets(
    skip: Int = 0
    first: Int = 100
    orderBy: mainnet_Asset_orderBy
    orderDirection: mainnet_OrderDirection
    where: mainnet_Asset_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mainnet_Asset!]!
  mainnet_assetStatus(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mainnet_AssetStatus
  mainnet_assetStatuses(
    skip: Int = 0
    first: Int = 100
    orderBy: mainnet_AssetStatus_orderBy
    orderDirection: mainnet_OrderDirection
    where: mainnet_AssetStatus_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mainnet_AssetStatus!]!
  mainnet_assetBalance(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mainnet_AssetBalance
  mainnet_assetBalances(
    skip: Int = 0
    first: Int = 100
    orderBy: mainnet_AssetBalance_orderBy
    orderDirection: mainnet_OrderDirection
    where: mainnet_AssetBalance_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mainnet_AssetBalance!]!
  mainnet_router(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mainnet_Router
  mainnet_routers(
    skip: Int = 0
    first: Int = 100
    orderBy: mainnet_Router_orderBy
    orderDirection: mainnet_OrderDirection
    where: mainnet_Router_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mainnet_Router!]!
  mainnet_routerDailyTVL(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mainnet_RouterDailyTVL
  mainnet_routerDailyTVLs(
    skip: Int = 0
    first: Int = 100
    orderBy: mainnet_RouterDailyTVL_orderBy
    orderDirection: mainnet_OrderDirection
    where: mainnet_RouterDailyTVL_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mainnet_RouterDailyTVL!]!
  mainnet_routerLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mainnet_RouterLiquidityEvent
  mainnet_routerLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: mainnet_RouterLiquidityEvent_orderBy
    orderDirection: mainnet_OrderDirection
    where: mainnet_RouterLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mainnet_RouterLiquidityEvent!]!
  mainnet_setting(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mainnet_Setting
  mainnet_settings(
    skip: Int = 0
    first: Int = 100
    orderBy: mainnet_Setting_orderBy
    orderDirection: mainnet_OrderDirection
    where: mainnet_Setting_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mainnet_Setting!]!
  mainnet_relayer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mainnet_Relayer
  mainnet_relayers(
    skip: Int = 0
    first: Int = 100
    orderBy: mainnet_Relayer_orderBy
    orderDirection: mainnet_OrderDirection
    where: mainnet_Relayer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mainnet_Relayer!]!
  mainnet_sequencer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mainnet_Sequencer
  mainnet_sequencers(
    skip: Int = 0
    first: Int = 100
    orderBy: mainnet_Sequencer_orderBy
    orderDirection: mainnet_OrderDirection
    where: mainnet_Sequencer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mainnet_Sequencer!]!
  mainnet_relayerFee(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mainnet_RelayerFee
  mainnet_relayerFees(
    skip: Int = 0
    first: Int = 100
    orderBy: mainnet_RelayerFee_orderBy
    orderDirection: mainnet_OrderDirection
    where: mainnet_RelayerFee_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mainnet_RelayerFee!]!
  mainnet_originTransfer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mainnet_OriginTransfer
  mainnet_originTransfers(
    skip: Int = 0
    first: Int = 100
    orderBy: mainnet_OriginTransfer_orderBy
    orderDirection: mainnet_OrderDirection
    where: mainnet_OriginTransfer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mainnet_OriginTransfer!]!
  mainnet_destinationTransfer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mainnet_DestinationTransfer
  mainnet_destinationTransfers(
    skip: Int = 0
    first: Int = 100
    orderBy: mainnet_DestinationTransfer_orderBy
    orderDirection: mainnet_OrderDirection
    where: mainnet_DestinationTransfer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mainnet_DestinationTransfer!]!
  mainnet_originMessage(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mainnet_OriginMessage
  mainnet_originMessages(
    skip: Int = 0
    first: Int = 100
    orderBy: mainnet_OriginMessage_orderBy
    orderDirection: mainnet_OrderDirection
    where: mainnet_OriginMessage_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mainnet_OriginMessage!]!
  mainnet_aggregateRoot(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mainnet_AggregateRoot
  mainnet_aggregateRoots(
    skip: Int = 0
    first: Int = 100
    orderBy: mainnet_AggregateRoot_orderBy
    orderDirection: mainnet_OrderDirection
    where: mainnet_AggregateRoot_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mainnet_AggregateRoot!]!
  mainnet_connectorMeta(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mainnet_ConnectorMeta
  mainnet_connectorMetas(
    skip: Int = 0
    first: Int = 100
    orderBy: mainnet_ConnectorMeta_orderBy
    orderDirection: mainnet_OrderDirection
    where: mainnet_ConnectorMeta_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mainnet_ConnectorMeta!]!
  mainnet_rootCount(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mainnet_RootCount
  mainnet_rootCounts(
    skip: Int = 0
    first: Int = 100
    orderBy: mainnet_RootCount_orderBy
    orderDirection: mainnet_OrderDirection
    where: mainnet_RootCount_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mainnet_RootCount!]!
  mainnet_rootMessageSent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mainnet_RootMessageSent
  mainnet_rootMessageSents(
    skip: Int = 0
    first: Int = 100
    orderBy: mainnet_RootMessageSent_orderBy
    orderDirection: mainnet_OrderDirection
    where: mainnet_RootMessageSent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mainnet_RootMessageSent!]!
  mainnet_relayerFeesIncrease(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mainnet_RelayerFeesIncrease
  mainnet_relayerFeesIncreases(
    skip: Int = 0
    first: Int = 100
    orderBy: mainnet_RelayerFeesIncrease_orderBy
    orderDirection: mainnet_OrderDirection
    where: mainnet_RelayerFeesIncrease_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mainnet_RelayerFeesIncrease!]!
  mainnet_slippageUpdate(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mainnet_SlippageUpdate
  mainnet_slippageUpdates(
    skip: Int = 0
    first: Int = 100
    orderBy: mainnet_SlippageUpdate_orderBy
    orderDirection: mainnet_OrderDirection
    where: mainnet_SlippageUpdate_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mainnet_SlippageUpdate!]!
  mainnet_snapshotRoot(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mainnet_SnapshotRoot
  mainnet_snapshotRoots(
    skip: Int = 0
    first: Int = 100
    orderBy: mainnet_SnapshotRoot_orderBy
    orderDirection: mainnet_OrderDirection
    where: mainnet_SnapshotRoot_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mainnet_SnapshotRoot!]!
  mainnet_spokeConnectorMode(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mainnet_SpokeConnectorMode
  mainnet_spokeConnectorModes(
    skip: Int = 0
    first: Int = 100
    orderBy: mainnet_SpokeConnectorMode_orderBy
    orderDirection: mainnet_OrderDirection
    where: mainnet_SpokeConnectorMode_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mainnet_SpokeConnectorMode!]!
  mainnet_aggregateRootProposed(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mainnet_AggregateRootProposed
  mainnet_aggregateRootProposeds(
    skip: Int = 0
    first: Int = 100
    orderBy: mainnet_AggregateRootProposed_orderBy
    orderDirection: mainnet_OrderDirection
    where: mainnet_AggregateRootProposed_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mainnet_AggregateRootProposed!]!
  mainnet_optimisticRootFinalized(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): mainnet_OptimisticRootFinalized
  mainnet_optimisticRootFinalizeds(
    skip: Int = 0
    first: Int = 100
    orderBy: mainnet_OptimisticRootFinalized_orderBy
    orderDirection: mainnet_OrderDirection
    where: mainnet_OptimisticRootFinalized_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: mainnet_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [mainnet_OptimisticRootFinalized!]!
  xdai_asset(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xdai_Asset
  xdai_assets(
    skip: Int = 0
    first: Int = 100
    orderBy: xdai_Asset_orderBy
    orderDirection: xdai_OrderDirection
    where: xdai_Asset_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xdai_Asset!]!
  xdai_assetStatus(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xdai_AssetStatus
  xdai_assetStatuses(
    skip: Int = 0
    first: Int = 100
    orderBy: xdai_AssetStatus_orderBy
    orderDirection: xdai_OrderDirection
    where: xdai_AssetStatus_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xdai_AssetStatus!]!
  xdai_assetBalance(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xdai_AssetBalance
  xdai_assetBalances(
    skip: Int = 0
    first: Int = 100
    orderBy: xdai_AssetBalance_orderBy
    orderDirection: xdai_OrderDirection
    where: xdai_AssetBalance_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xdai_AssetBalance!]!
  xdai_router(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xdai_Router
  xdai_routers(
    skip: Int = 0
    first: Int = 100
    orderBy: xdai_Router_orderBy
    orderDirection: xdai_OrderDirection
    where: xdai_Router_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xdai_Router!]!
  xdai_routerDailyTVL(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xdai_RouterDailyTVL
  xdai_routerDailyTVLs(
    skip: Int = 0
    first: Int = 100
    orderBy: xdai_RouterDailyTVL_orderBy
    orderDirection: xdai_OrderDirection
    where: xdai_RouterDailyTVL_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xdai_RouterDailyTVL!]!
  xdai_routerLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xdai_RouterLiquidityEvent
  xdai_routerLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: xdai_RouterLiquidityEvent_orderBy
    orderDirection: xdai_OrderDirection
    where: xdai_RouterLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xdai_RouterLiquidityEvent!]!
  xdai_setting(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xdai_Setting
  xdai_settings(
    skip: Int = 0
    first: Int = 100
    orderBy: xdai_Setting_orderBy
    orderDirection: xdai_OrderDirection
    where: xdai_Setting_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xdai_Setting!]!
  xdai_relayer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xdai_Relayer
  xdai_relayers(
    skip: Int = 0
    first: Int = 100
    orderBy: xdai_Relayer_orderBy
    orderDirection: xdai_OrderDirection
    where: xdai_Relayer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xdai_Relayer!]!
  xdai_sequencer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xdai_Sequencer
  xdai_sequencers(
    skip: Int = 0
    first: Int = 100
    orderBy: xdai_Sequencer_orderBy
    orderDirection: xdai_OrderDirection
    where: xdai_Sequencer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xdai_Sequencer!]!
  xdai_relayerFee(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xdai_RelayerFee
  xdai_relayerFees(
    skip: Int = 0
    first: Int = 100
    orderBy: xdai_RelayerFee_orderBy
    orderDirection: xdai_OrderDirection
    where: xdai_RelayerFee_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xdai_RelayerFee!]!
  xdai_originTransfer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xdai_OriginTransfer
  xdai_originTransfers(
    skip: Int = 0
    first: Int = 100
    orderBy: xdai_OriginTransfer_orderBy
    orderDirection: xdai_OrderDirection
    where: xdai_OriginTransfer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xdai_OriginTransfer!]!
  xdai_destinationTransfer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xdai_DestinationTransfer
  xdai_destinationTransfers(
    skip: Int = 0
    first: Int = 100
    orderBy: xdai_DestinationTransfer_orderBy
    orderDirection: xdai_OrderDirection
    where: xdai_DestinationTransfer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xdai_DestinationTransfer!]!
  xdai_originMessage(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xdai_OriginMessage
  xdai_originMessages(
    skip: Int = 0
    first: Int = 100
    orderBy: xdai_OriginMessage_orderBy
    orderDirection: xdai_OrderDirection
    where: xdai_OriginMessage_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xdai_OriginMessage!]!
  xdai_aggregateRoot(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xdai_AggregateRoot
  xdai_aggregateRoots(
    skip: Int = 0
    first: Int = 100
    orderBy: xdai_AggregateRoot_orderBy
    orderDirection: xdai_OrderDirection
    where: xdai_AggregateRoot_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xdai_AggregateRoot!]!
  xdai_connectorMeta(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xdai_ConnectorMeta
  xdai_connectorMetas(
    skip: Int = 0
    first: Int = 100
    orderBy: xdai_ConnectorMeta_orderBy
    orderDirection: xdai_OrderDirection
    where: xdai_ConnectorMeta_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xdai_ConnectorMeta!]!
  xdai_rootCount(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xdai_RootCount
  xdai_rootCounts(
    skip: Int = 0
    first: Int = 100
    orderBy: xdai_RootCount_orderBy
    orderDirection: xdai_OrderDirection
    where: xdai_RootCount_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xdai_RootCount!]!
  xdai_rootMessageSent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xdai_RootMessageSent
  xdai_rootMessageSents(
    skip: Int = 0
    first: Int = 100
    orderBy: xdai_RootMessageSent_orderBy
    orderDirection: xdai_OrderDirection
    where: xdai_RootMessageSent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xdai_RootMessageSent!]!
  xdai_relayerFeesIncrease(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xdai_RelayerFeesIncrease
  xdai_relayerFeesIncreases(
    skip: Int = 0
    first: Int = 100
    orderBy: xdai_RelayerFeesIncrease_orderBy
    orderDirection: xdai_OrderDirection
    where: xdai_RelayerFeesIncrease_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xdai_RelayerFeesIncrease!]!
  xdai_slippageUpdate(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xdai_SlippageUpdate
  xdai_slippageUpdates(
    skip: Int = 0
    first: Int = 100
    orderBy: xdai_SlippageUpdate_orderBy
    orderDirection: xdai_OrderDirection
    where: xdai_SlippageUpdate_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xdai_SlippageUpdate!]!
  xdai_snapshotRoot(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xdai_SnapshotRoot
  xdai_snapshotRoots(
    skip: Int = 0
    first: Int = 100
    orderBy: xdai_SnapshotRoot_orderBy
    orderDirection: xdai_OrderDirection
    where: xdai_SnapshotRoot_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xdai_SnapshotRoot!]!
  xdai_spokeConnectorMode(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xdai_SpokeConnectorMode
  xdai_spokeConnectorModes(
    skip: Int = 0
    first: Int = 100
    orderBy: xdai_SpokeConnectorMode_orderBy
    orderDirection: xdai_OrderDirection
    where: xdai_SpokeConnectorMode_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xdai_SpokeConnectorMode!]!
  xdai_aggregateRootProposed(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xdai_AggregateRootProposed
  xdai_aggregateRootProposeds(
    skip: Int = 0
    first: Int = 100
    orderBy: xdai_AggregateRootProposed_orderBy
    orderDirection: xdai_OrderDirection
    where: xdai_AggregateRootProposed_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xdai_AggregateRootProposed!]!
  xdai_optimisticRootFinalized(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xdai_OptimisticRootFinalized
  xdai_optimisticRootFinalizeds(
    skip: Int = 0
    first: Int = 100
    orderBy: xdai_OptimisticRootFinalized_orderBy
    orderDirection: xdai_OrderDirection
    where: xdai_OptimisticRootFinalized_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xdai_OptimisticRootFinalized!]!
  """Access to subgraph metadata"""
  xdai__meta(block: xdai_Block_height): xdai__Meta_
  avalanche_swap_systemInfo(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): avalanche_swap_SystemInfo
  avalanche_swap_systemInfos(
    skip: Int = 0
    first: Int = 100
    orderBy: avalanche_swap_SystemInfo_orderBy
    orderDirection: avalanche_swap_OrderDirection
    where: avalanche_swap_SystemInfo_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [avalanche_swap_SystemInfo!]!
  avalanche_swap_pooledToken(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): avalanche_swap_PooledToken
  avalanche_swap_pooledTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: avalanche_swap_PooledToken_orderBy
    orderDirection: avalanche_swap_OrderDirection
    where: avalanche_swap_PooledToken_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [avalanche_swap_PooledToken!]!
  avalanche_swap_stableSwap(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): avalanche_swap_StableSwap
  avalanche_swap_stableSwaps(
    skip: Int = 0
    first: Int = 100
    orderBy: avalanche_swap_StableSwap_orderBy
    orderDirection: avalanche_swap_OrderDirection
    where: avalanche_swap_StableSwap_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [avalanche_swap_StableSwap!]!
  avalanche_swap_stableSwapAddLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): avalanche_swap_StableSwapAddLiquidityEvent
  avalanche_swap_stableSwapAddLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: avalanche_swap_StableSwapAddLiquidityEvent_orderBy
    orderDirection: avalanche_swap_OrderDirection
    where: avalanche_swap_StableSwapAddLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [avalanche_swap_StableSwapAddLiquidityEvent!]!
  avalanche_swap_stableSwapRemoveLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): avalanche_swap_StableSwapRemoveLiquidityEvent
  avalanche_swap_stableSwapRemoveLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: avalanche_swap_StableSwapRemoveLiquidityEvent_orderBy
    orderDirection: avalanche_swap_OrderDirection
    where: avalanche_swap_StableSwapRemoveLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [avalanche_swap_StableSwapRemoveLiquidityEvent!]!
  avalanche_swap_stableSwapExchange(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): avalanche_swap_StableSwapExchange
  avalanche_swap_stableSwapExchanges(
    skip: Int = 0
    first: Int = 100
    orderBy: avalanche_swap_StableSwapExchange_orderBy
    orderDirection: avalanche_swap_OrderDirection
    where: avalanche_swap_StableSwapExchange_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [avalanche_swap_StableSwapExchange!]!
  avalanche_swap_swapDailyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): avalanche_swap_SwapDailyVolume
  avalanche_swap_swapDailyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: avalanche_swap_SwapDailyVolume_orderBy
    orderDirection: avalanche_swap_OrderDirection
    where: avalanche_swap_SwapDailyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [avalanche_swap_SwapDailyVolume!]!
  avalanche_swap_swapHourlyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): avalanche_swap_SwapHourlyVolume
  avalanche_swap_swapHourlyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: avalanche_swap_SwapHourlyVolume_orderBy
    orderDirection: avalanche_swap_OrderDirection
    where: avalanche_swap_SwapHourlyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [avalanche_swap_SwapHourlyVolume!]!
  avalanche_swap_swapWeeklyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): avalanche_swap_SwapWeeklyVolume
  avalanche_swap_swapWeeklyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: avalanche_swap_SwapWeeklyVolume_orderBy
    orderDirection: avalanche_swap_OrderDirection
    where: avalanche_swap_SwapWeeklyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [avalanche_swap_SwapWeeklyVolume!]!
  avalanche_swap_lpAccount(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): avalanche_swap_LpAccount
  avalanche_swap_lpAccounts(
    skip: Int = 0
    first: Int = 100
    orderBy: avalanche_swap_LpAccount_orderBy
    orderDirection: avalanche_swap_OrderDirection
    where: avalanche_swap_LpAccount_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [avalanche_swap_LpAccount!]!
  avalanche_swap_lpAccountBalance(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): avalanche_swap_LpAccountBalance
  avalanche_swap_lpAccountBalances(
    skip: Int = 0
    first: Int = 100
    orderBy: avalanche_swap_LpAccountBalance_orderBy
    orderDirection: avalanche_swap_OrderDirection
    where: avalanche_swap_LpAccountBalance_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [avalanche_swap_LpAccountBalance!]!
  avalanche_swap_lpToken(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): avalanche_swap_LpToken
  avalanche_swap_lpTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: avalanche_swap_LpToken_orderBy
    orderDirection: avalanche_swap_OrderDirection
    where: avalanche_swap_LpToken_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [avalanche_swap_LpToken!]!
  avalanche_swap_lpTransferEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): avalanche_swap_LpTransferEvent
  avalanche_swap_lpTransferEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: avalanche_swap_LpTransferEvent_orderBy
    orderDirection: avalanche_swap_OrderDirection
    where: avalanche_swap_LpTransferEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [avalanche_swap_LpTransferEvent!]!
  avalanche_swap_stableSwapEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): avalanche_swap_StableSwapEvent
  avalanche_swap_stableSwapEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: avalanche_swap_StableSwapEvent_orderBy
    orderDirection: avalanche_swap_OrderDirection
    where: avalanche_swap_StableSwapEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [avalanche_swap_StableSwapEvent!]!
  avalanche_swap_swapTradeVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): avalanche_swap_SwapTradeVolume
  avalanche_swap_swapTradeVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: avalanche_swap_SwapTradeVolume_orderBy
    orderDirection: avalanche_swap_OrderDirection
    where: avalanche_swap_SwapTradeVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [avalanche_swap_SwapTradeVolume!]!
  avalanche_swap_lpTokenEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): avalanche_swap_LpTokenEvent
  avalanche_swap_lpTokenEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: avalanche_swap_LpTokenEvent_orderBy
    orderDirection: avalanche_swap_OrderDirection
    where: avalanche_swap_LpTokenEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: avalanche_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [avalanche_swap_LpTokenEvent!]!
  """Access to subgraph metadata"""
  avalanche_swap__meta(block: avalanche_swap_Block_height): avalanche_swap__Meta_
  polygon_swap_systemInfo(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygon_swap_SystemInfo
  polygon_swap_systemInfos(
    skip: Int = 0
    first: Int = 100
    orderBy: polygon_swap_SystemInfo_orderBy
    orderDirection: polygon_swap_OrderDirection
    where: polygon_swap_SystemInfo_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygon_swap_SystemInfo!]!
  polygon_swap_pooledToken(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygon_swap_PooledToken
  polygon_swap_pooledTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: polygon_swap_PooledToken_orderBy
    orderDirection: polygon_swap_OrderDirection
    where: polygon_swap_PooledToken_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygon_swap_PooledToken!]!
  polygon_swap_stableSwap(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygon_swap_StableSwap
  polygon_swap_stableSwaps(
    skip: Int = 0
    first: Int = 100
    orderBy: polygon_swap_StableSwap_orderBy
    orderDirection: polygon_swap_OrderDirection
    where: polygon_swap_StableSwap_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygon_swap_StableSwap!]!
  polygon_swap_stableSwapAddLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygon_swap_StableSwapAddLiquidityEvent
  polygon_swap_stableSwapAddLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: polygon_swap_StableSwapAddLiquidityEvent_orderBy
    orderDirection: polygon_swap_OrderDirection
    where: polygon_swap_StableSwapAddLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygon_swap_StableSwapAddLiquidityEvent!]!
  polygon_swap_stableSwapRemoveLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygon_swap_StableSwapRemoveLiquidityEvent
  polygon_swap_stableSwapRemoveLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: polygon_swap_StableSwapRemoveLiquidityEvent_orderBy
    orderDirection: polygon_swap_OrderDirection
    where: polygon_swap_StableSwapRemoveLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygon_swap_StableSwapRemoveLiquidityEvent!]!
  polygon_swap_stableSwapExchange(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygon_swap_StableSwapExchange
  polygon_swap_stableSwapExchanges(
    skip: Int = 0
    first: Int = 100
    orderBy: polygon_swap_StableSwapExchange_orderBy
    orderDirection: polygon_swap_OrderDirection
    where: polygon_swap_StableSwapExchange_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygon_swap_StableSwapExchange!]!
  polygon_swap_swapDailyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygon_swap_SwapDailyVolume
  polygon_swap_swapDailyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: polygon_swap_SwapDailyVolume_orderBy
    orderDirection: polygon_swap_OrderDirection
    where: polygon_swap_SwapDailyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygon_swap_SwapDailyVolume!]!
  polygon_swap_swapHourlyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygon_swap_SwapHourlyVolume
  polygon_swap_swapHourlyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: polygon_swap_SwapHourlyVolume_orderBy
    orderDirection: polygon_swap_OrderDirection
    where: polygon_swap_SwapHourlyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygon_swap_SwapHourlyVolume!]!
  polygon_swap_swapWeeklyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygon_swap_SwapWeeklyVolume
  polygon_swap_swapWeeklyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: polygon_swap_SwapWeeklyVolume_orderBy
    orderDirection: polygon_swap_OrderDirection
    where: polygon_swap_SwapWeeklyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygon_swap_SwapWeeklyVolume!]!
  polygon_swap_lpAccount(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygon_swap_LpAccount
  polygon_swap_lpAccounts(
    skip: Int = 0
    first: Int = 100
    orderBy: polygon_swap_LpAccount_orderBy
    orderDirection: polygon_swap_OrderDirection
    where: polygon_swap_LpAccount_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygon_swap_LpAccount!]!
  polygon_swap_lpAccountBalance(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygon_swap_LpAccountBalance
  polygon_swap_lpAccountBalances(
    skip: Int = 0
    first: Int = 100
    orderBy: polygon_swap_LpAccountBalance_orderBy
    orderDirection: polygon_swap_OrderDirection
    where: polygon_swap_LpAccountBalance_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygon_swap_LpAccountBalance!]!
  polygon_swap_lpToken(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygon_swap_LpToken
  polygon_swap_lpTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: polygon_swap_LpToken_orderBy
    orderDirection: polygon_swap_OrderDirection
    where: polygon_swap_LpToken_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygon_swap_LpToken!]!
  polygon_swap_lpTransferEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygon_swap_LpTransferEvent
  polygon_swap_lpTransferEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: polygon_swap_LpTransferEvent_orderBy
    orderDirection: polygon_swap_OrderDirection
    where: polygon_swap_LpTransferEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygon_swap_LpTransferEvent!]!
  polygon_swap_stableSwapEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygon_swap_StableSwapEvent
  polygon_swap_stableSwapEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: polygon_swap_StableSwapEvent_orderBy
    orderDirection: polygon_swap_OrderDirection
    where: polygon_swap_StableSwapEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygon_swap_StableSwapEvent!]!
  polygon_swap_swapTradeVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygon_swap_SwapTradeVolume
  polygon_swap_swapTradeVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: polygon_swap_SwapTradeVolume_orderBy
    orderDirection: polygon_swap_OrderDirection
    where: polygon_swap_SwapTradeVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygon_swap_SwapTradeVolume!]!
  polygon_swap_lpTokenEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): polygon_swap_LpTokenEvent
  polygon_swap_lpTokenEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: polygon_swap_LpTokenEvent_orderBy
    orderDirection: polygon_swap_OrderDirection
    where: polygon_swap_LpTokenEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: polygon_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [polygon_swap_LpTokenEvent!]!
  """Access to subgraph metadata"""
  polygon_swap__meta(block: polygon_swap_Block_height): polygon_swap__Meta_
  optimism_swap_systemInfo(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): optimism_swap_SystemInfo
  optimism_swap_systemInfos(
    skip: Int = 0
    first: Int = 100
    orderBy: optimism_swap_SystemInfo_orderBy
    orderDirection: optimism_swap_OrderDirection
    where: optimism_swap_SystemInfo_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [optimism_swap_SystemInfo!]!
  optimism_swap_pooledToken(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): optimism_swap_PooledToken
  optimism_swap_pooledTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: optimism_swap_PooledToken_orderBy
    orderDirection: optimism_swap_OrderDirection
    where: optimism_swap_PooledToken_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [optimism_swap_PooledToken!]!
  optimism_swap_stableSwap(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): optimism_swap_StableSwap
  optimism_swap_stableSwaps(
    skip: Int = 0
    first: Int = 100
    orderBy: optimism_swap_StableSwap_orderBy
    orderDirection: optimism_swap_OrderDirection
    where: optimism_swap_StableSwap_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [optimism_swap_StableSwap!]!
  optimism_swap_stableSwapAddLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): optimism_swap_StableSwapAddLiquidityEvent
  optimism_swap_stableSwapAddLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: optimism_swap_StableSwapAddLiquidityEvent_orderBy
    orderDirection: optimism_swap_OrderDirection
    where: optimism_swap_StableSwapAddLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [optimism_swap_StableSwapAddLiquidityEvent!]!
  optimism_swap_stableSwapRemoveLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): optimism_swap_StableSwapRemoveLiquidityEvent
  optimism_swap_stableSwapRemoveLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: optimism_swap_StableSwapRemoveLiquidityEvent_orderBy
    orderDirection: optimism_swap_OrderDirection
    where: optimism_swap_StableSwapRemoveLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [optimism_swap_StableSwapRemoveLiquidityEvent!]!
  optimism_swap_stableSwapExchange(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): optimism_swap_StableSwapExchange
  optimism_swap_stableSwapExchanges(
    skip: Int = 0
    first: Int = 100
    orderBy: optimism_swap_StableSwapExchange_orderBy
    orderDirection: optimism_swap_OrderDirection
    where: optimism_swap_StableSwapExchange_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [optimism_swap_StableSwapExchange!]!
  optimism_swap_swapDailyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): optimism_swap_SwapDailyVolume
  optimism_swap_swapDailyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: optimism_swap_SwapDailyVolume_orderBy
    orderDirection: optimism_swap_OrderDirection
    where: optimism_swap_SwapDailyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [optimism_swap_SwapDailyVolume!]!
  optimism_swap_swapHourlyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): optimism_swap_SwapHourlyVolume
  optimism_swap_swapHourlyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: optimism_swap_SwapHourlyVolume_orderBy
    orderDirection: optimism_swap_OrderDirection
    where: optimism_swap_SwapHourlyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [optimism_swap_SwapHourlyVolume!]!
  optimism_swap_swapWeeklyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): optimism_swap_SwapWeeklyVolume
  optimism_swap_swapWeeklyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: optimism_swap_SwapWeeklyVolume_orderBy
    orderDirection: optimism_swap_OrderDirection
    where: optimism_swap_SwapWeeklyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [optimism_swap_SwapWeeklyVolume!]!
  optimism_swap_lpAccount(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): optimism_swap_LpAccount
  optimism_swap_lpAccounts(
    skip: Int = 0
    first: Int = 100
    orderBy: optimism_swap_LpAccount_orderBy
    orderDirection: optimism_swap_OrderDirection
    where: optimism_swap_LpAccount_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [optimism_swap_LpAccount!]!
  optimism_swap_lpAccountBalance(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): optimism_swap_LpAccountBalance
  optimism_swap_lpAccountBalances(
    skip: Int = 0
    first: Int = 100
    orderBy: optimism_swap_LpAccountBalance_orderBy
    orderDirection: optimism_swap_OrderDirection
    where: optimism_swap_LpAccountBalance_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [optimism_swap_LpAccountBalance!]!
  optimism_swap_lpToken(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): optimism_swap_LpToken
  optimism_swap_lpTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: optimism_swap_LpToken_orderBy
    orderDirection: optimism_swap_OrderDirection
    where: optimism_swap_LpToken_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [optimism_swap_LpToken!]!
  optimism_swap_lpTransferEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): optimism_swap_LpTransferEvent
  optimism_swap_lpTransferEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: optimism_swap_LpTransferEvent_orderBy
    orderDirection: optimism_swap_OrderDirection
    where: optimism_swap_LpTransferEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [optimism_swap_LpTransferEvent!]!
  optimism_swap_stableSwapEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): optimism_swap_StableSwapEvent
  optimism_swap_stableSwapEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: optimism_swap_StableSwapEvent_orderBy
    orderDirection: optimism_swap_OrderDirection
    where: optimism_swap_StableSwapEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [optimism_swap_StableSwapEvent!]!
  optimism_swap_swapTradeVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): optimism_swap_SwapTradeVolume
  optimism_swap_swapTradeVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: optimism_swap_SwapTradeVolume_orderBy
    orderDirection: optimism_swap_OrderDirection
    where: optimism_swap_SwapTradeVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [optimism_swap_SwapTradeVolume!]!
  optimism_swap_lpTokenEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): optimism_swap_LpTokenEvent
  optimism_swap_lpTokenEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: optimism_swap_LpTokenEvent_orderBy
    orderDirection: optimism_swap_OrderDirection
    where: optimism_swap_LpTokenEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: optimism_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [optimism_swap_LpTokenEvent!]!
  """Access to subgraph metadata"""
  optimism_swap__meta(block: optimism_swap_Block_height): optimism_swap__Meta_
  xdai_swap_systemInfo(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xdai_swap_SystemInfo
  xdai_swap_systemInfos(
    skip: Int = 0
    first: Int = 100
    orderBy: xdai_swap_SystemInfo_orderBy
    orderDirection: xdai_swap_OrderDirection
    where: xdai_swap_SystemInfo_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xdai_swap_SystemInfo!]!
  xdai_swap_pooledToken(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xdai_swap_PooledToken
  xdai_swap_pooledTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: xdai_swap_PooledToken_orderBy
    orderDirection: xdai_swap_OrderDirection
    where: xdai_swap_PooledToken_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xdai_swap_PooledToken!]!
  xdai_swap_stableSwap(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xdai_swap_StableSwap
  xdai_swap_stableSwaps(
    skip: Int = 0
    first: Int = 100
    orderBy: xdai_swap_StableSwap_orderBy
    orderDirection: xdai_swap_OrderDirection
    where: xdai_swap_StableSwap_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xdai_swap_StableSwap!]!
  xdai_swap_stableSwapAddLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xdai_swap_StableSwapAddLiquidityEvent
  xdai_swap_stableSwapAddLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: xdai_swap_StableSwapAddLiquidityEvent_orderBy
    orderDirection: xdai_swap_OrderDirection
    where: xdai_swap_StableSwapAddLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xdai_swap_StableSwapAddLiquidityEvent!]!
  xdai_swap_stableSwapRemoveLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xdai_swap_StableSwapRemoveLiquidityEvent
  xdai_swap_stableSwapRemoveLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: xdai_swap_StableSwapRemoveLiquidityEvent_orderBy
    orderDirection: xdai_swap_OrderDirection
    where: xdai_swap_StableSwapRemoveLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xdai_swap_StableSwapRemoveLiquidityEvent!]!
  xdai_swap_stableSwapExchange(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xdai_swap_StableSwapExchange
  xdai_swap_stableSwapExchanges(
    skip: Int = 0
    first: Int = 100
    orderBy: xdai_swap_StableSwapExchange_orderBy
    orderDirection: xdai_swap_OrderDirection
    where: xdai_swap_StableSwapExchange_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xdai_swap_StableSwapExchange!]!
  xdai_swap_swapDailyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xdai_swap_SwapDailyVolume
  xdai_swap_swapDailyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: xdai_swap_SwapDailyVolume_orderBy
    orderDirection: xdai_swap_OrderDirection
    where: xdai_swap_SwapDailyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xdai_swap_SwapDailyVolume!]!
  xdai_swap_swapHourlyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xdai_swap_SwapHourlyVolume
  xdai_swap_swapHourlyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: xdai_swap_SwapHourlyVolume_orderBy
    orderDirection: xdai_swap_OrderDirection
    where: xdai_swap_SwapHourlyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xdai_swap_SwapHourlyVolume!]!
  xdai_swap_swapWeeklyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xdai_swap_SwapWeeklyVolume
  xdai_swap_swapWeeklyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: xdai_swap_SwapWeeklyVolume_orderBy
    orderDirection: xdai_swap_OrderDirection
    where: xdai_swap_SwapWeeklyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xdai_swap_SwapWeeklyVolume!]!
  xdai_swap_lpAccount(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xdai_swap_LpAccount
  xdai_swap_lpAccounts(
    skip: Int = 0
    first: Int = 100
    orderBy: xdai_swap_LpAccount_orderBy
    orderDirection: xdai_swap_OrderDirection
    where: xdai_swap_LpAccount_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xdai_swap_LpAccount!]!
  xdai_swap_lpAccountBalance(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xdai_swap_LpAccountBalance
  xdai_swap_lpAccountBalances(
    skip: Int = 0
    first: Int = 100
    orderBy: xdai_swap_LpAccountBalance_orderBy
    orderDirection: xdai_swap_OrderDirection
    where: xdai_swap_LpAccountBalance_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xdai_swap_LpAccountBalance!]!
  xdai_swap_lpToken(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xdai_swap_LpToken
  xdai_swap_lpTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: xdai_swap_LpToken_orderBy
    orderDirection: xdai_swap_OrderDirection
    where: xdai_swap_LpToken_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xdai_swap_LpToken!]!
  xdai_swap_lpTransferEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xdai_swap_LpTransferEvent
  xdai_swap_lpTransferEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: xdai_swap_LpTransferEvent_orderBy
    orderDirection: xdai_swap_OrderDirection
    where: xdai_swap_LpTransferEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xdai_swap_LpTransferEvent!]!
  xdai_swap_stableSwapEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xdai_swap_StableSwapEvent
  xdai_swap_stableSwapEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: xdai_swap_StableSwapEvent_orderBy
    orderDirection: xdai_swap_OrderDirection
    where: xdai_swap_StableSwapEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xdai_swap_StableSwapEvent!]!
  xdai_swap_swapTradeVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xdai_swap_SwapTradeVolume
  xdai_swap_swapTradeVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: xdai_swap_SwapTradeVolume_orderBy
    orderDirection: xdai_swap_OrderDirection
    where: xdai_swap_SwapTradeVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xdai_swap_SwapTradeVolume!]!
  xdai_swap_lpTokenEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xdai_swap_LpTokenEvent
  xdai_swap_lpTokenEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: xdai_swap_LpTokenEvent_orderBy
    orderDirection: xdai_swap_OrderDirection
    where: xdai_swap_LpTokenEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xdai_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xdai_swap_LpTokenEvent!]!
  """Access to subgraph metadata"""
  xdai_swap__meta(block: xdai_swap_Block_height): xdai_swap__Meta_
  arbitrumone_swap_systemInfo(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): arbitrumone_swap_SystemInfo
  arbitrumone_swap_systemInfos(
    skip: Int = 0
    first: Int = 100
    orderBy: arbitrumone_swap_SystemInfo_orderBy
    orderDirection: arbitrumone_swap_OrderDirection
    where: arbitrumone_swap_SystemInfo_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [arbitrumone_swap_SystemInfo!]!
  arbitrumone_swap_pooledToken(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): arbitrumone_swap_PooledToken
  arbitrumone_swap_pooledTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: arbitrumone_swap_PooledToken_orderBy
    orderDirection: arbitrumone_swap_OrderDirection
    where: arbitrumone_swap_PooledToken_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [arbitrumone_swap_PooledToken!]!
  arbitrumone_swap_stableSwap(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): arbitrumone_swap_StableSwap
  arbitrumone_swap_stableSwaps(
    skip: Int = 0
    first: Int = 100
    orderBy: arbitrumone_swap_StableSwap_orderBy
    orderDirection: arbitrumone_swap_OrderDirection
    where: arbitrumone_swap_StableSwap_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [arbitrumone_swap_StableSwap!]!
  arbitrumone_swap_stableSwapAddLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): arbitrumone_swap_StableSwapAddLiquidityEvent
  arbitrumone_swap_stableSwapAddLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: arbitrumone_swap_StableSwapAddLiquidityEvent_orderBy
    orderDirection: arbitrumone_swap_OrderDirection
    where: arbitrumone_swap_StableSwapAddLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [arbitrumone_swap_StableSwapAddLiquidityEvent!]!
  arbitrumone_swap_stableSwapRemoveLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): arbitrumone_swap_StableSwapRemoveLiquidityEvent
  arbitrumone_swap_stableSwapRemoveLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: arbitrumone_swap_StableSwapRemoveLiquidityEvent_orderBy
    orderDirection: arbitrumone_swap_OrderDirection
    where: arbitrumone_swap_StableSwapRemoveLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [arbitrumone_swap_StableSwapRemoveLiquidityEvent!]!
  arbitrumone_swap_stableSwapExchange(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): arbitrumone_swap_StableSwapExchange
  arbitrumone_swap_stableSwapExchanges(
    skip: Int = 0
    first: Int = 100
    orderBy: arbitrumone_swap_StableSwapExchange_orderBy
    orderDirection: arbitrumone_swap_OrderDirection
    where: arbitrumone_swap_StableSwapExchange_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [arbitrumone_swap_StableSwapExchange!]!
  arbitrumone_swap_swapDailyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): arbitrumone_swap_SwapDailyVolume
  arbitrumone_swap_swapDailyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: arbitrumone_swap_SwapDailyVolume_orderBy
    orderDirection: arbitrumone_swap_OrderDirection
    where: arbitrumone_swap_SwapDailyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [arbitrumone_swap_SwapDailyVolume!]!
  arbitrumone_swap_swapHourlyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): arbitrumone_swap_SwapHourlyVolume
  arbitrumone_swap_swapHourlyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: arbitrumone_swap_SwapHourlyVolume_orderBy
    orderDirection: arbitrumone_swap_OrderDirection
    where: arbitrumone_swap_SwapHourlyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [arbitrumone_swap_SwapHourlyVolume!]!
  arbitrumone_swap_swapWeeklyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): arbitrumone_swap_SwapWeeklyVolume
  arbitrumone_swap_swapWeeklyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: arbitrumone_swap_SwapWeeklyVolume_orderBy
    orderDirection: arbitrumone_swap_OrderDirection
    where: arbitrumone_swap_SwapWeeklyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [arbitrumone_swap_SwapWeeklyVolume!]!
  arbitrumone_swap_lpAccount(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): arbitrumone_swap_LpAccount
  arbitrumone_swap_lpAccounts(
    skip: Int = 0
    first: Int = 100
    orderBy: arbitrumone_swap_LpAccount_orderBy
    orderDirection: arbitrumone_swap_OrderDirection
    where: arbitrumone_swap_LpAccount_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [arbitrumone_swap_LpAccount!]!
  arbitrumone_swap_lpAccountBalance(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): arbitrumone_swap_LpAccountBalance
  arbitrumone_swap_lpAccountBalances(
    skip: Int = 0
    first: Int = 100
    orderBy: arbitrumone_swap_LpAccountBalance_orderBy
    orderDirection: arbitrumone_swap_OrderDirection
    where: arbitrumone_swap_LpAccountBalance_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [arbitrumone_swap_LpAccountBalance!]!
  arbitrumone_swap_lpToken(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): arbitrumone_swap_LpToken
  arbitrumone_swap_lpTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: arbitrumone_swap_LpToken_orderBy
    orderDirection: arbitrumone_swap_OrderDirection
    where: arbitrumone_swap_LpToken_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [arbitrumone_swap_LpToken!]!
  arbitrumone_swap_lpTransferEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): arbitrumone_swap_LpTransferEvent
  arbitrumone_swap_lpTransferEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: arbitrumone_swap_LpTransferEvent_orderBy
    orderDirection: arbitrumone_swap_OrderDirection
    where: arbitrumone_swap_LpTransferEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [arbitrumone_swap_LpTransferEvent!]!
  arbitrumone_swap_stableSwapEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): arbitrumone_swap_StableSwapEvent
  arbitrumone_swap_stableSwapEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: arbitrumone_swap_StableSwapEvent_orderBy
    orderDirection: arbitrumone_swap_OrderDirection
    where: arbitrumone_swap_StableSwapEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [arbitrumone_swap_StableSwapEvent!]!
  arbitrumone_swap_swapTradeVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): arbitrumone_swap_SwapTradeVolume
  arbitrumone_swap_swapTradeVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: arbitrumone_swap_SwapTradeVolume_orderBy
    orderDirection: arbitrumone_swap_OrderDirection
    where: arbitrumone_swap_SwapTradeVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [arbitrumone_swap_SwapTradeVolume!]!
  arbitrumone_swap_lpTokenEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): arbitrumone_swap_LpTokenEvent
  arbitrumone_swap_lpTokenEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: arbitrumone_swap_LpTokenEvent_orderBy
    orderDirection: arbitrumone_swap_OrderDirection
    where: arbitrumone_swap_LpTokenEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: arbitrumone_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [arbitrumone_swap_LpTokenEvent!]!
  """Access to subgraph metadata"""
  arbitrumone_swap__meta(block: arbitrumone_swap_Block_height): arbitrumone_swap__Meta_
  bnb_swap_systemInfo(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): bnb_swap_SystemInfo
  bnb_swap_systemInfos(
    skip: Int = 0
    first: Int = 100
    orderBy: bnb_swap_SystemInfo_orderBy
    orderDirection: bnb_swap_OrderDirection
    where: bnb_swap_SystemInfo_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [bnb_swap_SystemInfo!]!
  bnb_swap_pooledToken(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): bnb_swap_PooledToken
  bnb_swap_pooledTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: bnb_swap_PooledToken_orderBy
    orderDirection: bnb_swap_OrderDirection
    where: bnb_swap_PooledToken_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [bnb_swap_PooledToken!]!
  bnb_swap_stableSwap(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): bnb_swap_StableSwap
  bnb_swap_stableSwaps(
    skip: Int = 0
    first: Int = 100
    orderBy: bnb_swap_StableSwap_orderBy
    orderDirection: bnb_swap_OrderDirection
    where: bnb_swap_StableSwap_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [bnb_swap_StableSwap!]!
  bnb_swap_stableSwapAddLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): bnb_swap_StableSwapAddLiquidityEvent
  bnb_swap_stableSwapAddLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: bnb_swap_StableSwapAddLiquidityEvent_orderBy
    orderDirection: bnb_swap_OrderDirection
    where: bnb_swap_StableSwapAddLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [bnb_swap_StableSwapAddLiquidityEvent!]!
  bnb_swap_stableSwapRemoveLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): bnb_swap_StableSwapRemoveLiquidityEvent
  bnb_swap_stableSwapRemoveLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: bnb_swap_StableSwapRemoveLiquidityEvent_orderBy
    orderDirection: bnb_swap_OrderDirection
    where: bnb_swap_StableSwapRemoveLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [bnb_swap_StableSwapRemoveLiquidityEvent!]!
  bnb_swap_stableSwapExchange(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): bnb_swap_StableSwapExchange
  bnb_swap_stableSwapExchanges(
    skip: Int = 0
    first: Int = 100
    orderBy: bnb_swap_StableSwapExchange_orderBy
    orderDirection: bnb_swap_OrderDirection
    where: bnb_swap_StableSwapExchange_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [bnb_swap_StableSwapExchange!]!
  bnb_swap_swapDailyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): bnb_swap_SwapDailyVolume
  bnb_swap_swapDailyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: bnb_swap_SwapDailyVolume_orderBy
    orderDirection: bnb_swap_OrderDirection
    where: bnb_swap_SwapDailyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [bnb_swap_SwapDailyVolume!]!
  bnb_swap_swapHourlyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): bnb_swap_SwapHourlyVolume
  bnb_swap_swapHourlyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: bnb_swap_SwapHourlyVolume_orderBy
    orderDirection: bnb_swap_OrderDirection
    where: bnb_swap_SwapHourlyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [bnb_swap_SwapHourlyVolume!]!
  bnb_swap_swapWeeklyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): bnb_swap_SwapWeeklyVolume
  bnb_swap_swapWeeklyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: bnb_swap_SwapWeeklyVolume_orderBy
    orderDirection: bnb_swap_OrderDirection
    where: bnb_swap_SwapWeeklyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [bnb_swap_SwapWeeklyVolume!]!
  bnb_swap_lpAccount(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): bnb_swap_LpAccount
  bnb_swap_lpAccounts(
    skip: Int = 0
    first: Int = 100
    orderBy: bnb_swap_LpAccount_orderBy
    orderDirection: bnb_swap_OrderDirection
    where: bnb_swap_LpAccount_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [bnb_swap_LpAccount!]!
  bnb_swap_lpAccountBalance(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): bnb_swap_LpAccountBalance
  bnb_swap_lpAccountBalances(
    skip: Int = 0
    first: Int = 100
    orderBy: bnb_swap_LpAccountBalance_orderBy
    orderDirection: bnb_swap_OrderDirection
    where: bnb_swap_LpAccountBalance_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [bnb_swap_LpAccountBalance!]!
  bnb_swap_lpToken(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): bnb_swap_LpToken
  bnb_swap_lpTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: bnb_swap_LpToken_orderBy
    orderDirection: bnb_swap_OrderDirection
    where: bnb_swap_LpToken_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [bnb_swap_LpToken!]!
  bnb_swap_lpTransferEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): bnb_swap_LpTransferEvent
  bnb_swap_lpTransferEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: bnb_swap_LpTransferEvent_orderBy
    orderDirection: bnb_swap_OrderDirection
    where: bnb_swap_LpTransferEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [bnb_swap_LpTransferEvent!]!
  bnb_swap_stableSwapEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): bnb_swap_StableSwapEvent
  bnb_swap_stableSwapEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: bnb_swap_StableSwapEvent_orderBy
    orderDirection: bnb_swap_OrderDirection
    where: bnb_swap_StableSwapEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [bnb_swap_StableSwapEvent!]!
  bnb_swap_swapTradeVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): bnb_swap_SwapTradeVolume
  bnb_swap_swapTradeVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: bnb_swap_SwapTradeVolume_orderBy
    orderDirection: bnb_swap_OrderDirection
    where: bnb_swap_SwapTradeVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [bnb_swap_SwapTradeVolume!]!
  bnb_swap_lpTokenEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): bnb_swap_LpTokenEvent
  bnb_swap_lpTokenEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: bnb_swap_LpTokenEvent_orderBy
    orderDirection: bnb_swap_OrderDirection
    where: bnb_swap_LpTokenEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: bnb_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [bnb_swap_LpTokenEvent!]!
  """Access to subgraph metadata"""
  bnb_swap__meta(block: bnb_swap_Block_height): bnb_swap__Meta_
  xlayer_swap_systemInfo(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xlayer_swap_SystemInfo
  xlayer_swap_systemInfos(
    skip: Int = 0
    first: Int = 100
    orderBy: xlayer_swap_SystemInfo_orderBy
    orderDirection: xlayer_swap_OrderDirection
    where: xlayer_swap_SystemInfo_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xlayer_swap_SystemInfo!]!
  xlayer_swap_pooledToken(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xlayer_swap_PooledToken
  xlayer_swap_pooledTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: xlayer_swap_PooledToken_orderBy
    orderDirection: xlayer_swap_OrderDirection
    where: xlayer_swap_PooledToken_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xlayer_swap_PooledToken!]!
  xlayer_swap_stableSwap(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xlayer_swap_StableSwap
  xlayer_swap_stableSwaps(
    skip: Int = 0
    first: Int = 100
    orderBy: xlayer_swap_StableSwap_orderBy
    orderDirection: xlayer_swap_OrderDirection
    where: xlayer_swap_StableSwap_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xlayer_swap_StableSwap!]!
  xlayer_swap_stableSwapAddLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xlayer_swap_StableSwapAddLiquidityEvent
  xlayer_swap_stableSwapAddLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: xlayer_swap_StableSwapAddLiquidityEvent_orderBy
    orderDirection: xlayer_swap_OrderDirection
    where: xlayer_swap_StableSwapAddLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xlayer_swap_StableSwapAddLiquidityEvent!]!
  xlayer_swap_stableSwapRemoveLiquidityEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xlayer_swap_StableSwapRemoveLiquidityEvent
  xlayer_swap_stableSwapRemoveLiquidityEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: xlayer_swap_StableSwapRemoveLiquidityEvent_orderBy
    orderDirection: xlayer_swap_OrderDirection
    where: xlayer_swap_StableSwapRemoveLiquidityEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xlayer_swap_StableSwapRemoveLiquidityEvent!]!
  xlayer_swap_stableSwapExchange(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xlayer_swap_StableSwapExchange
  xlayer_swap_stableSwapExchanges(
    skip: Int = 0
    first: Int = 100
    orderBy: xlayer_swap_StableSwapExchange_orderBy
    orderDirection: xlayer_swap_OrderDirection
    where: xlayer_swap_StableSwapExchange_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xlayer_swap_StableSwapExchange!]!
  xlayer_swap_swapDailyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xlayer_swap_SwapDailyVolume
  xlayer_swap_swapDailyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: xlayer_swap_SwapDailyVolume_orderBy
    orderDirection: xlayer_swap_OrderDirection
    where: xlayer_swap_SwapDailyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xlayer_swap_SwapDailyVolume!]!
  xlayer_swap_swapHourlyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xlayer_swap_SwapHourlyVolume
  xlayer_swap_swapHourlyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: xlayer_swap_SwapHourlyVolume_orderBy
    orderDirection: xlayer_swap_OrderDirection
    where: xlayer_swap_SwapHourlyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xlayer_swap_SwapHourlyVolume!]!
  xlayer_swap_swapWeeklyVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xlayer_swap_SwapWeeklyVolume
  xlayer_swap_swapWeeklyVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: xlayer_swap_SwapWeeklyVolume_orderBy
    orderDirection: xlayer_swap_OrderDirection
    where: xlayer_swap_SwapWeeklyVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xlayer_swap_SwapWeeklyVolume!]!
  xlayer_swap_lpAccount(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xlayer_swap_LpAccount
  xlayer_swap_lpAccounts(
    skip: Int = 0
    first: Int = 100
    orderBy: xlayer_swap_LpAccount_orderBy
    orderDirection: xlayer_swap_OrderDirection
    where: xlayer_swap_LpAccount_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xlayer_swap_LpAccount!]!
  xlayer_swap_lpAccountBalance(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xlayer_swap_LpAccountBalance
  xlayer_swap_lpAccountBalances(
    skip: Int = 0
    first: Int = 100
    orderBy: xlayer_swap_LpAccountBalance_orderBy
    orderDirection: xlayer_swap_OrderDirection
    where: xlayer_swap_LpAccountBalance_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xlayer_swap_LpAccountBalance!]!
  xlayer_swap_lpToken(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xlayer_swap_LpToken
  xlayer_swap_lpTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: xlayer_swap_LpToken_orderBy
    orderDirection: xlayer_swap_OrderDirection
    where: xlayer_swap_LpToken_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xlayer_swap_LpToken!]!
  xlayer_swap_lpTransferEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xlayer_swap_LpTransferEvent
  xlayer_swap_lpTransferEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: xlayer_swap_LpTransferEvent_orderBy
    orderDirection: xlayer_swap_OrderDirection
    where: xlayer_swap_LpTransferEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xlayer_swap_LpTransferEvent!]!
  xlayer_swap_stableSwapEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xlayer_swap_StableSwapEvent
  xlayer_swap_stableSwapEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: xlayer_swap_StableSwapEvent_orderBy
    orderDirection: xlayer_swap_OrderDirection
    where: xlayer_swap_StableSwapEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xlayer_swap_StableSwapEvent!]!
  xlayer_swap_swapTradeVolume(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xlayer_swap_SwapTradeVolume
  xlayer_swap_swapTradeVolumes(
    skip: Int = 0
    first: Int = 100
    orderBy: xlayer_swap_SwapTradeVolume_orderBy
    orderDirection: xlayer_swap_OrderDirection
    where: xlayer_swap_SwapTradeVolume_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xlayer_swap_SwapTradeVolume!]!
  xlayer_swap_lpTokenEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): xlayer_swap_LpTokenEvent
  xlayer_swap_lpTokenEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: xlayer_swap_LpTokenEvent_orderBy
    orderDirection: xlayer_swap_OrderDirection
    where: xlayer_swap_LpTokenEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: xlayer_swap_Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [xlayer_swap_LpTokenEvent!]!
  """Access to subgraph metadata"""
  xlayer_swap__meta(block: xlayer_swap_Block_height): xlayer_swap__Meta_
}

enum mode_swap_Aggregation_interval {
  hour
  day
}

scalar mode_swap_BigDecimal

scalar BigInt

input mode_swap_BlockChangedFilter {
  number_gte: Int!
}

input mode_swap_Block_height {
  hash: mode_swap_Bytes
  number: Int
  number_gte: Int
}

scalar mode_swap_Bytes

"""
8 bytes signed integer

"""
scalar mode_swap_Int8

type mode_swap_LpAccount {
  id: ID!
  address: mode_swap_Bytes!
  balances(skip: Int = 0, first: Int = 100, orderBy: mode_swap_LpAccountBalance_orderBy, orderDirection: mode_swap_OrderDirection, where: mode_swap_LpAccountBalance_filter): [mode_swap_LpAccountBalance!]!
}

type mode_swap_LpAccountBalance {
  id: ID!
  account: mode_swap_LpAccount!
  token: mode_swap_LpToken!
  amount: mode_swap_BigDecimal!
  block: BigInt
  modified: BigInt
  transaction: mode_swap_Bytes
}

input mode_swap_LpAccountBalance_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  account: String
  account_not: String
  account_gt: String
  account_lt: String
  account_gte: String
  account_lte: String
  account_in: [String!]
  account_not_in: [String!]
  account_contains: String
  account_contains_nocase: String
  account_not_contains: String
  account_not_contains_nocase: String
  account_starts_with: String
  account_starts_with_nocase: String
  account_not_starts_with: String
  account_not_starts_with_nocase: String
  account_ends_with: String
  account_ends_with_nocase: String
  account_not_ends_with: String
  account_not_ends_with_nocase: String
  account_: mode_swap_LpAccount_filter
  token: String
  token_not: String
  token_gt: String
  token_lt: String
  token_gte: String
  token_lte: String
  token_in: [String!]
  token_not_in: [String!]
  token_contains: String
  token_contains_nocase: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_: mode_swap_LpToken_filter
  amount: mode_swap_BigDecimal
  amount_not: mode_swap_BigDecimal
  amount_gt: mode_swap_BigDecimal
  amount_lt: mode_swap_BigDecimal
  amount_gte: mode_swap_BigDecimal
  amount_lte: mode_swap_BigDecimal
  amount_in: [mode_swap_BigDecimal!]
  amount_not_in: [mode_swap_BigDecimal!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  modified: BigInt
  modified_not: BigInt
  modified_gt: BigInt
  modified_lt: BigInt
  modified_gte: BigInt
  modified_lte: BigInt
  modified_in: [BigInt!]
  modified_not_in: [BigInt!]
  transaction: mode_swap_Bytes
  transaction_not: mode_swap_Bytes
  transaction_gt: mode_swap_Bytes
  transaction_lt: mode_swap_Bytes
  transaction_gte: mode_swap_Bytes
  transaction_lte: mode_swap_Bytes
  transaction_in: [mode_swap_Bytes!]
  transaction_not_in: [mode_swap_Bytes!]
  transaction_contains: mode_swap_Bytes
  transaction_not_contains: mode_swap_Bytes
  """Filter for the block changed event."""
  _change_block: mode_swap_BlockChangedFilter
  and: [mode_swap_LpAccountBalance_filter]
  or: [mode_swap_LpAccountBalance_filter]
}

enum mode_swap_LpAccountBalance_orderBy {
  id
  account
  account__id
  account__address
  token
  token__id
  token__address
  token__decimals
  token__name
  token__symbol
  token__totalSupply
  amount
  block
  modified
  transaction
}

input mode_swap_LpAccount_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  address: mode_swap_Bytes
  address_not: mode_swap_Bytes
  address_gt: mode_swap_Bytes
  address_lt: mode_swap_Bytes
  address_gte: mode_swap_Bytes
  address_lte: mode_swap_Bytes
  address_in: [mode_swap_Bytes!]
  address_not_in: [mode_swap_Bytes!]
  address_contains: mode_swap_Bytes
  address_not_contains: mode_swap_Bytes
  balances_: mode_swap_LpAccountBalance_filter
  """Filter for the block changed event."""
  _change_block: mode_swap_BlockChangedFilter
  and: [mode_swap_LpAccount_filter]
  or: [mode_swap_LpAccount_filter]
}

enum mode_swap_LpAccount_orderBy {
  id
  address
  balances
}

type mode_swap_LpToken {
  id: ID!
  address: mode_swap_Bytes!
  stableSwap: mode_swap_StableSwap!
  decimals: Int!
  name: String!
  symbol: String!
  totalSupply: mode_swap_BigDecimal!
  events(skip: Int = 0, first: Int = 100, orderBy: mode_swap_LpTokenEvent_orderBy, orderDirection: mode_swap_OrderDirection, where: mode_swap_LpTokenEvent_filter): [mode_swap_LpTokenEvent!]!
}

interface mode_swap_LpTokenEvent {
  id: ID!
  token: mode_swap_LpToken!
  amount: mode_swap_BigDecimal!
  block: BigInt!
  timestamp: BigInt!
  transaction: mode_swap_Bytes!
  nonce: BigInt!
}

input mode_swap_LpTokenEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  token: String
  token_not: String
  token_gt: String
  token_lt: String
  token_gte: String
  token_lte: String
  token_in: [String!]
  token_not_in: [String!]
  token_contains: String
  token_contains_nocase: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_: mode_swap_LpToken_filter
  amount: mode_swap_BigDecimal
  amount_not: mode_swap_BigDecimal
  amount_gt: mode_swap_BigDecimal
  amount_lt: mode_swap_BigDecimal
  amount_gte: mode_swap_BigDecimal
  amount_lte: mode_swap_BigDecimal
  amount_in: [mode_swap_BigDecimal!]
  amount_not_in: [mode_swap_BigDecimal!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: mode_swap_Bytes
  transaction_not: mode_swap_Bytes
  transaction_gt: mode_swap_Bytes
  transaction_lt: mode_swap_Bytes
  transaction_gte: mode_swap_Bytes
  transaction_lte: mode_swap_Bytes
  transaction_in: [mode_swap_Bytes!]
  transaction_not_in: [mode_swap_Bytes!]
  transaction_contains: mode_swap_Bytes
  transaction_not_contains: mode_swap_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: mode_swap_BlockChangedFilter
  and: [mode_swap_LpTokenEvent_filter]
  or: [mode_swap_LpTokenEvent_filter]
}

enum mode_swap_LpTokenEvent_orderBy {
  id
  token
  token__id
  token__address
  token__decimals
  token__name
  token__symbol
  token__totalSupply
  amount
  block
  timestamp
  transaction
  nonce
}

input mode_swap_LpToken_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  address: mode_swap_Bytes
  address_not: mode_swap_Bytes
  address_gt: mode_swap_Bytes
  address_lt: mode_swap_Bytes
  address_gte: mode_swap_Bytes
  address_lte: mode_swap_Bytes
  address_in: [mode_swap_Bytes!]
  address_not_in: [mode_swap_Bytes!]
  address_contains: mode_swap_Bytes
  address_not_contains: mode_swap_Bytes
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: mode_swap_StableSwap_filter
  decimals: Int
  decimals_not: Int
  decimals_gt: Int
  decimals_lt: Int
  decimals_gte: Int
  decimals_lte: Int
  decimals_in: [Int!]
  decimals_not_in: [Int!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  symbol: String
  symbol_not: String
  symbol_gt: String
  symbol_lt: String
  symbol_gte: String
  symbol_lte: String
  symbol_in: [String!]
  symbol_not_in: [String!]
  symbol_contains: String
  symbol_contains_nocase: String
  symbol_not_contains: String
  symbol_not_contains_nocase: String
  symbol_starts_with: String
  symbol_starts_with_nocase: String
  symbol_not_starts_with: String
  symbol_not_starts_with_nocase: String
  symbol_ends_with: String
  symbol_ends_with_nocase: String
  symbol_not_ends_with: String
  symbol_not_ends_with_nocase: String
  totalSupply: mode_swap_BigDecimal
  totalSupply_not: mode_swap_BigDecimal
  totalSupply_gt: mode_swap_BigDecimal
  totalSupply_lt: mode_swap_BigDecimal
  totalSupply_gte: mode_swap_BigDecimal
  totalSupply_lte: mode_swap_BigDecimal
  totalSupply_in: [mode_swap_BigDecimal!]
  totalSupply_not_in: [mode_swap_BigDecimal!]
  events_: mode_swap_LpTokenEvent_filter
  """Filter for the block changed event."""
  _change_block: mode_swap_BlockChangedFilter
  and: [mode_swap_LpToken_filter]
  or: [mode_swap_LpToken_filter]
}

enum mode_swap_LpToken_orderBy {
  id
  address
  stableSwap
  stableSwap__id
  stableSwap__isActive
  stableSwap__key
  stableSwap__canonicalId
  stableSwap__domain
  stableSwap__swapPool
  stableSwap__lpToken
  stableSwap__initialA
  stableSwap__futureA
  stableSwap__initialATime
  stableSwap__futureATime
  stableSwap__swapFee
  stableSwap__adminFee
  stableSwap__virtualPrice
  stableSwap__invariant
  stableSwap__lpTokenSupply
  decimals
  name
  symbol
  totalSupply
  events
}

type mode_swap_LpTransferEvent implements mode_swap_LpTokenEvent {
  id: ID!
  token: mode_swap_LpToken!
  amount: mode_swap_BigDecimal!
  from: mode_swap_Bytes!
  to: mode_swap_Bytes!
  fromBalance: mode_swap_BigDecimal!
  toBalance: mode_swap_BigDecimal!
  block: BigInt!
  timestamp: BigInt!
  transaction: mode_swap_Bytes!
  nonce: BigInt!
}

input mode_swap_LpTransferEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  token: String
  token_not: String
  token_gt: String
  token_lt: String
  token_gte: String
  token_lte: String
  token_in: [String!]
  token_not_in: [String!]
  token_contains: String
  token_contains_nocase: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_: mode_swap_LpToken_filter
  amount: mode_swap_BigDecimal
  amount_not: mode_swap_BigDecimal
  amount_gt: mode_swap_BigDecimal
  amount_lt: mode_swap_BigDecimal
  amount_gte: mode_swap_BigDecimal
  amount_lte: mode_swap_BigDecimal
  amount_in: [mode_swap_BigDecimal!]
  amount_not_in: [mode_swap_BigDecimal!]
  from: mode_swap_Bytes
  from_not: mode_swap_Bytes
  from_gt: mode_swap_Bytes
  from_lt: mode_swap_Bytes
  from_gte: mode_swap_Bytes
  from_lte: mode_swap_Bytes
  from_in: [mode_swap_Bytes!]
  from_not_in: [mode_swap_Bytes!]
  from_contains: mode_swap_Bytes
  from_not_contains: mode_swap_Bytes
  to: mode_swap_Bytes
  to_not: mode_swap_Bytes
  to_gt: mode_swap_Bytes
  to_lt: mode_swap_Bytes
  to_gte: mode_swap_Bytes
  to_lte: mode_swap_Bytes
  to_in: [mode_swap_Bytes!]
  to_not_in: [mode_swap_Bytes!]
  to_contains: mode_swap_Bytes
  to_not_contains: mode_swap_Bytes
  fromBalance: mode_swap_BigDecimal
  fromBalance_not: mode_swap_BigDecimal
  fromBalance_gt: mode_swap_BigDecimal
  fromBalance_lt: mode_swap_BigDecimal
  fromBalance_gte: mode_swap_BigDecimal
  fromBalance_lte: mode_swap_BigDecimal
  fromBalance_in: [mode_swap_BigDecimal!]
  fromBalance_not_in: [mode_swap_BigDecimal!]
  toBalance: mode_swap_BigDecimal
  toBalance_not: mode_swap_BigDecimal
  toBalance_gt: mode_swap_BigDecimal
  toBalance_lt: mode_swap_BigDecimal
  toBalance_gte: mode_swap_BigDecimal
  toBalance_lte: mode_swap_BigDecimal
  toBalance_in: [mode_swap_BigDecimal!]
  toBalance_not_in: [mode_swap_BigDecimal!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: mode_swap_Bytes
  transaction_not: mode_swap_Bytes
  transaction_gt: mode_swap_Bytes
  transaction_lt: mode_swap_Bytes
  transaction_gte: mode_swap_Bytes
  transaction_lte: mode_swap_Bytes
  transaction_in: [mode_swap_Bytes!]
  transaction_not_in: [mode_swap_Bytes!]
  transaction_contains: mode_swap_Bytes
  transaction_not_contains: mode_swap_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: mode_swap_BlockChangedFilter
  and: [mode_swap_LpTransferEvent_filter]
  or: [mode_swap_LpTransferEvent_filter]
}

enum mode_swap_LpTransferEvent_orderBy {
  id
  token
  token__id
  token__address
  token__decimals
  token__name
  token__symbol
  token__totalSupply
  amount
  from
  to
  fromBalance
  toBalance
  block
  timestamp
  transaction
  nonce
}

"""Defines the order direction, either ascending or descending"""
enum mode_swap_OrderDirection {
  asc
  desc
}

type mode_swap_PooledToken {
  id: ID!
  asset: mode_swap_Bytes!
}

input mode_swap_PooledToken_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  asset: mode_swap_Bytes
  asset_not: mode_swap_Bytes
  asset_gt: mode_swap_Bytes
  asset_lt: mode_swap_Bytes
  asset_gte: mode_swap_Bytes
  asset_lte: mode_swap_Bytes
  asset_in: [mode_swap_Bytes!]
  asset_not_in: [mode_swap_Bytes!]
  asset_contains: mode_swap_Bytes
  asset_not_contains: mode_swap_Bytes
  """Filter for the block changed event."""
  _change_block: mode_swap_BlockChangedFilter
  and: [mode_swap_PooledToken_filter]
  or: [mode_swap_PooledToken_filter]
}

enum mode_swap_PooledToken_orderBy {
  id
  asset
}

type mode_swap_StableSwap {
  id: ID!
  isActive: Boolean
  key: mode_swap_Bytes!
  canonicalId: mode_swap_Bytes
  domain: BigInt
  swapPool: mode_swap_Bytes
  lpToken: mode_swap_Bytes
  initialA: BigInt
  futureA: BigInt
  initialATime: BigInt
  futureATime: BigInt
  swapFee: BigInt
  adminFee: BigInt
  pooledTokens: [mode_swap_Bytes!]!
  tokenPrecisionMultipliers: [BigInt!]!
  balances: [BigInt!]!
  adminFees: [BigInt!]!
  virtualPrice: BigInt!
  invariant: BigInt!
  lpTokenSupply: BigInt!
  events(skip: Int = 0, first: Int = 100, orderBy: mode_swap_StableSwapEvent_orderBy, orderDirection: mode_swap_OrderDirection, where: mode_swap_StableSwapEvent_filter): [mode_swap_StableSwapEvent!]
  exchanges(skip: Int = 0, first: Int = 100, orderBy: mode_swap_StableSwapExchange_orderBy, orderDirection: mode_swap_OrderDirection, where: mode_swap_StableSwapExchange_filter): [mode_swap_StableSwapExchange!]
  hourlyVolumes(skip: Int = 0, first: Int = 100, orderBy: mode_swap_SwapHourlyVolume_orderBy, orderDirection: mode_swap_OrderDirection, where: mode_swap_SwapHourlyVolume_filter): [mode_swap_SwapHourlyVolume!]
  dailyVolumes(skip: Int = 0, first: Int = 100, orderBy: mode_swap_SwapDailyVolume_orderBy, orderDirection: mode_swap_OrderDirection, where: mode_swap_SwapDailyVolume_filter): [mode_swap_SwapDailyVolume!]
  weeklyVolumes(skip: Int = 0, first: Int = 100, orderBy: mode_swap_SwapWeeklyVolume_orderBy, orderDirection: mode_swap_OrderDirection, where: mode_swap_SwapWeeklyVolume_filter): [mode_swap_SwapWeeklyVolume!]
}

type mode_swap_StableSwapAddLiquidityEvent implements mode_swap_StableSwapEvent {
  id: ID!
  stableSwap: mode_swap_StableSwap!
  provider: mode_swap_Bytes!
  tokenAmounts: [BigInt!]!
  fees: [BigInt!]!
  invariant: BigInt
  lpTokenSupply: BigInt!
  lpTokenAmount: BigInt!
  balances: [BigInt!]!
  block: BigInt!
  timestamp: BigInt!
  transaction: mode_swap_Bytes!
  nonce: BigInt!
}

input mode_swap_StableSwapAddLiquidityEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: mode_swap_StableSwap_filter
  provider: mode_swap_Bytes
  provider_not: mode_swap_Bytes
  provider_gt: mode_swap_Bytes
  provider_lt: mode_swap_Bytes
  provider_gte: mode_swap_Bytes
  provider_lte: mode_swap_Bytes
  provider_in: [mode_swap_Bytes!]
  provider_not_in: [mode_swap_Bytes!]
  provider_contains: mode_swap_Bytes
  provider_not_contains: mode_swap_Bytes
  tokenAmounts: [BigInt!]
  tokenAmounts_not: [BigInt!]
  tokenAmounts_contains: [BigInt!]
  tokenAmounts_contains_nocase: [BigInt!]
  tokenAmounts_not_contains: [BigInt!]
  tokenAmounts_not_contains_nocase: [BigInt!]
  fees: [BigInt!]
  fees_not: [BigInt!]
  fees_contains: [BigInt!]
  fees_contains_nocase: [BigInt!]
  fees_not_contains: [BigInt!]
  fees_not_contains_nocase: [BigInt!]
  invariant: BigInt
  invariant_not: BigInt
  invariant_gt: BigInt
  invariant_lt: BigInt
  invariant_gte: BigInt
  invariant_lte: BigInt
  invariant_in: [BigInt!]
  invariant_not_in: [BigInt!]
  lpTokenSupply: BigInt
  lpTokenSupply_not: BigInt
  lpTokenSupply_gt: BigInt
  lpTokenSupply_lt: BigInt
  lpTokenSupply_gte: BigInt
  lpTokenSupply_lte: BigInt
  lpTokenSupply_in: [BigInt!]
  lpTokenSupply_not_in: [BigInt!]
  lpTokenAmount: BigInt
  lpTokenAmount_not: BigInt
  lpTokenAmount_gt: BigInt
  lpTokenAmount_lt: BigInt
  lpTokenAmount_gte: BigInt
  lpTokenAmount_lte: BigInt
  lpTokenAmount_in: [BigInt!]
  lpTokenAmount_not_in: [BigInt!]
  balances: [BigInt!]
  balances_not: [BigInt!]
  balances_contains: [BigInt!]
  balances_contains_nocase: [BigInt!]
  balances_not_contains: [BigInt!]
  balances_not_contains_nocase: [BigInt!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: mode_swap_Bytes
  transaction_not: mode_swap_Bytes
  transaction_gt: mode_swap_Bytes
  transaction_lt: mode_swap_Bytes
  transaction_gte: mode_swap_Bytes
  transaction_lte: mode_swap_Bytes
  transaction_in: [mode_swap_Bytes!]
  transaction_not_in: [mode_swap_Bytes!]
  transaction_contains: mode_swap_Bytes
  transaction_not_contains: mode_swap_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: mode_swap_BlockChangedFilter
  and: [mode_swap_StableSwapAddLiquidityEvent_filter]
  or: [mode_swap_StableSwapAddLiquidityEvent_filter]
}

enum mode_swap_StableSwapAddLiquidityEvent_orderBy {
  id
  stableSwap
  stableSwap__id
  stableSwap__isActive
  stableSwap__key
  stableSwap__canonicalId
  stableSwap__domain
  stableSwap__swapPool
  stableSwap__lpToken
  stableSwap__initialA
  stableSwap__futureA
  stableSwap__initialATime
  stableSwap__futureATime
  stableSwap__swapFee
  stableSwap__adminFee
  stableSwap__virtualPrice
  stableSwap__invariant
  stableSwap__lpTokenSupply
  provider
  tokenAmounts
  fees
  invariant
  lpTokenSupply
  lpTokenAmount
  balances
  block
  timestamp
  transaction
  nonce
}

interface mode_swap_StableSwapEvent {
  id: ID!
  stableSwap: mode_swap_StableSwap!
  block: BigInt!
  timestamp: BigInt!
  transaction: mode_swap_Bytes!
  nonce: BigInt!
}

input mode_swap_StableSwapEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: mode_swap_StableSwap_filter
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: mode_swap_Bytes
  transaction_not: mode_swap_Bytes
  transaction_gt: mode_swap_Bytes
  transaction_lt: mode_swap_Bytes
  transaction_gte: mode_swap_Bytes
  transaction_lte: mode_swap_Bytes
  transaction_in: [mode_swap_Bytes!]
  transaction_not_in: [mode_swap_Bytes!]
  transaction_contains: mode_swap_Bytes
  transaction_not_contains: mode_swap_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: mode_swap_BlockChangedFilter
  and: [mode_swap_StableSwapEvent_filter]
  or: [mode_swap_StableSwapEvent_filter]
}

enum mode_swap_StableSwapEvent_orderBy {
  id
  stableSwap
  stableSwap__id
  stableSwap__isActive
  stableSwap__key
  stableSwap__canonicalId
  stableSwap__domain
  stableSwap__swapPool
  stableSwap__lpToken
  stableSwap__initialA
  stableSwap__futureA
  stableSwap__initialATime
  stableSwap__futureATime
  stableSwap__swapFee
  stableSwap__adminFee
  stableSwap__virtualPrice
  stableSwap__invariant
  stableSwap__lpTokenSupply
  block
  timestamp
  transaction
  nonce
}

type mode_swap_StableSwapExchange {
  id: ID!
  stableSwap: mode_swap_StableSwap!
  buyer: mode_swap_Bytes!
  boughtId: BigInt!
  tokensBought: BigInt!
  soldId: BigInt!
  tokensSold: BigInt!
  balances: [BigInt!]!
  fee: BigInt!
  block: BigInt!
  timestamp: BigInt!
  transaction: mode_swap_Bytes!
  nonce: BigInt!
}

input mode_swap_StableSwapExchange_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: mode_swap_StableSwap_filter
  buyer: mode_swap_Bytes
  buyer_not: mode_swap_Bytes
  buyer_gt: mode_swap_Bytes
  buyer_lt: mode_swap_Bytes
  buyer_gte: mode_swap_Bytes
  buyer_lte: mode_swap_Bytes
  buyer_in: [mode_swap_Bytes!]
  buyer_not_in: [mode_swap_Bytes!]
  buyer_contains: mode_swap_Bytes
  buyer_not_contains: mode_swap_Bytes
  boughtId: BigInt
  boughtId_not: BigInt
  boughtId_gt: BigInt
  boughtId_lt: BigInt
  boughtId_gte: BigInt
  boughtId_lte: BigInt
  boughtId_in: [BigInt!]
  boughtId_not_in: [BigInt!]
  tokensBought: BigInt
  tokensBought_not: BigInt
  tokensBought_gt: BigInt
  tokensBought_lt: BigInt
  tokensBought_gte: BigInt
  tokensBought_lte: BigInt
  tokensBought_in: [BigInt!]
  tokensBought_not_in: [BigInt!]
  soldId: BigInt
  soldId_not: BigInt
  soldId_gt: BigInt
  soldId_lt: BigInt
  soldId_gte: BigInt
  soldId_lte: BigInt
  soldId_in: [BigInt!]
  soldId_not_in: [BigInt!]
  tokensSold: BigInt
  tokensSold_not: BigInt
  tokensSold_gt: BigInt
  tokensSold_lt: BigInt
  tokensSold_gte: BigInt
  tokensSold_lte: BigInt
  tokensSold_in: [BigInt!]
  tokensSold_not_in: [BigInt!]
  balances: [BigInt!]
  balances_not: [BigInt!]
  balances_contains: [BigInt!]
  balances_contains_nocase: [BigInt!]
  balances_not_contains: [BigInt!]
  balances_not_contains_nocase: [BigInt!]
  fee: BigInt
  fee_not: BigInt
  fee_gt: BigInt
  fee_lt: BigInt
  fee_gte: BigInt
  fee_lte: BigInt
  fee_in: [BigInt!]
  fee_not_in: [BigInt!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: mode_swap_Bytes
  transaction_not: mode_swap_Bytes
  transaction_gt: mode_swap_Bytes
  transaction_lt: mode_swap_Bytes
  transaction_gte: mode_swap_Bytes
  transaction_lte: mode_swap_Bytes
  transaction_in: [mode_swap_Bytes!]
  transaction_not_in: [mode_swap_Bytes!]
  transaction_contains: mode_swap_Bytes
  transaction_not_contains: mode_swap_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: mode_swap_BlockChangedFilter
  and: [mode_swap_StableSwapExchange_filter]
  or: [mode_swap_StableSwapExchange_filter]
}

enum mode_swap_StableSwapExchange_orderBy {
  id
  stableSwap
  stableSwap__id
  stableSwap__isActive
  stableSwap__key
  stableSwap__canonicalId
  stableSwap__domain
  stableSwap__swapPool
  stableSwap__lpToken
  stableSwap__initialA
  stableSwap__futureA
  stableSwap__initialATime
  stableSwap__futureATime
  stableSwap__swapFee
  stableSwap__adminFee
  stableSwap__virtualPrice
  stableSwap__invariant
  stableSwap__lpTokenSupply
  buyer
  boughtId
  tokensBought
  soldId
  tokensSold
  balances
  fee
  block
  timestamp
  transaction
  nonce
}

type mode_swap_StableSwapRemoveLiquidityEvent implements mode_swap_StableSwapEvent {
  id: ID!
  stableSwap: mode_swap_StableSwap!
  provider: mode_swap_Bytes!
  tokenAmounts: [BigInt!]!
  fees: [BigInt!]
  invariant: BigInt
  lpTokenSupply: BigInt!
  lpTokenAmount: BigInt!
  balances: [BigInt!]!
  block: BigInt!
  timestamp: BigInt!
  transaction: mode_swap_Bytes!
  nonce: BigInt!
}

input mode_swap_StableSwapRemoveLiquidityEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: mode_swap_StableSwap_filter
  provider: mode_swap_Bytes
  provider_not: mode_swap_Bytes
  provider_gt: mode_swap_Bytes
  provider_lt: mode_swap_Bytes
  provider_gte: mode_swap_Bytes
  provider_lte: mode_swap_Bytes
  provider_in: [mode_swap_Bytes!]
  provider_not_in: [mode_swap_Bytes!]
  provider_contains: mode_swap_Bytes
  provider_not_contains: mode_swap_Bytes
  tokenAmounts: [BigInt!]
  tokenAmounts_not: [BigInt!]
  tokenAmounts_contains: [BigInt!]
  tokenAmounts_contains_nocase: [BigInt!]
  tokenAmounts_not_contains: [BigInt!]
  tokenAmounts_not_contains_nocase: [BigInt!]
  fees: [BigInt!]
  fees_not: [BigInt!]
  fees_contains: [BigInt!]
  fees_contains_nocase: [BigInt!]
  fees_not_contains: [BigInt!]
  fees_not_contains_nocase: [BigInt!]
  invariant: BigInt
  invariant_not: BigInt
  invariant_gt: BigInt
  invariant_lt: BigInt
  invariant_gte: BigInt
  invariant_lte: BigInt
  invariant_in: [BigInt!]
  invariant_not_in: [BigInt!]
  lpTokenSupply: BigInt
  lpTokenSupply_not: BigInt
  lpTokenSupply_gt: BigInt
  lpTokenSupply_lt: BigInt
  lpTokenSupply_gte: BigInt
  lpTokenSupply_lte: BigInt
  lpTokenSupply_in: [BigInt!]
  lpTokenSupply_not_in: [BigInt!]
  lpTokenAmount: BigInt
  lpTokenAmount_not: BigInt
  lpTokenAmount_gt: BigInt
  lpTokenAmount_lt: BigInt
  lpTokenAmount_gte: BigInt
  lpTokenAmount_lte: BigInt
  lpTokenAmount_in: [BigInt!]
  lpTokenAmount_not_in: [BigInt!]
  balances: [BigInt!]
  balances_not: [BigInt!]
  balances_contains: [BigInt!]
  balances_contains_nocase: [BigInt!]
  balances_not_contains: [BigInt!]
  balances_not_contains_nocase: [BigInt!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: mode_swap_Bytes
  transaction_not: mode_swap_Bytes
  transaction_gt: mode_swap_Bytes
  transaction_lt: mode_swap_Bytes
  transaction_gte: mode_swap_Bytes
  transaction_lte: mode_swap_Bytes
  transaction_in: [mode_swap_Bytes!]
  transaction_not_in: [mode_swap_Bytes!]
  transaction_contains: mode_swap_Bytes
  transaction_not_contains: mode_swap_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: mode_swap_BlockChangedFilter
  and: [mode_swap_StableSwapRemoveLiquidityEvent_filter]
  or: [mode_swap_StableSwapRemoveLiquidityEvent_filter]
}

enum mode_swap_StableSwapRemoveLiquidityEvent_orderBy {
  id
  stableSwap
  stableSwap__id
  stableSwap__isActive
  stableSwap__key
  stableSwap__canonicalId
  stableSwap__domain
  stableSwap__swapPool
  stableSwap__lpToken
  stableSwap__initialA
  stableSwap__futureA
  stableSwap__initialATime
  stableSwap__futureATime
  stableSwap__swapFee
  stableSwap__adminFee
  stableSwap__virtualPrice
  stableSwap__invariant
  stableSwap__lpTokenSupply
  provider
  tokenAmounts
  fees
  invariant
  lpTokenSupply
  lpTokenAmount
  balances
  block
  timestamp
  transaction
  nonce
}

input mode_swap_StableSwap_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  isActive: Boolean
  isActive_not: Boolean
  isActive_in: [Boolean!]
  isActive_not_in: [Boolean!]
  key: mode_swap_Bytes
  key_not: mode_swap_Bytes
  key_gt: mode_swap_Bytes
  key_lt: mode_swap_Bytes
  key_gte: mode_swap_Bytes
  key_lte: mode_swap_Bytes
  key_in: [mode_swap_Bytes!]
  key_not_in: [mode_swap_Bytes!]
  key_contains: mode_swap_Bytes
  key_not_contains: mode_swap_Bytes
  canonicalId: mode_swap_Bytes
  canonicalId_not: mode_swap_Bytes
  canonicalId_gt: mode_swap_Bytes
  canonicalId_lt: mode_swap_Bytes
  canonicalId_gte: mode_swap_Bytes
  canonicalId_lte: mode_swap_Bytes
  canonicalId_in: [mode_swap_Bytes!]
  canonicalId_not_in: [mode_swap_Bytes!]
  canonicalId_contains: mode_swap_Bytes
  canonicalId_not_contains: mode_swap_Bytes
  domain: BigInt
  domain_not: BigInt
  domain_gt: BigInt
  domain_lt: BigInt
  domain_gte: BigInt
  domain_lte: BigInt
  domain_in: [BigInt!]
  domain_not_in: [BigInt!]
  swapPool: mode_swap_Bytes
  swapPool_not: mode_swap_Bytes
  swapPool_gt: mode_swap_Bytes
  swapPool_lt: mode_swap_Bytes
  swapPool_gte: mode_swap_Bytes
  swapPool_lte: mode_swap_Bytes
  swapPool_in: [mode_swap_Bytes!]
  swapPool_not_in: [mode_swap_Bytes!]
  swapPool_contains: mode_swap_Bytes
  swapPool_not_contains: mode_swap_Bytes
  lpToken: mode_swap_Bytes
  lpToken_not: mode_swap_Bytes
  lpToken_gt: mode_swap_Bytes
  lpToken_lt: mode_swap_Bytes
  lpToken_gte: mode_swap_Bytes
  lpToken_lte: mode_swap_Bytes
  lpToken_in: [mode_swap_Bytes!]
  lpToken_not_in: [mode_swap_Bytes!]
  lpToken_contains: mode_swap_Bytes
  lpToken_not_contains: mode_swap_Bytes
  initialA: BigInt
  initialA_not: BigInt
  initialA_gt: BigInt
  initialA_lt: BigInt
  initialA_gte: BigInt
  initialA_lte: BigInt
  initialA_in: [BigInt!]
  initialA_not_in: [BigInt!]
  futureA: BigInt
  futureA_not: BigInt
  futureA_gt: BigInt
  futureA_lt: BigInt
  futureA_gte: BigInt
  futureA_lte: BigInt
  futureA_in: [BigInt!]
  futureA_not_in: [BigInt!]
  initialATime: BigInt
  initialATime_not: BigInt
  initialATime_gt: BigInt
  initialATime_lt: BigInt
  initialATime_gte: BigInt
  initialATime_lte: BigInt
  initialATime_in: [BigInt!]
  initialATime_not_in: [BigInt!]
  futureATime: BigInt
  futureATime_not: BigInt
  futureATime_gt: BigInt
  futureATime_lt: BigInt
  futureATime_gte: BigInt
  futureATime_lte: BigInt
  futureATime_in: [BigInt!]
  futureATime_not_in: [BigInt!]
  swapFee: BigInt
  swapFee_not: BigInt
  swapFee_gt: BigInt
  swapFee_lt: BigInt
  swapFee_gte: BigInt
  swapFee_lte: BigInt
  swapFee_in: [BigInt!]
  swapFee_not_in: [BigInt!]
  adminFee: BigInt
  adminFee_not: BigInt
  adminFee_gt: BigInt
  adminFee_lt: BigInt
  adminFee_gte: BigInt
  adminFee_lte: BigInt
  adminFee_in: [BigInt!]
  adminFee_not_in: [BigInt!]
  pooledTokens: [mode_swap_Bytes!]
  pooledTokens_not: [mode_swap_Bytes!]
  pooledTokens_contains: [mode_swap_Bytes!]
  pooledTokens_contains_nocase: [mode_swap_Bytes!]
  pooledTokens_not_contains: [mode_swap_Bytes!]
  pooledTokens_not_contains_nocase: [mode_swap_Bytes!]
  tokenPrecisionMultipliers: [BigInt!]
  tokenPrecisionMultipliers_not: [BigInt!]
  tokenPrecisionMultipliers_contains: [BigInt!]
  tokenPrecisionMultipliers_contains_nocase: [BigInt!]
  tokenPrecisionMultipliers_not_contains: [BigInt!]
  tokenPrecisionMultipliers_not_contains_nocase: [BigInt!]
  balances: [BigInt!]
  balances_not: [BigInt!]
  balances_contains: [BigInt!]
  balances_contains_nocase: [BigInt!]
  balances_not_contains: [BigInt!]
  balances_not_contains_nocase: [BigInt!]
  adminFees: [BigInt!]
  adminFees_not: [BigInt!]
  adminFees_contains: [BigInt!]
  adminFees_contains_nocase: [BigInt!]
  adminFees_not_contains: [BigInt!]
  adminFees_not_contains_nocase: [BigInt!]
  virtualPrice: BigInt
  virtualPrice_not: BigInt
  virtualPrice_gt: BigInt
  virtualPrice_lt: BigInt
  virtualPrice_gte: BigInt
  virtualPrice_lte: BigInt
  virtualPrice_in: [BigInt!]
  virtualPrice_not_in: [BigInt!]
  invariant: BigInt
  invariant_not: BigInt
  invariant_gt: BigInt
  invariant_lt: BigInt
  invariant_gte: BigInt
  invariant_lte: BigInt
  invariant_in: [BigInt!]
  invariant_not_in: [BigInt!]
  lpTokenSupply: BigInt
  lpTokenSupply_not: BigInt
  lpTokenSupply_gt: BigInt
  lpTokenSupply_lt: BigInt
  lpTokenSupply_gte: BigInt
  lpTokenSupply_lte: BigInt
  lpTokenSupply_in: [BigInt!]
  lpTokenSupply_not_in: [BigInt!]
  events_: mode_swap_StableSwapEvent_filter
  exchanges_: mode_swap_StableSwapExchange_filter
  hourlyVolumes_: mode_swap_SwapHourlyVolume_filter
  dailyVolumes_: mode_swap_SwapDailyVolume_filter
  weeklyVolumes_: mode_swap_SwapWeeklyVolume_filter
  """Filter for the block changed event."""
  _change_block: mode_swap_BlockChangedFilter
  and: [mode_swap_StableSwap_filter]
  or: [mode_swap_StableSwap_filter]
}

enum mode_swap_StableSwap_orderBy {
  id
  isActive
  key
  canonicalId
  domain
  swapPool
  lpToken
  initialA
  futureA
  initialATime
  futureATime
  swapFee
  adminFee
  pooledTokens
  tokenPrecisionMultipliers
  balances
  adminFees
  virtualPrice
  invariant
  lpTokenSupply
  events
  exchanges
  hourlyVolumes
  dailyVolumes
  weeklyVolumes
}

type mode_swap_SwapDailyVolume implements mode_swap_SwapTradeVolume {
  id: ID!
  stableSwap: mode_swap_StableSwap!
  timestamp: BigInt!
  volume: mode_swap_BigDecimal!
}

input mode_swap_SwapDailyVolume_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: mode_swap_StableSwap_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  volume: mode_swap_BigDecimal
  volume_not: mode_swap_BigDecimal
  volume_gt: mode_swap_BigDecimal
  volume_lt: mode_swap_BigDecimal
  volume_gte: mode_swap_BigDecimal
  volume_lte: mode_swap_BigDecimal
  volume_in: [mode_swap_BigDecimal!]
  volume_not_in: [mode_swap_BigDecimal!]
  """Filter for the block changed event."""
  _change_block: mode_swap_BlockChangedFilter
  and: [mode_swap_SwapDailyVolume_filter]
  or: [mode_swap_SwapDailyVolume_filter]
}

enum mode_swap_SwapDailyVolume_orderBy {
  id
  stableSwap
  stableSwap__id
  stableSwap__isActive
  stableSwap__key
  stableSwap__canonicalId
  stableSwap__domain
  stableSwap__swapPool
  stableSwap__lpToken
  stableSwap__initialA
  stableSwap__futureA
  stableSwap__initialATime
  stableSwap__futureATime
  stableSwap__swapFee
  stableSwap__adminFee
  stableSwap__virtualPrice
  stableSwap__invariant
  stableSwap__lpTokenSupply
  timestamp
  volume
}

type mode_swap_SwapHourlyVolume implements mode_swap_SwapTradeVolume {
  id: ID!
  stableSwap: mode_swap_StableSwap!
  timestamp: BigInt!
  volume: mode_swap_BigDecimal!
}

input mode_swap_SwapHourlyVolume_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: mode_swap_StableSwap_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  volume: mode_swap_BigDecimal
  volume_not: mode_swap_BigDecimal
  volume_gt: mode_swap_BigDecimal
  volume_lt: mode_swap_BigDecimal
  volume_gte: mode_swap_BigDecimal
  volume_lte: mode_swap_BigDecimal
  volume_in: [mode_swap_BigDecimal!]
  volume_not_in: [mode_swap_BigDecimal!]
  """Filter for the block changed event."""
  _change_block: mode_swap_BlockChangedFilter
  and: [mode_swap_SwapHourlyVolume_filter]
  or: [mode_swap_SwapHourlyVolume_filter]
}

enum mode_swap_SwapHourlyVolume_orderBy {
  id
  stableSwap
  stableSwap__id
  stableSwap__isActive
  stableSwap__key
  stableSwap__canonicalId
  stableSwap__domain
  stableSwap__swapPool
  stableSwap__lpToken
  stableSwap__initialA
  stableSwap__futureA
  stableSwap__initialATime
  stableSwap__futureATime
  stableSwap__swapFee
  stableSwap__adminFee
  stableSwap__virtualPrice
  stableSwap__invariant
  stableSwap__lpTokenSupply
  timestamp
  volume
}

interface mode_swap_SwapTradeVolume {
  stableSwap: mode_swap_StableSwap!
  timestamp: BigInt!
  volume: mode_swap_BigDecimal!
}

input mode_swap_SwapTradeVolume_filter {
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: mode_swap_StableSwap_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  volume: mode_swap_BigDecimal
  volume_not: mode_swap_BigDecimal
  volume_gt: mode_swap_BigDecimal
  volume_lt: mode_swap_BigDecimal
  volume_gte: mode_swap_BigDecimal
  volume_lte: mode_swap_BigDecimal
  volume_in: [mode_swap_BigDecimal!]
  volume_not_in: [mode_swap_BigDecimal!]
  """Filter for the block changed event."""
  _change_block: mode_swap_BlockChangedFilter
  and: [mode_swap_SwapTradeVolume_filter]
  or: [mode_swap_SwapTradeVolume_filter]
}

enum mode_swap_SwapTradeVolume_orderBy {
  stableSwap
  stableSwap__id
  stableSwap__isActive
  stableSwap__key
  stableSwap__canonicalId
  stableSwap__domain
  stableSwap__swapPool
  stableSwap__lpToken
  stableSwap__initialA
  stableSwap__futureA
  stableSwap__initialATime
  stableSwap__futureATime
  stableSwap__swapFee
  stableSwap__adminFee
  stableSwap__virtualPrice
  stableSwap__invariant
  stableSwap__lpTokenSupply
  timestamp
  volume
}

type mode_swap_SwapWeeklyVolume implements mode_swap_SwapTradeVolume {
  id: ID!
  stableSwap: mode_swap_StableSwap!
  timestamp: BigInt!
  volume: mode_swap_BigDecimal!
}

input mode_swap_SwapWeeklyVolume_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: mode_swap_StableSwap_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  volume: mode_swap_BigDecimal
  volume_not: mode_swap_BigDecimal
  volume_gt: mode_swap_BigDecimal
  volume_lt: mode_swap_BigDecimal
  volume_gte: mode_swap_BigDecimal
  volume_lte: mode_swap_BigDecimal
  volume_in: [mode_swap_BigDecimal!]
  volume_not_in: [mode_swap_BigDecimal!]
  """Filter for the block changed event."""
  _change_block: mode_swap_BlockChangedFilter
  and: [mode_swap_SwapWeeklyVolume_filter]
  or: [mode_swap_SwapWeeklyVolume_filter]
}

enum mode_swap_SwapWeeklyVolume_orderBy {
  id
  stableSwap
  stableSwap__id
  stableSwap__isActive
  stableSwap__key
  stableSwap__canonicalId
  stableSwap__domain
  stableSwap__swapPool
  stableSwap__lpToken
  stableSwap__initialA
  stableSwap__futureA
  stableSwap__initialATime
  stableSwap__futureATime
  stableSwap__swapFee
  stableSwap__adminFee
  stableSwap__virtualPrice
  stableSwap__invariant
  stableSwap__lpTokenSupply
  timestamp
  volume
}

type mode_swap_SystemInfo {
  id: ID!
  exchangeCount: BigInt!
  swapCount: BigInt!
}

input mode_swap_SystemInfo_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  exchangeCount: BigInt
  exchangeCount_not: BigInt
  exchangeCount_gt: BigInt
  exchangeCount_lt: BigInt
  exchangeCount_gte: BigInt
  exchangeCount_lte: BigInt
  exchangeCount_in: [BigInt!]
  exchangeCount_not_in: [BigInt!]
  swapCount: BigInt
  swapCount_not: BigInt
  swapCount_gt: BigInt
  swapCount_lt: BigInt
  swapCount_gte: BigInt
  swapCount_lte: BigInt
  swapCount_in: [BigInt!]
  swapCount_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: mode_swap_BlockChangedFilter
  and: [mode_swap_SystemInfo_filter]
  or: [mode_swap_SystemInfo_filter]
}

enum mode_swap_SystemInfo_orderBy {
  id
  exchangeCount
  swapCount
}

"""
A string representation of microseconds UNIX timestamp (16 digits)

"""
scalar Timestamp

type mode_swap__Block_ {
  """The hash of the block"""
  hash: mode_swap_Bytes
  """The block number"""
  number: Int!
  """Integer representation of the timestamp stored in blocks for the chain"""
  timestamp: Int
  """The hash of the parent block"""
  parentHash: mode_swap_Bytes
}

"""The type for the top-level _meta field"""
type mode_swap__Meta_ {
  """
  Information about a specific subgraph block. The hash of the block
  will be null if the _meta field has a block constraint that asks for
  a block number. It will be filled if the _meta field has no block constraint
  and therefore asks for the latest  block
  
  """
  block: mode_swap__Block_!
  """The deployment ID"""
  deployment: String!
  """If `true`, the subgraph encountered indexing errors at some past block"""
  hasIndexingErrors: Boolean!
}

enum _SubgraphErrorPolicy_ {
  """Data will be returned even if the subgraph has indexing errors"""
  allow
  """
  If the subgraph has indexing errors, data will be omitted. The default.
  """
  deny
}

enum mantle_swap_Aggregation_interval {
  hour
  day
}

scalar mantle_swap_BigDecimal

input mantle_swap_BlockChangedFilter {
  number_gte: Int!
}

input mantle_swap_Block_height {
  hash: mantle_swap_Bytes
  number: Int
  number_gte: Int
}

scalar mantle_swap_Bytes

"""
8 bytes signed integer

"""
scalar mantle_swap_Int8

type mantle_swap_LpAccount {
  id: ID!
  address: mantle_swap_Bytes!
  balances(skip: Int = 0, first: Int = 100, orderBy: mantle_swap_LpAccountBalance_orderBy, orderDirection: mantle_swap_OrderDirection, where: mantle_swap_LpAccountBalance_filter): [mantle_swap_LpAccountBalance!]!
}

type mantle_swap_LpAccountBalance {
  id: ID!
  account: mantle_swap_LpAccount!
  token: mantle_swap_LpToken!
  amount: mantle_swap_BigDecimal!
  block: BigInt
  modified: BigInt
  transaction: mantle_swap_Bytes
}

input mantle_swap_LpAccountBalance_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  account: String
  account_not: String
  account_gt: String
  account_lt: String
  account_gte: String
  account_lte: String
  account_in: [String!]
  account_not_in: [String!]
  account_contains: String
  account_contains_nocase: String
  account_not_contains: String
  account_not_contains_nocase: String
  account_starts_with: String
  account_starts_with_nocase: String
  account_not_starts_with: String
  account_not_starts_with_nocase: String
  account_ends_with: String
  account_ends_with_nocase: String
  account_not_ends_with: String
  account_not_ends_with_nocase: String
  account_: mantle_swap_LpAccount_filter
  token: String
  token_not: String
  token_gt: String
  token_lt: String
  token_gte: String
  token_lte: String
  token_in: [String!]
  token_not_in: [String!]
  token_contains: String
  token_contains_nocase: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_: mantle_swap_LpToken_filter
  amount: mantle_swap_BigDecimal
  amount_not: mantle_swap_BigDecimal
  amount_gt: mantle_swap_BigDecimal
  amount_lt: mantle_swap_BigDecimal
  amount_gte: mantle_swap_BigDecimal
  amount_lte: mantle_swap_BigDecimal
  amount_in: [mantle_swap_BigDecimal!]
  amount_not_in: [mantle_swap_BigDecimal!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  modified: BigInt
  modified_not: BigInt
  modified_gt: BigInt
  modified_lt: BigInt
  modified_gte: BigInt
  modified_lte: BigInt
  modified_in: [BigInt!]
  modified_not_in: [BigInt!]
  transaction: mantle_swap_Bytes
  transaction_not: mantle_swap_Bytes
  transaction_gt: mantle_swap_Bytes
  transaction_lt: mantle_swap_Bytes
  transaction_gte: mantle_swap_Bytes
  transaction_lte: mantle_swap_Bytes
  transaction_in: [mantle_swap_Bytes!]
  transaction_not_in: [mantle_swap_Bytes!]
  transaction_contains: mantle_swap_Bytes
  transaction_not_contains: mantle_swap_Bytes
  """Filter for the block changed event."""
  _change_block: mantle_swap_BlockChangedFilter
  and: [mantle_swap_LpAccountBalance_filter]
  or: [mantle_swap_LpAccountBalance_filter]
}

enum mantle_swap_LpAccountBalance_orderBy {
  id
  account
  account__id
  account__address
  token
  token__id
  token__address
  token__decimals
  token__name
  token__symbol
  token__totalSupply
  amount
  block
  modified
  transaction
}

input mantle_swap_LpAccount_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  address: mantle_swap_Bytes
  address_not: mantle_swap_Bytes
  address_gt: mantle_swap_Bytes
  address_lt: mantle_swap_Bytes
  address_gte: mantle_swap_Bytes
  address_lte: mantle_swap_Bytes
  address_in: [mantle_swap_Bytes!]
  address_not_in: [mantle_swap_Bytes!]
  address_contains: mantle_swap_Bytes
  address_not_contains: mantle_swap_Bytes
  balances_: mantle_swap_LpAccountBalance_filter
  """Filter for the block changed event."""
  _change_block: mantle_swap_BlockChangedFilter
  and: [mantle_swap_LpAccount_filter]
  or: [mantle_swap_LpAccount_filter]
}

enum mantle_swap_LpAccount_orderBy {
  id
  address
  balances
}

type mantle_swap_LpToken {
  id: ID!
  address: mantle_swap_Bytes!
  stableSwap: mantle_swap_StableSwap!
  decimals: Int!
  name: String!
  symbol: String!
  totalSupply: mantle_swap_BigDecimal!
  events(skip: Int = 0, first: Int = 100, orderBy: mantle_swap_LpTokenEvent_orderBy, orderDirection: mantle_swap_OrderDirection, where: mantle_swap_LpTokenEvent_filter): [mantle_swap_LpTokenEvent!]!
}

interface mantle_swap_LpTokenEvent {
  id: ID!
  token: mantle_swap_LpToken!
  amount: mantle_swap_BigDecimal!
  block: BigInt!
  timestamp: BigInt!
  transaction: mantle_swap_Bytes!
  nonce: BigInt!
}

input mantle_swap_LpTokenEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  token: String
  token_not: String
  token_gt: String
  token_lt: String
  token_gte: String
  token_lte: String
  token_in: [String!]
  token_not_in: [String!]
  token_contains: String
  token_contains_nocase: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_: mantle_swap_LpToken_filter
  amount: mantle_swap_BigDecimal
  amount_not: mantle_swap_BigDecimal
  amount_gt: mantle_swap_BigDecimal
  amount_lt: mantle_swap_BigDecimal
  amount_gte: mantle_swap_BigDecimal
  amount_lte: mantle_swap_BigDecimal
  amount_in: [mantle_swap_BigDecimal!]
  amount_not_in: [mantle_swap_BigDecimal!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: mantle_swap_Bytes
  transaction_not: mantle_swap_Bytes
  transaction_gt: mantle_swap_Bytes
  transaction_lt: mantle_swap_Bytes
  transaction_gte: mantle_swap_Bytes
  transaction_lte: mantle_swap_Bytes
  transaction_in: [mantle_swap_Bytes!]
  transaction_not_in: [mantle_swap_Bytes!]
  transaction_contains: mantle_swap_Bytes
  transaction_not_contains: mantle_swap_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: mantle_swap_BlockChangedFilter
  and: [mantle_swap_LpTokenEvent_filter]
  or: [mantle_swap_LpTokenEvent_filter]
}

enum mantle_swap_LpTokenEvent_orderBy {
  id
  token
  token__id
  token__address
  token__decimals
  token__name
  token__symbol
  token__totalSupply
  amount
  block
  timestamp
  transaction
  nonce
}

input mantle_swap_LpToken_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  address: mantle_swap_Bytes
  address_not: mantle_swap_Bytes
  address_gt: mantle_swap_Bytes
  address_lt: mantle_swap_Bytes
  address_gte: mantle_swap_Bytes
  address_lte: mantle_swap_Bytes
  address_in: [mantle_swap_Bytes!]
  address_not_in: [mantle_swap_Bytes!]
  address_contains: mantle_swap_Bytes
  address_not_contains: mantle_swap_Bytes
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: mantle_swap_StableSwap_filter
  decimals: Int
  decimals_not: Int
  decimals_gt: Int
  decimals_lt: Int
  decimals_gte: Int
  decimals_lte: Int
  decimals_in: [Int!]
  decimals_not_in: [Int!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  symbol: String
  symbol_not: String
  symbol_gt: String
  symbol_lt: String
  symbol_gte: String
  symbol_lte: String
  symbol_in: [String!]
  symbol_not_in: [String!]
  symbol_contains: String
  symbol_contains_nocase: String
  symbol_not_contains: String
  symbol_not_contains_nocase: String
  symbol_starts_with: String
  symbol_starts_with_nocase: String
  symbol_not_starts_with: String
  symbol_not_starts_with_nocase: String
  symbol_ends_with: String
  symbol_ends_with_nocase: String
  symbol_not_ends_with: String
  symbol_not_ends_with_nocase: String
  totalSupply: mantle_swap_BigDecimal
  totalSupply_not: mantle_swap_BigDecimal
  totalSupply_gt: mantle_swap_BigDecimal
  totalSupply_lt: mantle_swap_BigDecimal
  totalSupply_gte: mantle_swap_BigDecimal
  totalSupply_lte: mantle_swap_BigDecimal
  totalSupply_in: [mantle_swap_BigDecimal!]
  totalSupply_not_in: [mantle_swap_BigDecimal!]
  events_: mantle_swap_LpTokenEvent_filter
  """Filter for the block changed event."""
  _change_block: mantle_swap_BlockChangedFilter
  and: [mantle_swap_LpToken_filter]
  or: [mantle_swap_LpToken_filter]
}

enum mantle_swap_LpToken_orderBy {
  id
  address
  stableSwap
  stableSwap__id
  stableSwap__isActive
  stableSwap__key
  stableSwap__canonicalId
  stableSwap__domain
  stableSwap__swapPool
  stableSwap__lpToken
  stableSwap__initialA
  stableSwap__futureA
  stableSwap__initialATime
  stableSwap__futureATime
  stableSwap__swapFee
  stableSwap__adminFee
  stableSwap__virtualPrice
  stableSwap__invariant
  stableSwap__lpTokenSupply
  decimals
  name
  symbol
  totalSupply
  events
}

type mantle_swap_LpTransferEvent implements mantle_swap_LpTokenEvent {
  id: ID!
  token: mantle_swap_LpToken!
  amount: mantle_swap_BigDecimal!
  from: mantle_swap_Bytes!
  to: mantle_swap_Bytes!
  fromBalance: mantle_swap_BigDecimal!
  toBalance: mantle_swap_BigDecimal!
  block: BigInt!
  timestamp: BigInt!
  transaction: mantle_swap_Bytes!
  nonce: BigInt!
}

input mantle_swap_LpTransferEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  token: String
  token_not: String
  token_gt: String
  token_lt: String
  token_gte: String
  token_lte: String
  token_in: [String!]
  token_not_in: [String!]
  token_contains: String
  token_contains_nocase: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_: mantle_swap_LpToken_filter
  amount: mantle_swap_BigDecimal
  amount_not: mantle_swap_BigDecimal
  amount_gt: mantle_swap_BigDecimal
  amount_lt: mantle_swap_BigDecimal
  amount_gte: mantle_swap_BigDecimal
  amount_lte: mantle_swap_BigDecimal
  amount_in: [mantle_swap_BigDecimal!]
  amount_not_in: [mantle_swap_BigDecimal!]
  from: mantle_swap_Bytes
  from_not: mantle_swap_Bytes
  from_gt: mantle_swap_Bytes
  from_lt: mantle_swap_Bytes
  from_gte: mantle_swap_Bytes
  from_lte: mantle_swap_Bytes
  from_in: [mantle_swap_Bytes!]
  from_not_in: [mantle_swap_Bytes!]
  from_contains: mantle_swap_Bytes
  from_not_contains: mantle_swap_Bytes
  to: mantle_swap_Bytes
  to_not: mantle_swap_Bytes
  to_gt: mantle_swap_Bytes
  to_lt: mantle_swap_Bytes
  to_gte: mantle_swap_Bytes
  to_lte: mantle_swap_Bytes
  to_in: [mantle_swap_Bytes!]
  to_not_in: [mantle_swap_Bytes!]
  to_contains: mantle_swap_Bytes
  to_not_contains: mantle_swap_Bytes
  fromBalance: mantle_swap_BigDecimal
  fromBalance_not: mantle_swap_BigDecimal
  fromBalance_gt: mantle_swap_BigDecimal
  fromBalance_lt: mantle_swap_BigDecimal
  fromBalance_gte: mantle_swap_BigDecimal
  fromBalance_lte: mantle_swap_BigDecimal
  fromBalance_in: [mantle_swap_BigDecimal!]
  fromBalance_not_in: [mantle_swap_BigDecimal!]
  toBalance: mantle_swap_BigDecimal
  toBalance_not: mantle_swap_BigDecimal
  toBalance_gt: mantle_swap_BigDecimal
  toBalance_lt: mantle_swap_BigDecimal
  toBalance_gte: mantle_swap_BigDecimal
  toBalance_lte: mantle_swap_BigDecimal
  toBalance_in: [mantle_swap_BigDecimal!]
  toBalance_not_in: [mantle_swap_BigDecimal!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: mantle_swap_Bytes
  transaction_not: mantle_swap_Bytes
  transaction_gt: mantle_swap_Bytes
  transaction_lt: mantle_swap_Bytes
  transaction_gte: mantle_swap_Bytes
  transaction_lte: mantle_swap_Bytes
  transaction_in: [mantle_swap_Bytes!]
  transaction_not_in: [mantle_swap_Bytes!]
  transaction_contains: mantle_swap_Bytes
  transaction_not_contains: mantle_swap_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: mantle_swap_BlockChangedFilter
  and: [mantle_swap_LpTransferEvent_filter]
  or: [mantle_swap_LpTransferEvent_filter]
}

enum mantle_swap_LpTransferEvent_orderBy {
  id
  token
  token__id
  token__address
  token__decimals
  token__name
  token__symbol
  token__totalSupply
  amount
  from
  to
  fromBalance
  toBalance
  block
  timestamp
  transaction
  nonce
}

"""Defines the order direction, either ascending or descending"""
enum mantle_swap_OrderDirection {
  asc
  desc
}

type mantle_swap_PooledToken {
  id: ID!
  asset: mantle_swap_Bytes!
}

input mantle_swap_PooledToken_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  asset: mantle_swap_Bytes
  asset_not: mantle_swap_Bytes
  asset_gt: mantle_swap_Bytes
  asset_lt: mantle_swap_Bytes
  asset_gte: mantle_swap_Bytes
  asset_lte: mantle_swap_Bytes
  asset_in: [mantle_swap_Bytes!]
  asset_not_in: [mantle_swap_Bytes!]
  asset_contains: mantle_swap_Bytes
  asset_not_contains: mantle_swap_Bytes
  """Filter for the block changed event."""
  _change_block: mantle_swap_BlockChangedFilter
  and: [mantle_swap_PooledToken_filter]
  or: [mantle_swap_PooledToken_filter]
}

enum mantle_swap_PooledToken_orderBy {
  id
  asset
}

type mantle_swap_StableSwap {
  id: ID!
  isActive: Boolean
  key: mantle_swap_Bytes!
  canonicalId: mantle_swap_Bytes
  domain: BigInt
  swapPool: mantle_swap_Bytes
  lpToken: mantle_swap_Bytes
  initialA: BigInt
  futureA: BigInt
  initialATime: BigInt
  futureATime: BigInt
  swapFee: BigInt
  adminFee: BigInt
  pooledTokens: [mantle_swap_Bytes!]!
  tokenPrecisionMultipliers: [BigInt!]!
  balances: [BigInt!]!
  adminFees: [BigInt!]!
  virtualPrice: BigInt!
  invariant: BigInt!
  lpTokenSupply: BigInt!
  events(skip: Int = 0, first: Int = 100, orderBy: mantle_swap_StableSwapEvent_orderBy, orderDirection: mantle_swap_OrderDirection, where: mantle_swap_StableSwapEvent_filter): [mantle_swap_StableSwapEvent!]
  exchanges(skip: Int = 0, first: Int = 100, orderBy: mantle_swap_StableSwapExchange_orderBy, orderDirection: mantle_swap_OrderDirection, where: mantle_swap_StableSwapExchange_filter): [mantle_swap_StableSwapExchange!]
  hourlyVolumes(skip: Int = 0, first: Int = 100, orderBy: mantle_swap_SwapHourlyVolume_orderBy, orderDirection: mantle_swap_OrderDirection, where: mantle_swap_SwapHourlyVolume_filter): [mantle_swap_SwapHourlyVolume!]
  dailyVolumes(skip: Int = 0, first: Int = 100, orderBy: mantle_swap_SwapDailyVolume_orderBy, orderDirection: mantle_swap_OrderDirection, where: mantle_swap_SwapDailyVolume_filter): [mantle_swap_SwapDailyVolume!]
  weeklyVolumes(skip: Int = 0, first: Int = 100, orderBy: mantle_swap_SwapWeeklyVolume_orderBy, orderDirection: mantle_swap_OrderDirection, where: mantle_swap_SwapWeeklyVolume_filter): [mantle_swap_SwapWeeklyVolume!]
}

type mantle_swap_StableSwapAddLiquidityEvent implements mantle_swap_StableSwapEvent {
  id: ID!
  stableSwap: mantle_swap_StableSwap!
  provider: mantle_swap_Bytes!
  tokenAmounts: [BigInt!]!
  fees: [BigInt!]!
  invariant: BigInt
  lpTokenSupply: BigInt!
  lpTokenAmount: BigInt!
  balances: [BigInt!]!
  block: BigInt!
  timestamp: BigInt!
  transaction: mantle_swap_Bytes!
  nonce: BigInt!
}

input mantle_swap_StableSwapAddLiquidityEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: mantle_swap_StableSwap_filter
  provider: mantle_swap_Bytes
  provider_not: mantle_swap_Bytes
  provider_gt: mantle_swap_Bytes
  provider_lt: mantle_swap_Bytes
  provider_gte: mantle_swap_Bytes
  provider_lte: mantle_swap_Bytes
  provider_in: [mantle_swap_Bytes!]
  provider_not_in: [mantle_swap_Bytes!]
  provider_contains: mantle_swap_Bytes
  provider_not_contains: mantle_swap_Bytes
  tokenAmounts: [BigInt!]
  tokenAmounts_not: [BigInt!]
  tokenAmounts_contains: [BigInt!]
  tokenAmounts_contains_nocase: [BigInt!]
  tokenAmounts_not_contains: [BigInt!]
  tokenAmounts_not_contains_nocase: [BigInt!]
  fees: [BigInt!]
  fees_not: [BigInt!]
  fees_contains: [BigInt!]
  fees_contains_nocase: [BigInt!]
  fees_not_contains: [BigInt!]
  fees_not_contains_nocase: [BigInt!]
  invariant: BigInt
  invariant_not: BigInt
  invariant_gt: BigInt
  invariant_lt: BigInt
  invariant_gte: BigInt
  invariant_lte: BigInt
  invariant_in: [BigInt!]
  invariant_not_in: [BigInt!]
  lpTokenSupply: BigInt
  lpTokenSupply_not: BigInt
  lpTokenSupply_gt: BigInt
  lpTokenSupply_lt: BigInt
  lpTokenSupply_gte: BigInt
  lpTokenSupply_lte: BigInt
  lpTokenSupply_in: [BigInt!]
  lpTokenSupply_not_in: [BigInt!]
  lpTokenAmount: BigInt
  lpTokenAmount_not: BigInt
  lpTokenAmount_gt: BigInt
  lpTokenAmount_lt: BigInt
  lpTokenAmount_gte: BigInt
  lpTokenAmount_lte: BigInt
  lpTokenAmount_in: [BigInt!]
  lpTokenAmount_not_in: [BigInt!]
  balances: [BigInt!]
  balances_not: [BigInt!]
  balances_contains: [BigInt!]
  balances_contains_nocase: [BigInt!]
  balances_not_contains: [BigInt!]
  balances_not_contains_nocase: [BigInt!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: mantle_swap_Bytes
  transaction_not: mantle_swap_Bytes
  transaction_gt: mantle_swap_Bytes
  transaction_lt: mantle_swap_Bytes
  transaction_gte: mantle_swap_Bytes
  transaction_lte: mantle_swap_Bytes
  transaction_in: [mantle_swap_Bytes!]
  transaction_not_in: [mantle_swap_Bytes!]
  transaction_contains: mantle_swap_Bytes
  transaction_not_contains: mantle_swap_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: mantle_swap_BlockChangedFilter
  and: [mantle_swap_StableSwapAddLiquidityEvent_filter]
  or: [mantle_swap_StableSwapAddLiquidityEvent_filter]
}

enum mantle_swap_StableSwapAddLiquidityEvent_orderBy {
  id
  stableSwap
  stableSwap__id
  stableSwap__isActive
  stableSwap__key
  stableSwap__canonicalId
  stableSwap__domain
  stableSwap__swapPool
  stableSwap__lpToken
  stableSwap__initialA
  stableSwap__futureA
  stableSwap__initialATime
  stableSwap__futureATime
  stableSwap__swapFee
  stableSwap__adminFee
  stableSwap__virtualPrice
  stableSwap__invariant
  stableSwap__lpTokenSupply
  provider
  tokenAmounts
  fees
  invariant
  lpTokenSupply
  lpTokenAmount
  balances
  block
  timestamp
  transaction
  nonce
}

interface mantle_swap_StableSwapEvent {
  id: ID!
  stableSwap: mantle_swap_StableSwap!
  block: BigInt!
  timestamp: BigInt!
  transaction: mantle_swap_Bytes!
  nonce: BigInt!
}

input mantle_swap_StableSwapEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: mantle_swap_StableSwap_filter
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: mantle_swap_Bytes
  transaction_not: mantle_swap_Bytes
  transaction_gt: mantle_swap_Bytes
  transaction_lt: mantle_swap_Bytes
  transaction_gte: mantle_swap_Bytes
  transaction_lte: mantle_swap_Bytes
  transaction_in: [mantle_swap_Bytes!]
  transaction_not_in: [mantle_swap_Bytes!]
  transaction_contains: mantle_swap_Bytes
  transaction_not_contains: mantle_swap_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: mantle_swap_BlockChangedFilter
  and: [mantle_swap_StableSwapEvent_filter]
  or: [mantle_swap_StableSwapEvent_filter]
}

enum mantle_swap_StableSwapEvent_orderBy {
  id
  stableSwap
  stableSwap__id
  stableSwap__isActive
  stableSwap__key
  stableSwap__canonicalId
  stableSwap__domain
  stableSwap__swapPool
  stableSwap__lpToken
  stableSwap__initialA
  stableSwap__futureA
  stableSwap__initialATime
  stableSwap__futureATime
  stableSwap__swapFee
  stableSwap__adminFee
  stableSwap__virtualPrice
  stableSwap__invariant
  stableSwap__lpTokenSupply
  block
  timestamp
  transaction
  nonce
}

type mantle_swap_StableSwapExchange {
  id: ID!
  stableSwap: mantle_swap_StableSwap!
  buyer: mantle_swap_Bytes!
  boughtId: BigInt!
  tokensBought: BigInt!
  soldId: BigInt!
  tokensSold: BigInt!
  balances: [BigInt!]!
  fee: BigInt!
  block: BigInt!
  timestamp: BigInt!
  transaction: mantle_swap_Bytes!
  nonce: BigInt!
}

input mantle_swap_StableSwapExchange_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: mantle_swap_StableSwap_filter
  buyer: mantle_swap_Bytes
  buyer_not: mantle_swap_Bytes
  buyer_gt: mantle_swap_Bytes
  buyer_lt: mantle_swap_Bytes
  buyer_gte: mantle_swap_Bytes
  buyer_lte: mantle_swap_Bytes
  buyer_in: [mantle_swap_Bytes!]
  buyer_not_in: [mantle_swap_Bytes!]
  buyer_contains: mantle_swap_Bytes
  buyer_not_contains: mantle_swap_Bytes
  boughtId: BigInt
  boughtId_not: BigInt
  boughtId_gt: BigInt
  boughtId_lt: BigInt
  boughtId_gte: BigInt
  boughtId_lte: BigInt
  boughtId_in: [BigInt!]
  boughtId_not_in: [BigInt!]
  tokensBought: BigInt
  tokensBought_not: BigInt
  tokensBought_gt: BigInt
  tokensBought_lt: BigInt
  tokensBought_gte: BigInt
  tokensBought_lte: BigInt
  tokensBought_in: [BigInt!]
  tokensBought_not_in: [BigInt!]
  soldId: BigInt
  soldId_not: BigInt
  soldId_gt: BigInt
  soldId_lt: BigInt
  soldId_gte: BigInt
  soldId_lte: BigInt
  soldId_in: [BigInt!]
  soldId_not_in: [BigInt!]
  tokensSold: BigInt
  tokensSold_not: BigInt
  tokensSold_gt: BigInt
  tokensSold_lt: BigInt
  tokensSold_gte: BigInt
  tokensSold_lte: BigInt
  tokensSold_in: [BigInt!]
  tokensSold_not_in: [BigInt!]
  balances: [BigInt!]
  balances_not: [BigInt!]
  balances_contains: [BigInt!]
  balances_contains_nocase: [BigInt!]
  balances_not_contains: [BigInt!]
  balances_not_contains_nocase: [BigInt!]
  fee: BigInt
  fee_not: BigInt
  fee_gt: BigInt
  fee_lt: BigInt
  fee_gte: BigInt
  fee_lte: BigInt
  fee_in: [BigInt!]
  fee_not_in: [BigInt!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: mantle_swap_Bytes
  transaction_not: mantle_swap_Bytes
  transaction_gt: mantle_swap_Bytes
  transaction_lt: mantle_swap_Bytes
  transaction_gte: mantle_swap_Bytes
  transaction_lte: mantle_swap_Bytes
  transaction_in: [mantle_swap_Bytes!]
  transaction_not_in: [mantle_swap_Bytes!]
  transaction_contains: mantle_swap_Bytes
  transaction_not_contains: mantle_swap_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: mantle_swap_BlockChangedFilter
  and: [mantle_swap_StableSwapExchange_filter]
  or: [mantle_swap_StableSwapExchange_filter]
}

enum mantle_swap_StableSwapExchange_orderBy {
  id
  stableSwap
  stableSwap__id
  stableSwap__isActive
  stableSwap__key
  stableSwap__canonicalId
  stableSwap__domain
  stableSwap__swapPool
  stableSwap__lpToken
  stableSwap__initialA
  stableSwap__futureA
  stableSwap__initialATime
  stableSwap__futureATime
  stableSwap__swapFee
  stableSwap__adminFee
  stableSwap__virtualPrice
  stableSwap__invariant
  stableSwap__lpTokenSupply
  buyer
  boughtId
  tokensBought
  soldId
  tokensSold
  balances
  fee
  block
  timestamp
  transaction
  nonce
}

type mantle_swap_StableSwapRemoveLiquidityEvent implements mantle_swap_StableSwapEvent {
  id: ID!
  stableSwap: mantle_swap_StableSwap!
  provider: mantle_swap_Bytes!
  tokenAmounts: [BigInt!]!
  fees: [BigInt!]
  invariant: BigInt
  lpTokenSupply: BigInt!
  lpTokenAmount: BigInt!
  balances: [BigInt!]!
  block: BigInt!
  timestamp: BigInt!
  transaction: mantle_swap_Bytes!
  nonce: BigInt!
}

input mantle_swap_StableSwapRemoveLiquidityEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: mantle_swap_StableSwap_filter
  provider: mantle_swap_Bytes
  provider_not: mantle_swap_Bytes
  provider_gt: mantle_swap_Bytes
  provider_lt: mantle_swap_Bytes
  provider_gte: mantle_swap_Bytes
  provider_lte: mantle_swap_Bytes
  provider_in: [mantle_swap_Bytes!]
  provider_not_in: [mantle_swap_Bytes!]
  provider_contains: mantle_swap_Bytes
  provider_not_contains: mantle_swap_Bytes
  tokenAmounts: [BigInt!]
  tokenAmounts_not: [BigInt!]
  tokenAmounts_contains: [BigInt!]
  tokenAmounts_contains_nocase: [BigInt!]
  tokenAmounts_not_contains: [BigInt!]
  tokenAmounts_not_contains_nocase: [BigInt!]
  fees: [BigInt!]
  fees_not: [BigInt!]
  fees_contains: [BigInt!]
  fees_contains_nocase: [BigInt!]
  fees_not_contains: [BigInt!]
  fees_not_contains_nocase: [BigInt!]
  invariant: BigInt
  invariant_not: BigInt
  invariant_gt: BigInt
  invariant_lt: BigInt
  invariant_gte: BigInt
  invariant_lte: BigInt
  invariant_in: [BigInt!]
  invariant_not_in: [BigInt!]
  lpTokenSupply: BigInt
  lpTokenSupply_not: BigInt
  lpTokenSupply_gt: BigInt
  lpTokenSupply_lt: BigInt
  lpTokenSupply_gte: BigInt
  lpTokenSupply_lte: BigInt
  lpTokenSupply_in: [BigInt!]
  lpTokenSupply_not_in: [BigInt!]
  lpTokenAmount: BigInt
  lpTokenAmount_not: BigInt
  lpTokenAmount_gt: BigInt
  lpTokenAmount_lt: BigInt
  lpTokenAmount_gte: BigInt
  lpTokenAmount_lte: BigInt
  lpTokenAmount_in: [BigInt!]
  lpTokenAmount_not_in: [BigInt!]
  balances: [BigInt!]
  balances_not: [BigInt!]
  balances_contains: [BigInt!]
  balances_contains_nocase: [BigInt!]
  balances_not_contains: [BigInt!]
  balances_not_contains_nocase: [BigInt!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: mantle_swap_Bytes
  transaction_not: mantle_swap_Bytes
  transaction_gt: mantle_swap_Bytes
  transaction_lt: mantle_swap_Bytes
  transaction_gte: mantle_swap_Bytes
  transaction_lte: mantle_swap_Bytes
  transaction_in: [mantle_swap_Bytes!]
  transaction_not_in: [mantle_swap_Bytes!]
  transaction_contains: mantle_swap_Bytes
  transaction_not_contains: mantle_swap_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: mantle_swap_BlockChangedFilter
  and: [mantle_swap_StableSwapRemoveLiquidityEvent_filter]
  or: [mantle_swap_StableSwapRemoveLiquidityEvent_filter]
}

enum mantle_swap_StableSwapRemoveLiquidityEvent_orderBy {
  id
  stableSwap
  stableSwap__id
  stableSwap__isActive
  stableSwap__key
  stableSwap__canonicalId
  stableSwap__domain
  stableSwap__swapPool
  stableSwap__lpToken
  stableSwap__initialA
  stableSwap__futureA
  stableSwap__initialATime
  stableSwap__futureATime
  stableSwap__swapFee
  stableSwap__adminFee
  stableSwap__virtualPrice
  stableSwap__invariant
  stableSwap__lpTokenSupply
  provider
  tokenAmounts
  fees
  invariant
  lpTokenSupply
  lpTokenAmount
  balances
  block
  timestamp
  transaction
  nonce
}

input mantle_swap_StableSwap_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  isActive: Boolean
  isActive_not: Boolean
  isActive_in: [Boolean!]
  isActive_not_in: [Boolean!]
  key: mantle_swap_Bytes
  key_not: mantle_swap_Bytes
  key_gt: mantle_swap_Bytes
  key_lt: mantle_swap_Bytes
  key_gte: mantle_swap_Bytes
  key_lte: mantle_swap_Bytes
  key_in: [mantle_swap_Bytes!]
  key_not_in: [mantle_swap_Bytes!]
  key_contains: mantle_swap_Bytes
  key_not_contains: mantle_swap_Bytes
  canonicalId: mantle_swap_Bytes
  canonicalId_not: mantle_swap_Bytes
  canonicalId_gt: mantle_swap_Bytes
  canonicalId_lt: mantle_swap_Bytes
  canonicalId_gte: mantle_swap_Bytes
  canonicalId_lte: mantle_swap_Bytes
  canonicalId_in: [mantle_swap_Bytes!]
  canonicalId_not_in: [mantle_swap_Bytes!]
  canonicalId_contains: mantle_swap_Bytes
  canonicalId_not_contains: mantle_swap_Bytes
  domain: BigInt
  domain_not: BigInt
  domain_gt: BigInt
  domain_lt: BigInt
  domain_gte: BigInt
  domain_lte: BigInt
  domain_in: [BigInt!]
  domain_not_in: [BigInt!]
  swapPool: mantle_swap_Bytes
  swapPool_not: mantle_swap_Bytes
  swapPool_gt: mantle_swap_Bytes
  swapPool_lt: mantle_swap_Bytes
  swapPool_gte: mantle_swap_Bytes
  swapPool_lte: mantle_swap_Bytes
  swapPool_in: [mantle_swap_Bytes!]
  swapPool_not_in: [mantle_swap_Bytes!]
  swapPool_contains: mantle_swap_Bytes
  swapPool_not_contains: mantle_swap_Bytes
  lpToken: mantle_swap_Bytes
  lpToken_not: mantle_swap_Bytes
  lpToken_gt: mantle_swap_Bytes
  lpToken_lt: mantle_swap_Bytes
  lpToken_gte: mantle_swap_Bytes
  lpToken_lte: mantle_swap_Bytes
  lpToken_in: [mantle_swap_Bytes!]
  lpToken_not_in: [mantle_swap_Bytes!]
  lpToken_contains: mantle_swap_Bytes
  lpToken_not_contains: mantle_swap_Bytes
  initialA: BigInt
  initialA_not: BigInt
  initialA_gt: BigInt
  initialA_lt: BigInt
  initialA_gte: BigInt
  initialA_lte: BigInt
  initialA_in: [BigInt!]
  initialA_not_in: [BigInt!]
  futureA: BigInt
  futureA_not: BigInt
  futureA_gt: BigInt
  futureA_lt: BigInt
  futureA_gte: BigInt
  futureA_lte: BigInt
  futureA_in: [BigInt!]
  futureA_not_in: [BigInt!]
  initialATime: BigInt
  initialATime_not: BigInt
  initialATime_gt: BigInt
  initialATime_lt: BigInt
  initialATime_gte: BigInt
  initialATime_lte: BigInt
  initialATime_in: [BigInt!]
  initialATime_not_in: [BigInt!]
  futureATime: BigInt
  futureATime_not: BigInt
  futureATime_gt: BigInt
  futureATime_lt: BigInt
  futureATime_gte: BigInt
  futureATime_lte: BigInt
  futureATime_in: [BigInt!]
  futureATime_not_in: [BigInt!]
  swapFee: BigInt
  swapFee_not: BigInt
  swapFee_gt: BigInt
  swapFee_lt: BigInt
  swapFee_gte: BigInt
  swapFee_lte: BigInt
  swapFee_in: [BigInt!]
  swapFee_not_in: [BigInt!]
  adminFee: BigInt
  adminFee_not: BigInt
  adminFee_gt: BigInt
  adminFee_lt: BigInt
  adminFee_gte: BigInt
  adminFee_lte: BigInt
  adminFee_in: [BigInt!]
  adminFee_not_in: [BigInt!]
  pooledTokens: [mantle_swap_Bytes!]
  pooledTokens_not: [mantle_swap_Bytes!]
  pooledTokens_contains: [mantle_swap_Bytes!]
  pooledTokens_contains_nocase: [mantle_swap_Bytes!]
  pooledTokens_not_contains: [mantle_swap_Bytes!]
  pooledTokens_not_contains_nocase: [mantle_swap_Bytes!]
  tokenPrecisionMultipliers: [BigInt!]
  tokenPrecisionMultipliers_not: [BigInt!]
  tokenPrecisionMultipliers_contains: [BigInt!]
  tokenPrecisionMultipliers_contains_nocase: [BigInt!]
  tokenPrecisionMultipliers_not_contains: [BigInt!]
  tokenPrecisionMultipliers_not_contains_nocase: [BigInt!]
  balances: [BigInt!]
  balances_not: [BigInt!]
  balances_contains: [BigInt!]
  balances_contains_nocase: [BigInt!]
  balances_not_contains: [BigInt!]
  balances_not_contains_nocase: [BigInt!]
  adminFees: [BigInt!]
  adminFees_not: [BigInt!]
  adminFees_contains: [BigInt!]
  adminFees_contains_nocase: [BigInt!]
  adminFees_not_contains: [BigInt!]
  adminFees_not_contains_nocase: [BigInt!]
  virtualPrice: BigInt
  virtualPrice_not: BigInt
  virtualPrice_gt: BigInt
  virtualPrice_lt: BigInt
  virtualPrice_gte: BigInt
  virtualPrice_lte: BigInt
  virtualPrice_in: [BigInt!]
  virtualPrice_not_in: [BigInt!]
  invariant: BigInt
  invariant_not: BigInt
  invariant_gt: BigInt
  invariant_lt: BigInt
  invariant_gte: BigInt
  invariant_lte: BigInt
  invariant_in: [BigInt!]
  invariant_not_in: [BigInt!]
  lpTokenSupply: BigInt
  lpTokenSupply_not: BigInt
  lpTokenSupply_gt: BigInt
  lpTokenSupply_lt: BigInt
  lpTokenSupply_gte: BigInt
  lpTokenSupply_lte: BigInt
  lpTokenSupply_in: [BigInt!]
  lpTokenSupply_not_in: [BigInt!]
  events_: mantle_swap_StableSwapEvent_filter
  exchanges_: mantle_swap_StableSwapExchange_filter
  hourlyVolumes_: mantle_swap_SwapHourlyVolume_filter
  dailyVolumes_: mantle_swap_SwapDailyVolume_filter
  weeklyVolumes_: mantle_swap_SwapWeeklyVolume_filter
  """Filter for the block changed event."""
  _change_block: mantle_swap_BlockChangedFilter
  and: [mantle_swap_StableSwap_filter]
  or: [mantle_swap_StableSwap_filter]
}

enum mantle_swap_StableSwap_orderBy {
  id
  isActive
  key
  canonicalId
  domain
  swapPool
  lpToken
  initialA
  futureA
  initialATime
  futureATime
  swapFee
  adminFee
  pooledTokens
  tokenPrecisionMultipliers
  balances
  adminFees
  virtualPrice
  invariant
  lpTokenSupply
  events
  exchanges
  hourlyVolumes
  dailyVolumes
  weeklyVolumes
}

type mantle_swap_SwapDailyVolume implements mantle_swap_SwapTradeVolume {
  id: ID!
  stableSwap: mantle_swap_StableSwap!
  timestamp: BigInt!
  volume: mantle_swap_BigDecimal!
}

input mantle_swap_SwapDailyVolume_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: mantle_swap_StableSwap_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  volume: mantle_swap_BigDecimal
  volume_not: mantle_swap_BigDecimal
  volume_gt: mantle_swap_BigDecimal
  volume_lt: mantle_swap_BigDecimal
  volume_gte: mantle_swap_BigDecimal
  volume_lte: mantle_swap_BigDecimal
  volume_in: [mantle_swap_BigDecimal!]
  volume_not_in: [mantle_swap_BigDecimal!]
  """Filter for the block changed event."""
  _change_block: mantle_swap_BlockChangedFilter
  and: [mantle_swap_SwapDailyVolume_filter]
  or: [mantle_swap_SwapDailyVolume_filter]
}

enum mantle_swap_SwapDailyVolume_orderBy {
  id
  stableSwap
  stableSwap__id
  stableSwap__isActive
  stableSwap__key
  stableSwap__canonicalId
  stableSwap__domain
  stableSwap__swapPool
  stableSwap__lpToken
  stableSwap__initialA
  stableSwap__futureA
  stableSwap__initialATime
  stableSwap__futureATime
  stableSwap__swapFee
  stableSwap__adminFee
  stableSwap__virtualPrice
  stableSwap__invariant
  stableSwap__lpTokenSupply
  timestamp
  volume
}

type mantle_swap_SwapHourlyVolume implements mantle_swap_SwapTradeVolume {
  id: ID!
  stableSwap: mantle_swap_StableSwap!
  timestamp: BigInt!
  volume: mantle_swap_BigDecimal!
}

input mantle_swap_SwapHourlyVolume_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: mantle_swap_StableSwap_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  volume: mantle_swap_BigDecimal
  volume_not: mantle_swap_BigDecimal
  volume_gt: mantle_swap_BigDecimal
  volume_lt: mantle_swap_BigDecimal
  volume_gte: mantle_swap_BigDecimal
  volume_lte: mantle_swap_BigDecimal
  volume_in: [mantle_swap_BigDecimal!]
  volume_not_in: [mantle_swap_BigDecimal!]
  """Filter for the block changed event."""
  _change_block: mantle_swap_BlockChangedFilter
  and: [mantle_swap_SwapHourlyVolume_filter]
  or: [mantle_swap_SwapHourlyVolume_filter]
}

enum mantle_swap_SwapHourlyVolume_orderBy {
  id
  stableSwap
  stableSwap__id
  stableSwap__isActive
  stableSwap__key
  stableSwap__canonicalId
  stableSwap__domain
  stableSwap__swapPool
  stableSwap__lpToken
  stableSwap__initialA
  stableSwap__futureA
  stableSwap__initialATime
  stableSwap__futureATime
  stableSwap__swapFee
  stableSwap__adminFee
  stableSwap__virtualPrice
  stableSwap__invariant
  stableSwap__lpTokenSupply
  timestamp
  volume
}

interface mantle_swap_SwapTradeVolume {
  stableSwap: mantle_swap_StableSwap!
  timestamp: BigInt!
  volume: mantle_swap_BigDecimal!
}

input mantle_swap_SwapTradeVolume_filter {
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: mantle_swap_StableSwap_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  volume: mantle_swap_BigDecimal
  volume_not: mantle_swap_BigDecimal
  volume_gt: mantle_swap_BigDecimal
  volume_lt: mantle_swap_BigDecimal
  volume_gte: mantle_swap_BigDecimal
  volume_lte: mantle_swap_BigDecimal
  volume_in: [mantle_swap_BigDecimal!]
  volume_not_in: [mantle_swap_BigDecimal!]
  """Filter for the block changed event."""
  _change_block: mantle_swap_BlockChangedFilter
  and: [mantle_swap_SwapTradeVolume_filter]
  or: [mantle_swap_SwapTradeVolume_filter]
}

enum mantle_swap_SwapTradeVolume_orderBy {
  stableSwap
  stableSwap__id
  stableSwap__isActive
  stableSwap__key
  stableSwap__canonicalId
  stableSwap__domain
  stableSwap__swapPool
  stableSwap__lpToken
  stableSwap__initialA
  stableSwap__futureA
  stableSwap__initialATime
  stableSwap__futureATime
  stableSwap__swapFee
  stableSwap__adminFee
  stableSwap__virtualPrice
  stableSwap__invariant
  stableSwap__lpTokenSupply
  timestamp
  volume
}

type mantle_swap_SwapWeeklyVolume implements mantle_swap_SwapTradeVolume {
  id: ID!
  stableSwap: mantle_swap_StableSwap!
  timestamp: BigInt!
  volume: mantle_swap_BigDecimal!
}

input mantle_swap_SwapWeeklyVolume_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: mantle_swap_StableSwap_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  volume: mantle_swap_BigDecimal
  volume_not: mantle_swap_BigDecimal
  volume_gt: mantle_swap_BigDecimal
  volume_lt: mantle_swap_BigDecimal
  volume_gte: mantle_swap_BigDecimal
  volume_lte: mantle_swap_BigDecimal
  volume_in: [mantle_swap_BigDecimal!]
  volume_not_in: [mantle_swap_BigDecimal!]
  """Filter for the block changed event."""
  _change_block: mantle_swap_BlockChangedFilter
  and: [mantle_swap_SwapWeeklyVolume_filter]
  or: [mantle_swap_SwapWeeklyVolume_filter]
}

enum mantle_swap_SwapWeeklyVolume_orderBy {
  id
  stableSwap
  stableSwap__id
  stableSwap__isActive
  stableSwap__key
  stableSwap__canonicalId
  stableSwap__domain
  stableSwap__swapPool
  stableSwap__lpToken
  stableSwap__initialA
  stableSwap__futureA
  stableSwap__initialATime
  stableSwap__futureATime
  stableSwap__swapFee
  stableSwap__adminFee
  stableSwap__virtualPrice
  stableSwap__invariant
  stableSwap__lpTokenSupply
  timestamp
  volume
}

type mantle_swap_SystemInfo {
  id: ID!
  exchangeCount: BigInt!
  swapCount: BigInt!
}

input mantle_swap_SystemInfo_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  exchangeCount: BigInt
  exchangeCount_not: BigInt
  exchangeCount_gt: BigInt
  exchangeCount_lt: BigInt
  exchangeCount_gte: BigInt
  exchangeCount_lte: BigInt
  exchangeCount_in: [BigInt!]
  exchangeCount_not_in: [BigInt!]
  swapCount: BigInt
  swapCount_not: BigInt
  swapCount_gt: BigInt
  swapCount_lt: BigInt
  swapCount_gte: BigInt
  swapCount_lte: BigInt
  swapCount_in: [BigInt!]
  swapCount_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: mantle_swap_BlockChangedFilter
  and: [mantle_swap_SystemInfo_filter]
  or: [mantle_swap_SystemInfo_filter]
}

enum mantle_swap_SystemInfo_orderBy {
  id
  exchangeCount
  swapCount
}

type mantle_swap__Block_ {
  """The hash of the block"""
  hash: mantle_swap_Bytes
  """The block number"""
  number: Int!
  """Integer representation of the timestamp stored in blocks for the chain"""
  timestamp: Int
  """The hash of the parent block"""
  parentHash: mantle_swap_Bytes
}

"""The type for the top-level _meta field"""
type mantle_swap__Meta_ {
  """
  Information about a specific subgraph block. The hash of the block
  will be null if the _meta field has a block constraint that asks for
  a block number. It will be filled if the _meta field has no block constraint
  and therefore asks for the latest  block
  
  """
  block: mantle_swap__Block_!
  """The deployment ID"""
  deployment: String!
  """If `true`, the subgraph encountered indexing errors at some past block"""
  hasIndexingErrors: Boolean!
}

type bnb_AggregateRoot {
  id: ID!
  root: bnb_Bytes!
  blockNumber: BigInt!
}

type bnb_AggregateRootProposed {
  id: ID!
  aggregateRoot: bnb_Bytes!
  rootTimestamp: BigInt!
  endOfDispute: BigInt!
  domain: BigInt!
  timestamp: BigInt!
  blockNumber: BigInt
}

input bnb_AggregateRootProposed_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  aggregateRoot: bnb_Bytes
  aggregateRoot_not: bnb_Bytes
  aggregateRoot_gt: bnb_Bytes
  aggregateRoot_lt: bnb_Bytes
  aggregateRoot_gte: bnb_Bytes
  aggregateRoot_lte: bnb_Bytes
  aggregateRoot_in: [bnb_Bytes!]
  aggregateRoot_not_in: [bnb_Bytes!]
  aggregateRoot_contains: bnb_Bytes
  aggregateRoot_not_contains: bnb_Bytes
  rootTimestamp: BigInt
  rootTimestamp_not: BigInt
  rootTimestamp_gt: BigInt
  rootTimestamp_lt: BigInt
  rootTimestamp_gte: BigInt
  rootTimestamp_lte: BigInt
  rootTimestamp_in: [BigInt!]
  rootTimestamp_not_in: [BigInt!]
  endOfDispute: BigInt
  endOfDispute_not: BigInt
  endOfDispute_gt: BigInt
  endOfDispute_lt: BigInt
  endOfDispute_gte: BigInt
  endOfDispute_lte: BigInt
  endOfDispute_in: [BigInt!]
  endOfDispute_not_in: [BigInt!]
  domain: BigInt
  domain_not: BigInt
  domain_gt: BigInt
  domain_lt: BigInt
  domain_gte: BigInt
  domain_lte: BigInt
  domain_in: [BigInt!]
  domain_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: bnb_BlockChangedFilter
  and: [bnb_AggregateRootProposed_filter]
  or: [bnb_AggregateRootProposed_filter]
}

enum bnb_AggregateRootProposed_orderBy {
  id
  aggregateRoot
  rootTimestamp
  endOfDispute
  domain
  timestamp
  blockNumber
}

input bnb_AggregateRoot_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  root: bnb_Bytes
  root_not: bnb_Bytes
  root_gt: bnb_Bytes
  root_lt: bnb_Bytes
  root_gte: bnb_Bytes
  root_lte: bnb_Bytes
  root_in: [bnb_Bytes!]
  root_not_in: [bnb_Bytes!]
  root_contains: bnb_Bytes
  root_not_contains: bnb_Bytes
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: bnb_BlockChangedFilter
  and: [bnb_AggregateRoot_filter]
  or: [bnb_AggregateRoot_filter]
}

enum bnb_AggregateRoot_orderBy {
  id
  root
  blockNumber
}

enum bnb_Aggregation_interval {
  hour
  day
}

type bnb_Asset {
  id: ID!
  key: bnb_Bytes
  decimal: BigInt
  adoptedDecimal: BigInt
  canonicalId: bnb_Bytes
  canonicalDomain: BigInt
  adoptedAsset: bnb_Bytes
  localAsset: bnb_Bytes
  blockNumber: BigInt
  status: bnb_AssetStatus
}

type bnb_AssetBalance {
  id: ID!
  amount: BigInt!
  locked: BigInt!
  supplied: BigInt!
  removed: BigInt!
  router: bnb_Router!
  asset: bnb_Asset!
  feesEarned: BigInt!
}

input bnb_AssetBalance_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  locked: BigInt
  locked_not: BigInt
  locked_gt: BigInt
  locked_lt: BigInt
  locked_gte: BigInt
  locked_lte: BigInt
  locked_in: [BigInt!]
  locked_not_in: [BigInt!]
  supplied: BigInt
  supplied_not: BigInt
  supplied_gt: BigInt
  supplied_lt: BigInt
  supplied_gte: BigInt
  supplied_lte: BigInt
  supplied_in: [BigInt!]
  supplied_not_in: [BigInt!]
  removed: BigInt
  removed_not: BigInt
  removed_gt: BigInt
  removed_lt: BigInt
  removed_gte: BigInt
  removed_lte: BigInt
  removed_in: [BigInt!]
  removed_not_in: [BigInt!]
  router: String
  router_not: String
  router_gt: String
  router_lt: String
  router_gte: String
  router_lte: String
  router_in: [String!]
  router_not_in: [String!]
  router_contains: String
  router_contains_nocase: String
  router_not_contains: String
  router_not_contains_nocase: String
  router_starts_with: String
  router_starts_with_nocase: String
  router_not_starts_with: String
  router_not_starts_with_nocase: String
  router_ends_with: String
  router_ends_with_nocase: String
  router_not_ends_with: String
  router_not_ends_with_nocase: String
  router_: bnb_Router_filter
  asset: String
  asset_not: String
  asset_gt: String
  asset_lt: String
  asset_gte: String
  asset_lte: String
  asset_in: [String!]
  asset_not_in: [String!]
  asset_contains: String
  asset_contains_nocase: String
  asset_not_contains: String
  asset_not_contains_nocase: String
  asset_starts_with: String
  asset_starts_with_nocase: String
  asset_not_starts_with: String
  asset_not_starts_with_nocase: String
  asset_ends_with: String
  asset_ends_with_nocase: String
  asset_not_ends_with: String
  asset_not_ends_with_nocase: String
  asset_: bnb_Asset_filter
  feesEarned: BigInt
  feesEarned_not: BigInt
  feesEarned_gt: BigInt
  feesEarned_lt: BigInt
  feesEarned_gte: BigInt
  feesEarned_lte: BigInt
  feesEarned_in: [BigInt!]
  feesEarned_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: bnb_BlockChangedFilter
  and: [bnb_AssetBalance_filter]
  or: [bnb_AssetBalance_filter]
}

enum bnb_AssetBalance_orderBy {
  id
  amount
  locked
  supplied
  removed
  router
  router__id
  router__isActive
  router__owner
  router__recipient
  router__proposedOwner
  router__proposedTimestamp
  asset
  asset__id
  asset__key
  asset__decimal
  asset__adoptedDecimal
  asset__canonicalId
  asset__canonicalDomain
  asset__adoptedAsset
  asset__localAsset
  asset__blockNumber
  feesEarned
}

type bnb_AssetStatus {
  id: ID!
  status: Boolean
}

input bnb_AssetStatus_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  status: Boolean
  status_not: Boolean
  status_in: [Boolean!]
  status_not_in: [Boolean!]
  """Filter for the block changed event."""
  _change_block: bnb_BlockChangedFilter
  and: [bnb_AssetStatus_filter]
  or: [bnb_AssetStatus_filter]
}

enum bnb_AssetStatus_orderBy {
  id
  status
}

input bnb_Asset_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  key: bnb_Bytes
  key_not: bnb_Bytes
  key_gt: bnb_Bytes
  key_lt: bnb_Bytes
  key_gte: bnb_Bytes
  key_lte: bnb_Bytes
  key_in: [bnb_Bytes!]
  key_not_in: [bnb_Bytes!]
  key_contains: bnb_Bytes
  key_not_contains: bnb_Bytes
  decimal: BigInt
  decimal_not: BigInt
  decimal_gt: BigInt
  decimal_lt: BigInt
  decimal_gte: BigInt
  decimal_lte: BigInt
  decimal_in: [BigInt!]
  decimal_not_in: [BigInt!]
  adoptedDecimal: BigInt
  adoptedDecimal_not: BigInt
  adoptedDecimal_gt: BigInt
  adoptedDecimal_lt: BigInt
  adoptedDecimal_gte: BigInt
  adoptedDecimal_lte: BigInt
  adoptedDecimal_in: [BigInt!]
  adoptedDecimal_not_in: [BigInt!]
  canonicalId: bnb_Bytes
  canonicalId_not: bnb_Bytes
  canonicalId_gt: bnb_Bytes
  canonicalId_lt: bnb_Bytes
  canonicalId_gte: bnb_Bytes
  canonicalId_lte: bnb_Bytes
  canonicalId_in: [bnb_Bytes!]
  canonicalId_not_in: [bnb_Bytes!]
  canonicalId_contains: bnb_Bytes
  canonicalId_not_contains: bnb_Bytes
  canonicalDomain: BigInt
  canonicalDomain_not: BigInt
  canonicalDomain_gt: BigInt
  canonicalDomain_lt: BigInt
  canonicalDomain_gte: BigInt
  canonicalDomain_lte: BigInt
  canonicalDomain_in: [BigInt!]
  canonicalDomain_not_in: [BigInt!]
  adoptedAsset: bnb_Bytes
  adoptedAsset_not: bnb_Bytes
  adoptedAsset_gt: bnb_Bytes
  adoptedAsset_lt: bnb_Bytes
  adoptedAsset_gte: bnb_Bytes
  adoptedAsset_lte: bnb_Bytes
  adoptedAsset_in: [bnb_Bytes!]
  adoptedAsset_not_in: [bnb_Bytes!]
  adoptedAsset_contains: bnb_Bytes
  adoptedAsset_not_contains: bnb_Bytes
  localAsset: bnb_Bytes
  localAsset_not: bnb_Bytes
  localAsset_gt: bnb_Bytes
  localAsset_lt: bnb_Bytes
  localAsset_gte: bnb_Bytes
  localAsset_lte: bnb_Bytes
  localAsset_in: [bnb_Bytes!]
  localAsset_not_in: [bnb_Bytes!]
  localAsset_contains: bnb_Bytes
  localAsset_not_contains: bnb_Bytes
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  status: String
  status_not: String
  status_gt: String
  status_lt: String
  status_gte: String
  status_lte: String
  status_in: [String!]
  status_not_in: [String!]
  status_contains: String
  status_contains_nocase: String
  status_not_contains: String
  status_not_contains_nocase: String
  status_starts_with: String
  status_starts_with_nocase: String
  status_not_starts_with: String
  status_not_starts_with_nocase: String
  status_ends_with: String
  status_ends_with_nocase: String
  status_not_ends_with: String
  status_not_ends_with_nocase: String
  status_: bnb_AssetStatus_filter
  """Filter for the block changed event."""
  _change_block: bnb_BlockChangedFilter
  and: [bnb_Asset_filter]
  or: [bnb_Asset_filter]
}

enum bnb_Asset_orderBy {
  id
  key
  decimal
  adoptedDecimal
  canonicalId
  canonicalDomain
  adoptedAsset
  localAsset
  blockNumber
  status
  status__id
  status__status
}

scalar bnb_BigDecimal

input bnb_BlockChangedFilter {
  number_gte: Int!
}

input bnb_Block_height {
  hash: bnb_Bytes
  number: Int
  number_gte: Int
}

scalar bnb_Bytes

type bnb_ConnectorMeta {
  id: ID!
  spokeDomain: BigInt
  hubDomain: BigInt
  amb: bnb_Bytes
  rootManager: bnb_Bytes
  mirrorConnector: bnb_Bytes
}

input bnb_ConnectorMeta_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  spokeDomain: BigInt
  spokeDomain_not: BigInt
  spokeDomain_gt: BigInt
  spokeDomain_lt: BigInt
  spokeDomain_gte: BigInt
  spokeDomain_lte: BigInt
  spokeDomain_in: [BigInt!]
  spokeDomain_not_in: [BigInt!]
  hubDomain: BigInt
  hubDomain_not: BigInt
  hubDomain_gt: BigInt
  hubDomain_lt: BigInt
  hubDomain_gte: BigInt
  hubDomain_lte: BigInt
  hubDomain_in: [BigInt!]
  hubDomain_not_in: [BigInt!]
  amb: bnb_Bytes
  amb_not: bnb_Bytes
  amb_gt: bnb_Bytes
  amb_lt: bnb_Bytes
  amb_gte: bnb_Bytes
  amb_lte: bnb_Bytes
  amb_in: [bnb_Bytes!]
  amb_not_in: [bnb_Bytes!]
  amb_contains: bnb_Bytes
  amb_not_contains: bnb_Bytes
  rootManager: bnb_Bytes
  rootManager_not: bnb_Bytes
  rootManager_gt: bnb_Bytes
  rootManager_lt: bnb_Bytes
  rootManager_gte: bnb_Bytes
  rootManager_lte: bnb_Bytes
  rootManager_in: [bnb_Bytes!]
  rootManager_not_in: [bnb_Bytes!]
  rootManager_contains: bnb_Bytes
  rootManager_not_contains: bnb_Bytes
  mirrorConnector: bnb_Bytes
  mirrorConnector_not: bnb_Bytes
  mirrorConnector_gt: bnb_Bytes
  mirrorConnector_lt: bnb_Bytes
  mirrorConnector_gte: bnb_Bytes
  mirrorConnector_lte: bnb_Bytes
  mirrorConnector_in: [bnb_Bytes!]
  mirrorConnector_not_in: [bnb_Bytes!]
  mirrorConnector_contains: bnb_Bytes
  mirrorConnector_not_contains: bnb_Bytes
  """Filter for the block changed event."""
  _change_block: bnb_BlockChangedFilter
  and: [bnb_ConnectorMeta_filter]
  or: [bnb_ConnectorMeta_filter]
}

enum bnb_ConnectorMeta_orderBy {
  id
  spokeDomain
  hubDomain
  amb
  rootManager
  mirrorConnector
}

type bnb_DestinationTransfer {
  id: ID!
  chainId: BigInt
  transferId: bnb_Bytes
  nonce: BigInt
  status: bnb_TransferStatus
  routers(skip: Int = 0, first: Int = 100, orderBy: bnb_Router_orderBy, orderDirection: bnb_OrderDirection, where: bnb_Router_filter): [bnb_Router!]
  originDomain: BigInt
  destinationDomain: BigInt
  canonicalDomain: BigInt
  to: bnb_Bytes
  delegate: bnb_Bytes
  receiveLocal: Boolean
  callData: bnb_Bytes
  slippage: BigInt
  bumpSlippageCount: BigInt
  originSender: bnb_Bytes
  bridgedAmt: BigInt
  normalizedIn: BigInt
  canonicalId: bnb_Bytes
  asset: bnb_Asset
  amount: BigInt
  routersFee: BigInt
  executedCaller: bnb_Bytes
  executedTransactionHash: bnb_Bytes
  executedTimestamp: BigInt
  executedGasPrice: BigInt
  executedGasLimit: BigInt
  executedBlockNumber: BigInt
  executedTxOrigin: bnb_Bytes
  executedTxNonce: BigInt
  reconciledCaller: bnb_Bytes
  reconciledTransactionHash: bnb_Bytes
  reconciledTimestamp: BigInt
  reconciledGasPrice: BigInt
  reconciledGasLimit: BigInt
  reconciledBlockNumber: BigInt
  reconciledTxOrigin: bnb_Bytes
  reconciledTxNonce: BigInt
}

input bnb_DestinationTransfer_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  chainId: BigInt
  chainId_not: BigInt
  chainId_gt: BigInt
  chainId_lt: BigInt
  chainId_gte: BigInt
  chainId_lte: BigInt
  chainId_in: [BigInt!]
  chainId_not_in: [BigInt!]
  transferId: bnb_Bytes
  transferId_not: bnb_Bytes
  transferId_gt: bnb_Bytes
  transferId_lt: bnb_Bytes
  transferId_gte: bnb_Bytes
  transferId_lte: bnb_Bytes
  transferId_in: [bnb_Bytes!]
  transferId_not_in: [bnb_Bytes!]
  transferId_contains: bnb_Bytes
  transferId_not_contains: bnb_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  status: bnb_TransferStatus
  status_not: bnb_TransferStatus
  status_in: [bnb_TransferStatus!]
  status_not_in: [bnb_TransferStatus!]
  routers: [String!]
  routers_not: [String!]
  routers_contains: [String!]
  routers_contains_nocase: [String!]
  routers_not_contains: [String!]
  routers_not_contains_nocase: [String!]
  routers_: bnb_Router_filter
  originDomain: BigInt
  originDomain_not: BigInt
  originDomain_gt: BigInt
  originDomain_lt: BigInt
  originDomain_gte: BigInt
  originDomain_lte: BigInt
  originDomain_in: [BigInt!]
  originDomain_not_in: [BigInt!]
  destinationDomain: BigInt
  destinationDomain_not: BigInt
  destinationDomain_gt: BigInt
  destinationDomain_lt: BigInt
  destinationDomain_gte: BigInt
  destinationDomain_lte: BigInt
  destinationDomain_in: [BigInt!]
  destinationDomain_not_in: [BigInt!]
  canonicalDomain: BigInt
  canonicalDomain_not: BigInt
  canonicalDomain_gt: BigInt
  canonicalDomain_lt: BigInt
  canonicalDomain_gte: BigInt
  canonicalDomain_lte: BigInt
  canonicalDomain_in: [BigInt!]
  canonicalDomain_not_in: [BigInt!]
  to: bnb_Bytes
  to_not: bnb_Bytes
  to_gt: bnb_Bytes
  to_lt: bnb_Bytes
  to_gte: bnb_Bytes
  to_lte: bnb_Bytes
  to_in: [bnb_Bytes!]
  to_not_in: [bnb_Bytes!]
  to_contains: bnb_Bytes
  to_not_contains: bnb_Bytes
  delegate: bnb_Bytes
  delegate_not: bnb_Bytes
  delegate_gt: bnb_Bytes
  delegate_lt: bnb_Bytes
  delegate_gte: bnb_Bytes
  delegate_lte: bnb_Bytes
  delegate_in: [bnb_Bytes!]
  delegate_not_in: [bnb_Bytes!]
  delegate_contains: bnb_Bytes
  delegate_not_contains: bnb_Bytes
  receiveLocal: Boolean
  receiveLocal_not: Boolean
  receiveLocal_in: [Boolean!]
  receiveLocal_not_in: [Boolean!]
  callData: bnb_Bytes
  callData_not: bnb_Bytes
  callData_gt: bnb_Bytes
  callData_lt: bnb_Bytes
  callData_gte: bnb_Bytes
  callData_lte: bnb_Bytes
  callData_in: [bnb_Bytes!]
  callData_not_in: [bnb_Bytes!]
  callData_contains: bnb_Bytes
  callData_not_contains: bnb_Bytes
  slippage: BigInt
  slippage_not: BigInt
  slippage_gt: BigInt
  slippage_lt: BigInt
  slippage_gte: BigInt
  slippage_lte: BigInt
  slippage_in: [BigInt!]
  slippage_not_in: [BigInt!]
  bumpSlippageCount: BigInt
  bumpSlippageCount_not: BigInt
  bumpSlippageCount_gt: BigInt
  bumpSlippageCount_lt: BigInt
  bumpSlippageCount_gte: BigInt
  bumpSlippageCount_lte: BigInt
  bumpSlippageCount_in: [BigInt!]
  bumpSlippageCount_not_in: [BigInt!]
  originSender: bnb_Bytes
  originSender_not: bnb_Bytes
  originSender_gt: bnb_Bytes
  originSender_lt: bnb_Bytes
  originSender_gte: bnb_Bytes
  originSender_lte: bnb_Bytes
  originSender_in: [bnb_Bytes!]
  originSender_not_in: [bnb_Bytes!]
  originSender_contains: bnb_Bytes
  originSender_not_contains: bnb_Bytes
  bridgedAmt: BigInt
  bridgedAmt_not: BigInt
  bridgedAmt_gt: BigInt
  bridgedAmt_lt: BigInt
  bridgedAmt_gte: BigInt
  bridgedAmt_lte: BigInt
  bridgedAmt_in: [BigInt!]
  bridgedAmt_not_in: [BigInt!]
  normalizedIn: BigInt
  normalizedIn_not: BigInt
  normalizedIn_gt: BigInt
  normalizedIn_lt: BigInt
  normalizedIn_gte: BigInt
  normalizedIn_lte: BigInt
  normalizedIn_in: [BigInt!]
  normalizedIn_not_in: [BigInt!]
  canonicalId: bnb_Bytes
  canonicalId_not: bnb_Bytes
  canonicalId_gt: bnb_Bytes
  canonicalId_lt: bnb_Bytes
  canonicalId_gte: bnb_Bytes
  canonicalId_lte: bnb_Bytes
  canonicalId_in: [bnb_Bytes!]
  canonicalId_not_in: [bnb_Bytes!]
  canonicalId_contains: bnb_Bytes
  canonicalId_not_contains: bnb_Bytes
  asset: String
  asset_not: String
  asset_gt: String
  asset_lt: String
  asset_gte: String
  asset_lte: String
  asset_in: [String!]
  asset_not_in: [String!]
  asset_contains: String
  asset_contains_nocase: String
  asset_not_contains: String
  asset_not_contains_nocase: String
  asset_starts_with: String
  asset_starts_with_nocase: String
  asset_not_starts_with: String
  asset_not_starts_with_nocase: String
  asset_ends_with: String
  asset_ends_with_nocase: String
  asset_not_ends_with: String
  asset_not_ends_with_nocase: String
  asset_: bnb_Asset_filter
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  routersFee: BigInt
  routersFee_not: BigInt
  routersFee_gt: BigInt
  routersFee_lt: BigInt
  routersFee_gte: BigInt
  routersFee_lte: BigInt
  routersFee_in: [BigInt!]
  routersFee_not_in: [BigInt!]
  executedCaller: bnb_Bytes
  executedCaller_not: bnb_Bytes
  executedCaller_gt: bnb_Bytes
  executedCaller_lt: bnb_Bytes
  executedCaller_gte: bnb_Bytes
  executedCaller_lte: bnb_Bytes
  executedCaller_in: [bnb_Bytes!]
  executedCaller_not_in: [bnb_Bytes!]
  executedCaller_contains: bnb_Bytes
  executedCaller_not_contains: bnb_Bytes
  executedTransactionHash: bnb_Bytes
  executedTransactionHash_not: bnb_Bytes
  executedTransactionHash_gt: bnb_Bytes
  executedTransactionHash_lt: bnb_Bytes
  executedTransactionHash_gte: bnb_Bytes
  executedTransactionHash_lte: bnb_Bytes
  executedTransactionHash_in: [bnb_Bytes!]
  executedTransactionHash_not_in: [bnb_Bytes!]
  executedTransactionHash_contains: bnb_Bytes
  executedTransactionHash_not_contains: bnb_Bytes
  executedTimestamp: BigInt
  executedTimestamp_not: BigInt
  executedTimestamp_gt: BigInt
  executedTimestamp_lt: BigInt
  executedTimestamp_gte: BigInt
  executedTimestamp_lte: BigInt
  executedTimestamp_in: [BigInt!]
  executedTimestamp_not_in: [BigInt!]
  executedGasPrice: BigInt
  executedGasPrice_not: BigInt
  executedGasPrice_gt: BigInt
  executedGasPrice_lt: BigInt
  executedGasPrice_gte: BigInt
  executedGasPrice_lte: BigInt
  executedGasPrice_in: [BigInt!]
  executedGasPrice_not_in: [BigInt!]
  executedGasLimit: BigInt
  executedGasLimit_not: BigInt
  executedGasLimit_gt: BigInt
  executedGasLimit_lt: BigInt
  executedGasLimit_gte: BigInt
  executedGasLimit_lte: BigInt
  executedGasLimit_in: [BigInt!]
  executedGasLimit_not_in: [BigInt!]
  executedBlockNumber: BigInt
  executedBlockNumber_not: BigInt
  executedBlockNumber_gt: BigInt
  executedBlockNumber_lt: BigInt
  executedBlockNumber_gte: BigInt
  executedBlockNumber_lte: BigInt
  executedBlockNumber_in: [BigInt!]
  executedBlockNumber_not_in: [BigInt!]
  executedTxOrigin: bnb_Bytes
  executedTxOrigin_not: bnb_Bytes
  executedTxOrigin_gt: bnb_Bytes
  executedTxOrigin_lt: bnb_Bytes
  executedTxOrigin_gte: bnb_Bytes
  executedTxOrigin_lte: bnb_Bytes
  executedTxOrigin_in: [bnb_Bytes!]
  executedTxOrigin_not_in: [bnb_Bytes!]
  executedTxOrigin_contains: bnb_Bytes
  executedTxOrigin_not_contains: bnb_Bytes
  executedTxNonce: BigInt
  executedTxNonce_not: BigInt
  executedTxNonce_gt: BigInt
  executedTxNonce_lt: BigInt
  executedTxNonce_gte: BigInt
  executedTxNonce_lte: BigInt
  executedTxNonce_in: [BigInt!]
  executedTxNonce_not_in: [BigInt!]
  reconciledCaller: bnb_Bytes
  reconciledCaller_not: bnb_Bytes
  reconciledCaller_gt: bnb_Bytes
  reconciledCaller_lt: bnb_Bytes
  reconciledCaller_gte: bnb_Bytes
  reconciledCaller_lte: bnb_Bytes
  reconciledCaller_in: [bnb_Bytes!]
  reconciledCaller_not_in: [bnb_Bytes!]
  reconciledCaller_contains: bnb_Bytes
  reconciledCaller_not_contains: bnb_Bytes
  reconciledTransactionHash: bnb_Bytes
  reconciledTransactionHash_not: bnb_Bytes
  reconciledTransactionHash_gt: bnb_Bytes
  reconciledTransactionHash_lt: bnb_Bytes
  reconciledTransactionHash_gte: bnb_Bytes
  reconciledTransactionHash_lte: bnb_Bytes
  reconciledTransactionHash_in: [bnb_Bytes!]
  reconciledTransactionHash_not_in: [bnb_Bytes!]
  reconciledTransactionHash_contains: bnb_Bytes
  reconciledTransactionHash_not_contains: bnb_Bytes
  reconciledTimestamp: BigInt
  reconciledTimestamp_not: BigInt
  reconciledTimestamp_gt: BigInt
  reconciledTimestamp_lt: BigInt
  reconciledTimestamp_gte: BigInt
  reconciledTimestamp_lte: BigInt
  reconciledTimestamp_in: [BigInt!]
  reconciledTimestamp_not_in: [BigInt!]
  reconciledGasPrice: BigInt
  reconciledGasPrice_not: BigInt
  reconciledGasPrice_gt: BigInt
  reconciledGasPrice_lt: BigInt
  reconciledGasPrice_gte: BigInt
  reconciledGasPrice_lte: BigInt
  reconciledGasPrice_in: [BigInt!]
  reconciledGasPrice_not_in: [BigInt!]
  reconciledGasLimit: BigInt
  reconciledGasLimit_not: BigInt
  reconciledGasLimit_gt: BigInt
  reconciledGasLimit_lt: BigInt
  reconciledGasLimit_gte: BigInt
  reconciledGasLimit_lte: BigInt
  reconciledGasLimit_in: [BigInt!]
  reconciledGasLimit_not_in: [BigInt!]
  reconciledBlockNumber: BigInt
  reconciledBlockNumber_not: BigInt
  reconciledBlockNumber_gt: BigInt
  reconciledBlockNumber_lt: BigInt
  reconciledBlockNumber_gte: BigInt
  reconciledBlockNumber_lte: BigInt
  reconciledBlockNumber_in: [BigInt!]
  reconciledBlockNumber_not_in: [BigInt!]
  reconciledTxOrigin: bnb_Bytes
  reconciledTxOrigin_not: bnb_Bytes
  reconciledTxOrigin_gt: bnb_Bytes
  reconciledTxOrigin_lt: bnb_Bytes
  reconciledTxOrigin_gte: bnb_Bytes
  reconciledTxOrigin_lte: bnb_Bytes
  reconciledTxOrigin_in: [bnb_Bytes!]
  reconciledTxOrigin_not_in: [bnb_Bytes!]
  reconciledTxOrigin_contains: bnb_Bytes
  reconciledTxOrigin_not_contains: bnb_Bytes
  reconciledTxNonce: BigInt
  reconciledTxNonce_not: BigInt
  reconciledTxNonce_gt: BigInt
  reconciledTxNonce_lt: BigInt
  reconciledTxNonce_gte: BigInt
  reconciledTxNonce_lte: BigInt
  reconciledTxNonce_in: [BigInt!]
  reconciledTxNonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: bnb_BlockChangedFilter
  and: [bnb_DestinationTransfer_filter]
  or: [bnb_DestinationTransfer_filter]
}

enum bnb_DestinationTransfer_orderBy {
  id
  chainId
  transferId
  nonce
  status
  routers
  originDomain
  destinationDomain
  canonicalDomain
  to
  delegate
  receiveLocal
  callData
  slippage
  bumpSlippageCount
  originSender
  bridgedAmt
  normalizedIn
  canonicalId
  asset
  asset__id
  asset__key
  asset__decimal
  asset__adoptedDecimal
  asset__canonicalId
  asset__canonicalDomain
  asset__adoptedAsset
  asset__localAsset
  asset__blockNumber
  amount
  routersFee
  executedCaller
  executedTransactionHash
  executedTimestamp
  executedGasPrice
  executedGasLimit
  executedBlockNumber
  executedTxOrigin
  executedTxNonce
  reconciledCaller
  reconciledTransactionHash
  reconciledTimestamp
  reconciledGasPrice
  reconciledGasLimit
  reconciledBlockNumber
  reconciledTxOrigin
  reconciledTxNonce
}

"""
8 bytes signed integer

"""
scalar bnb_Int8

type bnb_OptimisticRootFinalized {
  id: ID!
  aggregateRoot: bnb_Bytes!
  timestamp: BigInt!
  blockNumber: BigInt
}

input bnb_OptimisticRootFinalized_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  aggregateRoot: bnb_Bytes
  aggregateRoot_not: bnb_Bytes
  aggregateRoot_gt: bnb_Bytes
  aggregateRoot_lt: bnb_Bytes
  aggregateRoot_gte: bnb_Bytes
  aggregateRoot_lte: bnb_Bytes
  aggregateRoot_in: [bnb_Bytes!]
  aggregateRoot_not_in: [bnb_Bytes!]
  aggregateRoot_contains: bnb_Bytes
  aggregateRoot_not_contains: bnb_Bytes
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: bnb_BlockChangedFilter
  and: [bnb_OptimisticRootFinalized_filter]
  or: [bnb_OptimisticRootFinalized_filter]
}

enum bnb_OptimisticRootFinalized_orderBy {
  id
  aggregateRoot
  timestamp
  blockNumber
}

"""Defines the order direction, either ascending or descending"""
enum bnb_OrderDirection {
  asc
  desc
}

type bnb_OriginMessage {
  id: ID!
  transferId: bnb_Bytes
  destinationDomain: BigInt
  leaf: bnb_Bytes
  index: BigInt
  message: bnb_Bytes
  root: bnb_Bytes
  transactionHash: bnb_Bytes
  blockNumber: BigInt
  rootCount: bnb_RootCount
}

input bnb_OriginMessage_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transferId: bnb_Bytes
  transferId_not: bnb_Bytes
  transferId_gt: bnb_Bytes
  transferId_lt: bnb_Bytes
  transferId_gte: bnb_Bytes
  transferId_lte: bnb_Bytes
  transferId_in: [bnb_Bytes!]
  transferId_not_in: [bnb_Bytes!]
  transferId_contains: bnb_Bytes
  transferId_not_contains: bnb_Bytes
  destinationDomain: BigInt
  destinationDomain_not: BigInt
  destinationDomain_gt: BigInt
  destinationDomain_lt: BigInt
  destinationDomain_gte: BigInt
  destinationDomain_lte: BigInt
  destinationDomain_in: [BigInt!]
  destinationDomain_not_in: [BigInt!]
  leaf: bnb_Bytes
  leaf_not: bnb_Bytes
  leaf_gt: bnb_Bytes
  leaf_lt: bnb_Bytes
  leaf_gte: bnb_Bytes
  leaf_lte: bnb_Bytes
  leaf_in: [bnb_Bytes!]
  leaf_not_in: [bnb_Bytes!]
  leaf_contains: bnb_Bytes
  leaf_not_contains: bnb_Bytes
  index: BigInt
  index_not: BigInt
  index_gt: BigInt
  index_lt: BigInt
  index_gte: BigInt
  index_lte: BigInt
  index_in: [BigInt!]
  index_not_in: [BigInt!]
  message: bnb_Bytes
  message_not: bnb_Bytes
  message_gt: bnb_Bytes
  message_lt: bnb_Bytes
  message_gte: bnb_Bytes
  message_lte: bnb_Bytes
  message_in: [bnb_Bytes!]
  message_not_in: [bnb_Bytes!]
  message_contains: bnb_Bytes
  message_not_contains: bnb_Bytes
  root: bnb_Bytes
  root_not: bnb_Bytes
  root_gt: bnb_Bytes
  root_lt: bnb_Bytes
  root_gte: bnb_Bytes
  root_lte: bnb_Bytes
  root_in: [bnb_Bytes!]
  root_not_in: [bnb_Bytes!]
  root_contains: bnb_Bytes
  root_not_contains: bnb_Bytes
  transactionHash: bnb_Bytes
  transactionHash_not: bnb_Bytes
  transactionHash_gt: bnb_Bytes
  transactionHash_lt: bnb_Bytes
  transactionHash_gte: bnb_Bytes
  transactionHash_lte: bnb_Bytes
  transactionHash_in: [bnb_Bytes!]
  transactionHash_not_in: [bnb_Bytes!]
  transactionHash_contains: bnb_Bytes
  transactionHash_not_contains: bnb_Bytes
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  rootCount: String
  rootCount_not: String
  rootCount_gt: String
  rootCount_lt: String
  rootCount_gte: String
  rootCount_lte: String
  rootCount_in: [String!]
  rootCount_not_in: [String!]
  rootCount_contains: String
  rootCount_contains_nocase: String
  rootCount_not_contains: String
  rootCount_not_contains_nocase: String
  rootCount_starts_with: String
  rootCount_starts_with_nocase: String
  rootCount_not_starts_with: String
  rootCount_not_starts_with_nocase: String
  rootCount_ends_with: String
  rootCount_ends_with_nocase: String
  rootCount_not_ends_with: String
  rootCount_not_ends_with_nocase: String
  rootCount_: bnb_RootCount_filter
  """Filter for the block changed event."""
  _change_block: bnb_BlockChangedFilter
  and: [bnb_OriginMessage_filter]
  or: [bnb_OriginMessage_filter]
}

enum bnb_OriginMessage_orderBy {
  id
  transferId
  destinationDomain
  leaf
  index
  message
  root
  transactionHash
  blockNumber
  rootCount
  rootCount__id
  rootCount__count
}

type bnb_OriginTransfer {
  id: ID!
  chainId: BigInt
  transferId: bnb_Bytes
  nonce: BigInt
  status: bnb_TransferStatus
  messageHash: bnb_Bytes
  originDomain: BigInt
  destinationDomain: BigInt
  canonicalDomain: BigInt
  to: bnb_Bytes
  delegate: bnb_Bytes
  receiveLocal: Boolean
  callData: bnb_Bytes
  slippage: BigInt
  originSender: bnb_Bytes
  bridgedAmt: BigInt
  normalizedIn: BigInt
  canonicalId: bnb_Bytes
  asset: bnb_Asset
  transactingAsset: bnb_Bytes
  message: bnb_OriginMessage
  bumpRelayerFeeCount: BigInt
  relayerFees(skip: Int = 0, first: Int = 100, orderBy: bnb_RelayerFee_orderBy, orderDirection: bnb_OrderDirection, where: bnb_RelayerFee_filter): [bnb_RelayerFee!]
  initialRelayerFeeAsset: bnb_Bytes
  caller: bnb_Bytes
  transactionHash: bnb_Bytes
  timestamp: BigInt
  gasPrice: BigInt
  gasLimit: BigInt
  blockNumber: BigInt
  txOrigin: bnb_Bytes
  txNonce: BigInt
}

input bnb_OriginTransfer_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  chainId: BigInt
  chainId_not: BigInt
  chainId_gt: BigInt
  chainId_lt: BigInt
  chainId_gte: BigInt
  chainId_lte: BigInt
  chainId_in: [BigInt!]
  chainId_not_in: [BigInt!]
  transferId: bnb_Bytes
  transferId_not: bnb_Bytes
  transferId_gt: bnb_Bytes
  transferId_lt: bnb_Bytes
  transferId_gte: bnb_Bytes
  transferId_lte: bnb_Bytes
  transferId_in: [bnb_Bytes!]
  transferId_not_in: [bnb_Bytes!]
  transferId_contains: bnb_Bytes
  transferId_not_contains: bnb_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  status: bnb_TransferStatus
  status_not: bnb_TransferStatus
  status_in: [bnb_TransferStatus!]
  status_not_in: [bnb_TransferStatus!]
  messageHash: bnb_Bytes
  messageHash_not: bnb_Bytes
  messageHash_gt: bnb_Bytes
  messageHash_lt: bnb_Bytes
  messageHash_gte: bnb_Bytes
  messageHash_lte: bnb_Bytes
  messageHash_in: [bnb_Bytes!]
  messageHash_not_in: [bnb_Bytes!]
  messageHash_contains: bnb_Bytes
  messageHash_not_contains: bnb_Bytes
  originDomain: BigInt
  originDomain_not: BigInt
  originDomain_gt: BigInt
  originDomain_lt: BigInt
  originDomain_gte: BigInt
  originDomain_lte: BigInt
  originDomain_in: [BigInt!]
  originDomain_not_in: [BigInt!]
  destinationDomain: BigInt
  destinationDomain_not: BigInt
  destinationDomain_gt: BigInt
  destinationDomain_lt: BigInt
  destinationDomain_gte: BigInt
  destinationDomain_lte: BigInt
  destinationDomain_in: [BigInt!]
  destinationDomain_not_in: [BigInt!]
  canonicalDomain: BigInt
  canonicalDomain_not: BigInt
  canonicalDomain_gt: BigInt
  canonicalDomain_lt: BigInt
  canonicalDomain_gte: BigInt
  canonicalDomain_lte: BigInt
  canonicalDomain_in: [BigInt!]
  canonicalDomain_not_in: [BigInt!]
  to: bnb_Bytes
  to_not: bnb_Bytes
  to_gt: bnb_Bytes
  to_lt: bnb_Bytes
  to_gte: bnb_Bytes
  to_lte: bnb_Bytes
  to_in: [bnb_Bytes!]
  to_not_in: [bnb_Bytes!]
  to_contains: bnb_Bytes
  to_not_contains: bnb_Bytes
  delegate: bnb_Bytes
  delegate_not: bnb_Bytes
  delegate_gt: bnb_Bytes
  delegate_lt: bnb_Bytes
  delegate_gte: bnb_Bytes
  delegate_lte: bnb_Bytes
  delegate_in: [bnb_Bytes!]
  delegate_not_in: [bnb_Bytes!]
  delegate_contains: bnb_Bytes
  delegate_not_contains: bnb_Bytes
  receiveLocal: Boolean
  receiveLocal_not: Boolean
  receiveLocal_in: [Boolean!]
  receiveLocal_not_in: [Boolean!]
  callData: bnb_Bytes
  callData_not: bnb_Bytes
  callData_gt: bnb_Bytes
  callData_lt: bnb_Bytes
  callData_gte: bnb_Bytes
  callData_lte: bnb_Bytes
  callData_in: [bnb_Bytes!]
  callData_not_in: [bnb_Bytes!]
  callData_contains: bnb_Bytes
  callData_not_contains: bnb_Bytes
  slippage: BigInt
  slippage_not: BigInt
  slippage_gt: BigInt
  slippage_lt: BigInt
  slippage_gte: BigInt
  slippage_lte: BigInt
  slippage_in: [BigInt!]
  slippage_not_in: [BigInt!]
  originSender: bnb_Bytes
  originSender_not: bnb_Bytes
  originSender_gt: bnb_Bytes
  originSender_lt: bnb_Bytes
  originSender_gte: bnb_Bytes
  originSender_lte: bnb_Bytes
  originSender_in: [bnb_Bytes!]
  originSender_not_in: [bnb_Bytes!]
  originSender_contains: bnb_Bytes
  originSender_not_contains: bnb_Bytes
  bridgedAmt: BigInt
  bridgedAmt_not: BigInt
  bridgedAmt_gt: BigInt
  bridgedAmt_lt: BigInt
  bridgedAmt_gte: BigInt
  bridgedAmt_lte: BigInt
  bridgedAmt_in: [BigInt!]
  bridgedAmt_not_in: [BigInt!]
  normalizedIn: BigInt
  normalizedIn_not: BigInt
  normalizedIn_gt: BigInt
  normalizedIn_lt: BigInt
  normalizedIn_gte: BigInt
  normalizedIn_lte: BigInt
  normalizedIn_in: [BigInt!]
  normalizedIn_not_in: [BigInt!]
  canonicalId: bnb_Bytes
  canonicalId_not: bnb_Bytes
  canonicalId_gt: bnb_Bytes
  canonicalId_lt: bnb_Bytes
  canonicalId_gte: bnb_Bytes
  canonicalId_lte: bnb_Bytes
  canonicalId_in: [bnb_Bytes!]
  canonicalId_not_in: [bnb_Bytes!]
  canonicalId_contains: bnb_Bytes
  canonicalId_not_contains: bnb_Bytes
  asset: String
  asset_not: String
  asset_gt: String
  asset_lt: String
  asset_gte: String
  asset_lte: String
  asset_in: [String!]
  asset_not_in: [String!]
  asset_contains: String
  asset_contains_nocase: String
  asset_not_contains: String
  asset_not_contains_nocase: String
  asset_starts_with: String
  asset_starts_with_nocase: String
  asset_not_starts_with: String
  asset_not_starts_with_nocase: String
  asset_ends_with: String
  asset_ends_with_nocase: String
  asset_not_ends_with: String
  asset_not_ends_with_nocase: String
  asset_: bnb_Asset_filter
  transactingAsset: bnb_Bytes
  transactingAsset_not: bnb_Bytes
  transactingAsset_gt: bnb_Bytes
  transactingAsset_lt: bnb_Bytes
  transactingAsset_gte: bnb_Bytes
  transactingAsset_lte: bnb_Bytes
  transactingAsset_in: [bnb_Bytes!]
  transactingAsset_not_in: [bnb_Bytes!]
  transactingAsset_contains: bnb_Bytes
  transactingAsset_not_contains: bnb_Bytes
  message: String
  message_not: String
  message_gt: String
  message_lt: String
  message_gte: String
  message_lte: String
  message_in: [String!]
  message_not_in: [String!]
  message_contains: String
  message_contains_nocase: String
  message_not_contains: String
  message_not_contains_nocase: String
  message_starts_with: String
  message_starts_with_nocase: String
  message_not_starts_with: String
  message_not_starts_with_nocase: String
  message_ends_with: String
  message_ends_with_nocase: String
  message_not_ends_with: String
  message_not_ends_with_nocase: String
  message_: bnb_OriginMessage_filter
  bumpRelayerFeeCount: BigInt
  bumpRelayerFeeCount_not: BigInt
  bumpRelayerFeeCount_gt: BigInt
  bumpRelayerFeeCount_lt: BigInt
  bumpRelayerFeeCount_gte: BigInt
  bumpRelayerFeeCount_lte: BigInt
  bumpRelayerFeeCount_in: [BigInt!]
  bumpRelayerFeeCount_not_in: [BigInt!]
  relayerFees: [String!]
  relayerFees_not: [String!]
  relayerFees_contains: [String!]
  relayerFees_contains_nocase: [String!]
  relayerFees_not_contains: [String!]
  relayerFees_not_contains_nocase: [String!]
  relayerFees_: bnb_RelayerFee_filter
  initialRelayerFeeAsset: bnb_Bytes
  initialRelayerFeeAsset_not: bnb_Bytes
  initialRelayerFeeAsset_gt: bnb_Bytes
  initialRelayerFeeAsset_lt: bnb_Bytes
  initialRelayerFeeAsset_gte: bnb_Bytes
  initialRelayerFeeAsset_lte: bnb_Bytes
  initialRelayerFeeAsset_in: [bnb_Bytes!]
  initialRelayerFeeAsset_not_in: [bnb_Bytes!]
  initialRelayerFeeAsset_contains: bnb_Bytes
  initialRelayerFeeAsset_not_contains: bnb_Bytes
  caller: bnb_Bytes
  caller_not: bnb_Bytes
  caller_gt: bnb_Bytes
  caller_lt: bnb_Bytes
  caller_gte: bnb_Bytes
  caller_lte: bnb_Bytes
  caller_in: [bnb_Bytes!]
  caller_not_in: [bnb_Bytes!]
  caller_contains: bnb_Bytes
  caller_not_contains: bnb_Bytes
  transactionHash: bnb_Bytes
  transactionHash_not: bnb_Bytes
  transactionHash_gt: bnb_Bytes
  transactionHash_lt: bnb_Bytes
  transactionHash_gte: bnb_Bytes
  transactionHash_lte: bnb_Bytes
  transactionHash_in: [bnb_Bytes!]
  transactionHash_not_in: [bnb_Bytes!]
  transactionHash_contains: bnb_Bytes
  transactionHash_not_contains: bnb_Bytes
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  gasLimit: BigInt
  gasLimit_not: BigInt
  gasLimit_gt: BigInt
  gasLimit_lt: BigInt
  gasLimit_gte: BigInt
  gasLimit_lte: BigInt
  gasLimit_in: [BigInt!]
  gasLimit_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  txOrigin: bnb_Bytes
  txOrigin_not: bnb_Bytes
  txOrigin_gt: bnb_Bytes
  txOrigin_lt: bnb_Bytes
  txOrigin_gte: bnb_Bytes
  txOrigin_lte: bnb_Bytes
  txOrigin_in: [bnb_Bytes!]
  txOrigin_not_in: [bnb_Bytes!]
  txOrigin_contains: bnb_Bytes
  txOrigin_not_contains: bnb_Bytes
  txNonce: BigInt
  txNonce_not: BigInt
  txNonce_gt: BigInt
  txNonce_lt: BigInt
  txNonce_gte: BigInt
  txNonce_lte: BigInt
  txNonce_in: [BigInt!]
  txNonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: bnb_BlockChangedFilter
  and: [bnb_OriginTransfer_filter]
  or: [bnb_OriginTransfer_filter]
}

enum bnb_OriginTransfer_orderBy {
  id
  chainId
  transferId
  nonce
  status
  messageHash
  originDomain
  destinationDomain
  canonicalDomain
  to
  delegate
  receiveLocal
  callData
  slippage
  originSender
  bridgedAmt
  normalizedIn
  canonicalId
  asset
  asset__id
  asset__key
  asset__decimal
  asset__adoptedDecimal
  asset__canonicalId
  asset__canonicalDomain
  asset__adoptedAsset
  asset__localAsset
  asset__blockNumber
  transactingAsset
  message
  message__id
  message__transferId
  message__destinationDomain
  message__leaf
  message__index
  message__message
  message__root
  message__transactionHash
  message__blockNumber
  bumpRelayerFeeCount
  relayerFees
  initialRelayerFeeAsset
  caller
  transactionHash
  timestamp
  gasPrice
  gasLimit
  blockNumber
  txOrigin
  txNonce
}

type bnb_Relayer {
  id: ID!
  isActive: Boolean!
  relayer: bnb_Bytes
}

type bnb_RelayerFee {
  id: ID!
  transfer: bnb_OriginTransfer!
  fee: BigInt!
  asset: bnb_Bytes!
}

input bnb_RelayerFee_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transfer: String
  transfer_not: String
  transfer_gt: String
  transfer_lt: String
  transfer_gte: String
  transfer_lte: String
  transfer_in: [String!]
  transfer_not_in: [String!]
  transfer_contains: String
  transfer_contains_nocase: String
  transfer_not_contains: String
  transfer_not_contains_nocase: String
  transfer_starts_with: String
  transfer_starts_with_nocase: String
  transfer_not_starts_with: String
  transfer_not_starts_with_nocase: String
  transfer_ends_with: String
  transfer_ends_with_nocase: String
  transfer_not_ends_with: String
  transfer_not_ends_with_nocase: String
  transfer_: bnb_OriginTransfer_filter
  fee: BigInt
  fee_not: BigInt
  fee_gt: BigInt
  fee_lt: BigInt
  fee_gte: BigInt
  fee_lte: BigInt
  fee_in: [BigInt!]
  fee_not_in: [BigInt!]
  asset: bnb_Bytes
  asset_not: bnb_Bytes
  asset_gt: bnb_Bytes
  asset_lt: bnb_Bytes
  asset_gte: bnb_Bytes
  asset_lte: bnb_Bytes
  asset_in: [bnb_Bytes!]
  asset_not_in: [bnb_Bytes!]
  asset_contains: bnb_Bytes
  asset_not_contains: bnb_Bytes
  """Filter for the block changed event."""
  _change_block: bnb_BlockChangedFilter
  and: [bnb_RelayerFee_filter]
  or: [bnb_RelayerFee_filter]
}

enum bnb_RelayerFee_orderBy {
  id
  transfer
  transfer__id
  transfer__chainId
  transfer__transferId
  transfer__nonce
  transfer__status
  transfer__messageHash
  transfer__originDomain
  transfer__destinationDomain
  transfer__canonicalDomain
  transfer__to
  transfer__delegate
  transfer__receiveLocal
  transfer__callData
  transfer__slippage
  transfer__originSender
  transfer__bridgedAmt
  transfer__normalizedIn
  transfer__canonicalId
  transfer__transactingAsset
  transfer__bumpRelayerFeeCount
  transfer__initialRelayerFeeAsset
  transfer__caller
  transfer__transactionHash
  transfer__timestamp
  transfer__gasPrice
  transfer__gasLimit
  transfer__blockNumber
  transfer__txOrigin
  transfer__txNonce
  fee
  asset
}

type bnb_RelayerFeesIncrease {
  id: ID!
  transfer: bnb_OriginTransfer!
  increase: BigInt
  asset: bnb_Bytes
  caller: bnb_Bytes!
  transactionHash: bnb_Bytes!
  timestamp: BigInt!
  gasPrice: BigInt!
  gasLimit: BigInt!
  blockNumber: BigInt!
}

input bnb_RelayerFeesIncrease_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transfer: String
  transfer_not: String
  transfer_gt: String
  transfer_lt: String
  transfer_gte: String
  transfer_lte: String
  transfer_in: [String!]
  transfer_not_in: [String!]
  transfer_contains: String
  transfer_contains_nocase: String
  transfer_not_contains: String
  transfer_not_contains_nocase: String
  transfer_starts_with: String
  transfer_starts_with_nocase: String
  transfer_not_starts_with: String
  transfer_not_starts_with_nocase: String
  transfer_ends_with: String
  transfer_ends_with_nocase: String
  transfer_not_ends_with: String
  transfer_not_ends_with_nocase: String
  transfer_: bnb_OriginTransfer_filter
  increase: BigInt
  increase_not: BigInt
  increase_gt: BigInt
  increase_lt: BigInt
  increase_gte: BigInt
  increase_lte: BigInt
  increase_in: [BigInt!]
  increase_not_in: [BigInt!]
  asset: bnb_Bytes
  asset_not: bnb_Bytes
  asset_gt: bnb_Bytes
  asset_lt: bnb_Bytes
  asset_gte: bnb_Bytes
  asset_lte: bnb_Bytes
  asset_in: [bnb_Bytes!]
  asset_not_in: [bnb_Bytes!]
  asset_contains: bnb_Bytes
  asset_not_contains: bnb_Bytes
  caller: bnb_Bytes
  caller_not: bnb_Bytes
  caller_gt: bnb_Bytes
  caller_lt: bnb_Bytes
  caller_gte: bnb_Bytes
  caller_lte: bnb_Bytes
  caller_in: [bnb_Bytes!]
  caller_not_in: [bnb_Bytes!]
  caller_contains: bnb_Bytes
  caller_not_contains: bnb_Bytes
  transactionHash: bnb_Bytes
  transactionHash_not: bnb_Bytes
  transactionHash_gt: bnb_Bytes
  transactionHash_lt: bnb_Bytes
  transactionHash_gte: bnb_Bytes
  transactionHash_lte: bnb_Bytes
  transactionHash_in: [bnb_Bytes!]
  transactionHash_not_in: [bnb_Bytes!]
  transactionHash_contains: bnb_Bytes
  transactionHash_not_contains: bnb_Bytes
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  gasLimit: BigInt
  gasLimit_not: BigInt
  gasLimit_gt: BigInt
  gasLimit_lt: BigInt
  gasLimit_gte: BigInt
  gasLimit_lte: BigInt
  gasLimit_in: [BigInt!]
  gasLimit_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: bnb_BlockChangedFilter
  and: [bnb_RelayerFeesIncrease_filter]
  or: [bnb_RelayerFeesIncrease_filter]
}

enum bnb_RelayerFeesIncrease_orderBy {
  id
  transfer
  transfer__id
  transfer__chainId
  transfer__transferId
  transfer__nonce
  transfer__status
  transfer__messageHash
  transfer__originDomain
  transfer__destinationDomain
  transfer__canonicalDomain
  transfer__to
  transfer__delegate
  transfer__receiveLocal
  transfer__callData
  transfer__slippage
  transfer__originSender
  transfer__bridgedAmt
  transfer__normalizedIn
  transfer__canonicalId
  transfer__transactingAsset
  transfer__bumpRelayerFeeCount
  transfer__initialRelayerFeeAsset
  transfer__caller
  transfer__transactionHash
  transfer__timestamp
  transfer__gasPrice
  transfer__gasLimit
  transfer__blockNumber
  transfer__txOrigin
  transfer__txNonce
  increase
  asset
  caller
  transactionHash
  timestamp
  gasPrice
  gasLimit
  blockNumber
}

input bnb_Relayer_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  isActive: Boolean
  isActive_not: Boolean
  isActive_in: [Boolean!]
  isActive_not_in: [Boolean!]
  relayer: bnb_Bytes
  relayer_not: bnb_Bytes
  relayer_gt: bnb_Bytes
  relayer_lt: bnb_Bytes
  relayer_gte: bnb_Bytes
  relayer_lte: bnb_Bytes
  relayer_in: [bnb_Bytes!]
  relayer_not_in: [bnb_Bytes!]
  relayer_contains: bnb_Bytes
  relayer_not_contains: bnb_Bytes
  """Filter for the block changed event."""
  _change_block: bnb_BlockChangedFilter
  and: [bnb_Relayer_filter]
  or: [bnb_Relayer_filter]
}

enum bnb_Relayer_orderBy {
  id
  isActive
  relayer
}

type bnb_RootCount {
  id: ID!
  count: BigInt
}

input bnb_RootCount_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  count: BigInt
  count_not: BigInt
  count_gt: BigInt
  count_lt: BigInt
  count_gte: BigInt
  count_lte: BigInt
  count_in: [BigInt!]
  count_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: bnb_BlockChangedFilter
  and: [bnb_RootCount_filter]
  or: [bnb_RootCount_filter]
}

enum bnb_RootCount_orderBy {
  id
  count
}

type bnb_RootMessageSent {
  id: ID!
  spokeDomain: BigInt
  hubDomain: BigInt
  root: bnb_Bytes
  count: BigInt
  caller: bnb_Bytes
  transactionHash: bnb_Bytes
  timestamp: BigInt
  gasPrice: BigInt
  gasLimit: BigInt
  blockNumber: BigInt
}

input bnb_RootMessageSent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  spokeDomain: BigInt
  spokeDomain_not: BigInt
  spokeDomain_gt: BigInt
  spokeDomain_lt: BigInt
  spokeDomain_gte: BigInt
  spokeDomain_lte: BigInt
  spokeDomain_in: [BigInt!]
  spokeDomain_not_in: [BigInt!]
  hubDomain: BigInt
  hubDomain_not: BigInt
  hubDomain_gt: BigInt
  hubDomain_lt: BigInt
  hubDomain_gte: BigInt
  hubDomain_lte: BigInt
  hubDomain_in: [BigInt!]
  hubDomain_not_in: [BigInt!]
  root: bnb_Bytes
  root_not: bnb_Bytes
  root_gt: bnb_Bytes
  root_lt: bnb_Bytes
  root_gte: bnb_Bytes
  root_lte: bnb_Bytes
  root_in: [bnb_Bytes!]
  root_not_in: [bnb_Bytes!]
  root_contains: bnb_Bytes
  root_not_contains: bnb_Bytes
  count: BigInt
  count_not: BigInt
  count_gt: BigInt
  count_lt: BigInt
  count_gte: BigInt
  count_lte: BigInt
  count_in: [BigInt!]
  count_not_in: [BigInt!]
  caller: bnb_Bytes
  caller_not: bnb_Bytes
  caller_gt: bnb_Bytes
  caller_lt: bnb_Bytes
  caller_gte: bnb_Bytes
  caller_lte: bnb_Bytes
  caller_in: [bnb_Bytes!]
  caller_not_in: [bnb_Bytes!]
  caller_contains: bnb_Bytes
  caller_not_contains: bnb_Bytes
  transactionHash: bnb_Bytes
  transactionHash_not: bnb_Bytes
  transactionHash_gt: bnb_Bytes
  transactionHash_lt: bnb_Bytes
  transactionHash_gte: bnb_Bytes
  transactionHash_lte: bnb_Bytes
  transactionHash_in: [bnb_Bytes!]
  transactionHash_not_in: [bnb_Bytes!]
  transactionHash_contains: bnb_Bytes
  transactionHash_not_contains: bnb_Bytes
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  gasLimit: BigInt
  gasLimit_not: BigInt
  gasLimit_gt: BigInt
  gasLimit_lt: BigInt
  gasLimit_gte: BigInt
  gasLimit_lte: BigInt
  gasLimit_in: [BigInt!]
  gasLimit_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: bnb_BlockChangedFilter
  and: [bnb_RootMessageSent_filter]
  or: [bnb_RootMessageSent_filter]
}

enum bnb_RootMessageSent_orderBy {
  id
  spokeDomain
  hubDomain
  root
  count
  caller
  transactionHash
  timestamp
  gasPrice
  gasLimit
  blockNumber
}

type bnb_Router {
  id: ID!
  isActive: Boolean!
  owner: bnb_Bytes
  recipient: bnb_Bytes
  proposedOwner: bnb_Bytes
  proposedTimestamp: BigInt
  assetBalances(skip: Int = 0, first: Int = 100, orderBy: bnb_AssetBalance_orderBy, orderDirection: bnb_OrderDirection, where: bnb_AssetBalance_filter): [bnb_AssetBalance!]!
}

type bnb_RouterDailyTVL {
  id: ID!
  router: bnb_Router!
  asset: bnb_Asset!
  timestamp: BigInt!
  balance: BigInt!
}

input bnb_RouterDailyTVL_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  router: String
  router_not: String
  router_gt: String
  router_lt: String
  router_gte: String
  router_lte: String
  router_in: [String!]
  router_not_in: [String!]
  router_contains: String
  router_contains_nocase: String
  router_not_contains: String
  router_not_contains_nocase: String
  router_starts_with: String
  router_starts_with_nocase: String
  router_not_starts_with: String
  router_not_starts_with_nocase: String
  router_ends_with: String
  router_ends_with_nocase: String
  router_not_ends_with: String
  router_not_ends_with_nocase: String
  router_: bnb_Router_filter
  asset: String
  asset_not: String
  asset_gt: String
  asset_lt: String
  asset_gte: String
  asset_lte: String
  asset_in: [String!]
  asset_not_in: [String!]
  asset_contains: String
  asset_contains_nocase: String
  asset_not_contains: String
  asset_not_contains_nocase: String
  asset_starts_with: String
  asset_starts_with_nocase: String
  asset_not_starts_with: String
  asset_not_starts_with_nocase: String
  asset_ends_with: String
  asset_ends_with_nocase: String
  asset_not_ends_with: String
  asset_not_ends_with_nocase: String
  asset_: bnb_Asset_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  balance: BigInt
  balance_not: BigInt
  balance_gt: BigInt
  balance_lt: BigInt
  balance_gte: BigInt
  balance_lte: BigInt
  balance_in: [BigInt!]
  balance_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: bnb_BlockChangedFilter
  and: [bnb_RouterDailyTVL_filter]
  or: [bnb_RouterDailyTVL_filter]
}

enum bnb_RouterDailyTVL_orderBy {
  id
  router
  router__id
  router__isActive
  router__owner
  router__recipient
  router__proposedOwner
  router__proposedTimestamp
  asset
  asset__id
  asset__key
  asset__decimal
  asset__adoptedDecimal
  asset__canonicalId
  asset__canonicalDomain
  asset__adoptedAsset
  asset__localAsset
  asset__blockNumber
  timestamp
  balance
}

type bnb_RouterLiquidityEvent {
  id: ID!
  type: bnb_RouterLiquidityEventType
  router: bnb_Router!
  asset: bnb_Asset!
  amount: BigInt!
  balance: BigInt!
  caller: bnb_Bytes
  blockNumber: BigInt!
  timestamp: BigInt!
  transactionHash: bnb_Bytes!
  nonce: BigInt!
}

enum bnb_RouterLiquidityEventType {
  Add
  Remove
}

input bnb_RouterLiquidityEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  type: bnb_RouterLiquidityEventType
  type_not: bnb_RouterLiquidityEventType
  type_in: [bnb_RouterLiquidityEventType!]
  type_not_in: [bnb_RouterLiquidityEventType!]
  router: String
  router_not: String
  router_gt: String
  router_lt: String
  router_gte: String
  router_lte: String
  router_in: [String!]
  router_not_in: [String!]
  router_contains: String
  router_contains_nocase: String
  router_not_contains: String
  router_not_contains_nocase: String
  router_starts_with: String
  router_starts_with_nocase: String
  router_not_starts_with: String
  router_not_starts_with_nocase: String
  router_ends_with: String
  router_ends_with_nocase: String
  router_not_ends_with: String
  router_not_ends_with_nocase: String
  router_: bnb_Router_filter
  asset: String
  asset_not: String
  asset_gt: String
  asset_lt: String
  asset_gte: String
  asset_lte: String
  asset_in: [String!]
  asset_not_in: [String!]
  asset_contains: String
  asset_contains_nocase: String
  asset_not_contains: String
  asset_not_contains_nocase: String
  asset_starts_with: String
  asset_starts_with_nocase: String
  asset_not_starts_with: String
  asset_not_starts_with_nocase: String
  asset_ends_with: String
  asset_ends_with_nocase: String
  asset_not_ends_with: String
  asset_not_ends_with_nocase: String
  asset_: bnb_Asset_filter
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  balance: BigInt
  balance_not: BigInt
  balance_gt: BigInt
  balance_lt: BigInt
  balance_gte: BigInt
  balance_lte: BigInt
  balance_in: [BigInt!]
  balance_not_in: [BigInt!]
  caller: bnb_Bytes
  caller_not: bnb_Bytes
  caller_gt: bnb_Bytes
  caller_lt: bnb_Bytes
  caller_gte: bnb_Bytes
  caller_lte: bnb_Bytes
  caller_in: [bnb_Bytes!]
  caller_not_in: [bnb_Bytes!]
  caller_contains: bnb_Bytes
  caller_not_contains: bnb_Bytes
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transactionHash: bnb_Bytes
  transactionHash_not: bnb_Bytes
  transactionHash_gt: bnb_Bytes
  transactionHash_lt: bnb_Bytes
  transactionHash_gte: bnb_Bytes
  transactionHash_lte: bnb_Bytes
  transactionHash_in: [bnb_Bytes!]
  transactionHash_not_in: [bnb_Bytes!]
  transactionHash_contains: bnb_Bytes
  transactionHash_not_contains: bnb_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: bnb_BlockChangedFilter
  and: [bnb_RouterLiquidityEvent_filter]
  or: [bnb_RouterLiquidityEvent_filter]
}

enum bnb_RouterLiquidityEvent_orderBy {
  id
  type
  router
  router__id
  router__isActive
  router__owner
  router__recipient
  router__proposedOwner
  router__proposedTimestamp
  asset
  asset__id
  asset__key
  asset__decimal
  asset__adoptedDecimal
  asset__canonicalId
  asset__canonicalDomain
  asset__adoptedAsset
  asset__localAsset
  asset__blockNumber
  amount
  balance
  caller
  blockNumber
  timestamp
  transactionHash
  nonce
}

input bnb_Router_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  isActive: Boolean
  isActive_not: Boolean
  isActive_in: [Boolean!]
  isActive_not_in: [Boolean!]
  owner: bnb_Bytes
  owner_not: bnb_Bytes
  owner_gt: bnb_Bytes
  owner_lt: bnb_Bytes
  owner_gte: bnb_Bytes
  owner_lte: bnb_Bytes
  owner_in: [bnb_Bytes!]
  owner_not_in: [bnb_Bytes!]
  owner_contains: bnb_Bytes
  owner_not_contains: bnb_Bytes
  recipient: bnb_Bytes
  recipient_not: bnb_Bytes
  recipient_gt: bnb_Bytes
  recipient_lt: bnb_Bytes
  recipient_gte: bnb_Bytes
  recipient_lte: bnb_Bytes
  recipient_in: [bnb_Bytes!]
  recipient_not_in: [bnb_Bytes!]
  recipient_contains: bnb_Bytes
  recipient_not_contains: bnb_Bytes
  proposedOwner: bnb_Bytes
  proposedOwner_not: bnb_Bytes
  proposedOwner_gt: bnb_Bytes
  proposedOwner_lt: bnb_Bytes
  proposedOwner_gte: bnb_Bytes
  proposedOwner_lte: bnb_Bytes
  proposedOwner_in: [bnb_Bytes!]
  proposedOwner_not_in: [bnb_Bytes!]
  proposedOwner_contains: bnb_Bytes
  proposedOwner_not_contains: bnb_Bytes
  proposedTimestamp: BigInt
  proposedTimestamp_not: BigInt
  proposedTimestamp_gt: BigInt
  proposedTimestamp_lt: BigInt
  proposedTimestamp_gte: BigInt
  proposedTimestamp_lte: BigInt
  proposedTimestamp_in: [BigInt!]
  proposedTimestamp_not_in: [BigInt!]
  assetBalances_: bnb_AssetBalance_filter
  """Filter for the block changed event."""
  _change_block: bnb_BlockChangedFilter
  and: [bnb_Router_filter]
  or: [bnb_Router_filter]
}

enum bnb_Router_orderBy {
  id
  isActive
  owner
  recipient
  proposedOwner
  proposedTimestamp
  assetBalances
}

type bnb_Sequencer {
  id: ID!
  isActive: Boolean!
  sequencer: bnb_Bytes
}

input bnb_Sequencer_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  isActive: Boolean
  isActive_not: Boolean
  isActive_in: [Boolean!]
  isActive_not_in: [Boolean!]
  sequencer: bnb_Bytes
  sequencer_not: bnb_Bytes
  sequencer_gt: bnb_Bytes
  sequencer_lt: bnb_Bytes
  sequencer_gte: bnb_Bytes
  sequencer_lte: bnb_Bytes
  sequencer_in: [bnb_Bytes!]
  sequencer_not_in: [bnb_Bytes!]
  sequencer_contains: bnb_Bytes
  sequencer_not_contains: bnb_Bytes
  """Filter for the block changed event."""
  _change_block: bnb_BlockChangedFilter
  and: [bnb_Sequencer_filter]
  or: [bnb_Sequencer_filter]
}

enum bnb_Sequencer_orderBy {
  id
  isActive
  sequencer
}

type bnb_Setting {
  id: ID!
  maxRoutersPerTransfer: BigInt!
  caller: bnb_Bytes!
}

input bnb_Setting_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  maxRoutersPerTransfer: BigInt
  maxRoutersPerTransfer_not: BigInt
  maxRoutersPerTransfer_gt: BigInt
  maxRoutersPerTransfer_lt: BigInt
  maxRoutersPerTransfer_gte: BigInt
  maxRoutersPerTransfer_lte: BigInt
  maxRoutersPerTransfer_in: [BigInt!]
  maxRoutersPerTransfer_not_in: [BigInt!]
  caller: bnb_Bytes
  caller_not: bnb_Bytes
  caller_gt: bnb_Bytes
  caller_lt: bnb_Bytes
  caller_gte: bnb_Bytes
  caller_lte: bnb_Bytes
  caller_in: [bnb_Bytes!]
  caller_not_in: [bnb_Bytes!]
  caller_contains: bnb_Bytes
  caller_not_contains: bnb_Bytes
  """Filter for the block changed event."""
  _change_block: bnb_BlockChangedFilter
  and: [bnb_Setting_filter]
  or: [bnb_Setting_filter]
}

enum bnb_Setting_orderBy {
  id
  maxRoutersPerTransfer
  caller
}

type bnb_SlippageUpdate {
  id: ID!
  transfer: bnb_DestinationTransfer!
  slippage: BigInt!
  caller: bnb_Bytes!
  transactionHash: bnb_Bytes!
  timestamp: BigInt!
  gasPrice: BigInt!
  gasLimit: BigInt!
  blockNumber: BigInt!
}

input bnb_SlippageUpdate_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transfer: String
  transfer_not: String
  transfer_gt: String
  transfer_lt: String
  transfer_gte: String
  transfer_lte: String
  transfer_in: [String!]
  transfer_not_in: [String!]
  transfer_contains: String
  transfer_contains_nocase: String
  transfer_not_contains: String
  transfer_not_contains_nocase: String
  transfer_starts_with: String
  transfer_starts_with_nocase: String
  transfer_not_starts_with: String
  transfer_not_starts_with_nocase: String
  transfer_ends_with: String
  transfer_ends_with_nocase: String
  transfer_not_ends_with: String
  transfer_not_ends_with_nocase: String
  transfer_: bnb_DestinationTransfer_filter
  slippage: BigInt
  slippage_not: BigInt
  slippage_gt: BigInt
  slippage_lt: BigInt
  slippage_gte: BigInt
  slippage_lte: BigInt
  slippage_in: [BigInt!]
  slippage_not_in: [BigInt!]
  caller: bnb_Bytes
  caller_not: bnb_Bytes
  caller_gt: bnb_Bytes
  caller_lt: bnb_Bytes
  caller_gte: bnb_Bytes
  caller_lte: bnb_Bytes
  caller_in: [bnb_Bytes!]
  caller_not_in: [bnb_Bytes!]
  caller_contains: bnb_Bytes
  caller_not_contains: bnb_Bytes
  transactionHash: bnb_Bytes
  transactionHash_not: bnb_Bytes
  transactionHash_gt: bnb_Bytes
  transactionHash_lt: bnb_Bytes
  transactionHash_gte: bnb_Bytes
  transactionHash_lte: bnb_Bytes
  transactionHash_in: [bnb_Bytes!]
  transactionHash_not_in: [bnb_Bytes!]
  transactionHash_contains: bnb_Bytes
  transactionHash_not_contains: bnb_Bytes
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  gasLimit: BigInt
  gasLimit_not: BigInt
  gasLimit_gt: BigInt
  gasLimit_lt: BigInt
  gasLimit_gte: BigInt
  gasLimit_lte: BigInt
  gasLimit_in: [BigInt!]
  gasLimit_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: bnb_BlockChangedFilter
  and: [bnb_SlippageUpdate_filter]
  or: [bnb_SlippageUpdate_filter]
}

enum bnb_SlippageUpdate_orderBy {
  id
  transfer
  transfer__id
  transfer__chainId
  transfer__transferId
  transfer__nonce
  transfer__status
  transfer__originDomain
  transfer__destinationDomain
  transfer__canonicalDomain
  transfer__to
  transfer__delegate
  transfer__receiveLocal
  transfer__callData
  transfer__slippage
  transfer__bumpSlippageCount
  transfer__originSender
  transfer__bridgedAmt
  transfer__normalizedIn
  transfer__canonicalId
  transfer__amount
  transfer__routersFee
  transfer__executedCaller
  transfer__executedTransactionHash
  transfer__executedTimestamp
  transfer__executedGasPrice
  transfer__executedGasLimit
  transfer__executedBlockNumber
  transfer__executedTxOrigin
  transfer__executedTxNonce
  transfer__reconciledCaller
  transfer__reconciledTransactionHash
  transfer__reconciledTimestamp
  transfer__reconciledGasPrice
  transfer__reconciledGasLimit
  transfer__reconciledBlockNumber
  transfer__reconciledTxOrigin
  transfer__reconciledTxNonce
  slippage
  caller
  transactionHash
  timestamp
  gasPrice
  gasLimit
  blockNumber
}

type bnb_SnapshotRoot {
  id: ID!
  spokeDomain: BigInt
  root: bnb_Bytes!
  count: BigInt!
  timestamp: BigInt!
  blockNumber: BigInt!
}

input bnb_SnapshotRoot_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  spokeDomain: BigInt
  spokeDomain_not: BigInt
  spokeDomain_gt: BigInt
  spokeDomain_lt: BigInt
  spokeDomain_gte: BigInt
  spokeDomain_lte: BigInt
  spokeDomain_in: [BigInt!]
  spokeDomain_not_in: [BigInt!]
  root: bnb_Bytes
  root_not: bnb_Bytes
  root_gt: bnb_Bytes
  root_lt: bnb_Bytes
  root_gte: bnb_Bytes
  root_lte: bnb_Bytes
  root_in: [bnb_Bytes!]
  root_not_in: [bnb_Bytes!]
  root_contains: bnb_Bytes
  root_not_contains: bnb_Bytes
  count: BigInt
  count_not: BigInt
  count_gt: BigInt
  count_lt: BigInt
  count_gte: BigInt
  count_lte: BigInt
  count_in: [BigInt!]
  count_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: bnb_BlockChangedFilter
  and: [bnb_SnapshotRoot_filter]
  or: [bnb_SnapshotRoot_filter]
}

enum bnb_SnapshotRoot_orderBy {
  id
  spokeDomain
  root
  count
  timestamp
  blockNumber
}

type bnb_SpokeConnectorMode {
  id: ID!
  mode: String!
}

input bnb_SpokeConnectorMode_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  mode: String
  mode_not: String
  mode_gt: String
  mode_lt: String
  mode_gte: String
  mode_lte: String
  mode_in: [String!]
  mode_not_in: [String!]
  mode_contains: String
  mode_contains_nocase: String
  mode_not_contains: String
  mode_not_contains_nocase: String
  mode_starts_with: String
  mode_starts_with_nocase: String
  mode_not_starts_with: String
  mode_not_starts_with_nocase: String
  mode_ends_with: String
  mode_ends_with_nocase: String
  mode_not_ends_with: String
  mode_not_ends_with_nocase: String
  """Filter for the block changed event."""
  _change_block: bnb_BlockChangedFilter
  and: [bnb_SpokeConnectorMode_filter]
  or: [bnb_SpokeConnectorMode_filter]
}

enum bnb_SpokeConnectorMode_orderBy {
  id
  mode
}

enum bnb_TransferStatus {
  XCalled
  Executed
  Reconciled
  CompletedSlow
  CompletedFast
}

type bnb__Block_ {
  """The hash of the block"""
  hash: bnb_Bytes
  """The block number"""
  number: Int!
  """Integer representation of the timestamp stored in blocks for the chain"""
  timestamp: Int
  """The hash of the parent block"""
  parentHash: bnb_Bytes
}

"""The type for the top-level _meta field"""
type bnb__Meta_ {
  """
  Information about a specific subgraph block. The hash of the block
  will be null if the _meta field has a block constraint that asks for
  a block number. It will be filled if the _meta field has no block constraint
  and therefore asks for the latest  block
  
  """
  block: bnb__Block_!
  """The deployment ID"""
  deployment: String!
  """If `true`, the subgraph encountered indexing errors at some past block"""
  hasIndexingErrors: Boolean!
}

enum metis_swap_Aggregation_interval {
  hour
  day
}

scalar metis_swap_BigDecimal

input metis_swap_BlockChangedFilter {
  number_gte: Int!
}

input metis_swap_Block_height {
  hash: metis_swap_Bytes
  number: Int
  number_gte: Int
}

scalar metis_swap_Bytes

"""
8 bytes signed integer

"""
scalar metis_swap_Int8

type metis_swap_LpAccount {
  id: ID!
  address: metis_swap_Bytes!
  balances(skip: Int = 0, first: Int = 100, orderBy: metis_swap_LpAccountBalance_orderBy, orderDirection: metis_swap_OrderDirection, where: metis_swap_LpAccountBalance_filter): [metis_swap_LpAccountBalance!]!
}

type metis_swap_LpAccountBalance {
  id: ID!
  account: metis_swap_LpAccount!
  token: metis_swap_LpToken!
  amount: metis_swap_BigDecimal!
  block: BigInt
  modified: BigInt
  transaction: metis_swap_Bytes
}

input metis_swap_LpAccountBalance_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  account: String
  account_not: String
  account_gt: String
  account_lt: String
  account_gte: String
  account_lte: String
  account_in: [String!]
  account_not_in: [String!]
  account_contains: String
  account_contains_nocase: String
  account_not_contains: String
  account_not_contains_nocase: String
  account_starts_with: String
  account_starts_with_nocase: String
  account_not_starts_with: String
  account_not_starts_with_nocase: String
  account_ends_with: String
  account_ends_with_nocase: String
  account_not_ends_with: String
  account_not_ends_with_nocase: String
  account_: metis_swap_LpAccount_filter
  token: String
  token_not: String
  token_gt: String
  token_lt: String
  token_gte: String
  token_lte: String
  token_in: [String!]
  token_not_in: [String!]
  token_contains: String
  token_contains_nocase: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_: metis_swap_LpToken_filter
  amount: metis_swap_BigDecimal
  amount_not: metis_swap_BigDecimal
  amount_gt: metis_swap_BigDecimal
  amount_lt: metis_swap_BigDecimal
  amount_gte: metis_swap_BigDecimal
  amount_lte: metis_swap_BigDecimal
  amount_in: [metis_swap_BigDecimal!]
  amount_not_in: [metis_swap_BigDecimal!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  modified: BigInt
  modified_not: BigInt
  modified_gt: BigInt
  modified_lt: BigInt
  modified_gte: BigInt
  modified_lte: BigInt
  modified_in: [BigInt!]
  modified_not_in: [BigInt!]
  transaction: metis_swap_Bytes
  transaction_not: metis_swap_Bytes
  transaction_gt: metis_swap_Bytes
  transaction_lt: metis_swap_Bytes
  transaction_gte: metis_swap_Bytes
  transaction_lte: metis_swap_Bytes
  transaction_in: [metis_swap_Bytes!]
  transaction_not_in: [metis_swap_Bytes!]
  transaction_contains: metis_swap_Bytes
  transaction_not_contains: metis_swap_Bytes
  """Filter for the block changed event."""
  _change_block: metis_swap_BlockChangedFilter
  and: [metis_swap_LpAccountBalance_filter]
  or: [metis_swap_LpAccountBalance_filter]
}

enum metis_swap_LpAccountBalance_orderBy {
  id
  account
  account__id
  account__address
  token
  token__id
  token__address
  token__decimals
  token__name
  token__symbol
  token__totalSupply
  amount
  block
  modified
  transaction
}

input metis_swap_LpAccount_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  address: metis_swap_Bytes
  address_not: metis_swap_Bytes
  address_gt: metis_swap_Bytes
  address_lt: metis_swap_Bytes
  address_gte: metis_swap_Bytes
  address_lte: metis_swap_Bytes
  address_in: [metis_swap_Bytes!]
  address_not_in: [metis_swap_Bytes!]
  address_contains: metis_swap_Bytes
  address_not_contains: metis_swap_Bytes
  balances_: metis_swap_LpAccountBalance_filter
  """Filter for the block changed event."""
  _change_block: metis_swap_BlockChangedFilter
  and: [metis_swap_LpAccount_filter]
  or: [metis_swap_LpAccount_filter]
}

enum metis_swap_LpAccount_orderBy {
  id
  address
  balances
}

type metis_swap_LpToken {
  id: ID!
  address: metis_swap_Bytes!
  stableSwap: metis_swap_StableSwap!
  decimals: Int!
  name: String!
  symbol: String!
  totalSupply: metis_swap_BigDecimal!
  events(skip: Int = 0, first: Int = 100, orderBy: metis_swap_LpTokenEvent_orderBy, orderDirection: metis_swap_OrderDirection, where: metis_swap_LpTokenEvent_filter): [metis_swap_LpTokenEvent!]!
}

interface metis_swap_LpTokenEvent {
  id: ID!
  token: metis_swap_LpToken!
  amount: metis_swap_BigDecimal!
  block: BigInt!
  timestamp: BigInt!
  transaction: metis_swap_Bytes!
  nonce: BigInt!
}

input metis_swap_LpTokenEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  token: String
  token_not: String
  token_gt: String
  token_lt: String
  token_gte: String
  token_lte: String
  token_in: [String!]
  token_not_in: [String!]
  token_contains: String
  token_contains_nocase: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_: metis_swap_LpToken_filter
  amount: metis_swap_BigDecimal
  amount_not: metis_swap_BigDecimal
  amount_gt: metis_swap_BigDecimal
  amount_lt: metis_swap_BigDecimal
  amount_gte: metis_swap_BigDecimal
  amount_lte: metis_swap_BigDecimal
  amount_in: [metis_swap_BigDecimal!]
  amount_not_in: [metis_swap_BigDecimal!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: metis_swap_Bytes
  transaction_not: metis_swap_Bytes
  transaction_gt: metis_swap_Bytes
  transaction_lt: metis_swap_Bytes
  transaction_gte: metis_swap_Bytes
  transaction_lte: metis_swap_Bytes
  transaction_in: [metis_swap_Bytes!]
  transaction_not_in: [metis_swap_Bytes!]
  transaction_contains: metis_swap_Bytes
  transaction_not_contains: metis_swap_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: metis_swap_BlockChangedFilter
  and: [metis_swap_LpTokenEvent_filter]
  or: [metis_swap_LpTokenEvent_filter]
}

enum metis_swap_LpTokenEvent_orderBy {
  id
  token
  token__id
  token__address
  token__decimals
  token__name
  token__symbol
  token__totalSupply
  amount
  block
  timestamp
  transaction
  nonce
}

input metis_swap_LpToken_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  address: metis_swap_Bytes
  address_not: metis_swap_Bytes
  address_gt: metis_swap_Bytes
  address_lt: metis_swap_Bytes
  address_gte: metis_swap_Bytes
  address_lte: metis_swap_Bytes
  address_in: [metis_swap_Bytes!]
  address_not_in: [metis_swap_Bytes!]
  address_contains: metis_swap_Bytes
  address_not_contains: metis_swap_Bytes
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: metis_swap_StableSwap_filter
  decimals: Int
  decimals_not: Int
  decimals_gt: Int
  decimals_lt: Int
  decimals_gte: Int
  decimals_lte: Int
  decimals_in: [Int!]
  decimals_not_in: [Int!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  symbol: String
  symbol_not: String
  symbol_gt: String
  symbol_lt: String
  symbol_gte: String
  symbol_lte: String
  symbol_in: [String!]
  symbol_not_in: [String!]
  symbol_contains: String
  symbol_contains_nocase: String
  symbol_not_contains: String
  symbol_not_contains_nocase: String
  symbol_starts_with: String
  symbol_starts_with_nocase: String
  symbol_not_starts_with: String
  symbol_not_starts_with_nocase: String
  symbol_ends_with: String
  symbol_ends_with_nocase: String
  symbol_not_ends_with: String
  symbol_not_ends_with_nocase: String
  totalSupply: metis_swap_BigDecimal
  totalSupply_not: metis_swap_BigDecimal
  totalSupply_gt: metis_swap_BigDecimal
  totalSupply_lt: metis_swap_BigDecimal
  totalSupply_gte: metis_swap_BigDecimal
  totalSupply_lte: metis_swap_BigDecimal
  totalSupply_in: [metis_swap_BigDecimal!]
  totalSupply_not_in: [metis_swap_BigDecimal!]
  events_: metis_swap_LpTokenEvent_filter
  """Filter for the block changed event."""
  _change_block: metis_swap_BlockChangedFilter
  and: [metis_swap_LpToken_filter]
  or: [metis_swap_LpToken_filter]
}

enum metis_swap_LpToken_orderBy {
  id
  address
  stableSwap
  stableSwap__id
  stableSwap__isActive
  stableSwap__key
  stableSwap__canonicalId
  stableSwap__domain
  stableSwap__swapPool
  stableSwap__lpToken
  stableSwap__initialA
  stableSwap__futureA
  stableSwap__initialATime
  stableSwap__futureATime
  stableSwap__swapFee
  stableSwap__adminFee
  stableSwap__virtualPrice
  stableSwap__invariant
  stableSwap__lpTokenSupply
  decimals
  name
  symbol
  totalSupply
  events
}

type metis_swap_LpTransferEvent implements metis_swap_LpTokenEvent {
  id: ID!
  token: metis_swap_LpToken!
  amount: metis_swap_BigDecimal!
  from: metis_swap_Bytes!
  to: metis_swap_Bytes!
  fromBalance: metis_swap_BigDecimal!
  toBalance: metis_swap_BigDecimal!
  block: BigInt!
  timestamp: BigInt!
  transaction: metis_swap_Bytes!
  nonce: BigInt!
}

input metis_swap_LpTransferEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  token: String
  token_not: String
  token_gt: String
  token_lt: String
  token_gte: String
  token_lte: String
  token_in: [String!]
  token_not_in: [String!]
  token_contains: String
  token_contains_nocase: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_: metis_swap_LpToken_filter
  amount: metis_swap_BigDecimal
  amount_not: metis_swap_BigDecimal
  amount_gt: metis_swap_BigDecimal
  amount_lt: metis_swap_BigDecimal
  amount_gte: metis_swap_BigDecimal
  amount_lte: metis_swap_BigDecimal
  amount_in: [metis_swap_BigDecimal!]
  amount_not_in: [metis_swap_BigDecimal!]
  from: metis_swap_Bytes
  from_not: metis_swap_Bytes
  from_gt: metis_swap_Bytes
  from_lt: metis_swap_Bytes
  from_gte: metis_swap_Bytes
  from_lte: metis_swap_Bytes
  from_in: [metis_swap_Bytes!]
  from_not_in: [metis_swap_Bytes!]
  from_contains: metis_swap_Bytes
  from_not_contains: metis_swap_Bytes
  to: metis_swap_Bytes
  to_not: metis_swap_Bytes
  to_gt: metis_swap_Bytes
  to_lt: metis_swap_Bytes
  to_gte: metis_swap_Bytes
  to_lte: metis_swap_Bytes
  to_in: [metis_swap_Bytes!]
  to_not_in: [metis_swap_Bytes!]
  to_contains: metis_swap_Bytes
  to_not_contains: metis_swap_Bytes
  fromBalance: metis_swap_BigDecimal
  fromBalance_not: metis_swap_BigDecimal
  fromBalance_gt: metis_swap_BigDecimal
  fromBalance_lt: metis_swap_BigDecimal
  fromBalance_gte: metis_swap_BigDecimal
  fromBalance_lte: metis_swap_BigDecimal
  fromBalance_in: [metis_swap_BigDecimal!]
  fromBalance_not_in: [metis_swap_BigDecimal!]
  toBalance: metis_swap_BigDecimal
  toBalance_not: metis_swap_BigDecimal
  toBalance_gt: metis_swap_BigDecimal
  toBalance_lt: metis_swap_BigDecimal
  toBalance_gte: metis_swap_BigDecimal
  toBalance_lte: metis_swap_BigDecimal
  toBalance_in: [metis_swap_BigDecimal!]
  toBalance_not_in: [metis_swap_BigDecimal!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: metis_swap_Bytes
  transaction_not: metis_swap_Bytes
  transaction_gt: metis_swap_Bytes
  transaction_lt: metis_swap_Bytes
  transaction_gte: metis_swap_Bytes
  transaction_lte: metis_swap_Bytes
  transaction_in: [metis_swap_Bytes!]
  transaction_not_in: [metis_swap_Bytes!]
  transaction_contains: metis_swap_Bytes
  transaction_not_contains: metis_swap_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: metis_swap_BlockChangedFilter
  and: [metis_swap_LpTransferEvent_filter]
  or: [metis_swap_LpTransferEvent_filter]
}

enum metis_swap_LpTransferEvent_orderBy {
  id
  token
  token__id
  token__address
  token__decimals
  token__name
  token__symbol
  token__totalSupply
  amount
  from
  to
  fromBalance
  toBalance
  block
  timestamp
  transaction
  nonce
}

"""Defines the order direction, either ascending or descending"""
enum metis_swap_OrderDirection {
  asc
  desc
}

type metis_swap_PooledToken {
  id: ID!
  asset: metis_swap_Bytes!
}

input metis_swap_PooledToken_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  asset: metis_swap_Bytes
  asset_not: metis_swap_Bytes
  asset_gt: metis_swap_Bytes
  asset_lt: metis_swap_Bytes
  asset_gte: metis_swap_Bytes
  asset_lte: metis_swap_Bytes
  asset_in: [metis_swap_Bytes!]
  asset_not_in: [metis_swap_Bytes!]
  asset_contains: metis_swap_Bytes
  asset_not_contains: metis_swap_Bytes
  """Filter for the block changed event."""
  _change_block: metis_swap_BlockChangedFilter
  and: [metis_swap_PooledToken_filter]
  or: [metis_swap_PooledToken_filter]
}

enum metis_swap_PooledToken_orderBy {
  id
  asset
}

type metis_swap_StableSwap {
  id: ID!
  isActive: Boolean
  key: metis_swap_Bytes!
  canonicalId: metis_swap_Bytes
  domain: BigInt
  swapPool: metis_swap_Bytes
  lpToken: metis_swap_Bytes
  initialA: BigInt
  futureA: BigInt
  initialATime: BigInt
  futureATime: BigInt
  swapFee: BigInt
  adminFee: BigInt
  pooledTokens: [metis_swap_Bytes!]!
  tokenPrecisionMultipliers: [BigInt!]!
  balances: [BigInt!]!
  adminFees: [BigInt!]!
  virtualPrice: BigInt!
  invariant: BigInt!
  lpTokenSupply: BigInt!
  events(skip: Int = 0, first: Int = 100, orderBy: metis_swap_StableSwapEvent_orderBy, orderDirection: metis_swap_OrderDirection, where: metis_swap_StableSwapEvent_filter): [metis_swap_StableSwapEvent!]
  exchanges(skip: Int = 0, first: Int = 100, orderBy: metis_swap_StableSwapExchange_orderBy, orderDirection: metis_swap_OrderDirection, where: metis_swap_StableSwapExchange_filter): [metis_swap_StableSwapExchange!]
  hourlyVolumes(skip: Int = 0, first: Int = 100, orderBy: metis_swap_SwapHourlyVolume_orderBy, orderDirection: metis_swap_OrderDirection, where: metis_swap_SwapHourlyVolume_filter): [metis_swap_SwapHourlyVolume!]
  dailyVolumes(skip: Int = 0, first: Int = 100, orderBy: metis_swap_SwapDailyVolume_orderBy, orderDirection: metis_swap_OrderDirection, where: metis_swap_SwapDailyVolume_filter): [metis_swap_SwapDailyVolume!]
  weeklyVolumes(skip: Int = 0, first: Int = 100, orderBy: metis_swap_SwapWeeklyVolume_orderBy, orderDirection: metis_swap_OrderDirection, where: metis_swap_SwapWeeklyVolume_filter): [metis_swap_SwapWeeklyVolume!]
}

type metis_swap_StableSwapAddLiquidityEvent implements metis_swap_StableSwapEvent {
  id: ID!
  stableSwap: metis_swap_StableSwap!
  provider: metis_swap_Bytes!
  tokenAmounts: [BigInt!]!
  fees: [BigInt!]!
  invariant: BigInt
  lpTokenSupply: BigInt!
  lpTokenAmount: BigInt!
  balances: [BigInt!]!
  block: BigInt!
  timestamp: BigInt!
  transaction: metis_swap_Bytes!
  nonce: BigInt!
}

input metis_swap_StableSwapAddLiquidityEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: metis_swap_StableSwap_filter
  provider: metis_swap_Bytes
  provider_not: metis_swap_Bytes
  provider_gt: metis_swap_Bytes
  provider_lt: metis_swap_Bytes
  provider_gte: metis_swap_Bytes
  provider_lte: metis_swap_Bytes
  provider_in: [metis_swap_Bytes!]
  provider_not_in: [metis_swap_Bytes!]
  provider_contains: metis_swap_Bytes
  provider_not_contains: metis_swap_Bytes
  tokenAmounts: [BigInt!]
  tokenAmounts_not: [BigInt!]
  tokenAmounts_contains: [BigInt!]
  tokenAmounts_contains_nocase: [BigInt!]
  tokenAmounts_not_contains: [BigInt!]
  tokenAmounts_not_contains_nocase: [BigInt!]
  fees: [BigInt!]
  fees_not: [BigInt!]
  fees_contains: [BigInt!]
  fees_contains_nocase: [BigInt!]
  fees_not_contains: [BigInt!]
  fees_not_contains_nocase: [BigInt!]
  invariant: BigInt
  invariant_not: BigInt
  invariant_gt: BigInt
  invariant_lt: BigInt
  invariant_gte: BigInt
  invariant_lte: BigInt
  invariant_in: [BigInt!]
  invariant_not_in: [BigInt!]
  lpTokenSupply: BigInt
  lpTokenSupply_not: BigInt
  lpTokenSupply_gt: BigInt
  lpTokenSupply_lt: BigInt
  lpTokenSupply_gte: BigInt
  lpTokenSupply_lte: BigInt
  lpTokenSupply_in: [BigInt!]
  lpTokenSupply_not_in: [BigInt!]
  lpTokenAmount: BigInt
  lpTokenAmount_not: BigInt
  lpTokenAmount_gt: BigInt
  lpTokenAmount_lt: BigInt
  lpTokenAmount_gte: BigInt
  lpTokenAmount_lte: BigInt
  lpTokenAmount_in: [BigInt!]
  lpTokenAmount_not_in: [BigInt!]
  balances: [BigInt!]
  balances_not: [BigInt!]
  balances_contains: [BigInt!]
  balances_contains_nocase: [BigInt!]
  balances_not_contains: [BigInt!]
  balances_not_contains_nocase: [BigInt!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: metis_swap_Bytes
  transaction_not: metis_swap_Bytes
  transaction_gt: metis_swap_Bytes
  transaction_lt: metis_swap_Bytes
  transaction_gte: metis_swap_Bytes
  transaction_lte: metis_swap_Bytes
  transaction_in: [metis_swap_Bytes!]
  transaction_not_in: [metis_swap_Bytes!]
  transaction_contains: metis_swap_Bytes
  transaction_not_contains: metis_swap_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: metis_swap_BlockChangedFilter
  and: [metis_swap_StableSwapAddLiquidityEvent_filter]
  or: [metis_swap_StableSwapAddLiquidityEvent_filter]
}

enum metis_swap_StableSwapAddLiquidityEvent_orderBy {
  id
  stableSwap
  stableSwap__id
  stableSwap__isActive
  stableSwap__key
  stableSwap__canonicalId
  stableSwap__domain
  stableSwap__swapPool
  stableSwap__lpToken
  stableSwap__initialA
  stableSwap__futureA
  stableSwap__initialATime
  stableSwap__futureATime
  stableSwap__swapFee
  stableSwap__adminFee
  stableSwap__virtualPrice
  stableSwap__invariant
  stableSwap__lpTokenSupply
  provider
  tokenAmounts
  fees
  invariant
  lpTokenSupply
  lpTokenAmount
  balances
  block
  timestamp
  transaction
  nonce
}

interface metis_swap_StableSwapEvent {
  id: ID!
  stableSwap: metis_swap_StableSwap!
  block: BigInt!
  timestamp: BigInt!
  transaction: metis_swap_Bytes!
  nonce: BigInt!
}

input metis_swap_StableSwapEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: metis_swap_StableSwap_filter
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: metis_swap_Bytes
  transaction_not: metis_swap_Bytes
  transaction_gt: metis_swap_Bytes
  transaction_lt: metis_swap_Bytes
  transaction_gte: metis_swap_Bytes
  transaction_lte: metis_swap_Bytes
  transaction_in: [metis_swap_Bytes!]
  transaction_not_in: [metis_swap_Bytes!]
  transaction_contains: metis_swap_Bytes
  transaction_not_contains: metis_swap_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: metis_swap_BlockChangedFilter
  and: [metis_swap_StableSwapEvent_filter]
  or: [metis_swap_StableSwapEvent_filter]
}

enum metis_swap_StableSwapEvent_orderBy {
  id
  stableSwap
  stableSwap__id
  stableSwap__isActive
  stableSwap__key
  stableSwap__canonicalId
  stableSwap__domain
  stableSwap__swapPool
  stableSwap__lpToken
  stableSwap__initialA
  stableSwap__futureA
  stableSwap__initialATime
  stableSwap__futureATime
  stableSwap__swapFee
  stableSwap__adminFee
  stableSwap__virtualPrice
  stableSwap__invariant
  stableSwap__lpTokenSupply
  block
  timestamp
  transaction
  nonce
}

type metis_swap_StableSwapExchange {
  id: ID!
  stableSwap: metis_swap_StableSwap!
  buyer: metis_swap_Bytes!
  boughtId: BigInt!
  tokensBought: BigInt!
  soldId: BigInt!
  tokensSold: BigInt!
  balances: [BigInt!]!
  fee: BigInt!
  block: BigInt!
  timestamp: BigInt!
  transaction: metis_swap_Bytes!
  nonce: BigInt!
}

input metis_swap_StableSwapExchange_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: metis_swap_StableSwap_filter
  buyer: metis_swap_Bytes
  buyer_not: metis_swap_Bytes
  buyer_gt: metis_swap_Bytes
  buyer_lt: metis_swap_Bytes
  buyer_gte: metis_swap_Bytes
  buyer_lte: metis_swap_Bytes
  buyer_in: [metis_swap_Bytes!]
  buyer_not_in: [metis_swap_Bytes!]
  buyer_contains: metis_swap_Bytes
  buyer_not_contains: metis_swap_Bytes
  boughtId: BigInt
  boughtId_not: BigInt
  boughtId_gt: BigInt
  boughtId_lt: BigInt
  boughtId_gte: BigInt
  boughtId_lte: BigInt
  boughtId_in: [BigInt!]
  boughtId_not_in: [BigInt!]
  tokensBought: BigInt
  tokensBought_not: BigInt
  tokensBought_gt: BigInt
  tokensBought_lt: BigInt
  tokensBought_gte: BigInt
  tokensBought_lte: BigInt
  tokensBought_in: [BigInt!]
  tokensBought_not_in: [BigInt!]
  soldId: BigInt
  soldId_not: BigInt
  soldId_gt: BigInt
  soldId_lt: BigInt
  soldId_gte: BigInt
  soldId_lte: BigInt
  soldId_in: [BigInt!]
  soldId_not_in: [BigInt!]
  tokensSold: BigInt
  tokensSold_not: BigInt
  tokensSold_gt: BigInt
  tokensSold_lt: BigInt
  tokensSold_gte: BigInt
  tokensSold_lte: BigInt
  tokensSold_in: [BigInt!]
  tokensSold_not_in: [BigInt!]
  balances: [BigInt!]
  balances_not: [BigInt!]
  balances_contains: [BigInt!]
  balances_contains_nocase: [BigInt!]
  balances_not_contains: [BigInt!]
  balances_not_contains_nocase: [BigInt!]
  fee: BigInt
  fee_not: BigInt
  fee_gt: BigInt
  fee_lt: BigInt
  fee_gte: BigInt
  fee_lte: BigInt
  fee_in: [BigInt!]
  fee_not_in: [BigInt!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: metis_swap_Bytes
  transaction_not: metis_swap_Bytes
  transaction_gt: metis_swap_Bytes
  transaction_lt: metis_swap_Bytes
  transaction_gte: metis_swap_Bytes
  transaction_lte: metis_swap_Bytes
  transaction_in: [metis_swap_Bytes!]
  transaction_not_in: [metis_swap_Bytes!]
  transaction_contains: metis_swap_Bytes
  transaction_not_contains: metis_swap_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: metis_swap_BlockChangedFilter
  and: [metis_swap_StableSwapExchange_filter]
  or: [metis_swap_StableSwapExchange_filter]
}

enum metis_swap_StableSwapExchange_orderBy {
  id
  stableSwap
  stableSwap__id
  stableSwap__isActive
  stableSwap__key
  stableSwap__canonicalId
  stableSwap__domain
  stableSwap__swapPool
  stableSwap__lpToken
  stableSwap__initialA
  stableSwap__futureA
  stableSwap__initialATime
  stableSwap__futureATime
  stableSwap__swapFee
  stableSwap__adminFee
  stableSwap__virtualPrice
  stableSwap__invariant
  stableSwap__lpTokenSupply
  buyer
  boughtId
  tokensBought
  soldId
  tokensSold
  balances
  fee
  block
  timestamp
  transaction
  nonce
}

type metis_swap_StableSwapRemoveLiquidityEvent implements metis_swap_StableSwapEvent {
  id: ID!
  stableSwap: metis_swap_StableSwap!
  provider: metis_swap_Bytes!
  tokenAmounts: [BigInt!]!
  fees: [BigInt!]
  invariant: BigInt
  lpTokenSupply: BigInt!
  lpTokenAmount: BigInt!
  balances: [BigInt!]!
  block: BigInt!
  timestamp: BigInt!
  transaction: metis_swap_Bytes!
  nonce: BigInt!
}

input metis_swap_StableSwapRemoveLiquidityEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: metis_swap_StableSwap_filter
  provider: metis_swap_Bytes
  provider_not: metis_swap_Bytes
  provider_gt: metis_swap_Bytes
  provider_lt: metis_swap_Bytes
  provider_gte: metis_swap_Bytes
  provider_lte: metis_swap_Bytes
  provider_in: [metis_swap_Bytes!]
  provider_not_in: [metis_swap_Bytes!]
  provider_contains: metis_swap_Bytes
  provider_not_contains: metis_swap_Bytes
  tokenAmounts: [BigInt!]
  tokenAmounts_not: [BigInt!]
  tokenAmounts_contains: [BigInt!]
  tokenAmounts_contains_nocase: [BigInt!]
  tokenAmounts_not_contains: [BigInt!]
  tokenAmounts_not_contains_nocase: [BigInt!]
  fees: [BigInt!]
  fees_not: [BigInt!]
  fees_contains: [BigInt!]
  fees_contains_nocase: [BigInt!]
  fees_not_contains: [BigInt!]
  fees_not_contains_nocase: [BigInt!]
  invariant: BigInt
  invariant_not: BigInt
  invariant_gt: BigInt
  invariant_lt: BigInt
  invariant_gte: BigInt
  invariant_lte: BigInt
  invariant_in: [BigInt!]
  invariant_not_in: [BigInt!]
  lpTokenSupply: BigInt
  lpTokenSupply_not: BigInt
  lpTokenSupply_gt: BigInt
  lpTokenSupply_lt: BigInt
  lpTokenSupply_gte: BigInt
  lpTokenSupply_lte: BigInt
  lpTokenSupply_in: [BigInt!]
  lpTokenSupply_not_in: [BigInt!]
  lpTokenAmount: BigInt
  lpTokenAmount_not: BigInt
  lpTokenAmount_gt: BigInt
  lpTokenAmount_lt: BigInt
  lpTokenAmount_gte: BigInt
  lpTokenAmount_lte: BigInt
  lpTokenAmount_in: [BigInt!]
  lpTokenAmount_not_in: [BigInt!]
  balances: [BigInt!]
  balances_not: [BigInt!]
  balances_contains: [BigInt!]
  balances_contains_nocase: [BigInt!]
  balances_not_contains: [BigInt!]
  balances_not_contains_nocase: [BigInt!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: metis_swap_Bytes
  transaction_not: metis_swap_Bytes
  transaction_gt: metis_swap_Bytes
  transaction_lt: metis_swap_Bytes
  transaction_gte: metis_swap_Bytes
  transaction_lte: metis_swap_Bytes
  transaction_in: [metis_swap_Bytes!]
  transaction_not_in: [metis_swap_Bytes!]
  transaction_contains: metis_swap_Bytes
  transaction_not_contains: metis_swap_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: metis_swap_BlockChangedFilter
  and: [metis_swap_StableSwapRemoveLiquidityEvent_filter]
  or: [metis_swap_StableSwapRemoveLiquidityEvent_filter]
}

enum metis_swap_StableSwapRemoveLiquidityEvent_orderBy {
  id
  stableSwap
  stableSwap__id
  stableSwap__isActive
  stableSwap__key
  stableSwap__canonicalId
  stableSwap__domain
  stableSwap__swapPool
  stableSwap__lpToken
  stableSwap__initialA
  stableSwap__futureA
  stableSwap__initialATime
  stableSwap__futureATime
  stableSwap__swapFee
  stableSwap__adminFee
  stableSwap__virtualPrice
  stableSwap__invariant
  stableSwap__lpTokenSupply
  provider
  tokenAmounts
  fees
  invariant
  lpTokenSupply
  lpTokenAmount
  balances
  block
  timestamp
  transaction
  nonce
}

input metis_swap_StableSwap_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  isActive: Boolean
  isActive_not: Boolean
  isActive_in: [Boolean!]
  isActive_not_in: [Boolean!]
  key: metis_swap_Bytes
  key_not: metis_swap_Bytes
  key_gt: metis_swap_Bytes
  key_lt: metis_swap_Bytes
  key_gte: metis_swap_Bytes
  key_lte: metis_swap_Bytes
  key_in: [metis_swap_Bytes!]
  key_not_in: [metis_swap_Bytes!]
  key_contains: metis_swap_Bytes
  key_not_contains: metis_swap_Bytes
  canonicalId: metis_swap_Bytes
  canonicalId_not: metis_swap_Bytes
  canonicalId_gt: metis_swap_Bytes
  canonicalId_lt: metis_swap_Bytes
  canonicalId_gte: metis_swap_Bytes
  canonicalId_lte: metis_swap_Bytes
  canonicalId_in: [metis_swap_Bytes!]
  canonicalId_not_in: [metis_swap_Bytes!]
  canonicalId_contains: metis_swap_Bytes
  canonicalId_not_contains: metis_swap_Bytes
  domain: BigInt
  domain_not: BigInt
  domain_gt: BigInt
  domain_lt: BigInt
  domain_gte: BigInt
  domain_lte: BigInt
  domain_in: [BigInt!]
  domain_not_in: [BigInt!]
  swapPool: metis_swap_Bytes
  swapPool_not: metis_swap_Bytes
  swapPool_gt: metis_swap_Bytes
  swapPool_lt: metis_swap_Bytes
  swapPool_gte: metis_swap_Bytes
  swapPool_lte: metis_swap_Bytes
  swapPool_in: [metis_swap_Bytes!]
  swapPool_not_in: [metis_swap_Bytes!]
  swapPool_contains: metis_swap_Bytes
  swapPool_not_contains: metis_swap_Bytes
  lpToken: metis_swap_Bytes
  lpToken_not: metis_swap_Bytes
  lpToken_gt: metis_swap_Bytes
  lpToken_lt: metis_swap_Bytes
  lpToken_gte: metis_swap_Bytes
  lpToken_lte: metis_swap_Bytes
  lpToken_in: [metis_swap_Bytes!]
  lpToken_not_in: [metis_swap_Bytes!]
  lpToken_contains: metis_swap_Bytes
  lpToken_not_contains: metis_swap_Bytes
  initialA: BigInt
  initialA_not: BigInt
  initialA_gt: BigInt
  initialA_lt: BigInt
  initialA_gte: BigInt
  initialA_lte: BigInt
  initialA_in: [BigInt!]
  initialA_not_in: [BigInt!]
  futureA: BigInt
  futureA_not: BigInt
  futureA_gt: BigInt
  futureA_lt: BigInt
  futureA_gte: BigInt
  futureA_lte: BigInt
  futureA_in: [BigInt!]
  futureA_not_in: [BigInt!]
  initialATime: BigInt
  initialATime_not: BigInt
  initialATime_gt: BigInt
  initialATime_lt: BigInt
  initialATime_gte: BigInt
  initialATime_lte: BigInt
  initialATime_in: [BigInt!]
  initialATime_not_in: [BigInt!]
  futureATime: BigInt
  futureATime_not: BigInt
  futureATime_gt: BigInt
  futureATime_lt: BigInt
  futureATime_gte: BigInt
  futureATime_lte: BigInt
  futureATime_in: [BigInt!]
  futureATime_not_in: [BigInt!]
  swapFee: BigInt
  swapFee_not: BigInt
  swapFee_gt: BigInt
  swapFee_lt: BigInt
  swapFee_gte: BigInt
  swapFee_lte: BigInt
  swapFee_in: [BigInt!]
  swapFee_not_in: [BigInt!]
  adminFee: BigInt
  adminFee_not: BigInt
  adminFee_gt: BigInt
  adminFee_lt: BigInt
  adminFee_gte: BigInt
  adminFee_lte: BigInt
  adminFee_in: [BigInt!]
  adminFee_not_in: [BigInt!]
  pooledTokens: [metis_swap_Bytes!]
  pooledTokens_not: [metis_swap_Bytes!]
  pooledTokens_contains: [metis_swap_Bytes!]
  pooledTokens_contains_nocase: [metis_swap_Bytes!]
  pooledTokens_not_contains: [metis_swap_Bytes!]
  pooledTokens_not_contains_nocase: [metis_swap_Bytes!]
  tokenPrecisionMultipliers: [BigInt!]
  tokenPrecisionMultipliers_not: [BigInt!]
  tokenPrecisionMultipliers_contains: [BigInt!]
  tokenPrecisionMultipliers_contains_nocase: [BigInt!]
  tokenPrecisionMultipliers_not_contains: [BigInt!]
  tokenPrecisionMultipliers_not_contains_nocase: [BigInt!]
  balances: [BigInt!]
  balances_not: [BigInt!]
  balances_contains: [BigInt!]
  balances_contains_nocase: [BigInt!]
  balances_not_contains: [BigInt!]
  balances_not_contains_nocase: [BigInt!]
  adminFees: [BigInt!]
  adminFees_not: [BigInt!]
  adminFees_contains: [BigInt!]
  adminFees_contains_nocase: [BigInt!]
  adminFees_not_contains: [BigInt!]
  adminFees_not_contains_nocase: [BigInt!]
  virtualPrice: BigInt
  virtualPrice_not: BigInt
  virtualPrice_gt: BigInt
  virtualPrice_lt: BigInt
  virtualPrice_gte: BigInt
  virtualPrice_lte: BigInt
  virtualPrice_in: [BigInt!]
  virtualPrice_not_in: [BigInt!]
  invariant: BigInt
  invariant_not: BigInt
  invariant_gt: BigInt
  invariant_lt: BigInt
  invariant_gte: BigInt
  invariant_lte: BigInt
  invariant_in: [BigInt!]
  invariant_not_in: [BigInt!]
  lpTokenSupply: BigInt
  lpTokenSupply_not: BigInt
  lpTokenSupply_gt: BigInt
  lpTokenSupply_lt: BigInt
  lpTokenSupply_gte: BigInt
  lpTokenSupply_lte: BigInt
  lpTokenSupply_in: [BigInt!]
  lpTokenSupply_not_in: [BigInt!]
  events_: metis_swap_StableSwapEvent_filter
  exchanges_: metis_swap_StableSwapExchange_filter
  hourlyVolumes_: metis_swap_SwapHourlyVolume_filter
  dailyVolumes_: metis_swap_SwapDailyVolume_filter
  weeklyVolumes_: metis_swap_SwapWeeklyVolume_filter
  """Filter for the block changed event."""
  _change_block: metis_swap_BlockChangedFilter
  and: [metis_swap_StableSwap_filter]
  or: [metis_swap_StableSwap_filter]
}

enum metis_swap_StableSwap_orderBy {
  id
  isActive
  key
  canonicalId
  domain
  swapPool
  lpToken
  initialA
  futureA
  initialATime
  futureATime
  swapFee
  adminFee
  pooledTokens
  tokenPrecisionMultipliers
  balances
  adminFees
  virtualPrice
  invariant
  lpTokenSupply
  events
  exchanges
  hourlyVolumes
  dailyVolumes
  weeklyVolumes
}

type metis_swap_SwapDailyVolume implements metis_swap_SwapTradeVolume {
  id: ID!
  stableSwap: metis_swap_StableSwap!
  timestamp: BigInt!
  volume: metis_swap_BigDecimal!
}

input metis_swap_SwapDailyVolume_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: metis_swap_StableSwap_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  volume: metis_swap_BigDecimal
  volume_not: metis_swap_BigDecimal
  volume_gt: metis_swap_BigDecimal
  volume_lt: metis_swap_BigDecimal
  volume_gte: metis_swap_BigDecimal
  volume_lte: metis_swap_BigDecimal
  volume_in: [metis_swap_BigDecimal!]
  volume_not_in: [metis_swap_BigDecimal!]
  """Filter for the block changed event."""
  _change_block: metis_swap_BlockChangedFilter
  and: [metis_swap_SwapDailyVolume_filter]
  or: [metis_swap_SwapDailyVolume_filter]
}

enum metis_swap_SwapDailyVolume_orderBy {
  id
  stableSwap
  stableSwap__id
  stableSwap__isActive
  stableSwap__key
  stableSwap__canonicalId
  stableSwap__domain
  stableSwap__swapPool
  stableSwap__lpToken
  stableSwap__initialA
  stableSwap__futureA
  stableSwap__initialATime
  stableSwap__futureATime
  stableSwap__swapFee
  stableSwap__adminFee
  stableSwap__virtualPrice
  stableSwap__invariant
  stableSwap__lpTokenSupply
  timestamp
  volume
}

type metis_swap_SwapHourlyVolume implements metis_swap_SwapTradeVolume {
  id: ID!
  stableSwap: metis_swap_StableSwap!
  timestamp: BigInt!
  volume: metis_swap_BigDecimal!
}

input metis_swap_SwapHourlyVolume_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: metis_swap_StableSwap_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  volume: metis_swap_BigDecimal
  volume_not: metis_swap_BigDecimal
  volume_gt: metis_swap_BigDecimal
  volume_lt: metis_swap_BigDecimal
  volume_gte: metis_swap_BigDecimal
  volume_lte: metis_swap_BigDecimal
  volume_in: [metis_swap_BigDecimal!]
  volume_not_in: [metis_swap_BigDecimal!]
  """Filter for the block changed event."""
  _change_block: metis_swap_BlockChangedFilter
  and: [metis_swap_SwapHourlyVolume_filter]
  or: [metis_swap_SwapHourlyVolume_filter]
}

enum metis_swap_SwapHourlyVolume_orderBy {
  id
  stableSwap
  stableSwap__id
  stableSwap__isActive
  stableSwap__key
  stableSwap__canonicalId
  stableSwap__domain
  stableSwap__swapPool
  stableSwap__lpToken
  stableSwap__initialA
  stableSwap__futureA
  stableSwap__initialATime
  stableSwap__futureATime
  stableSwap__swapFee
  stableSwap__adminFee
  stableSwap__virtualPrice
  stableSwap__invariant
  stableSwap__lpTokenSupply
  timestamp
  volume
}

interface metis_swap_SwapTradeVolume {
  stableSwap: metis_swap_StableSwap!
  timestamp: BigInt!
  volume: metis_swap_BigDecimal!
}

input metis_swap_SwapTradeVolume_filter {
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: metis_swap_StableSwap_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  volume: metis_swap_BigDecimal
  volume_not: metis_swap_BigDecimal
  volume_gt: metis_swap_BigDecimal
  volume_lt: metis_swap_BigDecimal
  volume_gte: metis_swap_BigDecimal
  volume_lte: metis_swap_BigDecimal
  volume_in: [metis_swap_BigDecimal!]
  volume_not_in: [metis_swap_BigDecimal!]
  """Filter for the block changed event."""
  _change_block: metis_swap_BlockChangedFilter
  and: [metis_swap_SwapTradeVolume_filter]
  or: [metis_swap_SwapTradeVolume_filter]
}

enum metis_swap_SwapTradeVolume_orderBy {
  stableSwap
  stableSwap__id
  stableSwap__isActive
  stableSwap__key
  stableSwap__canonicalId
  stableSwap__domain
  stableSwap__swapPool
  stableSwap__lpToken
  stableSwap__initialA
  stableSwap__futureA
  stableSwap__initialATime
  stableSwap__futureATime
  stableSwap__swapFee
  stableSwap__adminFee
  stableSwap__virtualPrice
  stableSwap__invariant
  stableSwap__lpTokenSupply
  timestamp
  volume
}

type metis_swap_SwapWeeklyVolume implements metis_swap_SwapTradeVolume {
  id: ID!
  stableSwap: metis_swap_StableSwap!
  timestamp: BigInt!
  volume: metis_swap_BigDecimal!
}

input metis_swap_SwapWeeklyVolume_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: metis_swap_StableSwap_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  volume: metis_swap_BigDecimal
  volume_not: metis_swap_BigDecimal
  volume_gt: metis_swap_BigDecimal
  volume_lt: metis_swap_BigDecimal
  volume_gte: metis_swap_BigDecimal
  volume_lte: metis_swap_BigDecimal
  volume_in: [metis_swap_BigDecimal!]
  volume_not_in: [metis_swap_BigDecimal!]
  """Filter for the block changed event."""
  _change_block: metis_swap_BlockChangedFilter
  and: [metis_swap_SwapWeeklyVolume_filter]
  or: [metis_swap_SwapWeeklyVolume_filter]
}

enum metis_swap_SwapWeeklyVolume_orderBy {
  id
  stableSwap
  stableSwap__id
  stableSwap__isActive
  stableSwap__key
  stableSwap__canonicalId
  stableSwap__domain
  stableSwap__swapPool
  stableSwap__lpToken
  stableSwap__initialA
  stableSwap__futureA
  stableSwap__initialATime
  stableSwap__futureATime
  stableSwap__swapFee
  stableSwap__adminFee
  stableSwap__virtualPrice
  stableSwap__invariant
  stableSwap__lpTokenSupply
  timestamp
  volume
}

type metis_swap_SystemInfo {
  id: ID!
  exchangeCount: BigInt!
  swapCount: BigInt!
}

input metis_swap_SystemInfo_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  exchangeCount: BigInt
  exchangeCount_not: BigInt
  exchangeCount_gt: BigInt
  exchangeCount_lt: BigInt
  exchangeCount_gte: BigInt
  exchangeCount_lte: BigInt
  exchangeCount_in: [BigInt!]
  exchangeCount_not_in: [BigInt!]
  swapCount: BigInt
  swapCount_not: BigInt
  swapCount_gt: BigInt
  swapCount_lt: BigInt
  swapCount_gte: BigInt
  swapCount_lte: BigInt
  swapCount_in: [BigInt!]
  swapCount_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: metis_swap_BlockChangedFilter
  and: [metis_swap_SystemInfo_filter]
  or: [metis_swap_SystemInfo_filter]
}

enum metis_swap_SystemInfo_orderBy {
  id
  exchangeCount
  swapCount
}

type metis_swap__Block_ {
  """The hash of the block"""
  hash: metis_swap_Bytes
  """The block number"""
  number: Int!
  """Integer representation of the timestamp stored in blocks for the chain"""
  timestamp: Int
  """The hash of the parent block"""
  parentHash: metis_swap_Bytes
}

"""The type for the top-level _meta field"""
type metis_swap__Meta_ {
  """
  Information about a specific subgraph block. The hash of the block
  will be null if the _meta field has a block constraint that asks for
  a block number. It will be filled if the _meta field has no block constraint
  and therefore asks for the latest  block
  
  """
  block: metis_swap__Block_!
  """The deployment ID"""
  deployment: String!
  """If `true`, the subgraph encountered indexing errors at some past block"""
  hasIndexingErrors: Boolean!
}

type mainnet_AggregateRootSavedSlow {
  id: ID!
  aggregateRoot: mainnet_Bytes!
  count: BigInt!
  aggregatedRoots: [mainnet_Bytes!]
  rootTimestamp: BigInt!
}

input mainnet_AggregateRootSavedSlow_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  aggregateRoot: mainnet_Bytes
  aggregateRoot_not: mainnet_Bytes
  aggregateRoot_gt: mainnet_Bytes
  aggregateRoot_lt: mainnet_Bytes
  aggregateRoot_gte: mainnet_Bytes
  aggregateRoot_lte: mainnet_Bytes
  aggregateRoot_in: [mainnet_Bytes!]
  aggregateRoot_not_in: [mainnet_Bytes!]
  aggregateRoot_contains: mainnet_Bytes
  aggregateRoot_not_contains: mainnet_Bytes
  count: BigInt
  count_not: BigInt
  count_gt: BigInt
  count_lt: BigInt
  count_gte: BigInt
  count_lte: BigInt
  count_in: [BigInt!]
  count_not_in: [BigInt!]
  aggregatedRoots: [mainnet_Bytes!]
  aggregatedRoots_not: [mainnet_Bytes!]
  aggregatedRoots_contains: [mainnet_Bytes!]
  aggregatedRoots_contains_nocase: [mainnet_Bytes!]
  aggregatedRoots_not_contains: [mainnet_Bytes!]
  aggregatedRoots_not_contains_nocase: [mainnet_Bytes!]
  rootTimestamp: BigInt
  rootTimestamp_not: BigInt
  rootTimestamp_gt: BigInt
  rootTimestamp_lt: BigInt
  rootTimestamp_gte: BigInt
  rootTimestamp_lte: BigInt
  rootTimestamp_in: [BigInt!]
  rootTimestamp_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: mainnet_BlockChangedFilter
  and: [mainnet_AggregateRootSavedSlow_filter]
  or: [mainnet_AggregateRootSavedSlow_filter]
}

enum mainnet_AggregateRootSavedSlow_orderBy {
  id
  aggregateRoot
  count
  aggregatedRoots
  rootTimestamp
}

type mainnet_AggregatedMessageRoot {
  id: ID!
  index: BigInt!
  receivedRoot: mainnet_Bytes!
  domain: BigInt
  blockNumber: BigInt
}

input mainnet_AggregatedMessageRoot_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  index: BigInt
  index_not: BigInt
  index_gt: BigInt
  index_lt: BigInt
  index_gte: BigInt
  index_lte: BigInt
  index_in: [BigInt!]
  index_not_in: [BigInt!]
  receivedRoot: mainnet_Bytes
  receivedRoot_not: mainnet_Bytes
  receivedRoot_gt: mainnet_Bytes
  receivedRoot_lt: mainnet_Bytes
  receivedRoot_gte: mainnet_Bytes
  receivedRoot_lte: mainnet_Bytes
  receivedRoot_in: [mainnet_Bytes!]
  receivedRoot_not_in: [mainnet_Bytes!]
  receivedRoot_contains: mainnet_Bytes
  receivedRoot_not_contains: mainnet_Bytes
  domain: BigInt
  domain_not: BigInt
  domain_gt: BigInt
  domain_lt: BigInt
  domain_gte: BigInt
  domain_lte: BigInt
  domain_in: [BigInt!]
  domain_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: mainnet_BlockChangedFilter
  and: [mainnet_AggregatedMessageRoot_filter]
  or: [mainnet_AggregatedMessageRoot_filter]
}

enum mainnet_AggregatedMessageRoot_orderBy {
  id
  index
  receivedRoot
  domain
  blockNumber
}

enum mainnet_Aggregation_interval {
  hour
  day
}

type mainnet_ArbitrumConnectorMeta {
  id: ID!
  spokeDomain: BigInt!
  hubDomain: BigInt!
  amb: mainnet_Bytes!
  rootManager: mainnet_Bytes!
  mirrorConnector: mainnet_Bytes!
}

input mainnet_ArbitrumConnectorMeta_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  spokeDomain: BigInt
  spokeDomain_not: BigInt
  spokeDomain_gt: BigInt
  spokeDomain_lt: BigInt
  spokeDomain_gte: BigInt
  spokeDomain_lte: BigInt
  spokeDomain_in: [BigInt!]
  spokeDomain_not_in: [BigInt!]
  hubDomain: BigInt
  hubDomain_not: BigInt
  hubDomain_gt: BigInt
  hubDomain_lt: BigInt
  hubDomain_gte: BigInt
  hubDomain_lte: BigInt
  hubDomain_in: [BigInt!]
  hubDomain_not_in: [BigInt!]
  amb: mainnet_Bytes
  amb_not: mainnet_Bytes
  amb_gt: mainnet_Bytes
  amb_lt: mainnet_Bytes
  amb_gte: mainnet_Bytes
  amb_lte: mainnet_Bytes
  amb_in: [mainnet_Bytes!]
  amb_not_in: [mainnet_Bytes!]
  amb_contains: mainnet_Bytes
  amb_not_contains: mainnet_Bytes
  rootManager: mainnet_Bytes
  rootManager_not: mainnet_Bytes
  rootManager_gt: mainnet_Bytes
  rootManager_lt: mainnet_Bytes
  rootManager_gte: mainnet_Bytes
  rootManager_lte: mainnet_Bytes
  rootManager_in: [mainnet_Bytes!]
  rootManager_not_in: [mainnet_Bytes!]
  rootManager_contains: mainnet_Bytes
  rootManager_not_contains: mainnet_Bytes
  mirrorConnector: mainnet_Bytes
  mirrorConnector_not: mainnet_Bytes
  mirrorConnector_gt: mainnet_Bytes
  mirrorConnector_lt: mainnet_Bytes
  mirrorConnector_gte: mainnet_Bytes
  mirrorConnector_lte: mainnet_Bytes
  mirrorConnector_in: [mainnet_Bytes!]
  mirrorConnector_not_in: [mainnet_Bytes!]
  mirrorConnector_contains: mainnet_Bytes
  mirrorConnector_not_contains: mainnet_Bytes
  """Filter for the block changed event."""
  _change_block: mainnet_BlockChangedFilter
  and: [mainnet_ArbitrumConnectorMeta_filter]
  or: [mainnet_ArbitrumConnectorMeta_filter]
}

enum mainnet_ArbitrumConnectorMeta_orderBy {
  id
  spokeDomain
  hubDomain
  amb
  rootManager
  mirrorConnector
}

type mainnet_AvalancheConnectorMeta {
  id: ID!
  spokeDomain: BigInt!
  hubDomain: BigInt!
  amb: mainnet_Bytes!
  rootManager: mainnet_Bytes!
  mirrorConnector: mainnet_Bytes!
}

input mainnet_AvalancheConnectorMeta_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  spokeDomain: BigInt
  spokeDomain_not: BigInt
  spokeDomain_gt: BigInt
  spokeDomain_lt: BigInt
  spokeDomain_gte: BigInt
  spokeDomain_lte: BigInt
  spokeDomain_in: [BigInt!]
  spokeDomain_not_in: [BigInt!]
  hubDomain: BigInt
  hubDomain_not: BigInt
  hubDomain_gt: BigInt
  hubDomain_lt: BigInt
  hubDomain_gte: BigInt
  hubDomain_lte: BigInt
  hubDomain_in: [BigInt!]
  hubDomain_not_in: [BigInt!]
  amb: mainnet_Bytes
  amb_not: mainnet_Bytes
  amb_gt: mainnet_Bytes
  amb_lt: mainnet_Bytes
  amb_gte: mainnet_Bytes
  amb_lte: mainnet_Bytes
  amb_in: [mainnet_Bytes!]
  amb_not_in: [mainnet_Bytes!]
  amb_contains: mainnet_Bytes
  amb_not_contains: mainnet_Bytes
  rootManager: mainnet_Bytes
  rootManager_not: mainnet_Bytes
  rootManager_gt: mainnet_Bytes
  rootManager_lt: mainnet_Bytes
  rootManager_gte: mainnet_Bytes
  rootManager_lte: mainnet_Bytes
  rootManager_in: [mainnet_Bytes!]
  rootManager_not_in: [mainnet_Bytes!]
  rootManager_contains: mainnet_Bytes
  rootManager_not_contains: mainnet_Bytes
  mirrorConnector: mainnet_Bytes
  mirrorConnector_not: mainnet_Bytes
  mirrorConnector_gt: mainnet_Bytes
  mirrorConnector_lt: mainnet_Bytes
  mirrorConnector_gte: mainnet_Bytes
  mirrorConnector_lte: mainnet_Bytes
  mirrorConnector_in: [mainnet_Bytes!]
  mirrorConnector_not_in: [mainnet_Bytes!]
  mirrorConnector_contains: mainnet_Bytes
  mirrorConnector_not_contains: mainnet_Bytes
  """Filter for the block changed event."""
  _change_block: mainnet_BlockChangedFilter
  and: [mainnet_AvalancheConnectorMeta_filter]
  or: [mainnet_AvalancheConnectorMeta_filter]
}

enum mainnet_AvalancheConnectorMeta_orderBy {
  id
  spokeDomain
  hubDomain
  amb
  rootManager
  mirrorConnector
}

type mainnet_BaseConnectorMeta {
  id: ID!
  spokeDomain: BigInt!
  hubDomain: BigInt!
  amb: mainnet_Bytes!
  rootManager: mainnet_Bytes!
  mirrorConnector: mainnet_Bytes!
}

input mainnet_BaseConnectorMeta_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  spokeDomain: BigInt
  spokeDomain_not: BigInt
  spokeDomain_gt: BigInt
  spokeDomain_lt: BigInt
  spokeDomain_gte: BigInt
  spokeDomain_lte: BigInt
  spokeDomain_in: [BigInt!]
  spokeDomain_not_in: [BigInt!]
  hubDomain: BigInt
  hubDomain_not: BigInt
  hubDomain_gt: BigInt
  hubDomain_lt: BigInt
  hubDomain_gte: BigInt
  hubDomain_lte: BigInt
  hubDomain_in: [BigInt!]
  hubDomain_not_in: [BigInt!]
  amb: mainnet_Bytes
  amb_not: mainnet_Bytes
  amb_gt: mainnet_Bytes
  amb_lt: mainnet_Bytes
  amb_gte: mainnet_Bytes
  amb_lte: mainnet_Bytes
  amb_in: [mainnet_Bytes!]
  amb_not_in: [mainnet_Bytes!]
  amb_contains: mainnet_Bytes
  amb_not_contains: mainnet_Bytes
  rootManager: mainnet_Bytes
  rootManager_not: mainnet_Bytes
  rootManager_gt: mainnet_Bytes
  rootManager_lt: mainnet_Bytes
  rootManager_gte: mainnet_Bytes
  rootManager_lte: mainnet_Bytes
  rootManager_in: [mainnet_Bytes!]
  rootManager_not_in: [mainnet_Bytes!]
  rootManager_contains: mainnet_Bytes
  rootManager_not_contains: mainnet_Bytes
  mirrorConnector: mainnet_Bytes
  mirrorConnector_not: mainnet_Bytes
  mirrorConnector_gt: mainnet_Bytes
  mirrorConnector_lt: mainnet_Bytes
  mirrorConnector_gte: mainnet_Bytes
  mirrorConnector_lte: mainnet_Bytes
  mirrorConnector_in: [mainnet_Bytes!]
  mirrorConnector_not_in: [mainnet_Bytes!]
  mirrorConnector_contains: mainnet_Bytes
  mirrorConnector_not_contains: mainnet_Bytes
  """Filter for the block changed event."""
  _change_block: mainnet_BlockChangedFilter
  and: [mainnet_BaseConnectorMeta_filter]
  or: [mainnet_BaseConnectorMeta_filter]
}

enum mainnet_BaseConnectorMeta_orderBy {
  id
  spokeDomain
  hubDomain
  amb
  rootManager
  mirrorConnector
}

scalar mainnet_BigDecimal

input mainnet_BlockChangedFilter {
  number_gte: Int!
}

input mainnet_Block_height {
  hash: mainnet_Bytes
  number: Int
  number_gte: Int
}

type mainnet_BnbConnectorMeta {
  id: ID!
  spokeDomain: BigInt!
  hubDomain: BigInt!
  amb: mainnet_Bytes!
  rootManager: mainnet_Bytes!
  mirrorConnector: mainnet_Bytes!
}

input mainnet_BnbConnectorMeta_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  spokeDomain: BigInt
  spokeDomain_not: BigInt
  spokeDomain_gt: BigInt
  spokeDomain_lt: BigInt
  spokeDomain_gte: BigInt
  spokeDomain_lte: BigInt
  spokeDomain_in: [BigInt!]
  spokeDomain_not_in: [BigInt!]
  hubDomain: BigInt
  hubDomain_not: BigInt
  hubDomain_gt: BigInt
  hubDomain_lt: BigInt
  hubDomain_gte: BigInt
  hubDomain_lte: BigInt
  hubDomain_in: [BigInt!]
  hubDomain_not_in: [BigInt!]
  amb: mainnet_Bytes
  amb_not: mainnet_Bytes
  amb_gt: mainnet_Bytes
  amb_lt: mainnet_Bytes
  amb_gte: mainnet_Bytes
  amb_lte: mainnet_Bytes
  amb_in: [mainnet_Bytes!]
  amb_not_in: [mainnet_Bytes!]
  amb_contains: mainnet_Bytes
  amb_not_contains: mainnet_Bytes
  rootManager: mainnet_Bytes
  rootManager_not: mainnet_Bytes
  rootManager_gt: mainnet_Bytes
  rootManager_lt: mainnet_Bytes
  rootManager_gte: mainnet_Bytes
  rootManager_lte: mainnet_Bytes
  rootManager_in: [mainnet_Bytes!]
  rootManager_not_in: [mainnet_Bytes!]
  rootManager_contains: mainnet_Bytes
  rootManager_not_contains: mainnet_Bytes
  mirrorConnector: mainnet_Bytes
  mirrorConnector_not: mainnet_Bytes
  mirrorConnector_gt: mainnet_Bytes
  mirrorConnector_lt: mainnet_Bytes
  mirrorConnector_gte: mainnet_Bytes
  mirrorConnector_lte: mainnet_Bytes
  mirrorConnector_in: [mainnet_Bytes!]
  mirrorConnector_not_in: [mainnet_Bytes!]
  mirrorConnector_contains: mainnet_Bytes
  mirrorConnector_not_contains: mainnet_Bytes
  """Filter for the block changed event."""
  _change_block: mainnet_BlockChangedFilter
  and: [mainnet_BnbConnectorMeta_filter]
  or: [mainnet_BnbConnectorMeta_filter]
}

enum mainnet_BnbConnectorMeta_orderBy {
  id
  spokeDomain
  hubDomain
  amb
  rootManager
  mirrorConnector
}

scalar mainnet_Bytes

type mainnet_GnosisConnectorMeta {
  id: ID!
  spokeDomain: BigInt!
  hubDomain: BigInt!
  amb: mainnet_Bytes!
  rootManager: mainnet_Bytes!
  mirrorConnector: mainnet_Bytes!
}

input mainnet_GnosisConnectorMeta_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  spokeDomain: BigInt
  spokeDomain_not: BigInt
  spokeDomain_gt: BigInt
  spokeDomain_lt: BigInt
  spokeDomain_gte: BigInt
  spokeDomain_lte: BigInt
  spokeDomain_in: [BigInt!]
  spokeDomain_not_in: [BigInt!]
  hubDomain: BigInt
  hubDomain_not: BigInt
  hubDomain_gt: BigInt
  hubDomain_lt: BigInt
  hubDomain_gte: BigInt
  hubDomain_lte: BigInt
  hubDomain_in: [BigInt!]
  hubDomain_not_in: [BigInt!]
  amb: mainnet_Bytes
  amb_not: mainnet_Bytes
  amb_gt: mainnet_Bytes
  amb_lt: mainnet_Bytes
  amb_gte: mainnet_Bytes
  amb_lte: mainnet_Bytes
  amb_in: [mainnet_Bytes!]
  amb_not_in: [mainnet_Bytes!]
  amb_contains: mainnet_Bytes
  amb_not_contains: mainnet_Bytes
  rootManager: mainnet_Bytes
  rootManager_not: mainnet_Bytes
  rootManager_gt: mainnet_Bytes
  rootManager_lt: mainnet_Bytes
  rootManager_gte: mainnet_Bytes
  rootManager_lte: mainnet_Bytes
  rootManager_in: [mainnet_Bytes!]
  rootManager_not_in: [mainnet_Bytes!]
  rootManager_contains: mainnet_Bytes
  rootManager_not_contains: mainnet_Bytes
  mirrorConnector: mainnet_Bytes
  mirrorConnector_not: mainnet_Bytes
  mirrorConnector_gt: mainnet_Bytes
  mirrorConnector_lt: mainnet_Bytes
  mirrorConnector_gte: mainnet_Bytes
  mirrorConnector_lte: mainnet_Bytes
  mirrorConnector_in: [mainnet_Bytes!]
  mirrorConnector_not_in: [mainnet_Bytes!]
  mirrorConnector_contains: mainnet_Bytes
  mirrorConnector_not_contains: mainnet_Bytes
  """Filter for the block changed event."""
  _change_block: mainnet_BlockChangedFilter
  and: [mainnet_GnosisConnectorMeta_filter]
  or: [mainnet_GnosisConnectorMeta_filter]
}

enum mainnet_GnosisConnectorMeta_orderBy {
  id
  spokeDomain
  hubDomain
  amb
  rootManager
  mirrorConnector
}

type mainnet_HubDomain {
  id: ID!
  domain: BigInt
}

input mainnet_HubDomain_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  domain: BigInt
  domain_not: BigInt
  domain_gt: BigInt
  domain_lt: BigInt
  domain_gte: BigInt
  domain_lte: BigInt
  domain_in: [BigInt!]
  domain_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: mainnet_BlockChangedFilter
  and: [mainnet_HubDomain_filter]
  or: [mainnet_HubDomain_filter]
}

enum mainnet_HubDomain_orderBy {
  id
  domain
}

type mainnet_HubOptimisticRootFinalized {
  id: ID!
  aggregateRoot: mainnet_Bytes!
  timestamp: BigInt!
  blockNumber: BigInt
}

input mainnet_HubOptimisticRootFinalized_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  aggregateRoot: mainnet_Bytes
  aggregateRoot_not: mainnet_Bytes
  aggregateRoot_gt: mainnet_Bytes
  aggregateRoot_lt: mainnet_Bytes
  aggregateRoot_gte: mainnet_Bytes
  aggregateRoot_lte: mainnet_Bytes
  aggregateRoot_in: [mainnet_Bytes!]
  aggregateRoot_not_in: [mainnet_Bytes!]
  aggregateRoot_contains: mainnet_Bytes
  aggregateRoot_not_contains: mainnet_Bytes
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: mainnet_BlockChangedFilter
  and: [mainnet_HubOptimisticRootFinalized_filter]
  or: [mainnet_HubOptimisticRootFinalized_filter]
}

enum mainnet_HubOptimisticRootFinalized_orderBy {
  id
  aggregateRoot
  timestamp
  blockNumber
}

"""
8 bytes signed integer

"""
scalar mainnet_Int8

type mainnet_LineaConnectorMeta {
  id: ID!
  spokeDomain: BigInt!
  hubDomain: BigInt!
  amb: mainnet_Bytes!
  rootManager: mainnet_Bytes!
  mirrorConnector: mainnet_Bytes!
}

input mainnet_LineaConnectorMeta_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  spokeDomain: BigInt
  spokeDomain_not: BigInt
  spokeDomain_gt: BigInt
  spokeDomain_lt: BigInt
  spokeDomain_gte: BigInt
  spokeDomain_lte: BigInt
  spokeDomain_in: [BigInt!]
  spokeDomain_not_in: [BigInt!]
  hubDomain: BigInt
  hubDomain_not: BigInt
  hubDomain_gt: BigInt
  hubDomain_lt: BigInt
  hubDomain_gte: BigInt
  hubDomain_lte: BigInt
  hubDomain_in: [BigInt!]
  hubDomain_not_in: [BigInt!]
  amb: mainnet_Bytes
  amb_not: mainnet_Bytes
  amb_gt: mainnet_Bytes
  amb_lt: mainnet_Bytes
  amb_gte: mainnet_Bytes
  amb_lte: mainnet_Bytes
  amb_in: [mainnet_Bytes!]
  amb_not_in: [mainnet_Bytes!]
  amb_contains: mainnet_Bytes
  amb_not_contains: mainnet_Bytes
  rootManager: mainnet_Bytes
  rootManager_not: mainnet_Bytes
  rootManager_gt: mainnet_Bytes
  rootManager_lt: mainnet_Bytes
  rootManager_gte: mainnet_Bytes
  rootManager_lte: mainnet_Bytes
  rootManager_in: [mainnet_Bytes!]
  rootManager_not_in: [mainnet_Bytes!]
  rootManager_contains: mainnet_Bytes
  rootManager_not_contains: mainnet_Bytes
  mirrorConnector: mainnet_Bytes
  mirrorConnector_not: mainnet_Bytes
  mirrorConnector_gt: mainnet_Bytes
  mirrorConnector_lt: mainnet_Bytes
  mirrorConnector_gte: mainnet_Bytes
  mirrorConnector_lte: mainnet_Bytes
  mirrorConnector_in: [mainnet_Bytes!]
  mirrorConnector_not_in: [mainnet_Bytes!]
  mirrorConnector_contains: mainnet_Bytes
  mirrorConnector_not_contains: mainnet_Bytes
  """Filter for the block changed event."""
  _change_block: mainnet_BlockChangedFilter
  and: [mainnet_LineaConnectorMeta_filter]
  or: [mainnet_LineaConnectorMeta_filter]
}

enum mainnet_LineaConnectorMeta_orderBy {
  id
  spokeDomain
  hubDomain
  amb
  rootManager
  mirrorConnector
}

type mainnet_MantleConnectorMeta {
  id: ID!
  spokeDomain: BigInt!
  hubDomain: BigInt!
  amb: mainnet_Bytes!
  rootManager: mainnet_Bytes!
  mirrorConnector: mainnet_Bytes!
}

input mainnet_MantleConnectorMeta_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  spokeDomain: BigInt
  spokeDomain_not: BigInt
  spokeDomain_gt: BigInt
  spokeDomain_lt: BigInt
  spokeDomain_gte: BigInt
  spokeDomain_lte: BigInt
  spokeDomain_in: [BigInt!]
  spokeDomain_not_in: [BigInt!]
  hubDomain: BigInt
  hubDomain_not: BigInt
  hubDomain_gt: BigInt
  hubDomain_lt: BigInt
  hubDomain_gte: BigInt
  hubDomain_lte: BigInt
  hubDomain_in: [BigInt!]
  hubDomain_not_in: [BigInt!]
  amb: mainnet_Bytes
  amb_not: mainnet_Bytes
  amb_gt: mainnet_Bytes
  amb_lt: mainnet_Bytes
  amb_gte: mainnet_Bytes
  amb_lte: mainnet_Bytes
  amb_in: [mainnet_Bytes!]
  amb_not_in: [mainnet_Bytes!]
  amb_contains: mainnet_Bytes
  amb_not_contains: mainnet_Bytes
  rootManager: mainnet_Bytes
  rootManager_not: mainnet_Bytes
  rootManager_gt: mainnet_Bytes
  rootManager_lt: mainnet_Bytes
  rootManager_gte: mainnet_Bytes
  rootManager_lte: mainnet_Bytes
  rootManager_in: [mainnet_Bytes!]
  rootManager_not_in: [mainnet_Bytes!]
  rootManager_contains: mainnet_Bytes
  rootManager_not_contains: mainnet_Bytes
  mirrorConnector: mainnet_Bytes
  mirrorConnector_not: mainnet_Bytes
  mirrorConnector_gt: mainnet_Bytes
  mirrorConnector_lt: mainnet_Bytes
  mirrorConnector_gte: mainnet_Bytes
  mirrorConnector_lte: mainnet_Bytes
  mirrorConnector_in: [mainnet_Bytes!]
  mirrorConnector_not_in: [mainnet_Bytes!]
  mirrorConnector_contains: mainnet_Bytes
  mirrorConnector_not_contains: mainnet_Bytes
  """Filter for the block changed event."""
  _change_block: mainnet_BlockChangedFilter
  and: [mainnet_MantleConnectorMeta_filter]
  or: [mainnet_MantleConnectorMeta_filter]
}

enum mainnet_MantleConnectorMeta_orderBy {
  id
  spokeDomain
  hubDomain
  amb
  rootManager
  mirrorConnector
}

type mainnet_MetisConnectorMeta {
  id: ID!
  spokeDomain: BigInt!
  hubDomain: BigInt!
  amb: mainnet_Bytes!
  rootManager: mainnet_Bytes!
  mirrorConnector: mainnet_Bytes!
}

input mainnet_MetisConnectorMeta_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  spokeDomain: BigInt
  spokeDomain_not: BigInt
  spokeDomain_gt: BigInt
  spokeDomain_lt: BigInt
  spokeDomain_gte: BigInt
  spokeDomain_lte: BigInt
  spokeDomain_in: [BigInt!]
  spokeDomain_not_in: [BigInt!]
  hubDomain: BigInt
  hubDomain_not: BigInt
  hubDomain_gt: BigInt
  hubDomain_lt: BigInt
  hubDomain_gte: BigInt
  hubDomain_lte: BigInt
  hubDomain_in: [BigInt!]
  hubDomain_not_in: [BigInt!]
  amb: mainnet_Bytes
  amb_not: mainnet_Bytes
  amb_gt: mainnet_Bytes
  amb_lt: mainnet_Bytes
  amb_gte: mainnet_Bytes
  amb_lte: mainnet_Bytes
  amb_in: [mainnet_Bytes!]
  amb_not_in: [mainnet_Bytes!]
  amb_contains: mainnet_Bytes
  amb_not_contains: mainnet_Bytes
  rootManager: mainnet_Bytes
  rootManager_not: mainnet_Bytes
  rootManager_gt: mainnet_Bytes
  rootManager_lt: mainnet_Bytes
  rootManager_gte: mainnet_Bytes
  rootManager_lte: mainnet_Bytes
  rootManager_in: [mainnet_Bytes!]
  rootManager_not_in: [mainnet_Bytes!]
  rootManager_contains: mainnet_Bytes
  rootManager_not_contains: mainnet_Bytes
  mirrorConnector: mainnet_Bytes
  mirrorConnector_not: mainnet_Bytes
  mirrorConnector_gt: mainnet_Bytes
  mirrorConnector_lt: mainnet_Bytes
  mirrorConnector_gte: mainnet_Bytes
  mirrorConnector_lte: mainnet_Bytes
  mirrorConnector_in: [mainnet_Bytes!]
  mirrorConnector_not_in: [mainnet_Bytes!]
  mirrorConnector_contains: mainnet_Bytes
  mirrorConnector_not_contains: mainnet_Bytes
  """Filter for the block changed event."""
  _change_block: mainnet_BlockChangedFilter
  and: [mainnet_MetisConnectorMeta_filter]
  or: [mainnet_MetisConnectorMeta_filter]
}

enum mainnet_MetisConnectorMeta_orderBy {
  id
  spokeDomain
  hubDomain
  amb
  rootManager
  mirrorConnector
}

type mainnet_ModeConnectorMeta {
  id: ID!
  spokeDomain: BigInt!
  hubDomain: BigInt!
  amb: mainnet_Bytes!
  rootManager: mainnet_Bytes!
  mirrorConnector: mainnet_Bytes!
}

input mainnet_ModeConnectorMeta_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  spokeDomain: BigInt
  spokeDomain_not: BigInt
  spokeDomain_gt: BigInt
  spokeDomain_lt: BigInt
  spokeDomain_gte: BigInt
  spokeDomain_lte: BigInt
  spokeDomain_in: [BigInt!]
  spokeDomain_not_in: [BigInt!]
  hubDomain: BigInt
  hubDomain_not: BigInt
  hubDomain_gt: BigInt
  hubDomain_lt: BigInt
  hubDomain_gte: BigInt
  hubDomain_lte: BigInt
  hubDomain_in: [BigInt!]
  hubDomain_not_in: [BigInt!]
  amb: mainnet_Bytes
  amb_not: mainnet_Bytes
  amb_gt: mainnet_Bytes
  amb_lt: mainnet_Bytes
  amb_gte: mainnet_Bytes
  amb_lte: mainnet_Bytes
  amb_in: [mainnet_Bytes!]
  amb_not_in: [mainnet_Bytes!]
  amb_contains: mainnet_Bytes
  amb_not_contains: mainnet_Bytes
  rootManager: mainnet_Bytes
  rootManager_not: mainnet_Bytes
  rootManager_gt: mainnet_Bytes
  rootManager_lt: mainnet_Bytes
  rootManager_gte: mainnet_Bytes
  rootManager_lte: mainnet_Bytes
  rootManager_in: [mainnet_Bytes!]
  rootManager_not_in: [mainnet_Bytes!]
  rootManager_contains: mainnet_Bytes
  rootManager_not_contains: mainnet_Bytes
  mirrorConnector: mainnet_Bytes
  mirrorConnector_not: mainnet_Bytes
  mirrorConnector_gt: mainnet_Bytes
  mirrorConnector_lt: mainnet_Bytes
  mirrorConnector_gte: mainnet_Bytes
  mirrorConnector_lte: mainnet_Bytes
  mirrorConnector_in: [mainnet_Bytes!]
  mirrorConnector_not_in: [mainnet_Bytes!]
  mirrorConnector_contains: mainnet_Bytes
  mirrorConnector_not_contains: mainnet_Bytes
  """Filter for the block changed event."""
  _change_block: mainnet_BlockChangedFilter
  and: [mainnet_ModeConnectorMeta_filter]
  or: [mainnet_ModeConnectorMeta_filter]
}

enum mainnet_ModeConnectorMeta_orderBy {
  id
  spokeDomain
  hubDomain
  amb
  rootManager
  mirrorConnector
}

type mainnet_OptimismConnectorMeta {
  id: ID!
  spokeDomain: BigInt!
  hubDomain: BigInt!
  amb: mainnet_Bytes!
  rootManager: mainnet_Bytes!
  mirrorConnector: mainnet_Bytes!
}

input mainnet_OptimismConnectorMeta_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  spokeDomain: BigInt
  spokeDomain_not: BigInt
  spokeDomain_gt: BigInt
  spokeDomain_lt: BigInt
  spokeDomain_gte: BigInt
  spokeDomain_lte: BigInt
  spokeDomain_in: [BigInt!]
  spokeDomain_not_in: [BigInt!]
  hubDomain: BigInt
  hubDomain_not: BigInt
  hubDomain_gt: BigInt
  hubDomain_lt: BigInt
  hubDomain_gte: BigInt
  hubDomain_lte: BigInt
  hubDomain_in: [BigInt!]
  hubDomain_not_in: [BigInt!]
  amb: mainnet_Bytes
  amb_not: mainnet_Bytes
  amb_gt: mainnet_Bytes
  amb_lt: mainnet_Bytes
  amb_gte: mainnet_Bytes
  amb_lte: mainnet_Bytes
  amb_in: [mainnet_Bytes!]
  amb_not_in: [mainnet_Bytes!]
  amb_contains: mainnet_Bytes
  amb_not_contains: mainnet_Bytes
  rootManager: mainnet_Bytes
  rootManager_not: mainnet_Bytes
  rootManager_gt: mainnet_Bytes
  rootManager_lt: mainnet_Bytes
  rootManager_gte: mainnet_Bytes
  rootManager_lte: mainnet_Bytes
  rootManager_in: [mainnet_Bytes!]
  rootManager_not_in: [mainnet_Bytes!]
  rootManager_contains: mainnet_Bytes
  rootManager_not_contains: mainnet_Bytes
  mirrorConnector: mainnet_Bytes
  mirrorConnector_not: mainnet_Bytes
  mirrorConnector_gt: mainnet_Bytes
  mirrorConnector_lt: mainnet_Bytes
  mirrorConnector_gte: mainnet_Bytes
  mirrorConnector_lte: mainnet_Bytes
  mirrorConnector_in: [mainnet_Bytes!]
  mirrorConnector_not_in: [mainnet_Bytes!]
  mirrorConnector_contains: mainnet_Bytes
  mirrorConnector_not_contains: mainnet_Bytes
  """Filter for the block changed event."""
  _change_block: mainnet_BlockChangedFilter
  and: [mainnet_OptimismConnectorMeta_filter]
  or: [mainnet_OptimismConnectorMeta_filter]
}

enum mainnet_OptimismConnectorMeta_orderBy {
  id
  spokeDomain
  hubDomain
  amb
  rootManager
  mirrorConnector
}

type mainnet_OptimisticRootPropagated {
  id: ID!
  aggregateRoot: mainnet_Bytes!
  domainsHash: mainnet_Bytes!
  timestamp: BigInt!
  blockNumber: BigInt
}

input mainnet_OptimisticRootPropagated_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  aggregateRoot: mainnet_Bytes
  aggregateRoot_not: mainnet_Bytes
  aggregateRoot_gt: mainnet_Bytes
  aggregateRoot_lt: mainnet_Bytes
  aggregateRoot_gte: mainnet_Bytes
  aggregateRoot_lte: mainnet_Bytes
  aggregateRoot_in: [mainnet_Bytes!]
  aggregateRoot_not_in: [mainnet_Bytes!]
  aggregateRoot_contains: mainnet_Bytes
  aggregateRoot_not_contains: mainnet_Bytes
  domainsHash: mainnet_Bytes
  domainsHash_not: mainnet_Bytes
  domainsHash_gt: mainnet_Bytes
  domainsHash_lt: mainnet_Bytes
  domainsHash_gte: mainnet_Bytes
  domainsHash_lte: mainnet_Bytes
  domainsHash_in: [mainnet_Bytes!]
  domainsHash_not_in: [mainnet_Bytes!]
  domainsHash_contains: mainnet_Bytes
  domainsHash_not_contains: mainnet_Bytes
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: mainnet_BlockChangedFilter
  and: [mainnet_OptimisticRootPropagated_filter]
  or: [mainnet_OptimisticRootPropagated_filter]
}

enum mainnet_OptimisticRootPropagated_orderBy {
  id
  aggregateRoot
  domainsHash
  timestamp
  blockNumber
}

type mainnet_OptimisticRootProposed {
  id: ID!
  disputeCliff: BigInt!
  aggregateRoot: mainnet_Bytes!
  snapshotsRoots: [mainnet_Bytes!]
  domains: [BigInt!]
  baseAggregateRoot: mainnet_Bytes!
  timestamp: BigInt!
  blockNumber: BigInt
}

input mainnet_OptimisticRootProposed_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  disputeCliff: BigInt
  disputeCliff_not: BigInt
  disputeCliff_gt: BigInt
  disputeCliff_lt: BigInt
  disputeCliff_gte: BigInt
  disputeCliff_lte: BigInt
  disputeCliff_in: [BigInt!]
  disputeCliff_not_in: [BigInt!]
  aggregateRoot: mainnet_Bytes
  aggregateRoot_not: mainnet_Bytes
  aggregateRoot_gt: mainnet_Bytes
  aggregateRoot_lt: mainnet_Bytes
  aggregateRoot_gte: mainnet_Bytes
  aggregateRoot_lte: mainnet_Bytes
  aggregateRoot_in: [mainnet_Bytes!]
  aggregateRoot_not_in: [mainnet_Bytes!]
  aggregateRoot_contains: mainnet_Bytes
  aggregateRoot_not_contains: mainnet_Bytes
  snapshotsRoots: [mainnet_Bytes!]
  snapshotsRoots_not: [mainnet_Bytes!]
  snapshotsRoots_contains: [mainnet_Bytes!]
  snapshotsRoots_contains_nocase: [mainnet_Bytes!]
  snapshotsRoots_not_contains: [mainnet_Bytes!]
  snapshotsRoots_not_contains_nocase: [mainnet_Bytes!]
  domains: [BigInt!]
  domains_not: [BigInt!]
  domains_contains: [BigInt!]
  domains_contains_nocase: [BigInt!]
  domains_not_contains: [BigInt!]
  domains_not_contains_nocase: [BigInt!]
  baseAggregateRoot: mainnet_Bytes
  baseAggregateRoot_not: mainnet_Bytes
  baseAggregateRoot_gt: mainnet_Bytes
  baseAggregateRoot_lt: mainnet_Bytes
  baseAggregateRoot_gte: mainnet_Bytes
  baseAggregateRoot_lte: mainnet_Bytes
  baseAggregateRoot_in: [mainnet_Bytes!]
  baseAggregateRoot_not_in: [mainnet_Bytes!]
  baseAggregateRoot_contains: mainnet_Bytes
  baseAggregateRoot_not_contains: mainnet_Bytes
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: mainnet_BlockChangedFilter
  and: [mainnet_OptimisticRootProposed_filter]
  or: [mainnet_OptimisticRootProposed_filter]
}

enum mainnet_OptimisticRootProposed_orderBy {
  id
  disputeCliff
  aggregateRoot
  snapshotsRoots
  domains
  baseAggregateRoot
  timestamp
  blockNumber
}

"""Defines the order direction, either ascending or descending"""
enum mainnet_OrderDirection {
  asc
  desc
}

type mainnet_PolygonConnectorMeta {
  id: ID!
  spokeDomain: BigInt!
  hubDomain: BigInt!
  amb: mainnet_Bytes!
  rootManager: mainnet_Bytes!
  mirrorConnector: mainnet_Bytes!
}

input mainnet_PolygonConnectorMeta_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  spokeDomain: BigInt
  spokeDomain_not: BigInt
  spokeDomain_gt: BigInt
  spokeDomain_lt: BigInt
  spokeDomain_gte: BigInt
  spokeDomain_lte: BigInt
  spokeDomain_in: [BigInt!]
  spokeDomain_not_in: [BigInt!]
  hubDomain: BigInt
  hubDomain_not: BigInt
  hubDomain_gt: BigInt
  hubDomain_lt: BigInt
  hubDomain_gte: BigInt
  hubDomain_lte: BigInt
  hubDomain_in: [BigInt!]
  hubDomain_not_in: [BigInt!]
  amb: mainnet_Bytes
  amb_not: mainnet_Bytes
  amb_gt: mainnet_Bytes
  amb_lt: mainnet_Bytes
  amb_gte: mainnet_Bytes
  amb_lte: mainnet_Bytes
  amb_in: [mainnet_Bytes!]
  amb_not_in: [mainnet_Bytes!]
  amb_contains: mainnet_Bytes
  amb_not_contains: mainnet_Bytes
  rootManager: mainnet_Bytes
  rootManager_not: mainnet_Bytes
  rootManager_gt: mainnet_Bytes
  rootManager_lt: mainnet_Bytes
  rootManager_gte: mainnet_Bytes
  rootManager_lte: mainnet_Bytes
  rootManager_in: [mainnet_Bytes!]
  rootManager_not_in: [mainnet_Bytes!]
  rootManager_contains: mainnet_Bytes
  rootManager_not_contains: mainnet_Bytes
  mirrorConnector: mainnet_Bytes
  mirrorConnector_not: mainnet_Bytes
  mirrorConnector_gt: mainnet_Bytes
  mirrorConnector_lt: mainnet_Bytes
  mirrorConnector_gte: mainnet_Bytes
  mirrorConnector_lte: mainnet_Bytes
  mirrorConnector_in: [mainnet_Bytes!]
  mirrorConnector_not_in: [mainnet_Bytes!]
  mirrorConnector_contains: mainnet_Bytes
  mirrorConnector_not_contains: mainnet_Bytes
  """Filter for the block changed event."""
  _change_block: mainnet_BlockChangedFilter
  and: [mainnet_PolygonConnectorMeta_filter]
  or: [mainnet_PolygonConnectorMeta_filter]
}

enum mainnet_PolygonConnectorMeta_orderBy {
  id
  spokeDomain
  hubDomain
  amb
  rootManager
  mirrorConnector
}

type mainnet_PolygonZkConnectorMeta {
  id: ID!
  spokeDomain: BigInt!
  hubDomain: BigInt!
  amb: mainnet_Bytes!
  rootManager: mainnet_Bytes!
  mirrorConnector: mainnet_Bytes!
}

input mainnet_PolygonZkConnectorMeta_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  spokeDomain: BigInt
  spokeDomain_not: BigInt
  spokeDomain_gt: BigInt
  spokeDomain_lt: BigInt
  spokeDomain_gte: BigInt
  spokeDomain_lte: BigInt
  spokeDomain_in: [BigInt!]
  spokeDomain_not_in: [BigInt!]
  hubDomain: BigInt
  hubDomain_not: BigInt
  hubDomain_gt: BigInt
  hubDomain_lt: BigInt
  hubDomain_gte: BigInt
  hubDomain_lte: BigInt
  hubDomain_in: [BigInt!]
  hubDomain_not_in: [BigInt!]
  amb: mainnet_Bytes
  amb_not: mainnet_Bytes
  amb_gt: mainnet_Bytes
  amb_lt: mainnet_Bytes
  amb_gte: mainnet_Bytes
  amb_lte: mainnet_Bytes
  amb_in: [mainnet_Bytes!]
  amb_not_in: [mainnet_Bytes!]
  amb_contains: mainnet_Bytes
  amb_not_contains: mainnet_Bytes
  rootManager: mainnet_Bytes
  rootManager_not: mainnet_Bytes
  rootManager_gt: mainnet_Bytes
  rootManager_lt: mainnet_Bytes
  rootManager_gte: mainnet_Bytes
  rootManager_lte: mainnet_Bytes
  rootManager_in: [mainnet_Bytes!]
  rootManager_not_in: [mainnet_Bytes!]
  rootManager_contains: mainnet_Bytes
  rootManager_not_contains: mainnet_Bytes
  mirrorConnector: mainnet_Bytes
  mirrorConnector_not: mainnet_Bytes
  mirrorConnector_gt: mainnet_Bytes
  mirrorConnector_lt: mainnet_Bytes
  mirrorConnector_gte: mainnet_Bytes
  mirrorConnector_lte: mainnet_Bytes
  mirrorConnector_in: [mainnet_Bytes!]
  mirrorConnector_not_in: [mainnet_Bytes!]
  mirrorConnector_contains: mainnet_Bytes
  mirrorConnector_not_contains: mainnet_Bytes
  """Filter for the block changed event."""
  _change_block: mainnet_BlockChangedFilter
  and: [mainnet_PolygonZkConnectorMeta_filter]
  or: [mainnet_PolygonZkConnectorMeta_filter]
}

enum mainnet_PolygonZkConnectorMeta_orderBy {
  id
  spokeDomain
  hubDomain
  amb
  rootManager
  mirrorConnector
}

type mainnet_RootAggregated {
  id: ID!
  domain: BigInt!
  receivedRoot: mainnet_Bytes!
  index: BigInt!
}

input mainnet_RootAggregated_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  domain: BigInt
  domain_not: BigInt
  domain_gt: BigInt
  domain_lt: BigInt
  domain_gte: BigInt
  domain_lte: BigInt
  domain_in: [BigInt!]
  domain_not_in: [BigInt!]
  receivedRoot: mainnet_Bytes
  receivedRoot_not: mainnet_Bytes
  receivedRoot_gt: mainnet_Bytes
  receivedRoot_lt: mainnet_Bytes
  receivedRoot_gte: mainnet_Bytes
  receivedRoot_lte: mainnet_Bytes
  receivedRoot_in: [mainnet_Bytes!]
  receivedRoot_not_in: [mainnet_Bytes!]
  receivedRoot_contains: mainnet_Bytes
  receivedRoot_not_contains: mainnet_Bytes
  index: BigInt
  index_not: BigInt
  index_gt: BigInt
  index_lt: BigInt
  index_gte: BigInt
  index_lte: BigInt
  index_in: [BigInt!]
  index_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: mainnet_BlockChangedFilter
  and: [mainnet_RootAggregated_filter]
  or: [mainnet_RootAggregated_filter]
}

enum mainnet_RootAggregated_orderBy {
  id
  domain
  receivedRoot
  index
}

type mainnet_RootManagerMeta {
  id: ID!
  domains: [BigInt!]
  connectors: [mainnet_Bytes!]
}

input mainnet_RootManagerMeta_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  domains: [BigInt!]
  domains_not: [BigInt!]
  domains_contains: [BigInt!]
  domains_contains_nocase: [BigInt!]
  domains_not_contains: [BigInt!]
  domains_not_contains_nocase: [BigInt!]
  connectors: [mainnet_Bytes!]
  connectors_not: [mainnet_Bytes!]
  connectors_contains: [mainnet_Bytes!]
  connectors_contains_nocase: [mainnet_Bytes!]
  connectors_not_contains: [mainnet_Bytes!]
  connectors_not_contains_nocase: [mainnet_Bytes!]
  """Filter for the block changed event."""
  _change_block: mainnet_BlockChangedFilter
  and: [mainnet_RootManagerMeta_filter]
  or: [mainnet_RootManagerMeta_filter]
}

enum mainnet_RootManagerMeta_orderBy {
  id
  domains
  connectors
}

type mainnet_RootManagerMode {
  id: ID!
  mode: String!
}

input mainnet_RootManagerMode_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  mode: String
  mode_not: String
  mode_gt: String
  mode_lt: String
  mode_gte: String
  mode_lte: String
  mode_in: [String!]
  mode_not_in: [String!]
  mode_contains: String
  mode_contains_nocase: String
  mode_not_contains: String
  mode_not_contains_nocase: String
  mode_starts_with: String
  mode_starts_with_nocase: String
  mode_not_starts_with: String
  mode_not_starts_with_nocase: String
  mode_ends_with: String
  mode_ends_with_nocase: String
  mode_not_ends_with: String
  mode_not_ends_with_nocase: String
  """Filter for the block changed event."""
  _change_block: mainnet_BlockChangedFilter
  and: [mainnet_RootManagerMode_filter]
  or: [mainnet_RootManagerMode_filter]
}

enum mainnet_RootManagerMode_orderBy {
  id
  mode
}

type mainnet_RootMessageProcessed {
  id: ID!
  spokeDomain: BigInt!
  hubDomain: BigInt!
  root: mainnet_Bytes
  caller: mainnet_Bytes
  transactionHash: mainnet_Bytes
  timestamp: BigInt
  gasPrice: BigInt
  gasLimit: BigInt
  blockNumber: BigInt
}

input mainnet_RootMessageProcessed_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  spokeDomain: BigInt
  spokeDomain_not: BigInt
  spokeDomain_gt: BigInt
  spokeDomain_lt: BigInt
  spokeDomain_gte: BigInt
  spokeDomain_lte: BigInt
  spokeDomain_in: [BigInt!]
  spokeDomain_not_in: [BigInt!]
  hubDomain: BigInt
  hubDomain_not: BigInt
  hubDomain_gt: BigInt
  hubDomain_lt: BigInt
  hubDomain_gte: BigInt
  hubDomain_lte: BigInt
  hubDomain_in: [BigInt!]
  hubDomain_not_in: [BigInt!]
  root: mainnet_Bytes
  root_not: mainnet_Bytes
  root_gt: mainnet_Bytes
  root_lt: mainnet_Bytes
  root_gte: mainnet_Bytes
  root_lte: mainnet_Bytes
  root_in: [mainnet_Bytes!]
  root_not_in: [mainnet_Bytes!]
  root_contains: mainnet_Bytes
  root_not_contains: mainnet_Bytes
  caller: mainnet_Bytes
  caller_not: mainnet_Bytes
  caller_gt: mainnet_Bytes
  caller_lt: mainnet_Bytes
  caller_gte: mainnet_Bytes
  caller_lte: mainnet_Bytes
  caller_in: [mainnet_Bytes!]
  caller_not_in: [mainnet_Bytes!]
  caller_contains: mainnet_Bytes
  caller_not_contains: mainnet_Bytes
  transactionHash: mainnet_Bytes
  transactionHash_not: mainnet_Bytes
  transactionHash_gt: mainnet_Bytes
  transactionHash_lt: mainnet_Bytes
  transactionHash_gte: mainnet_Bytes
  transactionHash_lte: mainnet_Bytes
  transactionHash_in: [mainnet_Bytes!]
  transactionHash_not_in: [mainnet_Bytes!]
  transactionHash_contains: mainnet_Bytes
  transactionHash_not_contains: mainnet_Bytes
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  gasLimit: BigInt
  gasLimit_not: BigInt
  gasLimit_gt: BigInt
  gasLimit_lt: BigInt
  gasLimit_gte: BigInt
  gasLimit_lte: BigInt
  gasLimit_in: [BigInt!]
  gasLimit_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: mainnet_BlockChangedFilter
  and: [mainnet_RootMessageProcessed_filter]
  or: [mainnet_RootMessageProcessed_filter]
}

enum mainnet_RootMessageProcessed_orderBy {
  id
  spokeDomain
  hubDomain
  root
  caller
  transactionHash
  timestamp
  gasPrice
  gasLimit
  blockNumber
}

type mainnet_RootPropagated {
  id: ID!
  aggregate: mainnet_Bytes!
  domainsHash: mainnet_Bytes!
  count: BigInt!
  blockNumber: BigInt
}

input mainnet_RootPropagated_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  aggregate: mainnet_Bytes
  aggregate_not: mainnet_Bytes
  aggregate_gt: mainnet_Bytes
  aggregate_lt: mainnet_Bytes
  aggregate_gte: mainnet_Bytes
  aggregate_lte: mainnet_Bytes
  aggregate_in: [mainnet_Bytes!]
  aggregate_not_in: [mainnet_Bytes!]
  aggregate_contains: mainnet_Bytes
  aggregate_not_contains: mainnet_Bytes
  domainsHash: mainnet_Bytes
  domainsHash_not: mainnet_Bytes
  domainsHash_gt: mainnet_Bytes
  domainsHash_lt: mainnet_Bytes
  domainsHash_gte: mainnet_Bytes
  domainsHash_lte: mainnet_Bytes
  domainsHash_in: [mainnet_Bytes!]
  domainsHash_not_in: [mainnet_Bytes!]
  domainsHash_contains: mainnet_Bytes
  domainsHash_not_contains: mainnet_Bytes
  count: BigInt
  count_not: BigInt
  count_gt: BigInt
  count_lt: BigInt
  count_gte: BigInt
  count_lte: BigInt
  count_in: [BigInt!]
  count_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: mainnet_BlockChangedFilter
  and: [mainnet_RootPropagated_filter]
  or: [mainnet_RootPropagated_filter]
}

enum mainnet_RootPropagated_orderBy {
  id
  aggregate
  domainsHash
  count
  blockNumber
}

type mainnet_ScrollConnectorMeta {
  id: ID!
  spokeDomain: BigInt!
  hubDomain: BigInt!
  amb: mainnet_Bytes!
  rootManager: mainnet_Bytes!
  mirrorConnector: mainnet_Bytes!
}

input mainnet_ScrollConnectorMeta_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  spokeDomain: BigInt
  spokeDomain_not: BigInt
  spokeDomain_gt: BigInt
  spokeDomain_lt: BigInt
  spokeDomain_gte: BigInt
  spokeDomain_lte: BigInt
  spokeDomain_in: [BigInt!]
  spokeDomain_not_in: [BigInt!]
  hubDomain: BigInt
  hubDomain_not: BigInt
  hubDomain_gt: BigInt
  hubDomain_lt: BigInt
  hubDomain_gte: BigInt
  hubDomain_lte: BigInt
  hubDomain_in: [BigInt!]
  hubDomain_not_in: [BigInt!]
  amb: mainnet_Bytes
  amb_not: mainnet_Bytes
  amb_gt: mainnet_Bytes
  amb_lt: mainnet_Bytes
  amb_gte: mainnet_Bytes
  amb_lte: mainnet_Bytes
  amb_in: [mainnet_Bytes!]
  amb_not_in: [mainnet_Bytes!]
  amb_contains: mainnet_Bytes
  amb_not_contains: mainnet_Bytes
  rootManager: mainnet_Bytes
  rootManager_not: mainnet_Bytes
  rootManager_gt: mainnet_Bytes
  rootManager_lt: mainnet_Bytes
  rootManager_gte: mainnet_Bytes
  rootManager_lte: mainnet_Bytes
  rootManager_in: [mainnet_Bytes!]
  rootManager_not_in: [mainnet_Bytes!]
  rootManager_contains: mainnet_Bytes
  rootManager_not_contains: mainnet_Bytes
  mirrorConnector: mainnet_Bytes
  mirrorConnector_not: mainnet_Bytes
  mirrorConnector_gt: mainnet_Bytes
  mirrorConnector_lt: mainnet_Bytes
  mirrorConnector_gte: mainnet_Bytes
  mirrorConnector_lte: mainnet_Bytes
  mirrorConnector_in: [mainnet_Bytes!]
  mirrorConnector_not_in: [mainnet_Bytes!]
  mirrorConnector_contains: mainnet_Bytes
  mirrorConnector_not_contains: mainnet_Bytes
  """Filter for the block changed event."""
  _change_block: mainnet_BlockChangedFilter
  and: [mainnet_ScrollConnectorMeta_filter]
  or: [mainnet_ScrollConnectorMeta_filter]
}

enum mainnet_ScrollConnectorMeta_orderBy {
  id
  spokeDomain
  hubDomain
  amb
  rootManager
  mirrorConnector
}

type mainnet_XlayerConnectorMeta {
  id: ID!
  spokeDomain: BigInt!
  hubDomain: BigInt!
  amb: mainnet_Bytes!
  rootManager: mainnet_Bytes!
  mirrorConnector: mainnet_Bytes!
}

input mainnet_XlayerConnectorMeta_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  spokeDomain: BigInt
  spokeDomain_not: BigInt
  spokeDomain_gt: BigInt
  spokeDomain_lt: BigInt
  spokeDomain_gte: BigInt
  spokeDomain_lte: BigInt
  spokeDomain_in: [BigInt!]
  spokeDomain_not_in: [BigInt!]
  hubDomain: BigInt
  hubDomain_not: BigInt
  hubDomain_gt: BigInt
  hubDomain_lt: BigInt
  hubDomain_gte: BigInt
  hubDomain_lte: BigInt
  hubDomain_in: [BigInt!]
  hubDomain_not_in: [BigInt!]
  amb: mainnet_Bytes
  amb_not: mainnet_Bytes
  amb_gt: mainnet_Bytes
  amb_lt: mainnet_Bytes
  amb_gte: mainnet_Bytes
  amb_lte: mainnet_Bytes
  amb_in: [mainnet_Bytes!]
  amb_not_in: [mainnet_Bytes!]
  amb_contains: mainnet_Bytes
  amb_not_contains: mainnet_Bytes
  rootManager: mainnet_Bytes
  rootManager_not: mainnet_Bytes
  rootManager_gt: mainnet_Bytes
  rootManager_lt: mainnet_Bytes
  rootManager_gte: mainnet_Bytes
  rootManager_lte: mainnet_Bytes
  rootManager_in: [mainnet_Bytes!]
  rootManager_not_in: [mainnet_Bytes!]
  rootManager_contains: mainnet_Bytes
  rootManager_not_contains: mainnet_Bytes
  mirrorConnector: mainnet_Bytes
  mirrorConnector_not: mainnet_Bytes
  mirrorConnector_gt: mainnet_Bytes
  mirrorConnector_lt: mainnet_Bytes
  mirrorConnector_gte: mainnet_Bytes
  mirrorConnector_lte: mainnet_Bytes
  mirrorConnector_in: [mainnet_Bytes!]
  mirrorConnector_not_in: [mainnet_Bytes!]
  mirrorConnector_contains: mainnet_Bytes
  mirrorConnector_not_contains: mainnet_Bytes
  """Filter for the block changed event."""
  _change_block: mainnet_BlockChangedFilter
  and: [mainnet_XlayerConnectorMeta_filter]
  or: [mainnet_XlayerConnectorMeta_filter]
}

enum mainnet_XlayerConnectorMeta_orderBy {
  id
  spokeDomain
  hubDomain
  amb
  rootManager
  mirrorConnector
}

type mainnet_ZkSyncConnectorMeta {
  id: ID!
  spokeDomain: BigInt!
  hubDomain: BigInt!
  amb: mainnet_Bytes!
  rootManager: mainnet_Bytes!
  mirrorConnector: mainnet_Bytes!
}

input mainnet_ZkSyncConnectorMeta_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  spokeDomain: BigInt
  spokeDomain_not: BigInt
  spokeDomain_gt: BigInt
  spokeDomain_lt: BigInt
  spokeDomain_gte: BigInt
  spokeDomain_lte: BigInt
  spokeDomain_in: [BigInt!]
  spokeDomain_not_in: [BigInt!]
  hubDomain: BigInt
  hubDomain_not: BigInt
  hubDomain_gt: BigInt
  hubDomain_lt: BigInt
  hubDomain_gte: BigInt
  hubDomain_lte: BigInt
  hubDomain_in: [BigInt!]
  hubDomain_not_in: [BigInt!]
  amb: mainnet_Bytes
  amb_not: mainnet_Bytes
  amb_gt: mainnet_Bytes
  amb_lt: mainnet_Bytes
  amb_gte: mainnet_Bytes
  amb_lte: mainnet_Bytes
  amb_in: [mainnet_Bytes!]
  amb_not_in: [mainnet_Bytes!]
  amb_contains: mainnet_Bytes
  amb_not_contains: mainnet_Bytes
  rootManager: mainnet_Bytes
  rootManager_not: mainnet_Bytes
  rootManager_gt: mainnet_Bytes
  rootManager_lt: mainnet_Bytes
  rootManager_gte: mainnet_Bytes
  rootManager_lte: mainnet_Bytes
  rootManager_in: [mainnet_Bytes!]
  rootManager_not_in: [mainnet_Bytes!]
  rootManager_contains: mainnet_Bytes
  rootManager_not_contains: mainnet_Bytes
  mirrorConnector: mainnet_Bytes
  mirrorConnector_not: mainnet_Bytes
  mirrorConnector_gt: mainnet_Bytes
  mirrorConnector_lt: mainnet_Bytes
  mirrorConnector_gte: mainnet_Bytes
  mirrorConnector_lte: mainnet_Bytes
  mirrorConnector_in: [mainnet_Bytes!]
  mirrorConnector_not_in: [mainnet_Bytes!]
  mirrorConnector_contains: mainnet_Bytes
  mirrorConnector_not_contains: mainnet_Bytes
  """Filter for the block changed event."""
  _change_block: mainnet_BlockChangedFilter
  and: [mainnet_ZkSyncConnectorMeta_filter]
  or: [mainnet_ZkSyncConnectorMeta_filter]
}

enum mainnet_ZkSyncConnectorMeta_orderBy {
  id
  spokeDomain
  hubDomain
  amb
  rootManager
  mirrorConnector
}

type mainnet__Block_ {
  """The hash of the block"""
  hash: mainnet_Bytes
  """The block number"""
  number: Int!
  """Integer representation of the timestamp stored in blocks for the chain"""
  timestamp: Int
  """The hash of the parent block"""
  parentHash: mainnet_Bytes
}

"""The type for the top-level _meta field"""
type mainnet__Meta_ {
  """
  Information about a specific subgraph block. The hash of the block
  will be null if the _meta field has a block constraint that asks for
  a block number. It will be filled if the _meta field has no block constraint
  and therefore asks for the latest  block
  
  """
  block: mainnet__Block_!
  """The deployment ID"""
  deployment: String!
  """If `true`, the subgraph encountered indexing errors at some past block"""
  hasIndexingErrors: Boolean!
}

type polygonzkevm_AggregateRoot {
  id: ID!
  root: polygonzkevm_Bytes!
  blockNumber: BigInt!
}

type polygonzkevm_AggregateRootProposed {
  id: ID!
  aggregateRoot: polygonzkevm_Bytes!
  rootTimestamp: BigInt!
  endOfDispute: BigInt!
  domain: BigInt!
  timestamp: BigInt!
  blockNumber: BigInt
}

input polygonzkevm_AggregateRootProposed_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  aggregateRoot: polygonzkevm_Bytes
  aggregateRoot_not: polygonzkevm_Bytes
  aggregateRoot_gt: polygonzkevm_Bytes
  aggregateRoot_lt: polygonzkevm_Bytes
  aggregateRoot_gte: polygonzkevm_Bytes
  aggregateRoot_lte: polygonzkevm_Bytes
  aggregateRoot_in: [polygonzkevm_Bytes!]
  aggregateRoot_not_in: [polygonzkevm_Bytes!]
  aggregateRoot_contains: polygonzkevm_Bytes
  aggregateRoot_not_contains: polygonzkevm_Bytes
  rootTimestamp: BigInt
  rootTimestamp_not: BigInt
  rootTimestamp_gt: BigInt
  rootTimestamp_lt: BigInt
  rootTimestamp_gte: BigInt
  rootTimestamp_lte: BigInt
  rootTimestamp_in: [BigInt!]
  rootTimestamp_not_in: [BigInt!]
  endOfDispute: BigInt
  endOfDispute_not: BigInt
  endOfDispute_gt: BigInt
  endOfDispute_lt: BigInt
  endOfDispute_gte: BigInt
  endOfDispute_lte: BigInt
  endOfDispute_in: [BigInt!]
  endOfDispute_not_in: [BigInt!]
  domain: BigInt
  domain_not: BigInt
  domain_gt: BigInt
  domain_lt: BigInt
  domain_gte: BigInt
  domain_lte: BigInt
  domain_in: [BigInt!]
  domain_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: polygonzkevm_BlockChangedFilter
  and: [polygonzkevm_AggregateRootProposed_filter]
  or: [polygonzkevm_AggregateRootProposed_filter]
}

enum polygonzkevm_AggregateRootProposed_orderBy {
  id
  aggregateRoot
  rootTimestamp
  endOfDispute
  domain
  timestamp
  blockNumber
}

input polygonzkevm_AggregateRoot_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  root: polygonzkevm_Bytes
  root_not: polygonzkevm_Bytes
  root_gt: polygonzkevm_Bytes
  root_lt: polygonzkevm_Bytes
  root_gte: polygonzkevm_Bytes
  root_lte: polygonzkevm_Bytes
  root_in: [polygonzkevm_Bytes!]
  root_not_in: [polygonzkevm_Bytes!]
  root_contains: polygonzkevm_Bytes
  root_not_contains: polygonzkevm_Bytes
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: polygonzkevm_BlockChangedFilter
  and: [polygonzkevm_AggregateRoot_filter]
  or: [polygonzkevm_AggregateRoot_filter]
}

enum polygonzkevm_AggregateRoot_orderBy {
  id
  root
  blockNumber
}

enum polygonzkevm_Aggregation_interval {
  hour
  day
}

type polygonzkevm_Asset {
  id: ID!
  key: polygonzkevm_Bytes
  decimal: BigInt
  adoptedDecimal: BigInt
  canonicalId: polygonzkevm_Bytes
  canonicalDomain: BigInt
  adoptedAsset: polygonzkevm_Bytes
  localAsset: polygonzkevm_Bytes
  blockNumber: BigInt
  status: polygonzkevm_AssetStatus
}

type polygonzkevm_AssetBalance {
  id: ID!
  amount: BigInt!
  locked: BigInt!
  supplied: BigInt!
  removed: BigInt!
  router: polygonzkevm_Router!
  asset: polygonzkevm_Asset!
  feesEarned: BigInt!
}

input polygonzkevm_AssetBalance_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  locked: BigInt
  locked_not: BigInt
  locked_gt: BigInt
  locked_lt: BigInt
  locked_gte: BigInt
  locked_lte: BigInt
  locked_in: [BigInt!]
  locked_not_in: [BigInt!]
  supplied: BigInt
  supplied_not: BigInt
  supplied_gt: BigInt
  supplied_lt: BigInt
  supplied_gte: BigInt
  supplied_lte: BigInt
  supplied_in: [BigInt!]
  supplied_not_in: [BigInt!]
  removed: BigInt
  removed_not: BigInt
  removed_gt: BigInt
  removed_lt: BigInt
  removed_gte: BigInt
  removed_lte: BigInt
  removed_in: [BigInt!]
  removed_not_in: [BigInt!]
  router: String
  router_not: String
  router_gt: String
  router_lt: String
  router_gte: String
  router_lte: String
  router_in: [String!]
  router_not_in: [String!]
  router_contains: String
  router_contains_nocase: String
  router_not_contains: String
  router_not_contains_nocase: String
  router_starts_with: String
  router_starts_with_nocase: String
  router_not_starts_with: String
  router_not_starts_with_nocase: String
  router_ends_with: String
  router_ends_with_nocase: String
  router_not_ends_with: String
  router_not_ends_with_nocase: String
  router_: polygonzkevm_Router_filter
  asset: String
  asset_not: String
  asset_gt: String
  asset_lt: String
  asset_gte: String
  asset_lte: String
  asset_in: [String!]
  asset_not_in: [String!]
  asset_contains: String
  asset_contains_nocase: String
  asset_not_contains: String
  asset_not_contains_nocase: String
  asset_starts_with: String
  asset_starts_with_nocase: String
  asset_not_starts_with: String
  asset_not_starts_with_nocase: String
  asset_ends_with: String
  asset_ends_with_nocase: String
  asset_not_ends_with: String
  asset_not_ends_with_nocase: String
  asset_: polygonzkevm_Asset_filter
  feesEarned: BigInt
  feesEarned_not: BigInt
  feesEarned_gt: BigInt
  feesEarned_lt: BigInt
  feesEarned_gte: BigInt
  feesEarned_lte: BigInt
  feesEarned_in: [BigInt!]
  feesEarned_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: polygonzkevm_BlockChangedFilter
  and: [polygonzkevm_AssetBalance_filter]
  or: [polygonzkevm_AssetBalance_filter]
}

enum polygonzkevm_AssetBalance_orderBy {
  id
  amount
  locked
  supplied
  removed
  router
  router__id
  router__isActive
  router__owner
  router__recipient
  router__proposedOwner
  router__proposedTimestamp
  asset
  asset__id
  asset__key
  asset__decimal
  asset__adoptedDecimal
  asset__canonicalId
  asset__canonicalDomain
  asset__adoptedAsset
  asset__localAsset
  asset__blockNumber
  feesEarned
}

type polygonzkevm_AssetStatus {
  id: ID!
  status: Boolean
}

input polygonzkevm_AssetStatus_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  status: Boolean
  status_not: Boolean
  status_in: [Boolean!]
  status_not_in: [Boolean!]
  """Filter for the block changed event."""
  _change_block: polygonzkevm_BlockChangedFilter
  and: [polygonzkevm_AssetStatus_filter]
  or: [polygonzkevm_AssetStatus_filter]
}

enum polygonzkevm_AssetStatus_orderBy {
  id
  status
}

input polygonzkevm_Asset_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  key: polygonzkevm_Bytes
  key_not: polygonzkevm_Bytes
  key_gt: polygonzkevm_Bytes
  key_lt: polygonzkevm_Bytes
  key_gte: polygonzkevm_Bytes
  key_lte: polygonzkevm_Bytes
  key_in: [polygonzkevm_Bytes!]
  key_not_in: [polygonzkevm_Bytes!]
  key_contains: polygonzkevm_Bytes
  key_not_contains: polygonzkevm_Bytes
  decimal: BigInt
  decimal_not: BigInt
  decimal_gt: BigInt
  decimal_lt: BigInt
  decimal_gte: BigInt
  decimal_lte: BigInt
  decimal_in: [BigInt!]
  decimal_not_in: [BigInt!]
  adoptedDecimal: BigInt
  adoptedDecimal_not: BigInt
  adoptedDecimal_gt: BigInt
  adoptedDecimal_lt: BigInt
  adoptedDecimal_gte: BigInt
  adoptedDecimal_lte: BigInt
  adoptedDecimal_in: [BigInt!]
  adoptedDecimal_not_in: [BigInt!]
  canonicalId: polygonzkevm_Bytes
  canonicalId_not: polygonzkevm_Bytes
  canonicalId_gt: polygonzkevm_Bytes
  canonicalId_lt: polygonzkevm_Bytes
  canonicalId_gte: polygonzkevm_Bytes
  canonicalId_lte: polygonzkevm_Bytes
  canonicalId_in: [polygonzkevm_Bytes!]
  canonicalId_not_in: [polygonzkevm_Bytes!]
  canonicalId_contains: polygonzkevm_Bytes
  canonicalId_not_contains: polygonzkevm_Bytes
  canonicalDomain: BigInt
  canonicalDomain_not: BigInt
  canonicalDomain_gt: BigInt
  canonicalDomain_lt: BigInt
  canonicalDomain_gte: BigInt
  canonicalDomain_lte: BigInt
  canonicalDomain_in: [BigInt!]
  canonicalDomain_not_in: [BigInt!]
  adoptedAsset: polygonzkevm_Bytes
  adoptedAsset_not: polygonzkevm_Bytes
  adoptedAsset_gt: polygonzkevm_Bytes
  adoptedAsset_lt: polygonzkevm_Bytes
  adoptedAsset_gte: polygonzkevm_Bytes
  adoptedAsset_lte: polygonzkevm_Bytes
  adoptedAsset_in: [polygonzkevm_Bytes!]
  adoptedAsset_not_in: [polygonzkevm_Bytes!]
  adoptedAsset_contains: polygonzkevm_Bytes
  adoptedAsset_not_contains: polygonzkevm_Bytes
  localAsset: polygonzkevm_Bytes
  localAsset_not: polygonzkevm_Bytes
  localAsset_gt: polygonzkevm_Bytes
  localAsset_lt: polygonzkevm_Bytes
  localAsset_gte: polygonzkevm_Bytes
  localAsset_lte: polygonzkevm_Bytes
  localAsset_in: [polygonzkevm_Bytes!]
  localAsset_not_in: [polygonzkevm_Bytes!]
  localAsset_contains: polygonzkevm_Bytes
  localAsset_not_contains: polygonzkevm_Bytes
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  status: String
  status_not: String
  status_gt: String
  status_lt: String
  status_gte: String
  status_lte: String
  status_in: [String!]
  status_not_in: [String!]
  status_contains: String
  status_contains_nocase: String
  status_not_contains: String
  status_not_contains_nocase: String
  status_starts_with: String
  status_starts_with_nocase: String
  status_not_starts_with: String
  status_not_starts_with_nocase: String
  status_ends_with: String
  status_ends_with_nocase: String
  status_not_ends_with: String
  status_not_ends_with_nocase: String
  status_: polygonzkevm_AssetStatus_filter
  """Filter for the block changed event."""
  _change_block: polygonzkevm_BlockChangedFilter
  and: [polygonzkevm_Asset_filter]
  or: [polygonzkevm_Asset_filter]
}

enum polygonzkevm_Asset_orderBy {
  id
  key
  decimal
  adoptedDecimal
  canonicalId
  canonicalDomain
  adoptedAsset
  localAsset
  blockNumber
  status
  status__id
  status__status
}

scalar polygonzkevm_BigDecimal

input polygonzkevm_BlockChangedFilter {
  number_gte: Int!
}

input polygonzkevm_Block_height {
  hash: polygonzkevm_Bytes
  number: Int
  number_gte: Int
}

scalar polygonzkevm_Bytes

type polygonzkevm_ConnectorMeta {
  id: ID!
  spokeDomain: BigInt
  hubDomain: BigInt
  amb: polygonzkevm_Bytes
  rootManager: polygonzkevm_Bytes
  mirrorConnector: polygonzkevm_Bytes
}

input polygonzkevm_ConnectorMeta_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  spokeDomain: BigInt
  spokeDomain_not: BigInt
  spokeDomain_gt: BigInt
  spokeDomain_lt: BigInt
  spokeDomain_gte: BigInt
  spokeDomain_lte: BigInt
  spokeDomain_in: [BigInt!]
  spokeDomain_not_in: [BigInt!]
  hubDomain: BigInt
  hubDomain_not: BigInt
  hubDomain_gt: BigInt
  hubDomain_lt: BigInt
  hubDomain_gte: BigInt
  hubDomain_lte: BigInt
  hubDomain_in: [BigInt!]
  hubDomain_not_in: [BigInt!]
  amb: polygonzkevm_Bytes
  amb_not: polygonzkevm_Bytes
  amb_gt: polygonzkevm_Bytes
  amb_lt: polygonzkevm_Bytes
  amb_gte: polygonzkevm_Bytes
  amb_lte: polygonzkevm_Bytes
  amb_in: [polygonzkevm_Bytes!]
  amb_not_in: [polygonzkevm_Bytes!]
  amb_contains: polygonzkevm_Bytes
  amb_not_contains: polygonzkevm_Bytes
  rootManager: polygonzkevm_Bytes
  rootManager_not: polygonzkevm_Bytes
  rootManager_gt: polygonzkevm_Bytes
  rootManager_lt: polygonzkevm_Bytes
  rootManager_gte: polygonzkevm_Bytes
  rootManager_lte: polygonzkevm_Bytes
  rootManager_in: [polygonzkevm_Bytes!]
  rootManager_not_in: [polygonzkevm_Bytes!]
  rootManager_contains: polygonzkevm_Bytes
  rootManager_not_contains: polygonzkevm_Bytes
  mirrorConnector: polygonzkevm_Bytes
  mirrorConnector_not: polygonzkevm_Bytes
  mirrorConnector_gt: polygonzkevm_Bytes
  mirrorConnector_lt: polygonzkevm_Bytes
  mirrorConnector_gte: polygonzkevm_Bytes
  mirrorConnector_lte: polygonzkevm_Bytes
  mirrorConnector_in: [polygonzkevm_Bytes!]
  mirrorConnector_not_in: [polygonzkevm_Bytes!]
  mirrorConnector_contains: polygonzkevm_Bytes
  mirrorConnector_not_contains: polygonzkevm_Bytes
  """Filter for the block changed event."""
  _change_block: polygonzkevm_BlockChangedFilter
  and: [polygonzkevm_ConnectorMeta_filter]
  or: [polygonzkevm_ConnectorMeta_filter]
}

enum polygonzkevm_ConnectorMeta_orderBy {
  id
  spokeDomain
  hubDomain
  amb
  rootManager
  mirrorConnector
}

type polygonzkevm_DestinationTransfer {
  id: ID!
  chainId: BigInt
  transferId: polygonzkevm_Bytes
  nonce: BigInt
  status: polygonzkevm_TransferStatus
  routers(skip: Int = 0, first: Int = 100, orderBy: polygonzkevm_Router_orderBy, orderDirection: polygonzkevm_OrderDirection, where: polygonzkevm_Router_filter): [polygonzkevm_Router!]
  originDomain: BigInt
  destinationDomain: BigInt
  canonicalDomain: BigInt
  to: polygonzkevm_Bytes
  delegate: polygonzkevm_Bytes
  receiveLocal: Boolean
  callData: polygonzkevm_Bytes
  slippage: BigInt
  bumpSlippageCount: BigInt
  originSender: polygonzkevm_Bytes
  bridgedAmt: BigInt
  normalizedIn: BigInt
  canonicalId: polygonzkevm_Bytes
  asset: polygonzkevm_Asset
  amount: BigInt
  routersFee: BigInt
  executedCaller: polygonzkevm_Bytes
  executedTransactionHash: polygonzkevm_Bytes
  executedTimestamp: BigInt
  executedGasPrice: BigInt
  executedGasLimit: BigInt
  executedBlockNumber: BigInt
  executedTxOrigin: polygonzkevm_Bytes
  executedTxNonce: BigInt
  reconciledCaller: polygonzkevm_Bytes
  reconciledTransactionHash: polygonzkevm_Bytes
  reconciledTimestamp: BigInt
  reconciledGasPrice: BigInt
  reconciledGasLimit: BigInt
  reconciledBlockNumber: BigInt
  reconciledTxOrigin: polygonzkevm_Bytes
  reconciledTxNonce: BigInt
}

input polygonzkevm_DestinationTransfer_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  chainId: BigInt
  chainId_not: BigInt
  chainId_gt: BigInt
  chainId_lt: BigInt
  chainId_gte: BigInt
  chainId_lte: BigInt
  chainId_in: [BigInt!]
  chainId_not_in: [BigInt!]
  transferId: polygonzkevm_Bytes
  transferId_not: polygonzkevm_Bytes
  transferId_gt: polygonzkevm_Bytes
  transferId_lt: polygonzkevm_Bytes
  transferId_gte: polygonzkevm_Bytes
  transferId_lte: polygonzkevm_Bytes
  transferId_in: [polygonzkevm_Bytes!]
  transferId_not_in: [polygonzkevm_Bytes!]
  transferId_contains: polygonzkevm_Bytes
  transferId_not_contains: polygonzkevm_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  status: polygonzkevm_TransferStatus
  status_not: polygonzkevm_TransferStatus
  status_in: [polygonzkevm_TransferStatus!]
  status_not_in: [polygonzkevm_TransferStatus!]
  routers: [String!]
  routers_not: [String!]
  routers_contains: [String!]
  routers_contains_nocase: [String!]
  routers_not_contains: [String!]
  routers_not_contains_nocase: [String!]
  routers_: polygonzkevm_Router_filter
  originDomain: BigInt
  originDomain_not: BigInt
  originDomain_gt: BigInt
  originDomain_lt: BigInt
  originDomain_gte: BigInt
  originDomain_lte: BigInt
  originDomain_in: [BigInt!]
  originDomain_not_in: [BigInt!]
  destinationDomain: BigInt
  destinationDomain_not: BigInt
  destinationDomain_gt: BigInt
  destinationDomain_lt: BigInt
  destinationDomain_gte: BigInt
  destinationDomain_lte: BigInt
  destinationDomain_in: [BigInt!]
  destinationDomain_not_in: [BigInt!]
  canonicalDomain: BigInt
  canonicalDomain_not: BigInt
  canonicalDomain_gt: BigInt
  canonicalDomain_lt: BigInt
  canonicalDomain_gte: BigInt
  canonicalDomain_lte: BigInt
  canonicalDomain_in: [BigInt!]
  canonicalDomain_not_in: [BigInt!]
  to: polygonzkevm_Bytes
  to_not: polygonzkevm_Bytes
  to_gt: polygonzkevm_Bytes
  to_lt: polygonzkevm_Bytes
  to_gte: polygonzkevm_Bytes
  to_lte: polygonzkevm_Bytes
  to_in: [polygonzkevm_Bytes!]
  to_not_in: [polygonzkevm_Bytes!]
  to_contains: polygonzkevm_Bytes
  to_not_contains: polygonzkevm_Bytes
  delegate: polygonzkevm_Bytes
  delegate_not: polygonzkevm_Bytes
  delegate_gt: polygonzkevm_Bytes
  delegate_lt: polygonzkevm_Bytes
  delegate_gte: polygonzkevm_Bytes
  delegate_lte: polygonzkevm_Bytes
  delegate_in: [polygonzkevm_Bytes!]
  delegate_not_in: [polygonzkevm_Bytes!]
  delegate_contains: polygonzkevm_Bytes
  delegate_not_contains: polygonzkevm_Bytes
  receiveLocal: Boolean
  receiveLocal_not: Boolean
  receiveLocal_in: [Boolean!]
  receiveLocal_not_in: [Boolean!]
  callData: polygonzkevm_Bytes
  callData_not: polygonzkevm_Bytes
  callData_gt: polygonzkevm_Bytes
  callData_lt: polygonzkevm_Bytes
  callData_gte: polygonzkevm_Bytes
  callData_lte: polygonzkevm_Bytes
  callData_in: [polygonzkevm_Bytes!]
  callData_not_in: [polygonzkevm_Bytes!]
  callData_contains: polygonzkevm_Bytes
  callData_not_contains: polygonzkevm_Bytes
  slippage: BigInt
  slippage_not: BigInt
  slippage_gt: BigInt
  slippage_lt: BigInt
  slippage_gte: BigInt
  slippage_lte: BigInt
  slippage_in: [BigInt!]
  slippage_not_in: [BigInt!]
  bumpSlippageCount: BigInt
  bumpSlippageCount_not: BigInt
  bumpSlippageCount_gt: BigInt
  bumpSlippageCount_lt: BigInt
  bumpSlippageCount_gte: BigInt
  bumpSlippageCount_lte: BigInt
  bumpSlippageCount_in: [BigInt!]
  bumpSlippageCount_not_in: [BigInt!]
  originSender: polygonzkevm_Bytes
  originSender_not: polygonzkevm_Bytes
  originSender_gt: polygonzkevm_Bytes
  originSender_lt: polygonzkevm_Bytes
  originSender_gte: polygonzkevm_Bytes
  originSender_lte: polygonzkevm_Bytes
  originSender_in: [polygonzkevm_Bytes!]
  originSender_not_in: [polygonzkevm_Bytes!]
  originSender_contains: polygonzkevm_Bytes
  originSender_not_contains: polygonzkevm_Bytes
  bridgedAmt: BigInt
  bridgedAmt_not: BigInt
  bridgedAmt_gt: BigInt
  bridgedAmt_lt: BigInt
  bridgedAmt_gte: BigInt
  bridgedAmt_lte: BigInt
  bridgedAmt_in: [BigInt!]
  bridgedAmt_not_in: [BigInt!]
  normalizedIn: BigInt
  normalizedIn_not: BigInt
  normalizedIn_gt: BigInt
  normalizedIn_lt: BigInt
  normalizedIn_gte: BigInt
  normalizedIn_lte: BigInt
  normalizedIn_in: [BigInt!]
  normalizedIn_not_in: [BigInt!]
  canonicalId: polygonzkevm_Bytes
  canonicalId_not: polygonzkevm_Bytes
  canonicalId_gt: polygonzkevm_Bytes
  canonicalId_lt: polygonzkevm_Bytes
  canonicalId_gte: polygonzkevm_Bytes
  canonicalId_lte: polygonzkevm_Bytes
  canonicalId_in: [polygonzkevm_Bytes!]
  canonicalId_not_in: [polygonzkevm_Bytes!]
  canonicalId_contains: polygonzkevm_Bytes
  canonicalId_not_contains: polygonzkevm_Bytes
  asset: String
  asset_not: String
  asset_gt: String
  asset_lt: String
  asset_gte: String
  asset_lte: String
  asset_in: [String!]
  asset_not_in: [String!]
  asset_contains: String
  asset_contains_nocase: String
  asset_not_contains: String
  asset_not_contains_nocase: String
  asset_starts_with: String
  asset_starts_with_nocase: String
  asset_not_starts_with: String
  asset_not_starts_with_nocase: String
  asset_ends_with: String
  asset_ends_with_nocase: String
  asset_not_ends_with: String
  asset_not_ends_with_nocase: String
  asset_: polygonzkevm_Asset_filter
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  routersFee: BigInt
  routersFee_not: BigInt
  routersFee_gt: BigInt
  routersFee_lt: BigInt
  routersFee_gte: BigInt
  routersFee_lte: BigInt
  routersFee_in: [BigInt!]
  routersFee_not_in: [BigInt!]
  executedCaller: polygonzkevm_Bytes
  executedCaller_not: polygonzkevm_Bytes
  executedCaller_gt: polygonzkevm_Bytes
  executedCaller_lt: polygonzkevm_Bytes
  executedCaller_gte: polygonzkevm_Bytes
  executedCaller_lte: polygonzkevm_Bytes
  executedCaller_in: [polygonzkevm_Bytes!]
  executedCaller_not_in: [polygonzkevm_Bytes!]
  executedCaller_contains: polygonzkevm_Bytes
  executedCaller_not_contains: polygonzkevm_Bytes
  executedTransactionHash: polygonzkevm_Bytes
  executedTransactionHash_not: polygonzkevm_Bytes
  executedTransactionHash_gt: polygonzkevm_Bytes
  executedTransactionHash_lt: polygonzkevm_Bytes
  executedTransactionHash_gte: polygonzkevm_Bytes
  executedTransactionHash_lte: polygonzkevm_Bytes
  executedTransactionHash_in: [polygonzkevm_Bytes!]
  executedTransactionHash_not_in: [polygonzkevm_Bytes!]
  executedTransactionHash_contains: polygonzkevm_Bytes
  executedTransactionHash_not_contains: polygonzkevm_Bytes
  executedTimestamp: BigInt
  executedTimestamp_not: BigInt
  executedTimestamp_gt: BigInt
  executedTimestamp_lt: BigInt
  executedTimestamp_gte: BigInt
  executedTimestamp_lte: BigInt
  executedTimestamp_in: [BigInt!]
  executedTimestamp_not_in: [BigInt!]
  executedGasPrice: BigInt
  executedGasPrice_not: BigInt
  executedGasPrice_gt: BigInt
  executedGasPrice_lt: BigInt
  executedGasPrice_gte: BigInt
  executedGasPrice_lte: BigInt
  executedGasPrice_in: [BigInt!]
  executedGasPrice_not_in: [BigInt!]
  executedGasLimit: BigInt
  executedGasLimit_not: BigInt
  executedGasLimit_gt: BigInt
  executedGasLimit_lt: BigInt
  executedGasLimit_gte: BigInt
  executedGasLimit_lte: BigInt
  executedGasLimit_in: [BigInt!]
  executedGasLimit_not_in: [BigInt!]
  executedBlockNumber: BigInt
  executedBlockNumber_not: BigInt
  executedBlockNumber_gt: BigInt
  executedBlockNumber_lt: BigInt
  executedBlockNumber_gte: BigInt
  executedBlockNumber_lte: BigInt
  executedBlockNumber_in: [BigInt!]
  executedBlockNumber_not_in: [BigInt!]
  executedTxOrigin: polygonzkevm_Bytes
  executedTxOrigin_not: polygonzkevm_Bytes
  executedTxOrigin_gt: polygonzkevm_Bytes
  executedTxOrigin_lt: polygonzkevm_Bytes
  executedTxOrigin_gte: polygonzkevm_Bytes
  executedTxOrigin_lte: polygonzkevm_Bytes
  executedTxOrigin_in: [polygonzkevm_Bytes!]
  executedTxOrigin_not_in: [polygonzkevm_Bytes!]
  executedTxOrigin_contains: polygonzkevm_Bytes
  executedTxOrigin_not_contains: polygonzkevm_Bytes
  executedTxNonce: BigInt
  executedTxNonce_not: BigInt
  executedTxNonce_gt: BigInt
  executedTxNonce_lt: BigInt
  executedTxNonce_gte: BigInt
  executedTxNonce_lte: BigInt
  executedTxNonce_in: [BigInt!]
  executedTxNonce_not_in: [BigInt!]
  reconciledCaller: polygonzkevm_Bytes
  reconciledCaller_not: polygonzkevm_Bytes
  reconciledCaller_gt: polygonzkevm_Bytes
  reconciledCaller_lt: polygonzkevm_Bytes
  reconciledCaller_gte: polygonzkevm_Bytes
  reconciledCaller_lte: polygonzkevm_Bytes
  reconciledCaller_in: [polygonzkevm_Bytes!]
  reconciledCaller_not_in: [polygonzkevm_Bytes!]
  reconciledCaller_contains: polygonzkevm_Bytes
  reconciledCaller_not_contains: polygonzkevm_Bytes
  reconciledTransactionHash: polygonzkevm_Bytes
  reconciledTransactionHash_not: polygonzkevm_Bytes
  reconciledTransactionHash_gt: polygonzkevm_Bytes
  reconciledTransactionHash_lt: polygonzkevm_Bytes
  reconciledTransactionHash_gte: polygonzkevm_Bytes
  reconciledTransactionHash_lte: polygonzkevm_Bytes
  reconciledTransactionHash_in: [polygonzkevm_Bytes!]
  reconciledTransactionHash_not_in: [polygonzkevm_Bytes!]
  reconciledTransactionHash_contains: polygonzkevm_Bytes
  reconciledTransactionHash_not_contains: polygonzkevm_Bytes
  reconciledTimestamp: BigInt
  reconciledTimestamp_not: BigInt
  reconciledTimestamp_gt: BigInt
  reconciledTimestamp_lt: BigInt
  reconciledTimestamp_gte: BigInt
  reconciledTimestamp_lte: BigInt
  reconciledTimestamp_in: [BigInt!]
  reconciledTimestamp_not_in: [BigInt!]
  reconciledGasPrice: BigInt
  reconciledGasPrice_not: BigInt
  reconciledGasPrice_gt: BigInt
  reconciledGasPrice_lt: BigInt
  reconciledGasPrice_gte: BigInt
  reconciledGasPrice_lte: BigInt
  reconciledGasPrice_in: [BigInt!]
  reconciledGasPrice_not_in: [BigInt!]
  reconciledGasLimit: BigInt
  reconciledGasLimit_not: BigInt
  reconciledGasLimit_gt: BigInt
  reconciledGasLimit_lt: BigInt
  reconciledGasLimit_gte: BigInt
  reconciledGasLimit_lte: BigInt
  reconciledGasLimit_in: [BigInt!]
  reconciledGasLimit_not_in: [BigInt!]
  reconciledBlockNumber: BigInt
  reconciledBlockNumber_not: BigInt
  reconciledBlockNumber_gt: BigInt
  reconciledBlockNumber_lt: BigInt
  reconciledBlockNumber_gte: BigInt
  reconciledBlockNumber_lte: BigInt
  reconciledBlockNumber_in: [BigInt!]
  reconciledBlockNumber_not_in: [BigInt!]
  reconciledTxOrigin: polygonzkevm_Bytes
  reconciledTxOrigin_not: polygonzkevm_Bytes
  reconciledTxOrigin_gt: polygonzkevm_Bytes
  reconciledTxOrigin_lt: polygonzkevm_Bytes
  reconciledTxOrigin_gte: polygonzkevm_Bytes
  reconciledTxOrigin_lte: polygonzkevm_Bytes
  reconciledTxOrigin_in: [polygonzkevm_Bytes!]
  reconciledTxOrigin_not_in: [polygonzkevm_Bytes!]
  reconciledTxOrigin_contains: polygonzkevm_Bytes
  reconciledTxOrigin_not_contains: polygonzkevm_Bytes
  reconciledTxNonce: BigInt
  reconciledTxNonce_not: BigInt
  reconciledTxNonce_gt: BigInt
  reconciledTxNonce_lt: BigInt
  reconciledTxNonce_gte: BigInt
  reconciledTxNonce_lte: BigInt
  reconciledTxNonce_in: [BigInt!]
  reconciledTxNonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: polygonzkevm_BlockChangedFilter
  and: [polygonzkevm_DestinationTransfer_filter]
  or: [polygonzkevm_DestinationTransfer_filter]
}

enum polygonzkevm_DestinationTransfer_orderBy {
  id
  chainId
  transferId
  nonce
  status
  routers
  originDomain
  destinationDomain
  canonicalDomain
  to
  delegate
  receiveLocal
  callData
  slippage
  bumpSlippageCount
  originSender
  bridgedAmt
  normalizedIn
  canonicalId
  asset
  asset__id
  asset__key
  asset__decimal
  asset__adoptedDecimal
  asset__canonicalId
  asset__canonicalDomain
  asset__adoptedAsset
  asset__localAsset
  asset__blockNumber
  amount
  routersFee
  executedCaller
  executedTransactionHash
  executedTimestamp
  executedGasPrice
  executedGasLimit
  executedBlockNumber
  executedTxOrigin
  executedTxNonce
  reconciledCaller
  reconciledTransactionHash
  reconciledTimestamp
  reconciledGasPrice
  reconciledGasLimit
  reconciledBlockNumber
  reconciledTxOrigin
  reconciledTxNonce
}

"""
8 bytes signed integer

"""
scalar polygonzkevm_Int8

type polygonzkevm_OptimisticRootFinalized {
  id: ID!
  aggregateRoot: polygonzkevm_Bytes!
  timestamp: BigInt!
  blockNumber: BigInt
}

input polygonzkevm_OptimisticRootFinalized_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  aggregateRoot: polygonzkevm_Bytes
  aggregateRoot_not: polygonzkevm_Bytes
  aggregateRoot_gt: polygonzkevm_Bytes
  aggregateRoot_lt: polygonzkevm_Bytes
  aggregateRoot_gte: polygonzkevm_Bytes
  aggregateRoot_lte: polygonzkevm_Bytes
  aggregateRoot_in: [polygonzkevm_Bytes!]
  aggregateRoot_not_in: [polygonzkevm_Bytes!]
  aggregateRoot_contains: polygonzkevm_Bytes
  aggregateRoot_not_contains: polygonzkevm_Bytes
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: polygonzkevm_BlockChangedFilter
  and: [polygonzkevm_OptimisticRootFinalized_filter]
  or: [polygonzkevm_OptimisticRootFinalized_filter]
}

enum polygonzkevm_OptimisticRootFinalized_orderBy {
  id
  aggregateRoot
  timestamp
  blockNumber
}

"""Defines the order direction, either ascending or descending"""
enum polygonzkevm_OrderDirection {
  asc
  desc
}

type polygonzkevm_OriginMessage {
  id: ID!
  transferId: polygonzkevm_Bytes
  destinationDomain: BigInt
  leaf: polygonzkevm_Bytes
  index: BigInt
  message: polygonzkevm_Bytes
  root: polygonzkevm_Bytes
  transactionHash: polygonzkevm_Bytes
  blockNumber: BigInt
  rootCount: polygonzkevm_RootCount
}

input polygonzkevm_OriginMessage_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transferId: polygonzkevm_Bytes
  transferId_not: polygonzkevm_Bytes
  transferId_gt: polygonzkevm_Bytes
  transferId_lt: polygonzkevm_Bytes
  transferId_gte: polygonzkevm_Bytes
  transferId_lte: polygonzkevm_Bytes
  transferId_in: [polygonzkevm_Bytes!]
  transferId_not_in: [polygonzkevm_Bytes!]
  transferId_contains: polygonzkevm_Bytes
  transferId_not_contains: polygonzkevm_Bytes
  destinationDomain: BigInt
  destinationDomain_not: BigInt
  destinationDomain_gt: BigInt
  destinationDomain_lt: BigInt
  destinationDomain_gte: BigInt
  destinationDomain_lte: BigInt
  destinationDomain_in: [BigInt!]
  destinationDomain_not_in: [BigInt!]
  leaf: polygonzkevm_Bytes
  leaf_not: polygonzkevm_Bytes
  leaf_gt: polygonzkevm_Bytes
  leaf_lt: polygonzkevm_Bytes
  leaf_gte: polygonzkevm_Bytes
  leaf_lte: polygonzkevm_Bytes
  leaf_in: [polygonzkevm_Bytes!]
  leaf_not_in: [polygonzkevm_Bytes!]
  leaf_contains: polygonzkevm_Bytes
  leaf_not_contains: polygonzkevm_Bytes
  index: BigInt
  index_not: BigInt
  index_gt: BigInt
  index_lt: BigInt
  index_gte: BigInt
  index_lte: BigInt
  index_in: [BigInt!]
  index_not_in: [BigInt!]
  message: polygonzkevm_Bytes
  message_not: polygonzkevm_Bytes
  message_gt: polygonzkevm_Bytes
  message_lt: polygonzkevm_Bytes
  message_gte: polygonzkevm_Bytes
  message_lte: polygonzkevm_Bytes
  message_in: [polygonzkevm_Bytes!]
  message_not_in: [polygonzkevm_Bytes!]
  message_contains: polygonzkevm_Bytes
  message_not_contains: polygonzkevm_Bytes
  root: polygonzkevm_Bytes
  root_not: polygonzkevm_Bytes
  root_gt: polygonzkevm_Bytes
  root_lt: polygonzkevm_Bytes
  root_gte: polygonzkevm_Bytes
  root_lte: polygonzkevm_Bytes
  root_in: [polygonzkevm_Bytes!]
  root_not_in: [polygonzkevm_Bytes!]
  root_contains: polygonzkevm_Bytes
  root_not_contains: polygonzkevm_Bytes
  transactionHash: polygonzkevm_Bytes
  transactionHash_not: polygonzkevm_Bytes
  transactionHash_gt: polygonzkevm_Bytes
  transactionHash_lt: polygonzkevm_Bytes
  transactionHash_gte: polygonzkevm_Bytes
  transactionHash_lte: polygonzkevm_Bytes
  transactionHash_in: [polygonzkevm_Bytes!]
  transactionHash_not_in: [polygonzkevm_Bytes!]
  transactionHash_contains: polygonzkevm_Bytes
  transactionHash_not_contains: polygonzkevm_Bytes
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  rootCount: String
  rootCount_not: String
  rootCount_gt: String
  rootCount_lt: String
  rootCount_gte: String
  rootCount_lte: String
  rootCount_in: [String!]
  rootCount_not_in: [String!]
  rootCount_contains: String
  rootCount_contains_nocase: String
  rootCount_not_contains: String
  rootCount_not_contains_nocase: String
  rootCount_starts_with: String
  rootCount_starts_with_nocase: String
  rootCount_not_starts_with: String
  rootCount_not_starts_with_nocase: String
  rootCount_ends_with: String
  rootCount_ends_with_nocase: String
  rootCount_not_ends_with: String
  rootCount_not_ends_with_nocase: String
  rootCount_: polygonzkevm_RootCount_filter
  """Filter for the block changed event."""
  _change_block: polygonzkevm_BlockChangedFilter
  and: [polygonzkevm_OriginMessage_filter]
  or: [polygonzkevm_OriginMessage_filter]
}

enum polygonzkevm_OriginMessage_orderBy {
  id
  transferId
  destinationDomain
  leaf
  index
  message
  root
  transactionHash
  blockNumber
  rootCount
  rootCount__id
  rootCount__count
}

type polygonzkevm_OriginTransfer {
  id: ID!
  chainId: BigInt
  transferId: polygonzkevm_Bytes
  nonce: BigInt
  status: polygonzkevm_TransferStatus
  messageHash: polygonzkevm_Bytes
  originDomain: BigInt
  destinationDomain: BigInt
  canonicalDomain: BigInt
  to: polygonzkevm_Bytes
  delegate: polygonzkevm_Bytes
  receiveLocal: Boolean
  callData: polygonzkevm_Bytes
  slippage: BigInt
  originSender: polygonzkevm_Bytes
  bridgedAmt: BigInt
  normalizedIn: BigInt
  canonicalId: polygonzkevm_Bytes
  asset: polygonzkevm_Asset
  transactingAsset: polygonzkevm_Bytes
  message: polygonzkevm_OriginMessage
  bumpRelayerFeeCount: BigInt
  relayerFees(skip: Int = 0, first: Int = 100, orderBy: polygonzkevm_RelayerFee_orderBy, orderDirection: polygonzkevm_OrderDirection, where: polygonzkevm_RelayerFee_filter): [polygonzkevm_RelayerFee!]
  initialRelayerFeeAsset: polygonzkevm_Bytes
  caller: polygonzkevm_Bytes
  transactionHash: polygonzkevm_Bytes
  timestamp: BigInt
  gasPrice: BigInt
  gasLimit: BigInt
  blockNumber: BigInt
  txOrigin: polygonzkevm_Bytes
  txNonce: BigInt
}

input polygonzkevm_OriginTransfer_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  chainId: BigInt
  chainId_not: BigInt
  chainId_gt: BigInt
  chainId_lt: BigInt
  chainId_gte: BigInt
  chainId_lte: BigInt
  chainId_in: [BigInt!]
  chainId_not_in: [BigInt!]
  transferId: polygonzkevm_Bytes
  transferId_not: polygonzkevm_Bytes
  transferId_gt: polygonzkevm_Bytes
  transferId_lt: polygonzkevm_Bytes
  transferId_gte: polygonzkevm_Bytes
  transferId_lte: polygonzkevm_Bytes
  transferId_in: [polygonzkevm_Bytes!]
  transferId_not_in: [polygonzkevm_Bytes!]
  transferId_contains: polygonzkevm_Bytes
  transferId_not_contains: polygonzkevm_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  status: polygonzkevm_TransferStatus
  status_not: polygonzkevm_TransferStatus
  status_in: [polygonzkevm_TransferStatus!]
  status_not_in: [polygonzkevm_TransferStatus!]
  messageHash: polygonzkevm_Bytes
  messageHash_not: polygonzkevm_Bytes
  messageHash_gt: polygonzkevm_Bytes
  messageHash_lt: polygonzkevm_Bytes
  messageHash_gte: polygonzkevm_Bytes
  messageHash_lte: polygonzkevm_Bytes
  messageHash_in: [polygonzkevm_Bytes!]
  messageHash_not_in: [polygonzkevm_Bytes!]
  messageHash_contains: polygonzkevm_Bytes
  messageHash_not_contains: polygonzkevm_Bytes
  originDomain: BigInt
  originDomain_not: BigInt
  originDomain_gt: BigInt
  originDomain_lt: BigInt
  originDomain_gte: BigInt
  originDomain_lte: BigInt
  originDomain_in: [BigInt!]
  originDomain_not_in: [BigInt!]
  destinationDomain: BigInt
  destinationDomain_not: BigInt
  destinationDomain_gt: BigInt
  destinationDomain_lt: BigInt
  destinationDomain_gte: BigInt
  destinationDomain_lte: BigInt
  destinationDomain_in: [BigInt!]
  destinationDomain_not_in: [BigInt!]
  canonicalDomain: BigInt
  canonicalDomain_not: BigInt
  canonicalDomain_gt: BigInt
  canonicalDomain_lt: BigInt
  canonicalDomain_gte: BigInt
  canonicalDomain_lte: BigInt
  canonicalDomain_in: [BigInt!]
  canonicalDomain_not_in: [BigInt!]
  to: polygonzkevm_Bytes
  to_not: polygonzkevm_Bytes
  to_gt: polygonzkevm_Bytes
  to_lt: polygonzkevm_Bytes
  to_gte: polygonzkevm_Bytes
  to_lte: polygonzkevm_Bytes
  to_in: [polygonzkevm_Bytes!]
  to_not_in: [polygonzkevm_Bytes!]
  to_contains: polygonzkevm_Bytes
  to_not_contains: polygonzkevm_Bytes
  delegate: polygonzkevm_Bytes
  delegate_not: polygonzkevm_Bytes
  delegate_gt: polygonzkevm_Bytes
  delegate_lt: polygonzkevm_Bytes
  delegate_gte: polygonzkevm_Bytes
  delegate_lte: polygonzkevm_Bytes
  delegate_in: [polygonzkevm_Bytes!]
  delegate_not_in: [polygonzkevm_Bytes!]
  delegate_contains: polygonzkevm_Bytes
  delegate_not_contains: polygonzkevm_Bytes
  receiveLocal: Boolean
  receiveLocal_not: Boolean
  receiveLocal_in: [Boolean!]
  receiveLocal_not_in: [Boolean!]
  callData: polygonzkevm_Bytes
  callData_not: polygonzkevm_Bytes
  callData_gt: polygonzkevm_Bytes
  callData_lt: polygonzkevm_Bytes
  callData_gte: polygonzkevm_Bytes
  callData_lte: polygonzkevm_Bytes
  callData_in: [polygonzkevm_Bytes!]
  callData_not_in: [polygonzkevm_Bytes!]
  callData_contains: polygonzkevm_Bytes
  callData_not_contains: polygonzkevm_Bytes
  slippage: BigInt
  slippage_not: BigInt
  slippage_gt: BigInt
  slippage_lt: BigInt
  slippage_gte: BigInt
  slippage_lte: BigInt
  slippage_in: [BigInt!]
  slippage_not_in: [BigInt!]
  originSender: polygonzkevm_Bytes
  originSender_not: polygonzkevm_Bytes
  originSender_gt: polygonzkevm_Bytes
  originSender_lt: polygonzkevm_Bytes
  originSender_gte: polygonzkevm_Bytes
  originSender_lte: polygonzkevm_Bytes
  originSender_in: [polygonzkevm_Bytes!]
  originSender_not_in: [polygonzkevm_Bytes!]
  originSender_contains: polygonzkevm_Bytes
  originSender_not_contains: polygonzkevm_Bytes
  bridgedAmt: BigInt
  bridgedAmt_not: BigInt
  bridgedAmt_gt: BigInt
  bridgedAmt_lt: BigInt
  bridgedAmt_gte: BigInt
  bridgedAmt_lte: BigInt
  bridgedAmt_in: [BigInt!]
  bridgedAmt_not_in: [BigInt!]
  normalizedIn: BigInt
  normalizedIn_not: BigInt
  normalizedIn_gt: BigInt
  normalizedIn_lt: BigInt
  normalizedIn_gte: BigInt
  normalizedIn_lte: BigInt
  normalizedIn_in: [BigInt!]
  normalizedIn_not_in: [BigInt!]
  canonicalId: polygonzkevm_Bytes
  canonicalId_not: polygonzkevm_Bytes
  canonicalId_gt: polygonzkevm_Bytes
  canonicalId_lt: polygonzkevm_Bytes
  canonicalId_gte: polygonzkevm_Bytes
  canonicalId_lte: polygonzkevm_Bytes
  canonicalId_in: [polygonzkevm_Bytes!]
  canonicalId_not_in: [polygonzkevm_Bytes!]
  canonicalId_contains: polygonzkevm_Bytes
  canonicalId_not_contains: polygonzkevm_Bytes
  asset: String
  asset_not: String
  asset_gt: String
  asset_lt: String
  asset_gte: String
  asset_lte: String
  asset_in: [String!]
  asset_not_in: [String!]
  asset_contains: String
  asset_contains_nocase: String
  asset_not_contains: String
  asset_not_contains_nocase: String
  asset_starts_with: String
  asset_starts_with_nocase: String
  asset_not_starts_with: String
  asset_not_starts_with_nocase: String
  asset_ends_with: String
  asset_ends_with_nocase: String
  asset_not_ends_with: String
  asset_not_ends_with_nocase: String
  asset_: polygonzkevm_Asset_filter
  transactingAsset: polygonzkevm_Bytes
  transactingAsset_not: polygonzkevm_Bytes
  transactingAsset_gt: polygonzkevm_Bytes
  transactingAsset_lt: polygonzkevm_Bytes
  transactingAsset_gte: polygonzkevm_Bytes
  transactingAsset_lte: polygonzkevm_Bytes
  transactingAsset_in: [polygonzkevm_Bytes!]
  transactingAsset_not_in: [polygonzkevm_Bytes!]
  transactingAsset_contains: polygonzkevm_Bytes
  transactingAsset_not_contains: polygonzkevm_Bytes
  message: String
  message_not: String
  message_gt: String
  message_lt: String
  message_gte: String
  message_lte: String
  message_in: [String!]
  message_not_in: [String!]
  message_contains: String
  message_contains_nocase: String
  message_not_contains: String
  message_not_contains_nocase: String
  message_starts_with: String
  message_starts_with_nocase: String
  message_not_starts_with: String
  message_not_starts_with_nocase: String
  message_ends_with: String
  message_ends_with_nocase: String
  message_not_ends_with: String
  message_not_ends_with_nocase: String
  message_: polygonzkevm_OriginMessage_filter
  bumpRelayerFeeCount: BigInt
  bumpRelayerFeeCount_not: BigInt
  bumpRelayerFeeCount_gt: BigInt
  bumpRelayerFeeCount_lt: BigInt
  bumpRelayerFeeCount_gte: BigInt
  bumpRelayerFeeCount_lte: BigInt
  bumpRelayerFeeCount_in: [BigInt!]
  bumpRelayerFeeCount_not_in: [BigInt!]
  relayerFees: [String!]
  relayerFees_not: [String!]
  relayerFees_contains: [String!]
  relayerFees_contains_nocase: [String!]
  relayerFees_not_contains: [String!]
  relayerFees_not_contains_nocase: [String!]
  relayerFees_: polygonzkevm_RelayerFee_filter
  initialRelayerFeeAsset: polygonzkevm_Bytes
  initialRelayerFeeAsset_not: polygonzkevm_Bytes
  initialRelayerFeeAsset_gt: polygonzkevm_Bytes
  initialRelayerFeeAsset_lt: polygonzkevm_Bytes
  initialRelayerFeeAsset_gte: polygonzkevm_Bytes
  initialRelayerFeeAsset_lte: polygonzkevm_Bytes
  initialRelayerFeeAsset_in: [polygonzkevm_Bytes!]
  initialRelayerFeeAsset_not_in: [polygonzkevm_Bytes!]
  initialRelayerFeeAsset_contains: polygonzkevm_Bytes
  initialRelayerFeeAsset_not_contains: polygonzkevm_Bytes
  caller: polygonzkevm_Bytes
  caller_not: polygonzkevm_Bytes
  caller_gt: polygonzkevm_Bytes
  caller_lt: polygonzkevm_Bytes
  caller_gte: polygonzkevm_Bytes
  caller_lte: polygonzkevm_Bytes
  caller_in: [polygonzkevm_Bytes!]
  caller_not_in: [polygonzkevm_Bytes!]
  caller_contains: polygonzkevm_Bytes
  caller_not_contains: polygonzkevm_Bytes
  transactionHash: polygonzkevm_Bytes
  transactionHash_not: polygonzkevm_Bytes
  transactionHash_gt: polygonzkevm_Bytes
  transactionHash_lt: polygonzkevm_Bytes
  transactionHash_gte: polygonzkevm_Bytes
  transactionHash_lte: polygonzkevm_Bytes
  transactionHash_in: [polygonzkevm_Bytes!]
  transactionHash_not_in: [polygonzkevm_Bytes!]
  transactionHash_contains: polygonzkevm_Bytes
  transactionHash_not_contains: polygonzkevm_Bytes
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  gasLimit: BigInt
  gasLimit_not: BigInt
  gasLimit_gt: BigInt
  gasLimit_lt: BigInt
  gasLimit_gte: BigInt
  gasLimit_lte: BigInt
  gasLimit_in: [BigInt!]
  gasLimit_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  txOrigin: polygonzkevm_Bytes
  txOrigin_not: polygonzkevm_Bytes
  txOrigin_gt: polygonzkevm_Bytes
  txOrigin_lt: polygonzkevm_Bytes
  txOrigin_gte: polygonzkevm_Bytes
  txOrigin_lte: polygonzkevm_Bytes
  txOrigin_in: [polygonzkevm_Bytes!]
  txOrigin_not_in: [polygonzkevm_Bytes!]
  txOrigin_contains: polygonzkevm_Bytes
  txOrigin_not_contains: polygonzkevm_Bytes
  txNonce: BigInt
  txNonce_not: BigInt
  txNonce_gt: BigInt
  txNonce_lt: BigInt
  txNonce_gte: BigInt
  txNonce_lte: BigInt
  txNonce_in: [BigInt!]
  txNonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: polygonzkevm_BlockChangedFilter
  and: [polygonzkevm_OriginTransfer_filter]
  or: [polygonzkevm_OriginTransfer_filter]
}

enum polygonzkevm_OriginTransfer_orderBy {
  id
  chainId
  transferId
  nonce
  status
  messageHash
  originDomain
  destinationDomain
  canonicalDomain
  to
  delegate
  receiveLocal
  callData
  slippage
  originSender
  bridgedAmt
  normalizedIn
  canonicalId
  asset
  asset__id
  asset__key
  asset__decimal
  asset__adoptedDecimal
  asset__canonicalId
  asset__canonicalDomain
  asset__adoptedAsset
  asset__localAsset
  asset__blockNumber
  transactingAsset
  message
  message__id
  message__transferId
  message__destinationDomain
  message__leaf
  message__index
  message__message
  message__root
  message__transactionHash
  message__blockNumber
  bumpRelayerFeeCount
  relayerFees
  initialRelayerFeeAsset
  caller
  transactionHash
  timestamp
  gasPrice
  gasLimit
  blockNumber
  txOrigin
  txNonce
}

type polygonzkevm_Relayer {
  id: ID!
  isActive: Boolean!
  relayer: polygonzkevm_Bytes
}

type polygonzkevm_RelayerFee {
  id: ID!
  transfer: polygonzkevm_OriginTransfer!
  fee: BigInt!
  asset: polygonzkevm_Bytes!
}

input polygonzkevm_RelayerFee_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transfer: String
  transfer_not: String
  transfer_gt: String
  transfer_lt: String
  transfer_gte: String
  transfer_lte: String
  transfer_in: [String!]
  transfer_not_in: [String!]
  transfer_contains: String
  transfer_contains_nocase: String
  transfer_not_contains: String
  transfer_not_contains_nocase: String
  transfer_starts_with: String
  transfer_starts_with_nocase: String
  transfer_not_starts_with: String
  transfer_not_starts_with_nocase: String
  transfer_ends_with: String
  transfer_ends_with_nocase: String
  transfer_not_ends_with: String
  transfer_not_ends_with_nocase: String
  transfer_: polygonzkevm_OriginTransfer_filter
  fee: BigInt
  fee_not: BigInt
  fee_gt: BigInt
  fee_lt: BigInt
  fee_gte: BigInt
  fee_lte: BigInt
  fee_in: [BigInt!]
  fee_not_in: [BigInt!]
  asset: polygonzkevm_Bytes
  asset_not: polygonzkevm_Bytes
  asset_gt: polygonzkevm_Bytes
  asset_lt: polygonzkevm_Bytes
  asset_gte: polygonzkevm_Bytes
  asset_lte: polygonzkevm_Bytes
  asset_in: [polygonzkevm_Bytes!]
  asset_not_in: [polygonzkevm_Bytes!]
  asset_contains: polygonzkevm_Bytes
  asset_not_contains: polygonzkevm_Bytes
  """Filter for the block changed event."""
  _change_block: polygonzkevm_BlockChangedFilter
  and: [polygonzkevm_RelayerFee_filter]
  or: [polygonzkevm_RelayerFee_filter]
}

enum polygonzkevm_RelayerFee_orderBy {
  id
  transfer
  transfer__id
  transfer__chainId
  transfer__transferId
  transfer__nonce
  transfer__status
  transfer__messageHash
  transfer__originDomain
  transfer__destinationDomain
  transfer__canonicalDomain
  transfer__to
  transfer__delegate
  transfer__receiveLocal
  transfer__callData
  transfer__slippage
  transfer__originSender
  transfer__bridgedAmt
  transfer__normalizedIn
  transfer__canonicalId
  transfer__transactingAsset
  transfer__bumpRelayerFeeCount
  transfer__initialRelayerFeeAsset
  transfer__caller
  transfer__transactionHash
  transfer__timestamp
  transfer__gasPrice
  transfer__gasLimit
  transfer__blockNumber
  transfer__txOrigin
  transfer__txNonce
  fee
  asset
}

type polygonzkevm_RelayerFeesIncrease {
  id: ID!
  transfer: polygonzkevm_OriginTransfer!
  increase: BigInt
  asset: polygonzkevm_Bytes
  caller: polygonzkevm_Bytes!
  transactionHash: polygonzkevm_Bytes!
  timestamp: BigInt!
  gasPrice: BigInt!
  gasLimit: BigInt!
  blockNumber: BigInt!
}

input polygonzkevm_RelayerFeesIncrease_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transfer: String
  transfer_not: String
  transfer_gt: String
  transfer_lt: String
  transfer_gte: String
  transfer_lte: String
  transfer_in: [String!]
  transfer_not_in: [String!]
  transfer_contains: String
  transfer_contains_nocase: String
  transfer_not_contains: String
  transfer_not_contains_nocase: String
  transfer_starts_with: String
  transfer_starts_with_nocase: String
  transfer_not_starts_with: String
  transfer_not_starts_with_nocase: String
  transfer_ends_with: String
  transfer_ends_with_nocase: String
  transfer_not_ends_with: String
  transfer_not_ends_with_nocase: String
  transfer_: polygonzkevm_OriginTransfer_filter
  increase: BigInt
  increase_not: BigInt
  increase_gt: BigInt
  increase_lt: BigInt
  increase_gte: BigInt
  increase_lte: BigInt
  increase_in: [BigInt!]
  increase_not_in: [BigInt!]
  asset: polygonzkevm_Bytes
  asset_not: polygonzkevm_Bytes
  asset_gt: polygonzkevm_Bytes
  asset_lt: polygonzkevm_Bytes
  asset_gte: polygonzkevm_Bytes
  asset_lte: polygonzkevm_Bytes
  asset_in: [polygonzkevm_Bytes!]
  asset_not_in: [polygonzkevm_Bytes!]
  asset_contains: polygonzkevm_Bytes
  asset_not_contains: polygonzkevm_Bytes
  caller: polygonzkevm_Bytes
  caller_not: polygonzkevm_Bytes
  caller_gt: polygonzkevm_Bytes
  caller_lt: polygonzkevm_Bytes
  caller_gte: polygonzkevm_Bytes
  caller_lte: polygonzkevm_Bytes
  caller_in: [polygonzkevm_Bytes!]
  caller_not_in: [polygonzkevm_Bytes!]
  caller_contains: polygonzkevm_Bytes
  caller_not_contains: polygonzkevm_Bytes
  transactionHash: polygonzkevm_Bytes
  transactionHash_not: polygonzkevm_Bytes
  transactionHash_gt: polygonzkevm_Bytes
  transactionHash_lt: polygonzkevm_Bytes
  transactionHash_gte: polygonzkevm_Bytes
  transactionHash_lte: polygonzkevm_Bytes
  transactionHash_in: [polygonzkevm_Bytes!]
  transactionHash_not_in: [polygonzkevm_Bytes!]
  transactionHash_contains: polygonzkevm_Bytes
  transactionHash_not_contains: polygonzkevm_Bytes
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  gasLimit: BigInt
  gasLimit_not: BigInt
  gasLimit_gt: BigInt
  gasLimit_lt: BigInt
  gasLimit_gte: BigInt
  gasLimit_lte: BigInt
  gasLimit_in: [BigInt!]
  gasLimit_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: polygonzkevm_BlockChangedFilter
  and: [polygonzkevm_RelayerFeesIncrease_filter]
  or: [polygonzkevm_RelayerFeesIncrease_filter]
}

enum polygonzkevm_RelayerFeesIncrease_orderBy {
  id
  transfer
  transfer__id
  transfer__chainId
  transfer__transferId
  transfer__nonce
  transfer__status
  transfer__messageHash
  transfer__originDomain
  transfer__destinationDomain
  transfer__canonicalDomain
  transfer__to
  transfer__delegate
  transfer__receiveLocal
  transfer__callData
  transfer__slippage
  transfer__originSender
  transfer__bridgedAmt
  transfer__normalizedIn
  transfer__canonicalId
  transfer__transactingAsset
  transfer__bumpRelayerFeeCount
  transfer__initialRelayerFeeAsset
  transfer__caller
  transfer__transactionHash
  transfer__timestamp
  transfer__gasPrice
  transfer__gasLimit
  transfer__blockNumber
  transfer__txOrigin
  transfer__txNonce
  increase
  asset
  caller
  transactionHash
  timestamp
  gasPrice
  gasLimit
  blockNumber
}

input polygonzkevm_Relayer_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  isActive: Boolean
  isActive_not: Boolean
  isActive_in: [Boolean!]
  isActive_not_in: [Boolean!]
  relayer: polygonzkevm_Bytes
  relayer_not: polygonzkevm_Bytes
  relayer_gt: polygonzkevm_Bytes
  relayer_lt: polygonzkevm_Bytes
  relayer_gte: polygonzkevm_Bytes
  relayer_lte: polygonzkevm_Bytes
  relayer_in: [polygonzkevm_Bytes!]
  relayer_not_in: [polygonzkevm_Bytes!]
  relayer_contains: polygonzkevm_Bytes
  relayer_not_contains: polygonzkevm_Bytes
  """Filter for the block changed event."""
  _change_block: polygonzkevm_BlockChangedFilter
  and: [polygonzkevm_Relayer_filter]
  or: [polygonzkevm_Relayer_filter]
}

enum polygonzkevm_Relayer_orderBy {
  id
  isActive
  relayer
}

type polygonzkevm_RootCount {
  id: ID!
  count: BigInt
}

input polygonzkevm_RootCount_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  count: BigInt
  count_not: BigInt
  count_gt: BigInt
  count_lt: BigInt
  count_gte: BigInt
  count_lte: BigInt
  count_in: [BigInt!]
  count_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: polygonzkevm_BlockChangedFilter
  and: [polygonzkevm_RootCount_filter]
  or: [polygonzkevm_RootCount_filter]
}

enum polygonzkevm_RootCount_orderBy {
  id
  count
}

type polygonzkevm_RootMessageSent {
  id: ID!
  spokeDomain: BigInt
  hubDomain: BigInt
  root: polygonzkevm_Bytes
  count: BigInt
  caller: polygonzkevm_Bytes
  transactionHash: polygonzkevm_Bytes
  timestamp: BigInt
  gasPrice: BigInt
  gasLimit: BigInt
  blockNumber: BigInt
}

input polygonzkevm_RootMessageSent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  spokeDomain: BigInt
  spokeDomain_not: BigInt
  spokeDomain_gt: BigInt
  spokeDomain_lt: BigInt
  spokeDomain_gte: BigInt
  spokeDomain_lte: BigInt
  spokeDomain_in: [BigInt!]
  spokeDomain_not_in: [BigInt!]
  hubDomain: BigInt
  hubDomain_not: BigInt
  hubDomain_gt: BigInt
  hubDomain_lt: BigInt
  hubDomain_gte: BigInt
  hubDomain_lte: BigInt
  hubDomain_in: [BigInt!]
  hubDomain_not_in: [BigInt!]
  root: polygonzkevm_Bytes
  root_not: polygonzkevm_Bytes
  root_gt: polygonzkevm_Bytes
  root_lt: polygonzkevm_Bytes
  root_gte: polygonzkevm_Bytes
  root_lte: polygonzkevm_Bytes
  root_in: [polygonzkevm_Bytes!]
  root_not_in: [polygonzkevm_Bytes!]
  root_contains: polygonzkevm_Bytes
  root_not_contains: polygonzkevm_Bytes
  count: BigInt
  count_not: BigInt
  count_gt: BigInt
  count_lt: BigInt
  count_gte: BigInt
  count_lte: BigInt
  count_in: [BigInt!]
  count_not_in: [BigInt!]
  caller: polygonzkevm_Bytes
  caller_not: polygonzkevm_Bytes
  caller_gt: polygonzkevm_Bytes
  caller_lt: polygonzkevm_Bytes
  caller_gte: polygonzkevm_Bytes
  caller_lte: polygonzkevm_Bytes
  caller_in: [polygonzkevm_Bytes!]
  caller_not_in: [polygonzkevm_Bytes!]
  caller_contains: polygonzkevm_Bytes
  caller_not_contains: polygonzkevm_Bytes
  transactionHash: polygonzkevm_Bytes
  transactionHash_not: polygonzkevm_Bytes
  transactionHash_gt: polygonzkevm_Bytes
  transactionHash_lt: polygonzkevm_Bytes
  transactionHash_gte: polygonzkevm_Bytes
  transactionHash_lte: polygonzkevm_Bytes
  transactionHash_in: [polygonzkevm_Bytes!]
  transactionHash_not_in: [polygonzkevm_Bytes!]
  transactionHash_contains: polygonzkevm_Bytes
  transactionHash_not_contains: polygonzkevm_Bytes
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  gasLimit: BigInt
  gasLimit_not: BigInt
  gasLimit_gt: BigInt
  gasLimit_lt: BigInt
  gasLimit_gte: BigInt
  gasLimit_lte: BigInt
  gasLimit_in: [BigInt!]
  gasLimit_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: polygonzkevm_BlockChangedFilter
  and: [polygonzkevm_RootMessageSent_filter]
  or: [polygonzkevm_RootMessageSent_filter]
}

enum polygonzkevm_RootMessageSent_orderBy {
  id
  spokeDomain
  hubDomain
  root
  count
  caller
  transactionHash
  timestamp
  gasPrice
  gasLimit
  blockNumber
}

type polygonzkevm_Router {
  id: ID!
  isActive: Boolean!
  owner: polygonzkevm_Bytes
  recipient: polygonzkevm_Bytes
  proposedOwner: polygonzkevm_Bytes
  proposedTimestamp: BigInt
  assetBalances(skip: Int = 0, first: Int = 100, orderBy: polygonzkevm_AssetBalance_orderBy, orderDirection: polygonzkevm_OrderDirection, where: polygonzkevm_AssetBalance_filter): [polygonzkevm_AssetBalance!]!
}

type polygonzkevm_RouterDailyTVL {
  id: ID!
  router: polygonzkevm_Router!
  asset: polygonzkevm_Asset!
  timestamp: BigInt!
  balance: BigInt!
}

input polygonzkevm_RouterDailyTVL_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  router: String
  router_not: String
  router_gt: String
  router_lt: String
  router_gte: String
  router_lte: String
  router_in: [String!]
  router_not_in: [String!]
  router_contains: String
  router_contains_nocase: String
  router_not_contains: String
  router_not_contains_nocase: String
  router_starts_with: String
  router_starts_with_nocase: String
  router_not_starts_with: String
  router_not_starts_with_nocase: String
  router_ends_with: String
  router_ends_with_nocase: String
  router_not_ends_with: String
  router_not_ends_with_nocase: String
  router_: polygonzkevm_Router_filter
  asset: String
  asset_not: String
  asset_gt: String
  asset_lt: String
  asset_gte: String
  asset_lte: String
  asset_in: [String!]
  asset_not_in: [String!]
  asset_contains: String
  asset_contains_nocase: String
  asset_not_contains: String
  asset_not_contains_nocase: String
  asset_starts_with: String
  asset_starts_with_nocase: String
  asset_not_starts_with: String
  asset_not_starts_with_nocase: String
  asset_ends_with: String
  asset_ends_with_nocase: String
  asset_not_ends_with: String
  asset_not_ends_with_nocase: String
  asset_: polygonzkevm_Asset_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  balance: BigInt
  balance_not: BigInt
  balance_gt: BigInt
  balance_lt: BigInt
  balance_gte: BigInt
  balance_lte: BigInt
  balance_in: [BigInt!]
  balance_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: polygonzkevm_BlockChangedFilter
  and: [polygonzkevm_RouterDailyTVL_filter]
  or: [polygonzkevm_RouterDailyTVL_filter]
}

enum polygonzkevm_RouterDailyTVL_orderBy {
  id
  router
  router__id
  router__isActive
  router__owner
  router__recipient
  router__proposedOwner
  router__proposedTimestamp
  asset
  asset__id
  asset__key
  asset__decimal
  asset__adoptedDecimal
  asset__canonicalId
  asset__canonicalDomain
  asset__adoptedAsset
  asset__localAsset
  asset__blockNumber
  timestamp
  balance
}

type polygonzkevm_RouterLiquidityEvent {
  id: ID!
  type: polygonzkevm_RouterLiquidityEventType
  router: polygonzkevm_Router!
  asset: polygonzkevm_Asset!
  amount: BigInt!
  balance: BigInt!
  caller: polygonzkevm_Bytes
  blockNumber: BigInt!
  timestamp: BigInt!
  transactionHash: polygonzkevm_Bytes!
  nonce: BigInt!
}

enum polygonzkevm_RouterLiquidityEventType {
  Add
  Remove
}

input polygonzkevm_RouterLiquidityEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  type: polygonzkevm_RouterLiquidityEventType
  type_not: polygonzkevm_RouterLiquidityEventType
  type_in: [polygonzkevm_RouterLiquidityEventType!]
  type_not_in: [polygonzkevm_RouterLiquidityEventType!]
  router: String
  router_not: String
  router_gt: String
  router_lt: String
  router_gte: String
  router_lte: String
  router_in: [String!]
  router_not_in: [String!]
  router_contains: String
  router_contains_nocase: String
  router_not_contains: String
  router_not_contains_nocase: String
  router_starts_with: String
  router_starts_with_nocase: String
  router_not_starts_with: String
  router_not_starts_with_nocase: String
  router_ends_with: String
  router_ends_with_nocase: String
  router_not_ends_with: String
  router_not_ends_with_nocase: String
  router_: polygonzkevm_Router_filter
  asset: String
  asset_not: String
  asset_gt: String
  asset_lt: String
  asset_gte: String
  asset_lte: String
  asset_in: [String!]
  asset_not_in: [String!]
  asset_contains: String
  asset_contains_nocase: String
  asset_not_contains: String
  asset_not_contains_nocase: String
  asset_starts_with: String
  asset_starts_with_nocase: String
  asset_not_starts_with: String
  asset_not_starts_with_nocase: String
  asset_ends_with: String
  asset_ends_with_nocase: String
  asset_not_ends_with: String
  asset_not_ends_with_nocase: String
  asset_: polygonzkevm_Asset_filter
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  balance: BigInt
  balance_not: BigInt
  balance_gt: BigInt
  balance_lt: BigInt
  balance_gte: BigInt
  balance_lte: BigInt
  balance_in: [BigInt!]
  balance_not_in: [BigInt!]
  caller: polygonzkevm_Bytes
  caller_not: polygonzkevm_Bytes
  caller_gt: polygonzkevm_Bytes
  caller_lt: polygonzkevm_Bytes
  caller_gte: polygonzkevm_Bytes
  caller_lte: polygonzkevm_Bytes
  caller_in: [polygonzkevm_Bytes!]
  caller_not_in: [polygonzkevm_Bytes!]
  caller_contains: polygonzkevm_Bytes
  caller_not_contains: polygonzkevm_Bytes
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transactionHash: polygonzkevm_Bytes
  transactionHash_not: polygonzkevm_Bytes
  transactionHash_gt: polygonzkevm_Bytes
  transactionHash_lt: polygonzkevm_Bytes
  transactionHash_gte: polygonzkevm_Bytes
  transactionHash_lte: polygonzkevm_Bytes
  transactionHash_in: [polygonzkevm_Bytes!]
  transactionHash_not_in: [polygonzkevm_Bytes!]
  transactionHash_contains: polygonzkevm_Bytes
  transactionHash_not_contains: polygonzkevm_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: polygonzkevm_BlockChangedFilter
  and: [polygonzkevm_RouterLiquidityEvent_filter]
  or: [polygonzkevm_RouterLiquidityEvent_filter]
}

enum polygonzkevm_RouterLiquidityEvent_orderBy {
  id
  type
  router
  router__id
  router__isActive
  router__owner
  router__recipient
  router__proposedOwner
  router__proposedTimestamp
  asset
  asset__id
  asset__key
  asset__decimal
  asset__adoptedDecimal
  asset__canonicalId
  asset__canonicalDomain
  asset__adoptedAsset
  asset__localAsset
  asset__blockNumber
  amount
  balance
  caller
  blockNumber
  timestamp
  transactionHash
  nonce
}

input polygonzkevm_Router_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  isActive: Boolean
  isActive_not: Boolean
  isActive_in: [Boolean!]
  isActive_not_in: [Boolean!]
  owner: polygonzkevm_Bytes
  owner_not: polygonzkevm_Bytes
  owner_gt: polygonzkevm_Bytes
  owner_lt: polygonzkevm_Bytes
  owner_gte: polygonzkevm_Bytes
  owner_lte: polygonzkevm_Bytes
  owner_in: [polygonzkevm_Bytes!]
  owner_not_in: [polygonzkevm_Bytes!]
  owner_contains: polygonzkevm_Bytes
  owner_not_contains: polygonzkevm_Bytes
  recipient: polygonzkevm_Bytes
  recipient_not: polygonzkevm_Bytes
  recipient_gt: polygonzkevm_Bytes
  recipient_lt: polygonzkevm_Bytes
  recipient_gte: polygonzkevm_Bytes
  recipient_lte: polygonzkevm_Bytes
  recipient_in: [polygonzkevm_Bytes!]
  recipient_not_in: [polygonzkevm_Bytes!]
  recipient_contains: polygonzkevm_Bytes
  recipient_not_contains: polygonzkevm_Bytes
  proposedOwner: polygonzkevm_Bytes
  proposedOwner_not: polygonzkevm_Bytes
  proposedOwner_gt: polygonzkevm_Bytes
  proposedOwner_lt: polygonzkevm_Bytes
  proposedOwner_gte: polygonzkevm_Bytes
  proposedOwner_lte: polygonzkevm_Bytes
  proposedOwner_in: [polygonzkevm_Bytes!]
  proposedOwner_not_in: [polygonzkevm_Bytes!]
  proposedOwner_contains: polygonzkevm_Bytes
  proposedOwner_not_contains: polygonzkevm_Bytes
  proposedTimestamp: BigInt
  proposedTimestamp_not: BigInt
  proposedTimestamp_gt: BigInt
  proposedTimestamp_lt: BigInt
  proposedTimestamp_gte: BigInt
  proposedTimestamp_lte: BigInt
  proposedTimestamp_in: [BigInt!]
  proposedTimestamp_not_in: [BigInt!]
  assetBalances_: polygonzkevm_AssetBalance_filter
  """Filter for the block changed event."""
  _change_block: polygonzkevm_BlockChangedFilter
  and: [polygonzkevm_Router_filter]
  or: [polygonzkevm_Router_filter]
}

enum polygonzkevm_Router_orderBy {
  id
  isActive
  owner
  recipient
  proposedOwner
  proposedTimestamp
  assetBalances
}

type polygonzkevm_Sequencer {
  id: ID!
  isActive: Boolean!
  sequencer: polygonzkevm_Bytes
}

input polygonzkevm_Sequencer_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  isActive: Boolean
  isActive_not: Boolean
  isActive_in: [Boolean!]
  isActive_not_in: [Boolean!]
  sequencer: polygonzkevm_Bytes
  sequencer_not: polygonzkevm_Bytes
  sequencer_gt: polygonzkevm_Bytes
  sequencer_lt: polygonzkevm_Bytes
  sequencer_gte: polygonzkevm_Bytes
  sequencer_lte: polygonzkevm_Bytes
  sequencer_in: [polygonzkevm_Bytes!]
  sequencer_not_in: [polygonzkevm_Bytes!]
  sequencer_contains: polygonzkevm_Bytes
  sequencer_not_contains: polygonzkevm_Bytes
  """Filter for the block changed event."""
  _change_block: polygonzkevm_BlockChangedFilter
  and: [polygonzkevm_Sequencer_filter]
  or: [polygonzkevm_Sequencer_filter]
}

enum polygonzkevm_Sequencer_orderBy {
  id
  isActive
  sequencer
}

type polygonzkevm_Setting {
  id: ID!
  maxRoutersPerTransfer: BigInt!
  caller: polygonzkevm_Bytes!
}

input polygonzkevm_Setting_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  maxRoutersPerTransfer: BigInt
  maxRoutersPerTransfer_not: BigInt
  maxRoutersPerTransfer_gt: BigInt
  maxRoutersPerTransfer_lt: BigInt
  maxRoutersPerTransfer_gte: BigInt
  maxRoutersPerTransfer_lte: BigInt
  maxRoutersPerTransfer_in: [BigInt!]
  maxRoutersPerTransfer_not_in: [BigInt!]
  caller: polygonzkevm_Bytes
  caller_not: polygonzkevm_Bytes
  caller_gt: polygonzkevm_Bytes
  caller_lt: polygonzkevm_Bytes
  caller_gte: polygonzkevm_Bytes
  caller_lte: polygonzkevm_Bytes
  caller_in: [polygonzkevm_Bytes!]
  caller_not_in: [polygonzkevm_Bytes!]
  caller_contains: polygonzkevm_Bytes
  caller_not_contains: polygonzkevm_Bytes
  """Filter for the block changed event."""
  _change_block: polygonzkevm_BlockChangedFilter
  and: [polygonzkevm_Setting_filter]
  or: [polygonzkevm_Setting_filter]
}

enum polygonzkevm_Setting_orderBy {
  id
  maxRoutersPerTransfer
  caller
}

type polygonzkevm_SlippageUpdate {
  id: ID!
  transfer: polygonzkevm_DestinationTransfer!
  slippage: BigInt!
  caller: polygonzkevm_Bytes!
  transactionHash: polygonzkevm_Bytes!
  timestamp: BigInt!
  gasPrice: BigInt!
  gasLimit: BigInt!
  blockNumber: BigInt!
}

input polygonzkevm_SlippageUpdate_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transfer: String
  transfer_not: String
  transfer_gt: String
  transfer_lt: String
  transfer_gte: String
  transfer_lte: String
  transfer_in: [String!]
  transfer_not_in: [String!]
  transfer_contains: String
  transfer_contains_nocase: String
  transfer_not_contains: String
  transfer_not_contains_nocase: String
  transfer_starts_with: String
  transfer_starts_with_nocase: String
  transfer_not_starts_with: String
  transfer_not_starts_with_nocase: String
  transfer_ends_with: String
  transfer_ends_with_nocase: String
  transfer_not_ends_with: String
  transfer_not_ends_with_nocase: String
  transfer_: polygonzkevm_DestinationTransfer_filter
  slippage: BigInt
  slippage_not: BigInt
  slippage_gt: BigInt
  slippage_lt: BigInt
  slippage_gte: BigInt
  slippage_lte: BigInt
  slippage_in: [BigInt!]
  slippage_not_in: [BigInt!]
  caller: polygonzkevm_Bytes
  caller_not: polygonzkevm_Bytes
  caller_gt: polygonzkevm_Bytes
  caller_lt: polygonzkevm_Bytes
  caller_gte: polygonzkevm_Bytes
  caller_lte: polygonzkevm_Bytes
  caller_in: [polygonzkevm_Bytes!]
  caller_not_in: [polygonzkevm_Bytes!]
  caller_contains: polygonzkevm_Bytes
  caller_not_contains: polygonzkevm_Bytes
  transactionHash: polygonzkevm_Bytes
  transactionHash_not: polygonzkevm_Bytes
  transactionHash_gt: polygonzkevm_Bytes
  transactionHash_lt: polygonzkevm_Bytes
  transactionHash_gte: polygonzkevm_Bytes
  transactionHash_lte: polygonzkevm_Bytes
  transactionHash_in: [polygonzkevm_Bytes!]
  transactionHash_not_in: [polygonzkevm_Bytes!]
  transactionHash_contains: polygonzkevm_Bytes
  transactionHash_not_contains: polygonzkevm_Bytes
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  gasLimit: BigInt
  gasLimit_not: BigInt
  gasLimit_gt: BigInt
  gasLimit_lt: BigInt
  gasLimit_gte: BigInt
  gasLimit_lte: BigInt
  gasLimit_in: [BigInt!]
  gasLimit_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: polygonzkevm_BlockChangedFilter
  and: [polygonzkevm_SlippageUpdate_filter]
  or: [polygonzkevm_SlippageUpdate_filter]
}

enum polygonzkevm_SlippageUpdate_orderBy {
  id
  transfer
  transfer__id
  transfer__chainId
  transfer__transferId
  transfer__nonce
  transfer__status
  transfer__originDomain
  transfer__destinationDomain
  transfer__canonicalDomain
  transfer__to
  transfer__delegate
  transfer__receiveLocal
  transfer__callData
  transfer__slippage
  transfer__bumpSlippageCount
  transfer__originSender
  transfer__bridgedAmt
  transfer__normalizedIn
  transfer__canonicalId
  transfer__amount
  transfer__routersFee
  transfer__executedCaller
  transfer__executedTransactionHash
  transfer__executedTimestamp
  transfer__executedGasPrice
  transfer__executedGasLimit
  transfer__executedBlockNumber
  transfer__executedTxOrigin
  transfer__executedTxNonce
  transfer__reconciledCaller
  transfer__reconciledTransactionHash
  transfer__reconciledTimestamp
  transfer__reconciledGasPrice
  transfer__reconciledGasLimit
  transfer__reconciledBlockNumber
  transfer__reconciledTxOrigin
  transfer__reconciledTxNonce
  slippage
  caller
  transactionHash
  timestamp
  gasPrice
  gasLimit
  blockNumber
}

type polygonzkevm_SnapshotRoot {
  id: ID!
  spokeDomain: BigInt
  root: polygonzkevm_Bytes!
  count: BigInt!
  timestamp: BigInt!
  blockNumber: BigInt!
}

input polygonzkevm_SnapshotRoot_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  spokeDomain: BigInt
  spokeDomain_not: BigInt
  spokeDomain_gt: BigInt
  spokeDomain_lt: BigInt
  spokeDomain_gte: BigInt
  spokeDomain_lte: BigInt
  spokeDomain_in: [BigInt!]
  spokeDomain_not_in: [BigInt!]
  root: polygonzkevm_Bytes
  root_not: polygonzkevm_Bytes
  root_gt: polygonzkevm_Bytes
  root_lt: polygonzkevm_Bytes
  root_gte: polygonzkevm_Bytes
  root_lte: polygonzkevm_Bytes
  root_in: [polygonzkevm_Bytes!]
  root_not_in: [polygonzkevm_Bytes!]
  root_contains: polygonzkevm_Bytes
  root_not_contains: polygonzkevm_Bytes
  count: BigInt
  count_not: BigInt
  count_gt: BigInt
  count_lt: BigInt
  count_gte: BigInt
  count_lte: BigInt
  count_in: [BigInt!]
  count_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: polygonzkevm_BlockChangedFilter
  and: [polygonzkevm_SnapshotRoot_filter]
  or: [polygonzkevm_SnapshotRoot_filter]
}

enum polygonzkevm_SnapshotRoot_orderBy {
  id
  spokeDomain
  root
  count
  timestamp
  blockNumber
}

type polygonzkevm_SpokeConnectorMode {
  id: ID!
  mode: String!
}

input polygonzkevm_SpokeConnectorMode_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  mode: String
  mode_not: String
  mode_gt: String
  mode_lt: String
  mode_gte: String
  mode_lte: String
  mode_in: [String!]
  mode_not_in: [String!]
  mode_contains: String
  mode_contains_nocase: String
  mode_not_contains: String
  mode_not_contains_nocase: String
  mode_starts_with: String
  mode_starts_with_nocase: String
  mode_not_starts_with: String
  mode_not_starts_with_nocase: String
  mode_ends_with: String
  mode_ends_with_nocase: String
  mode_not_ends_with: String
  mode_not_ends_with_nocase: String
  """Filter for the block changed event."""
  _change_block: polygonzkevm_BlockChangedFilter
  and: [polygonzkevm_SpokeConnectorMode_filter]
  or: [polygonzkevm_SpokeConnectorMode_filter]
}

enum polygonzkevm_SpokeConnectorMode_orderBy {
  id
  mode
}

enum polygonzkevm_TransferStatus {
  XCalled
  Executed
  Reconciled
  CompletedSlow
  CompletedFast
}

type polygonzkevm__Block_ {
  """The hash of the block"""
  hash: polygonzkevm_Bytes
  """The block number"""
  number: Int!
  """Integer representation of the timestamp stored in blocks for the chain"""
  timestamp: Int
  """The hash of the parent block"""
  parentHash: polygonzkevm_Bytes
}

"""The type for the top-level _meta field"""
type polygonzkevm__Meta_ {
  """
  Information about a specific subgraph block. The hash of the block
  will be null if the _meta field has a block constraint that asks for
  a block number. It will be filled if the _meta field has no block constraint
  and therefore asks for the latest  block
  
  """
  block: polygonzkevm__Block_!
  """The deployment ID"""
  deployment: String!
  """If `true`, the subgraph encountered indexing errors at some past block"""
  hasIndexingErrors: Boolean!
}

enum zksync_swap_Aggregation_interval {
  hour
  day
}

scalar zksync_swap_BigDecimal

input zksync_swap_BlockChangedFilter {
  number_gte: Int!
}

input zksync_swap_Block_height {
  hash: zksync_swap_Bytes
  number: Int
  number_gte: Int
}

scalar zksync_swap_Bytes

"""
8 bytes signed integer

"""
scalar zksync_swap_Int8

type zksync_swap_LpAccount {
  id: ID!
  address: zksync_swap_Bytes!
  balances(skip: Int = 0, first: Int = 100, orderBy: zksync_swap_LpAccountBalance_orderBy, orderDirection: zksync_swap_OrderDirection, where: zksync_swap_LpAccountBalance_filter): [zksync_swap_LpAccountBalance!]!
}

type zksync_swap_LpAccountBalance {
  id: ID!
  account: zksync_swap_LpAccount!
  token: zksync_swap_LpToken!
  amount: zksync_swap_BigDecimal!
  block: BigInt
  modified: BigInt
  transaction: zksync_swap_Bytes
}

input zksync_swap_LpAccountBalance_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  account: String
  account_not: String
  account_gt: String
  account_lt: String
  account_gte: String
  account_lte: String
  account_in: [String!]
  account_not_in: [String!]
  account_contains: String
  account_contains_nocase: String
  account_not_contains: String
  account_not_contains_nocase: String
  account_starts_with: String
  account_starts_with_nocase: String
  account_not_starts_with: String
  account_not_starts_with_nocase: String
  account_ends_with: String
  account_ends_with_nocase: String
  account_not_ends_with: String
  account_not_ends_with_nocase: String
  account_: zksync_swap_LpAccount_filter
  token: String
  token_not: String
  token_gt: String
  token_lt: String
  token_gte: String
  token_lte: String
  token_in: [String!]
  token_not_in: [String!]
  token_contains: String
  token_contains_nocase: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_: zksync_swap_LpToken_filter
  amount: zksync_swap_BigDecimal
  amount_not: zksync_swap_BigDecimal
  amount_gt: zksync_swap_BigDecimal
  amount_lt: zksync_swap_BigDecimal
  amount_gte: zksync_swap_BigDecimal
  amount_lte: zksync_swap_BigDecimal
  amount_in: [zksync_swap_BigDecimal!]
  amount_not_in: [zksync_swap_BigDecimal!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  modified: BigInt
  modified_not: BigInt
  modified_gt: BigInt
  modified_lt: BigInt
  modified_gte: BigInt
  modified_lte: BigInt
  modified_in: [BigInt!]
  modified_not_in: [BigInt!]
  transaction: zksync_swap_Bytes
  transaction_not: zksync_swap_Bytes
  transaction_gt: zksync_swap_Bytes
  transaction_lt: zksync_swap_Bytes
  transaction_gte: zksync_swap_Bytes
  transaction_lte: zksync_swap_Bytes
  transaction_in: [zksync_swap_Bytes!]
  transaction_not_in: [zksync_swap_Bytes!]
  transaction_contains: zksync_swap_Bytes
  transaction_not_contains: zksync_swap_Bytes
  """Filter for the block changed event."""
  _change_block: zksync_swap_BlockChangedFilter
  and: [zksync_swap_LpAccountBalance_filter]
  or: [zksync_swap_LpAccountBalance_filter]
}

enum zksync_swap_LpAccountBalance_orderBy {
  id
  account
  account__id
  account__address
  token
  token__id
  token__address
  token__decimals
  token__name
  token__symbol
  token__totalSupply
  amount
  block
  modified
  transaction
}

input zksync_swap_LpAccount_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  address: zksync_swap_Bytes
  address_not: zksync_swap_Bytes
  address_gt: zksync_swap_Bytes
  address_lt: zksync_swap_Bytes
  address_gte: zksync_swap_Bytes
  address_lte: zksync_swap_Bytes
  address_in: [zksync_swap_Bytes!]
  address_not_in: [zksync_swap_Bytes!]
  address_contains: zksync_swap_Bytes
  address_not_contains: zksync_swap_Bytes
  balances_: zksync_swap_LpAccountBalance_filter
  """Filter for the block changed event."""
  _change_block: zksync_swap_BlockChangedFilter
  and: [zksync_swap_LpAccount_filter]
  or: [zksync_swap_LpAccount_filter]
}

enum zksync_swap_LpAccount_orderBy {
  id
  address
  balances
}

type zksync_swap_LpToken {
  id: ID!
  address: zksync_swap_Bytes!
  stableSwap: zksync_swap_StableSwap!
  decimals: Int!
  name: String!
  symbol: String!
  totalSupply: zksync_swap_BigDecimal!
  events(skip: Int = 0, first: Int = 100, orderBy: zksync_swap_LpTokenEvent_orderBy, orderDirection: zksync_swap_OrderDirection, where: zksync_swap_LpTokenEvent_filter): [zksync_swap_LpTokenEvent!]!
}

interface zksync_swap_LpTokenEvent {
  id: ID!
  token: zksync_swap_LpToken!
  amount: zksync_swap_BigDecimal!
  block: BigInt!
  timestamp: BigInt!
  transaction: zksync_swap_Bytes!
  nonce: BigInt!
}

input zksync_swap_LpTokenEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  token: String
  token_not: String
  token_gt: String
  token_lt: String
  token_gte: String
  token_lte: String
  token_in: [String!]
  token_not_in: [String!]
  token_contains: String
  token_contains_nocase: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_: zksync_swap_LpToken_filter
  amount: zksync_swap_BigDecimal
  amount_not: zksync_swap_BigDecimal
  amount_gt: zksync_swap_BigDecimal
  amount_lt: zksync_swap_BigDecimal
  amount_gte: zksync_swap_BigDecimal
  amount_lte: zksync_swap_BigDecimal
  amount_in: [zksync_swap_BigDecimal!]
  amount_not_in: [zksync_swap_BigDecimal!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: zksync_swap_Bytes
  transaction_not: zksync_swap_Bytes
  transaction_gt: zksync_swap_Bytes
  transaction_lt: zksync_swap_Bytes
  transaction_gte: zksync_swap_Bytes
  transaction_lte: zksync_swap_Bytes
  transaction_in: [zksync_swap_Bytes!]
  transaction_not_in: [zksync_swap_Bytes!]
  transaction_contains: zksync_swap_Bytes
  transaction_not_contains: zksync_swap_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: zksync_swap_BlockChangedFilter
  and: [zksync_swap_LpTokenEvent_filter]
  or: [zksync_swap_LpTokenEvent_filter]
}

enum zksync_swap_LpTokenEvent_orderBy {
  id
  token
  token__id
  token__address
  token__decimals
  token__name
  token__symbol
  token__totalSupply
  amount
  block
  timestamp
  transaction
  nonce
}

input zksync_swap_LpToken_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  address: zksync_swap_Bytes
  address_not: zksync_swap_Bytes
  address_gt: zksync_swap_Bytes
  address_lt: zksync_swap_Bytes
  address_gte: zksync_swap_Bytes
  address_lte: zksync_swap_Bytes
  address_in: [zksync_swap_Bytes!]
  address_not_in: [zksync_swap_Bytes!]
  address_contains: zksync_swap_Bytes
  address_not_contains: zksync_swap_Bytes
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: zksync_swap_StableSwap_filter
  decimals: Int
  decimals_not: Int
  decimals_gt: Int
  decimals_lt: Int
  decimals_gte: Int
  decimals_lte: Int
  decimals_in: [Int!]
  decimals_not_in: [Int!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  symbol: String
  symbol_not: String
  symbol_gt: String
  symbol_lt: String
  symbol_gte: String
  symbol_lte: String
  symbol_in: [String!]
  symbol_not_in: [String!]
  symbol_contains: String
  symbol_contains_nocase: String
  symbol_not_contains: String
  symbol_not_contains_nocase: String
  symbol_starts_with: String
  symbol_starts_with_nocase: String
  symbol_not_starts_with: String
  symbol_not_starts_with_nocase: String
  symbol_ends_with: String
  symbol_ends_with_nocase: String
  symbol_not_ends_with: String
  symbol_not_ends_with_nocase: String
  totalSupply: zksync_swap_BigDecimal
  totalSupply_not: zksync_swap_BigDecimal
  totalSupply_gt: zksync_swap_BigDecimal
  totalSupply_lt: zksync_swap_BigDecimal
  totalSupply_gte: zksync_swap_BigDecimal
  totalSupply_lte: zksync_swap_BigDecimal
  totalSupply_in: [zksync_swap_BigDecimal!]
  totalSupply_not_in: [zksync_swap_BigDecimal!]
  events_: zksync_swap_LpTokenEvent_filter
  """Filter for the block changed event."""
  _change_block: zksync_swap_BlockChangedFilter
  and: [zksync_swap_LpToken_filter]
  or: [zksync_swap_LpToken_filter]
}

enum zksync_swap_LpToken_orderBy {
  id
  address
  stableSwap
  stableSwap__id
  stableSwap__isActive
  stableSwap__key
  stableSwap__canonicalId
  stableSwap__domain
  stableSwap__swapPool
  stableSwap__lpToken
  stableSwap__initialA
  stableSwap__futureA
  stableSwap__initialATime
  stableSwap__futureATime
  stableSwap__swapFee
  stableSwap__adminFee
  stableSwap__virtualPrice
  stableSwap__invariant
  stableSwap__lpTokenSupply
  decimals
  name
  symbol
  totalSupply
  events
}

type zksync_swap_LpTransferEvent implements zksync_swap_LpTokenEvent {
  id: ID!
  token: zksync_swap_LpToken!
  amount: zksync_swap_BigDecimal!
  from: zksync_swap_Bytes!
  to: zksync_swap_Bytes!
  fromBalance: zksync_swap_BigDecimal!
  toBalance: zksync_swap_BigDecimal!
  block: BigInt!
  timestamp: BigInt!
  transaction: zksync_swap_Bytes!
  nonce: BigInt!
}

input zksync_swap_LpTransferEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  token: String
  token_not: String
  token_gt: String
  token_lt: String
  token_gte: String
  token_lte: String
  token_in: [String!]
  token_not_in: [String!]
  token_contains: String
  token_contains_nocase: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_: zksync_swap_LpToken_filter
  amount: zksync_swap_BigDecimal
  amount_not: zksync_swap_BigDecimal
  amount_gt: zksync_swap_BigDecimal
  amount_lt: zksync_swap_BigDecimal
  amount_gte: zksync_swap_BigDecimal
  amount_lte: zksync_swap_BigDecimal
  amount_in: [zksync_swap_BigDecimal!]
  amount_not_in: [zksync_swap_BigDecimal!]
  from: zksync_swap_Bytes
  from_not: zksync_swap_Bytes
  from_gt: zksync_swap_Bytes
  from_lt: zksync_swap_Bytes
  from_gte: zksync_swap_Bytes
  from_lte: zksync_swap_Bytes
  from_in: [zksync_swap_Bytes!]
  from_not_in: [zksync_swap_Bytes!]
  from_contains: zksync_swap_Bytes
  from_not_contains: zksync_swap_Bytes
  to: zksync_swap_Bytes
  to_not: zksync_swap_Bytes
  to_gt: zksync_swap_Bytes
  to_lt: zksync_swap_Bytes
  to_gte: zksync_swap_Bytes
  to_lte: zksync_swap_Bytes
  to_in: [zksync_swap_Bytes!]
  to_not_in: [zksync_swap_Bytes!]
  to_contains: zksync_swap_Bytes
  to_not_contains: zksync_swap_Bytes
  fromBalance: zksync_swap_BigDecimal
  fromBalance_not: zksync_swap_BigDecimal
  fromBalance_gt: zksync_swap_BigDecimal
  fromBalance_lt: zksync_swap_BigDecimal
  fromBalance_gte: zksync_swap_BigDecimal
  fromBalance_lte: zksync_swap_BigDecimal
  fromBalance_in: [zksync_swap_BigDecimal!]
  fromBalance_not_in: [zksync_swap_BigDecimal!]
  toBalance: zksync_swap_BigDecimal
  toBalance_not: zksync_swap_BigDecimal
  toBalance_gt: zksync_swap_BigDecimal
  toBalance_lt: zksync_swap_BigDecimal
  toBalance_gte: zksync_swap_BigDecimal
  toBalance_lte: zksync_swap_BigDecimal
  toBalance_in: [zksync_swap_BigDecimal!]
  toBalance_not_in: [zksync_swap_BigDecimal!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: zksync_swap_Bytes
  transaction_not: zksync_swap_Bytes
  transaction_gt: zksync_swap_Bytes
  transaction_lt: zksync_swap_Bytes
  transaction_gte: zksync_swap_Bytes
  transaction_lte: zksync_swap_Bytes
  transaction_in: [zksync_swap_Bytes!]
  transaction_not_in: [zksync_swap_Bytes!]
  transaction_contains: zksync_swap_Bytes
  transaction_not_contains: zksync_swap_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: zksync_swap_BlockChangedFilter
  and: [zksync_swap_LpTransferEvent_filter]
  or: [zksync_swap_LpTransferEvent_filter]
}

enum zksync_swap_LpTransferEvent_orderBy {
  id
  token
  token__id
  token__address
  token__decimals
  token__name
  token__symbol
  token__totalSupply
  amount
  from
  to
  fromBalance
  toBalance
  block
  timestamp
  transaction
  nonce
}

"""Defines the order direction, either ascending or descending"""
enum zksync_swap_OrderDirection {
  asc
  desc
}

type zksync_swap_PooledToken {
  id: ID!
  asset: zksync_swap_Bytes!
}

input zksync_swap_PooledToken_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  asset: zksync_swap_Bytes
  asset_not: zksync_swap_Bytes
  asset_gt: zksync_swap_Bytes
  asset_lt: zksync_swap_Bytes
  asset_gte: zksync_swap_Bytes
  asset_lte: zksync_swap_Bytes
  asset_in: [zksync_swap_Bytes!]
  asset_not_in: [zksync_swap_Bytes!]
  asset_contains: zksync_swap_Bytes
  asset_not_contains: zksync_swap_Bytes
  """Filter for the block changed event."""
  _change_block: zksync_swap_BlockChangedFilter
  and: [zksync_swap_PooledToken_filter]
  or: [zksync_swap_PooledToken_filter]
}

enum zksync_swap_PooledToken_orderBy {
  id
  asset
}

type zksync_swap_StableSwap {
  id: ID!
  isActive: Boolean
  key: zksync_swap_Bytes!
  canonicalId: zksync_swap_Bytes
  domain: BigInt
  swapPool: zksync_swap_Bytes
  lpToken: zksync_swap_Bytes
  initialA: BigInt
  futureA: BigInt
  initialATime: BigInt
  futureATime: BigInt
  swapFee: BigInt
  adminFee: BigInt
  pooledTokens: [zksync_swap_Bytes!]!
  tokenPrecisionMultipliers: [BigInt!]!
  balances: [BigInt!]!
  adminFees: [BigInt!]!
  virtualPrice: BigInt!
  invariant: BigInt!
  lpTokenSupply: BigInt!
  events(skip: Int = 0, first: Int = 100, orderBy: zksync_swap_StableSwapEvent_orderBy, orderDirection: zksync_swap_OrderDirection, where: zksync_swap_StableSwapEvent_filter): [zksync_swap_StableSwapEvent!]
  exchanges(skip: Int = 0, first: Int = 100, orderBy: zksync_swap_StableSwapExchange_orderBy, orderDirection: zksync_swap_OrderDirection, where: zksync_swap_StableSwapExchange_filter): [zksync_swap_StableSwapExchange!]
  hourlyVolumes(skip: Int = 0, first: Int = 100, orderBy: zksync_swap_SwapHourlyVolume_orderBy, orderDirection: zksync_swap_OrderDirection, where: zksync_swap_SwapHourlyVolume_filter): [zksync_swap_SwapHourlyVolume!]
  dailyVolumes(skip: Int = 0, first: Int = 100, orderBy: zksync_swap_SwapDailyVolume_orderBy, orderDirection: zksync_swap_OrderDirection, where: zksync_swap_SwapDailyVolume_filter): [zksync_swap_SwapDailyVolume!]
  weeklyVolumes(skip: Int = 0, first: Int = 100, orderBy: zksync_swap_SwapWeeklyVolume_orderBy, orderDirection: zksync_swap_OrderDirection, where: zksync_swap_SwapWeeklyVolume_filter): [zksync_swap_SwapWeeklyVolume!]
}

type zksync_swap_StableSwapAddLiquidityEvent implements zksync_swap_StableSwapEvent {
  id: ID!
  stableSwap: zksync_swap_StableSwap!
  provider: zksync_swap_Bytes!
  tokenAmounts: [BigInt!]!
  fees: [BigInt!]!
  invariant: BigInt
  lpTokenSupply: BigInt!
  lpTokenAmount: BigInt!
  balances: [BigInt!]!
  block: BigInt!
  timestamp: BigInt!
  transaction: zksync_swap_Bytes!
  nonce: BigInt!
}

input zksync_swap_StableSwapAddLiquidityEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: zksync_swap_StableSwap_filter
  provider: zksync_swap_Bytes
  provider_not: zksync_swap_Bytes
  provider_gt: zksync_swap_Bytes
  provider_lt: zksync_swap_Bytes
  provider_gte: zksync_swap_Bytes
  provider_lte: zksync_swap_Bytes
  provider_in: [zksync_swap_Bytes!]
  provider_not_in: [zksync_swap_Bytes!]
  provider_contains: zksync_swap_Bytes
  provider_not_contains: zksync_swap_Bytes
  tokenAmounts: [BigInt!]
  tokenAmounts_not: [BigInt!]
  tokenAmounts_contains: [BigInt!]
  tokenAmounts_contains_nocase: [BigInt!]
  tokenAmounts_not_contains: [BigInt!]
  tokenAmounts_not_contains_nocase: [BigInt!]
  fees: [BigInt!]
  fees_not: [BigInt!]
  fees_contains: [BigInt!]
  fees_contains_nocase: [BigInt!]
  fees_not_contains: [BigInt!]
  fees_not_contains_nocase: [BigInt!]
  invariant: BigInt
  invariant_not: BigInt
  invariant_gt: BigInt
  invariant_lt: BigInt
  invariant_gte: BigInt
  invariant_lte: BigInt
  invariant_in: [BigInt!]
  invariant_not_in: [BigInt!]
  lpTokenSupply: BigInt
  lpTokenSupply_not: BigInt
  lpTokenSupply_gt: BigInt
  lpTokenSupply_lt: BigInt
  lpTokenSupply_gte: BigInt
  lpTokenSupply_lte: BigInt
  lpTokenSupply_in: [BigInt!]
  lpTokenSupply_not_in: [BigInt!]
  lpTokenAmount: BigInt
  lpTokenAmount_not: BigInt
  lpTokenAmount_gt: BigInt
  lpTokenAmount_lt: BigInt
  lpTokenAmount_gte: BigInt
  lpTokenAmount_lte: BigInt
  lpTokenAmount_in: [BigInt!]
  lpTokenAmount_not_in: [BigInt!]
  balances: [BigInt!]
  balances_not: [BigInt!]
  balances_contains: [BigInt!]
  balances_contains_nocase: [BigInt!]
  balances_not_contains: [BigInt!]
  balances_not_contains_nocase: [BigInt!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: zksync_swap_Bytes
  transaction_not: zksync_swap_Bytes
  transaction_gt: zksync_swap_Bytes
  transaction_lt: zksync_swap_Bytes
  transaction_gte: zksync_swap_Bytes
  transaction_lte: zksync_swap_Bytes
  transaction_in: [zksync_swap_Bytes!]
  transaction_not_in: [zksync_swap_Bytes!]
  transaction_contains: zksync_swap_Bytes
  transaction_not_contains: zksync_swap_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: zksync_swap_BlockChangedFilter
  and: [zksync_swap_StableSwapAddLiquidityEvent_filter]
  or: [zksync_swap_StableSwapAddLiquidityEvent_filter]
}

enum zksync_swap_StableSwapAddLiquidityEvent_orderBy {
  id
  stableSwap
  stableSwap__id
  stableSwap__isActive
  stableSwap__key
  stableSwap__canonicalId
  stableSwap__domain
  stableSwap__swapPool
  stableSwap__lpToken
  stableSwap__initialA
  stableSwap__futureA
  stableSwap__initialATime
  stableSwap__futureATime
  stableSwap__swapFee
  stableSwap__adminFee
  stableSwap__virtualPrice
  stableSwap__invariant
  stableSwap__lpTokenSupply
  provider
  tokenAmounts
  fees
  invariant
  lpTokenSupply
  lpTokenAmount
  balances
  block
  timestamp
  transaction
  nonce
}

interface zksync_swap_StableSwapEvent {
  id: ID!
  stableSwap: zksync_swap_StableSwap!
  block: BigInt!
  timestamp: BigInt!
  transaction: zksync_swap_Bytes!
  nonce: BigInt!
}

input zksync_swap_StableSwapEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: zksync_swap_StableSwap_filter
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: zksync_swap_Bytes
  transaction_not: zksync_swap_Bytes
  transaction_gt: zksync_swap_Bytes
  transaction_lt: zksync_swap_Bytes
  transaction_gte: zksync_swap_Bytes
  transaction_lte: zksync_swap_Bytes
  transaction_in: [zksync_swap_Bytes!]
  transaction_not_in: [zksync_swap_Bytes!]
  transaction_contains: zksync_swap_Bytes
  transaction_not_contains: zksync_swap_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: zksync_swap_BlockChangedFilter
  and: [zksync_swap_StableSwapEvent_filter]
  or: [zksync_swap_StableSwapEvent_filter]
}

enum zksync_swap_StableSwapEvent_orderBy {
  id
  stableSwap
  stableSwap__id
  stableSwap__isActive
  stableSwap__key
  stableSwap__canonicalId
  stableSwap__domain
  stableSwap__swapPool
  stableSwap__lpToken
  stableSwap__initialA
  stableSwap__futureA
  stableSwap__initialATime
  stableSwap__futureATime
  stableSwap__swapFee
  stableSwap__adminFee
  stableSwap__virtualPrice
  stableSwap__invariant
  stableSwap__lpTokenSupply
  block
  timestamp
  transaction
  nonce
}

type zksync_swap_StableSwapExchange {
  id: ID!
  stableSwap: zksync_swap_StableSwap!
  buyer: zksync_swap_Bytes!
  boughtId: BigInt!
  tokensBought: BigInt!
  soldId: BigInt!
  tokensSold: BigInt!
  balances: [BigInt!]!
  fee: BigInt!
  block: BigInt!
  timestamp: BigInt!
  transaction: zksync_swap_Bytes!
  nonce: BigInt!
}

input zksync_swap_StableSwapExchange_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: zksync_swap_StableSwap_filter
  buyer: zksync_swap_Bytes
  buyer_not: zksync_swap_Bytes
  buyer_gt: zksync_swap_Bytes
  buyer_lt: zksync_swap_Bytes
  buyer_gte: zksync_swap_Bytes
  buyer_lte: zksync_swap_Bytes
  buyer_in: [zksync_swap_Bytes!]
  buyer_not_in: [zksync_swap_Bytes!]
  buyer_contains: zksync_swap_Bytes
  buyer_not_contains: zksync_swap_Bytes
  boughtId: BigInt
  boughtId_not: BigInt
  boughtId_gt: BigInt
  boughtId_lt: BigInt
  boughtId_gte: BigInt
  boughtId_lte: BigInt
  boughtId_in: [BigInt!]
  boughtId_not_in: [BigInt!]
  tokensBought: BigInt
  tokensBought_not: BigInt
  tokensBought_gt: BigInt
  tokensBought_lt: BigInt
  tokensBought_gte: BigInt
  tokensBought_lte: BigInt
  tokensBought_in: [BigInt!]
  tokensBought_not_in: [BigInt!]
  soldId: BigInt
  soldId_not: BigInt
  soldId_gt: BigInt
  soldId_lt: BigInt
  soldId_gte: BigInt
  soldId_lte: BigInt
  soldId_in: [BigInt!]
  soldId_not_in: [BigInt!]
  tokensSold: BigInt
  tokensSold_not: BigInt
  tokensSold_gt: BigInt
  tokensSold_lt: BigInt
  tokensSold_gte: BigInt
  tokensSold_lte: BigInt
  tokensSold_in: [BigInt!]
  tokensSold_not_in: [BigInt!]
  balances: [BigInt!]
  balances_not: [BigInt!]
  balances_contains: [BigInt!]
  balances_contains_nocase: [BigInt!]
  balances_not_contains: [BigInt!]
  balances_not_contains_nocase: [BigInt!]
  fee: BigInt
  fee_not: BigInt
  fee_gt: BigInt
  fee_lt: BigInt
  fee_gte: BigInt
  fee_lte: BigInt
  fee_in: [BigInt!]
  fee_not_in: [BigInt!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: zksync_swap_Bytes
  transaction_not: zksync_swap_Bytes
  transaction_gt: zksync_swap_Bytes
  transaction_lt: zksync_swap_Bytes
  transaction_gte: zksync_swap_Bytes
  transaction_lte: zksync_swap_Bytes
  transaction_in: [zksync_swap_Bytes!]
  transaction_not_in: [zksync_swap_Bytes!]
  transaction_contains: zksync_swap_Bytes
  transaction_not_contains: zksync_swap_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: zksync_swap_BlockChangedFilter
  and: [zksync_swap_StableSwapExchange_filter]
  or: [zksync_swap_StableSwapExchange_filter]
}

enum zksync_swap_StableSwapExchange_orderBy {
  id
  stableSwap
  stableSwap__id
  stableSwap__isActive
  stableSwap__key
  stableSwap__canonicalId
  stableSwap__domain
  stableSwap__swapPool
  stableSwap__lpToken
  stableSwap__initialA
  stableSwap__futureA
  stableSwap__initialATime
  stableSwap__futureATime
  stableSwap__swapFee
  stableSwap__adminFee
  stableSwap__virtualPrice
  stableSwap__invariant
  stableSwap__lpTokenSupply
  buyer
  boughtId
  tokensBought
  soldId
  tokensSold
  balances
  fee
  block
  timestamp
  transaction
  nonce
}

type zksync_swap_StableSwapRemoveLiquidityEvent implements zksync_swap_StableSwapEvent {
  id: ID!
  stableSwap: zksync_swap_StableSwap!
  provider: zksync_swap_Bytes!
  tokenAmounts: [BigInt!]!
  fees: [BigInt!]
  invariant: BigInt
  lpTokenSupply: BigInt!
  lpTokenAmount: BigInt!
  balances: [BigInt!]!
  block: BigInt!
  timestamp: BigInt!
  transaction: zksync_swap_Bytes!
  nonce: BigInt!
}

input zksync_swap_StableSwapRemoveLiquidityEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: zksync_swap_StableSwap_filter
  provider: zksync_swap_Bytes
  provider_not: zksync_swap_Bytes
  provider_gt: zksync_swap_Bytes
  provider_lt: zksync_swap_Bytes
  provider_gte: zksync_swap_Bytes
  provider_lte: zksync_swap_Bytes
  provider_in: [zksync_swap_Bytes!]
  provider_not_in: [zksync_swap_Bytes!]
  provider_contains: zksync_swap_Bytes
  provider_not_contains: zksync_swap_Bytes
  tokenAmounts: [BigInt!]
  tokenAmounts_not: [BigInt!]
  tokenAmounts_contains: [BigInt!]
  tokenAmounts_contains_nocase: [BigInt!]
  tokenAmounts_not_contains: [BigInt!]
  tokenAmounts_not_contains_nocase: [BigInt!]
  fees: [BigInt!]
  fees_not: [BigInt!]
  fees_contains: [BigInt!]
  fees_contains_nocase: [BigInt!]
  fees_not_contains: [BigInt!]
  fees_not_contains_nocase: [BigInt!]
  invariant: BigInt
  invariant_not: BigInt
  invariant_gt: BigInt
  invariant_lt: BigInt
  invariant_gte: BigInt
  invariant_lte: BigInt
  invariant_in: [BigInt!]
  invariant_not_in: [BigInt!]
  lpTokenSupply: BigInt
  lpTokenSupply_not: BigInt
  lpTokenSupply_gt: BigInt
  lpTokenSupply_lt: BigInt
  lpTokenSupply_gte: BigInt
  lpTokenSupply_lte: BigInt
  lpTokenSupply_in: [BigInt!]
  lpTokenSupply_not_in: [BigInt!]
  lpTokenAmount: BigInt
  lpTokenAmount_not: BigInt
  lpTokenAmount_gt: BigInt
  lpTokenAmount_lt: BigInt
  lpTokenAmount_gte: BigInt
  lpTokenAmount_lte: BigInt
  lpTokenAmount_in: [BigInt!]
  lpTokenAmount_not_in: [BigInt!]
  balances: [BigInt!]
  balances_not: [BigInt!]
  balances_contains: [BigInt!]
  balances_contains_nocase: [BigInt!]
  balances_not_contains: [BigInt!]
  balances_not_contains_nocase: [BigInt!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: zksync_swap_Bytes
  transaction_not: zksync_swap_Bytes
  transaction_gt: zksync_swap_Bytes
  transaction_lt: zksync_swap_Bytes
  transaction_gte: zksync_swap_Bytes
  transaction_lte: zksync_swap_Bytes
  transaction_in: [zksync_swap_Bytes!]
  transaction_not_in: [zksync_swap_Bytes!]
  transaction_contains: zksync_swap_Bytes
  transaction_not_contains: zksync_swap_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: zksync_swap_BlockChangedFilter
  and: [zksync_swap_StableSwapRemoveLiquidityEvent_filter]
  or: [zksync_swap_StableSwapRemoveLiquidityEvent_filter]
}

enum zksync_swap_StableSwapRemoveLiquidityEvent_orderBy {
  id
  stableSwap
  stableSwap__id
  stableSwap__isActive
  stableSwap__key
  stableSwap__canonicalId
  stableSwap__domain
  stableSwap__swapPool
  stableSwap__lpToken
  stableSwap__initialA
  stableSwap__futureA
  stableSwap__initialATime
  stableSwap__futureATime
  stableSwap__swapFee
  stableSwap__adminFee
  stableSwap__virtualPrice
  stableSwap__invariant
  stableSwap__lpTokenSupply
  provider
  tokenAmounts
  fees
  invariant
  lpTokenSupply
  lpTokenAmount
  balances
  block
  timestamp
  transaction
  nonce
}

input zksync_swap_StableSwap_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  isActive: Boolean
  isActive_not: Boolean
  isActive_in: [Boolean!]
  isActive_not_in: [Boolean!]
  key: zksync_swap_Bytes
  key_not: zksync_swap_Bytes
  key_gt: zksync_swap_Bytes
  key_lt: zksync_swap_Bytes
  key_gte: zksync_swap_Bytes
  key_lte: zksync_swap_Bytes
  key_in: [zksync_swap_Bytes!]
  key_not_in: [zksync_swap_Bytes!]
  key_contains: zksync_swap_Bytes
  key_not_contains: zksync_swap_Bytes
  canonicalId: zksync_swap_Bytes
  canonicalId_not: zksync_swap_Bytes
  canonicalId_gt: zksync_swap_Bytes
  canonicalId_lt: zksync_swap_Bytes
  canonicalId_gte: zksync_swap_Bytes
  canonicalId_lte: zksync_swap_Bytes
  canonicalId_in: [zksync_swap_Bytes!]
  canonicalId_not_in: [zksync_swap_Bytes!]
  canonicalId_contains: zksync_swap_Bytes
  canonicalId_not_contains: zksync_swap_Bytes
  domain: BigInt
  domain_not: BigInt
  domain_gt: BigInt
  domain_lt: BigInt
  domain_gte: BigInt
  domain_lte: BigInt
  domain_in: [BigInt!]
  domain_not_in: [BigInt!]
  swapPool: zksync_swap_Bytes
  swapPool_not: zksync_swap_Bytes
  swapPool_gt: zksync_swap_Bytes
  swapPool_lt: zksync_swap_Bytes
  swapPool_gte: zksync_swap_Bytes
  swapPool_lte: zksync_swap_Bytes
  swapPool_in: [zksync_swap_Bytes!]
  swapPool_not_in: [zksync_swap_Bytes!]
  swapPool_contains: zksync_swap_Bytes
  swapPool_not_contains: zksync_swap_Bytes
  lpToken: zksync_swap_Bytes
  lpToken_not: zksync_swap_Bytes
  lpToken_gt: zksync_swap_Bytes
  lpToken_lt: zksync_swap_Bytes
  lpToken_gte: zksync_swap_Bytes
  lpToken_lte: zksync_swap_Bytes
  lpToken_in: [zksync_swap_Bytes!]
  lpToken_not_in: [zksync_swap_Bytes!]
  lpToken_contains: zksync_swap_Bytes
  lpToken_not_contains: zksync_swap_Bytes
  initialA: BigInt
  initialA_not: BigInt
  initialA_gt: BigInt
  initialA_lt: BigInt
  initialA_gte: BigInt
  initialA_lte: BigInt
  initialA_in: [BigInt!]
  initialA_not_in: [BigInt!]
  futureA: BigInt
  futureA_not: BigInt
  futureA_gt: BigInt
  futureA_lt: BigInt
  futureA_gte: BigInt
  futureA_lte: BigInt
  futureA_in: [BigInt!]
  futureA_not_in: [BigInt!]
  initialATime: BigInt
  initialATime_not: BigInt
  initialATime_gt: BigInt
  initialATime_lt: BigInt
  initialATime_gte: BigInt
  initialATime_lte: BigInt
  initialATime_in: [BigInt!]
  initialATime_not_in: [BigInt!]
  futureATime: BigInt
  futureATime_not: BigInt
  futureATime_gt: BigInt
  futureATime_lt: BigInt
  futureATime_gte: BigInt
  futureATime_lte: BigInt
  futureATime_in: [BigInt!]
  futureATime_not_in: [BigInt!]
  swapFee: BigInt
  swapFee_not: BigInt
  swapFee_gt: BigInt
  swapFee_lt: BigInt
  swapFee_gte: BigInt
  swapFee_lte: BigInt
  swapFee_in: [BigInt!]
  swapFee_not_in: [BigInt!]
  adminFee: BigInt
  adminFee_not: BigInt
  adminFee_gt: BigInt
  adminFee_lt: BigInt
  adminFee_gte: BigInt
  adminFee_lte: BigInt
  adminFee_in: [BigInt!]
  adminFee_not_in: [BigInt!]
  pooledTokens: [zksync_swap_Bytes!]
  pooledTokens_not: [zksync_swap_Bytes!]
  pooledTokens_contains: [zksync_swap_Bytes!]
  pooledTokens_contains_nocase: [zksync_swap_Bytes!]
  pooledTokens_not_contains: [zksync_swap_Bytes!]
  pooledTokens_not_contains_nocase: [zksync_swap_Bytes!]
  tokenPrecisionMultipliers: [BigInt!]
  tokenPrecisionMultipliers_not: [BigInt!]
  tokenPrecisionMultipliers_contains: [BigInt!]
  tokenPrecisionMultipliers_contains_nocase: [BigInt!]
  tokenPrecisionMultipliers_not_contains: [BigInt!]
  tokenPrecisionMultipliers_not_contains_nocase: [BigInt!]
  balances: [BigInt!]
  balances_not: [BigInt!]
  balances_contains: [BigInt!]
  balances_contains_nocase: [BigInt!]
  balances_not_contains: [BigInt!]
  balances_not_contains_nocase: [BigInt!]
  adminFees: [BigInt!]
  adminFees_not: [BigInt!]
  adminFees_contains: [BigInt!]
  adminFees_contains_nocase: [BigInt!]
  adminFees_not_contains: [BigInt!]
  adminFees_not_contains_nocase: [BigInt!]
  virtualPrice: BigInt
  virtualPrice_not: BigInt
  virtualPrice_gt: BigInt
  virtualPrice_lt: BigInt
  virtualPrice_gte: BigInt
  virtualPrice_lte: BigInt
  virtualPrice_in: [BigInt!]
  virtualPrice_not_in: [BigInt!]
  invariant: BigInt
  invariant_not: BigInt
  invariant_gt: BigInt
  invariant_lt: BigInt
  invariant_gte: BigInt
  invariant_lte: BigInt
  invariant_in: [BigInt!]
  invariant_not_in: [BigInt!]
  lpTokenSupply: BigInt
  lpTokenSupply_not: BigInt
  lpTokenSupply_gt: BigInt
  lpTokenSupply_lt: BigInt
  lpTokenSupply_gte: BigInt
  lpTokenSupply_lte: BigInt
  lpTokenSupply_in: [BigInt!]
  lpTokenSupply_not_in: [BigInt!]
  events_: zksync_swap_StableSwapEvent_filter
  exchanges_: zksync_swap_StableSwapExchange_filter
  hourlyVolumes_: zksync_swap_SwapHourlyVolume_filter
  dailyVolumes_: zksync_swap_SwapDailyVolume_filter
  weeklyVolumes_: zksync_swap_SwapWeeklyVolume_filter
  """Filter for the block changed event."""
  _change_block: zksync_swap_BlockChangedFilter
  and: [zksync_swap_StableSwap_filter]
  or: [zksync_swap_StableSwap_filter]
}

enum zksync_swap_StableSwap_orderBy {
  id
  isActive
  key
  canonicalId
  domain
  swapPool
  lpToken
  initialA
  futureA
  initialATime
  futureATime
  swapFee
  adminFee
  pooledTokens
  tokenPrecisionMultipliers
  balances
  adminFees
  virtualPrice
  invariant
  lpTokenSupply
  events
  exchanges
  hourlyVolumes
  dailyVolumes
  weeklyVolumes
}

type zksync_swap_SwapDailyVolume implements zksync_swap_SwapTradeVolume {
  id: ID!
  stableSwap: zksync_swap_StableSwap!
  timestamp: BigInt!
  volume: zksync_swap_BigDecimal!
}

input zksync_swap_SwapDailyVolume_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: zksync_swap_StableSwap_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  volume: zksync_swap_BigDecimal
  volume_not: zksync_swap_BigDecimal
  volume_gt: zksync_swap_BigDecimal
  volume_lt: zksync_swap_BigDecimal
  volume_gte: zksync_swap_BigDecimal
  volume_lte: zksync_swap_BigDecimal
  volume_in: [zksync_swap_BigDecimal!]
  volume_not_in: [zksync_swap_BigDecimal!]
  """Filter for the block changed event."""
  _change_block: zksync_swap_BlockChangedFilter
  and: [zksync_swap_SwapDailyVolume_filter]
  or: [zksync_swap_SwapDailyVolume_filter]
}

enum zksync_swap_SwapDailyVolume_orderBy {
  id
  stableSwap
  stableSwap__id
  stableSwap__isActive
  stableSwap__key
  stableSwap__canonicalId
  stableSwap__domain
  stableSwap__swapPool
  stableSwap__lpToken
  stableSwap__initialA
  stableSwap__futureA
  stableSwap__initialATime
  stableSwap__futureATime
  stableSwap__swapFee
  stableSwap__adminFee
  stableSwap__virtualPrice
  stableSwap__invariant
  stableSwap__lpTokenSupply
  timestamp
  volume
}

type zksync_swap_SwapHourlyVolume implements zksync_swap_SwapTradeVolume {
  id: ID!
  stableSwap: zksync_swap_StableSwap!
  timestamp: BigInt!
  volume: zksync_swap_BigDecimal!
}

input zksync_swap_SwapHourlyVolume_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: zksync_swap_StableSwap_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  volume: zksync_swap_BigDecimal
  volume_not: zksync_swap_BigDecimal
  volume_gt: zksync_swap_BigDecimal
  volume_lt: zksync_swap_BigDecimal
  volume_gte: zksync_swap_BigDecimal
  volume_lte: zksync_swap_BigDecimal
  volume_in: [zksync_swap_BigDecimal!]
  volume_not_in: [zksync_swap_BigDecimal!]
  """Filter for the block changed event."""
  _change_block: zksync_swap_BlockChangedFilter
  and: [zksync_swap_SwapHourlyVolume_filter]
  or: [zksync_swap_SwapHourlyVolume_filter]
}

enum zksync_swap_SwapHourlyVolume_orderBy {
  id
  stableSwap
  stableSwap__id
  stableSwap__isActive
  stableSwap__key
  stableSwap__canonicalId
  stableSwap__domain
  stableSwap__swapPool
  stableSwap__lpToken
  stableSwap__initialA
  stableSwap__futureA
  stableSwap__initialATime
  stableSwap__futureATime
  stableSwap__swapFee
  stableSwap__adminFee
  stableSwap__virtualPrice
  stableSwap__invariant
  stableSwap__lpTokenSupply
  timestamp
  volume
}

interface zksync_swap_SwapTradeVolume {
  stableSwap: zksync_swap_StableSwap!
  timestamp: BigInt!
  volume: zksync_swap_BigDecimal!
}

input zksync_swap_SwapTradeVolume_filter {
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: zksync_swap_StableSwap_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  volume: zksync_swap_BigDecimal
  volume_not: zksync_swap_BigDecimal
  volume_gt: zksync_swap_BigDecimal
  volume_lt: zksync_swap_BigDecimal
  volume_gte: zksync_swap_BigDecimal
  volume_lte: zksync_swap_BigDecimal
  volume_in: [zksync_swap_BigDecimal!]
  volume_not_in: [zksync_swap_BigDecimal!]
  """Filter for the block changed event."""
  _change_block: zksync_swap_BlockChangedFilter
  and: [zksync_swap_SwapTradeVolume_filter]
  or: [zksync_swap_SwapTradeVolume_filter]
}

enum zksync_swap_SwapTradeVolume_orderBy {
  stableSwap
  stableSwap__id
  stableSwap__isActive
  stableSwap__key
  stableSwap__canonicalId
  stableSwap__domain
  stableSwap__swapPool
  stableSwap__lpToken
  stableSwap__initialA
  stableSwap__futureA
  stableSwap__initialATime
  stableSwap__futureATime
  stableSwap__swapFee
  stableSwap__adminFee
  stableSwap__virtualPrice
  stableSwap__invariant
  stableSwap__lpTokenSupply
  timestamp
  volume
}

type zksync_swap_SwapWeeklyVolume implements zksync_swap_SwapTradeVolume {
  id: ID!
  stableSwap: zksync_swap_StableSwap!
  timestamp: BigInt!
  volume: zksync_swap_BigDecimal!
}

input zksync_swap_SwapWeeklyVolume_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: zksync_swap_StableSwap_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  volume: zksync_swap_BigDecimal
  volume_not: zksync_swap_BigDecimal
  volume_gt: zksync_swap_BigDecimal
  volume_lt: zksync_swap_BigDecimal
  volume_gte: zksync_swap_BigDecimal
  volume_lte: zksync_swap_BigDecimal
  volume_in: [zksync_swap_BigDecimal!]
  volume_not_in: [zksync_swap_BigDecimal!]
  """Filter for the block changed event."""
  _change_block: zksync_swap_BlockChangedFilter
  and: [zksync_swap_SwapWeeklyVolume_filter]
  or: [zksync_swap_SwapWeeklyVolume_filter]
}

enum zksync_swap_SwapWeeklyVolume_orderBy {
  id
  stableSwap
  stableSwap__id
  stableSwap__isActive
  stableSwap__key
  stableSwap__canonicalId
  stableSwap__domain
  stableSwap__swapPool
  stableSwap__lpToken
  stableSwap__initialA
  stableSwap__futureA
  stableSwap__initialATime
  stableSwap__futureATime
  stableSwap__swapFee
  stableSwap__adminFee
  stableSwap__virtualPrice
  stableSwap__invariant
  stableSwap__lpTokenSupply
  timestamp
  volume
}

type zksync_swap_SystemInfo {
  id: ID!
  exchangeCount: BigInt!
  swapCount: BigInt!
}

input zksync_swap_SystemInfo_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  exchangeCount: BigInt
  exchangeCount_not: BigInt
  exchangeCount_gt: BigInt
  exchangeCount_lt: BigInt
  exchangeCount_gte: BigInt
  exchangeCount_lte: BigInt
  exchangeCount_in: [BigInt!]
  exchangeCount_not_in: [BigInt!]
  swapCount: BigInt
  swapCount_not: BigInt
  swapCount_gt: BigInt
  swapCount_lt: BigInt
  swapCount_gte: BigInt
  swapCount_lte: BigInt
  swapCount_in: [BigInt!]
  swapCount_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: zksync_swap_BlockChangedFilter
  and: [zksync_swap_SystemInfo_filter]
  or: [zksync_swap_SystemInfo_filter]
}

enum zksync_swap_SystemInfo_orderBy {
  id
  exchangeCount
  swapCount
}

type zksync_swap__Block_ {
  """The hash of the block"""
  hash: zksync_swap_Bytes
  """The block number"""
  number: Int!
  """Integer representation of the timestamp stored in blocks for the chain"""
  timestamp: Int
  """The hash of the parent block"""
  parentHash: zksync_swap_Bytes
}

"""The type for the top-level _meta field"""
type zksync_swap__Meta_ {
  """
  Information about a specific subgraph block. The hash of the block
  will be null if the _meta field has a block constraint that asks for
  a block number. It will be filled if the _meta field has no block constraint
  and therefore asks for the latest  block
  
  """
  block: zksync_swap__Block_!
  """The deployment ID"""
  deployment: String!
  """If `true`, the subgraph encountered indexing errors at some past block"""
  hasIndexingErrors: Boolean!
}

enum linea_swap_Aggregation_interval {
  hour
  day
}

scalar linea_swap_BigDecimal

input linea_swap_BlockChangedFilter {
  number_gte: Int!
}

input linea_swap_Block_height {
  hash: linea_swap_Bytes
  number: Int
  number_gte: Int
}

scalar linea_swap_Bytes

"""
8 bytes signed integer

"""
scalar linea_swap_Int8

type linea_swap_LpAccount {
  id: ID!
  address: linea_swap_Bytes!
  balances(skip: Int = 0, first: Int = 100, orderBy: linea_swap_LpAccountBalance_orderBy, orderDirection: linea_swap_OrderDirection, where: linea_swap_LpAccountBalance_filter): [linea_swap_LpAccountBalance!]!
}

type linea_swap_LpAccountBalance {
  id: ID!
  account: linea_swap_LpAccount!
  token: linea_swap_LpToken!
  amount: linea_swap_BigDecimal!
  block: BigInt
  modified: BigInt
  transaction: linea_swap_Bytes
}

input linea_swap_LpAccountBalance_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  account: String
  account_not: String
  account_gt: String
  account_lt: String
  account_gte: String
  account_lte: String
  account_in: [String!]
  account_not_in: [String!]
  account_contains: String
  account_contains_nocase: String
  account_not_contains: String
  account_not_contains_nocase: String
  account_starts_with: String
  account_starts_with_nocase: String
  account_not_starts_with: String
  account_not_starts_with_nocase: String
  account_ends_with: String
  account_ends_with_nocase: String
  account_not_ends_with: String
  account_not_ends_with_nocase: String
  account_: linea_swap_LpAccount_filter
  token: String
  token_not: String
  token_gt: String
  token_lt: String
  token_gte: String
  token_lte: String
  token_in: [String!]
  token_not_in: [String!]
  token_contains: String
  token_contains_nocase: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_: linea_swap_LpToken_filter
  amount: linea_swap_BigDecimal
  amount_not: linea_swap_BigDecimal
  amount_gt: linea_swap_BigDecimal
  amount_lt: linea_swap_BigDecimal
  amount_gte: linea_swap_BigDecimal
  amount_lte: linea_swap_BigDecimal
  amount_in: [linea_swap_BigDecimal!]
  amount_not_in: [linea_swap_BigDecimal!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  modified: BigInt
  modified_not: BigInt
  modified_gt: BigInt
  modified_lt: BigInt
  modified_gte: BigInt
  modified_lte: BigInt
  modified_in: [BigInt!]
  modified_not_in: [BigInt!]
  transaction: linea_swap_Bytes
  transaction_not: linea_swap_Bytes
  transaction_gt: linea_swap_Bytes
  transaction_lt: linea_swap_Bytes
  transaction_gte: linea_swap_Bytes
  transaction_lte: linea_swap_Bytes
  transaction_in: [linea_swap_Bytes!]
  transaction_not_in: [linea_swap_Bytes!]
  transaction_contains: linea_swap_Bytes
  transaction_not_contains: linea_swap_Bytes
  """Filter for the block changed event."""
  _change_block: linea_swap_BlockChangedFilter
  and: [linea_swap_LpAccountBalance_filter]
  or: [linea_swap_LpAccountBalance_filter]
}

enum linea_swap_LpAccountBalance_orderBy {
  id
  account
  account__id
  account__address
  token
  token__id
  token__address
  token__decimals
  token__name
  token__symbol
  token__totalSupply
  amount
  block
  modified
  transaction
}

input linea_swap_LpAccount_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  address: linea_swap_Bytes
  address_not: linea_swap_Bytes
  address_gt: linea_swap_Bytes
  address_lt: linea_swap_Bytes
  address_gte: linea_swap_Bytes
  address_lte: linea_swap_Bytes
  address_in: [linea_swap_Bytes!]
  address_not_in: [linea_swap_Bytes!]
  address_contains: linea_swap_Bytes
  address_not_contains: linea_swap_Bytes
  balances_: linea_swap_LpAccountBalance_filter
  """Filter for the block changed event."""
  _change_block: linea_swap_BlockChangedFilter
  and: [linea_swap_LpAccount_filter]
  or: [linea_swap_LpAccount_filter]
}

enum linea_swap_LpAccount_orderBy {
  id
  address
  balances
}

type linea_swap_LpToken {
  id: ID!
  address: linea_swap_Bytes!
  stableSwap: linea_swap_StableSwap!
  decimals: Int!
  name: String!
  symbol: String!
  totalSupply: linea_swap_BigDecimal!
  events(skip: Int = 0, first: Int = 100, orderBy: linea_swap_LpTokenEvent_orderBy, orderDirection: linea_swap_OrderDirection, where: linea_swap_LpTokenEvent_filter): [linea_swap_LpTokenEvent!]!
}

interface linea_swap_LpTokenEvent {
  id: ID!
  token: linea_swap_LpToken!
  amount: linea_swap_BigDecimal!
  block: BigInt!
  timestamp: BigInt!
  transaction: linea_swap_Bytes!
  nonce: BigInt!
}

input linea_swap_LpTokenEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  token: String
  token_not: String
  token_gt: String
  token_lt: String
  token_gte: String
  token_lte: String
  token_in: [String!]
  token_not_in: [String!]
  token_contains: String
  token_contains_nocase: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_: linea_swap_LpToken_filter
  amount: linea_swap_BigDecimal
  amount_not: linea_swap_BigDecimal
  amount_gt: linea_swap_BigDecimal
  amount_lt: linea_swap_BigDecimal
  amount_gte: linea_swap_BigDecimal
  amount_lte: linea_swap_BigDecimal
  amount_in: [linea_swap_BigDecimal!]
  amount_not_in: [linea_swap_BigDecimal!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: linea_swap_Bytes
  transaction_not: linea_swap_Bytes
  transaction_gt: linea_swap_Bytes
  transaction_lt: linea_swap_Bytes
  transaction_gte: linea_swap_Bytes
  transaction_lte: linea_swap_Bytes
  transaction_in: [linea_swap_Bytes!]
  transaction_not_in: [linea_swap_Bytes!]
  transaction_contains: linea_swap_Bytes
  transaction_not_contains: linea_swap_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: linea_swap_BlockChangedFilter
  and: [linea_swap_LpTokenEvent_filter]
  or: [linea_swap_LpTokenEvent_filter]
}

enum linea_swap_LpTokenEvent_orderBy {
  id
  token
  token__id
  token__address
  token__decimals
  token__name
  token__symbol
  token__totalSupply
  amount
  block
  timestamp
  transaction
  nonce
}

input linea_swap_LpToken_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  address: linea_swap_Bytes
  address_not: linea_swap_Bytes
  address_gt: linea_swap_Bytes
  address_lt: linea_swap_Bytes
  address_gte: linea_swap_Bytes
  address_lte: linea_swap_Bytes
  address_in: [linea_swap_Bytes!]
  address_not_in: [linea_swap_Bytes!]
  address_contains: linea_swap_Bytes
  address_not_contains: linea_swap_Bytes
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: linea_swap_StableSwap_filter
  decimals: Int
  decimals_not: Int
  decimals_gt: Int
  decimals_lt: Int
  decimals_gte: Int
  decimals_lte: Int
  decimals_in: [Int!]
  decimals_not_in: [Int!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  symbol: String
  symbol_not: String
  symbol_gt: String
  symbol_lt: String
  symbol_gte: String
  symbol_lte: String
  symbol_in: [String!]
  symbol_not_in: [String!]
  symbol_contains: String
  symbol_contains_nocase: String
  symbol_not_contains: String
  symbol_not_contains_nocase: String
  symbol_starts_with: String
  symbol_starts_with_nocase: String
  symbol_not_starts_with: String
  symbol_not_starts_with_nocase: String
  symbol_ends_with: String
  symbol_ends_with_nocase: String
  symbol_not_ends_with: String
  symbol_not_ends_with_nocase: String
  totalSupply: linea_swap_BigDecimal
  totalSupply_not: linea_swap_BigDecimal
  totalSupply_gt: linea_swap_BigDecimal
  totalSupply_lt: linea_swap_BigDecimal
  totalSupply_gte: linea_swap_BigDecimal
  totalSupply_lte: linea_swap_BigDecimal
  totalSupply_in: [linea_swap_BigDecimal!]
  totalSupply_not_in: [linea_swap_BigDecimal!]
  events_: linea_swap_LpTokenEvent_filter
  """Filter for the block changed event."""
  _change_block: linea_swap_BlockChangedFilter
  and: [linea_swap_LpToken_filter]
  or: [linea_swap_LpToken_filter]
}

enum linea_swap_LpToken_orderBy {
  id
  address
  stableSwap
  stableSwap__id
  stableSwap__isActive
  stableSwap__key
  stableSwap__canonicalId
  stableSwap__domain
  stableSwap__swapPool
  stableSwap__lpToken
  stableSwap__initialA
  stableSwap__futureA
  stableSwap__initialATime
  stableSwap__futureATime
  stableSwap__swapFee
  stableSwap__adminFee
  stableSwap__virtualPrice
  stableSwap__invariant
  stableSwap__lpTokenSupply
  decimals
  name
  symbol
  totalSupply
  events
}

type linea_swap_LpTransferEvent implements linea_swap_LpTokenEvent {
  id: ID!
  token: linea_swap_LpToken!
  amount: linea_swap_BigDecimal!
  from: linea_swap_Bytes!
  to: linea_swap_Bytes!
  fromBalance: linea_swap_BigDecimal!
  toBalance: linea_swap_BigDecimal!
  block: BigInt!
  timestamp: BigInt!
  transaction: linea_swap_Bytes!
  nonce: BigInt!
}

input linea_swap_LpTransferEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  token: String
  token_not: String
  token_gt: String
  token_lt: String
  token_gte: String
  token_lte: String
  token_in: [String!]
  token_not_in: [String!]
  token_contains: String
  token_contains_nocase: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_: linea_swap_LpToken_filter
  amount: linea_swap_BigDecimal
  amount_not: linea_swap_BigDecimal
  amount_gt: linea_swap_BigDecimal
  amount_lt: linea_swap_BigDecimal
  amount_gte: linea_swap_BigDecimal
  amount_lte: linea_swap_BigDecimal
  amount_in: [linea_swap_BigDecimal!]
  amount_not_in: [linea_swap_BigDecimal!]
  from: linea_swap_Bytes
  from_not: linea_swap_Bytes
  from_gt: linea_swap_Bytes
  from_lt: linea_swap_Bytes
  from_gte: linea_swap_Bytes
  from_lte: linea_swap_Bytes
  from_in: [linea_swap_Bytes!]
  from_not_in: [linea_swap_Bytes!]
  from_contains: linea_swap_Bytes
  from_not_contains: linea_swap_Bytes
  to: linea_swap_Bytes
  to_not: linea_swap_Bytes
  to_gt: linea_swap_Bytes
  to_lt: linea_swap_Bytes
  to_gte: linea_swap_Bytes
  to_lte: linea_swap_Bytes
  to_in: [linea_swap_Bytes!]
  to_not_in: [linea_swap_Bytes!]
  to_contains: linea_swap_Bytes
  to_not_contains: linea_swap_Bytes
  fromBalance: linea_swap_BigDecimal
  fromBalance_not: linea_swap_BigDecimal
  fromBalance_gt: linea_swap_BigDecimal
  fromBalance_lt: linea_swap_BigDecimal
  fromBalance_gte: linea_swap_BigDecimal
  fromBalance_lte: linea_swap_BigDecimal
  fromBalance_in: [linea_swap_BigDecimal!]
  fromBalance_not_in: [linea_swap_BigDecimal!]
  toBalance: linea_swap_BigDecimal
  toBalance_not: linea_swap_BigDecimal
  toBalance_gt: linea_swap_BigDecimal
  toBalance_lt: linea_swap_BigDecimal
  toBalance_gte: linea_swap_BigDecimal
  toBalance_lte: linea_swap_BigDecimal
  toBalance_in: [linea_swap_BigDecimal!]
  toBalance_not_in: [linea_swap_BigDecimal!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: linea_swap_Bytes
  transaction_not: linea_swap_Bytes
  transaction_gt: linea_swap_Bytes
  transaction_lt: linea_swap_Bytes
  transaction_gte: linea_swap_Bytes
  transaction_lte: linea_swap_Bytes
  transaction_in: [linea_swap_Bytes!]
  transaction_not_in: [linea_swap_Bytes!]
  transaction_contains: linea_swap_Bytes
  transaction_not_contains: linea_swap_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: linea_swap_BlockChangedFilter
  and: [linea_swap_LpTransferEvent_filter]
  or: [linea_swap_LpTransferEvent_filter]
}

enum linea_swap_LpTransferEvent_orderBy {
  id
  token
  token__id
  token__address
  token__decimals
  token__name
  token__symbol
  token__totalSupply
  amount
  from
  to
  fromBalance
  toBalance
  block
  timestamp
  transaction
  nonce
}

"""Defines the order direction, either ascending or descending"""
enum linea_swap_OrderDirection {
  asc
  desc
}

type linea_swap_PooledToken {
  id: ID!
  asset: linea_swap_Bytes!
}

input linea_swap_PooledToken_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  asset: linea_swap_Bytes
  asset_not: linea_swap_Bytes
  asset_gt: linea_swap_Bytes
  asset_lt: linea_swap_Bytes
  asset_gte: linea_swap_Bytes
  asset_lte: linea_swap_Bytes
  asset_in: [linea_swap_Bytes!]
  asset_not_in: [linea_swap_Bytes!]
  asset_contains: linea_swap_Bytes
  asset_not_contains: linea_swap_Bytes
  """Filter for the block changed event."""
  _change_block: linea_swap_BlockChangedFilter
  and: [linea_swap_PooledToken_filter]
  or: [linea_swap_PooledToken_filter]
}

enum linea_swap_PooledToken_orderBy {
  id
  asset
}

type linea_swap_StableSwap {
  id: ID!
  isActive: Boolean
  key: linea_swap_Bytes!
  canonicalId: linea_swap_Bytes
  domain: BigInt
  swapPool: linea_swap_Bytes
  lpToken: linea_swap_Bytes
  initialA: BigInt
  futureA: BigInt
  initialATime: BigInt
  futureATime: BigInt
  swapFee: BigInt
  adminFee: BigInt
  pooledTokens: [linea_swap_Bytes!]!
  tokenPrecisionMultipliers: [BigInt!]!
  balances: [BigInt!]!
  adminFees: [BigInt!]!
  virtualPrice: BigInt!
  invariant: BigInt!
  lpTokenSupply: BigInt!
  events(skip: Int = 0, first: Int = 100, orderBy: linea_swap_StableSwapEvent_orderBy, orderDirection: linea_swap_OrderDirection, where: linea_swap_StableSwapEvent_filter): [linea_swap_StableSwapEvent!]
  exchanges(skip: Int = 0, first: Int = 100, orderBy: linea_swap_StableSwapExchange_orderBy, orderDirection: linea_swap_OrderDirection, where: linea_swap_StableSwapExchange_filter): [linea_swap_StableSwapExchange!]
  hourlyVolumes(skip: Int = 0, first: Int = 100, orderBy: linea_swap_SwapHourlyVolume_orderBy, orderDirection: linea_swap_OrderDirection, where: linea_swap_SwapHourlyVolume_filter): [linea_swap_SwapHourlyVolume!]
  dailyVolumes(skip: Int = 0, first: Int = 100, orderBy: linea_swap_SwapDailyVolume_orderBy, orderDirection: linea_swap_OrderDirection, where: linea_swap_SwapDailyVolume_filter): [linea_swap_SwapDailyVolume!]
  weeklyVolumes(skip: Int = 0, first: Int = 100, orderBy: linea_swap_SwapWeeklyVolume_orderBy, orderDirection: linea_swap_OrderDirection, where: linea_swap_SwapWeeklyVolume_filter): [linea_swap_SwapWeeklyVolume!]
}

type linea_swap_StableSwapAddLiquidityEvent implements linea_swap_StableSwapEvent {
  id: ID!
  stableSwap: linea_swap_StableSwap!
  provider: linea_swap_Bytes!
  tokenAmounts: [BigInt!]!
  fees: [BigInt!]!
  invariant: BigInt
  lpTokenSupply: BigInt!
  lpTokenAmount: BigInt!
  balances: [BigInt!]!
  block: BigInt!
  timestamp: BigInt!
  transaction: linea_swap_Bytes!
  nonce: BigInt!
}

input linea_swap_StableSwapAddLiquidityEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: linea_swap_StableSwap_filter
  provider: linea_swap_Bytes
  provider_not: linea_swap_Bytes
  provider_gt: linea_swap_Bytes
  provider_lt: linea_swap_Bytes
  provider_gte: linea_swap_Bytes
  provider_lte: linea_swap_Bytes
  provider_in: [linea_swap_Bytes!]
  provider_not_in: [linea_swap_Bytes!]
  provider_contains: linea_swap_Bytes
  provider_not_contains: linea_swap_Bytes
  tokenAmounts: [BigInt!]
  tokenAmounts_not: [BigInt!]
  tokenAmounts_contains: [BigInt!]
  tokenAmounts_contains_nocase: [BigInt!]
  tokenAmounts_not_contains: [BigInt!]
  tokenAmounts_not_contains_nocase: [BigInt!]
  fees: [BigInt!]
  fees_not: [BigInt!]
  fees_contains: [BigInt!]
  fees_contains_nocase: [BigInt!]
  fees_not_contains: [BigInt!]
  fees_not_contains_nocase: [BigInt!]
  invariant: BigInt
  invariant_not: BigInt
  invariant_gt: BigInt
  invariant_lt: BigInt
  invariant_gte: BigInt
  invariant_lte: BigInt
  invariant_in: [BigInt!]
  invariant_not_in: [BigInt!]
  lpTokenSupply: BigInt
  lpTokenSupply_not: BigInt
  lpTokenSupply_gt: BigInt
  lpTokenSupply_lt: BigInt
  lpTokenSupply_gte: BigInt
  lpTokenSupply_lte: BigInt
  lpTokenSupply_in: [BigInt!]
  lpTokenSupply_not_in: [BigInt!]
  lpTokenAmount: BigInt
  lpTokenAmount_not: BigInt
  lpTokenAmount_gt: BigInt
  lpTokenAmount_lt: BigInt
  lpTokenAmount_gte: BigInt
  lpTokenAmount_lte: BigInt
  lpTokenAmount_in: [BigInt!]
  lpTokenAmount_not_in: [BigInt!]
  balances: [BigInt!]
  balances_not: [BigInt!]
  balances_contains: [BigInt!]
  balances_contains_nocase: [BigInt!]
  balances_not_contains: [BigInt!]
  balances_not_contains_nocase: [BigInt!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: linea_swap_Bytes
  transaction_not: linea_swap_Bytes
  transaction_gt: linea_swap_Bytes
  transaction_lt: linea_swap_Bytes
  transaction_gte: linea_swap_Bytes
  transaction_lte: linea_swap_Bytes
  transaction_in: [linea_swap_Bytes!]
  transaction_not_in: [linea_swap_Bytes!]
  transaction_contains: linea_swap_Bytes
  transaction_not_contains: linea_swap_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: linea_swap_BlockChangedFilter
  and: [linea_swap_StableSwapAddLiquidityEvent_filter]
  or: [linea_swap_StableSwapAddLiquidityEvent_filter]
}

enum linea_swap_StableSwapAddLiquidityEvent_orderBy {
  id
  stableSwap
  stableSwap__id
  stableSwap__isActive
  stableSwap__key
  stableSwap__canonicalId
  stableSwap__domain
  stableSwap__swapPool
  stableSwap__lpToken
  stableSwap__initialA
  stableSwap__futureA
  stableSwap__initialATime
  stableSwap__futureATime
  stableSwap__swapFee
  stableSwap__adminFee
  stableSwap__virtualPrice
  stableSwap__invariant
  stableSwap__lpTokenSupply
  provider
  tokenAmounts
  fees
  invariant
  lpTokenSupply
  lpTokenAmount
  balances
  block
  timestamp
  transaction
  nonce
}

interface linea_swap_StableSwapEvent {
  id: ID!
  stableSwap: linea_swap_StableSwap!
  block: BigInt!
  timestamp: BigInt!
  transaction: linea_swap_Bytes!
  nonce: BigInt!
}

input linea_swap_StableSwapEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: linea_swap_StableSwap_filter
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: linea_swap_Bytes
  transaction_not: linea_swap_Bytes
  transaction_gt: linea_swap_Bytes
  transaction_lt: linea_swap_Bytes
  transaction_gte: linea_swap_Bytes
  transaction_lte: linea_swap_Bytes
  transaction_in: [linea_swap_Bytes!]
  transaction_not_in: [linea_swap_Bytes!]
  transaction_contains: linea_swap_Bytes
  transaction_not_contains: linea_swap_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: linea_swap_BlockChangedFilter
  and: [linea_swap_StableSwapEvent_filter]
  or: [linea_swap_StableSwapEvent_filter]
}

enum linea_swap_StableSwapEvent_orderBy {
  id
  stableSwap
  stableSwap__id
  stableSwap__isActive
  stableSwap__key
  stableSwap__canonicalId
  stableSwap__domain
  stableSwap__swapPool
  stableSwap__lpToken
  stableSwap__initialA
  stableSwap__futureA
  stableSwap__initialATime
  stableSwap__futureATime
  stableSwap__swapFee
  stableSwap__adminFee
  stableSwap__virtualPrice
  stableSwap__invariant
  stableSwap__lpTokenSupply
  block
  timestamp
  transaction
  nonce
}

type linea_swap_StableSwapExchange {
  id: ID!
  stableSwap: linea_swap_StableSwap!
  buyer: linea_swap_Bytes!
  boughtId: BigInt!
  tokensBought: BigInt!
  soldId: BigInt!
  tokensSold: BigInt!
  balances: [BigInt!]!
  fee: BigInt!
  block: BigInt!
  timestamp: BigInt!
  transaction: linea_swap_Bytes!
  nonce: BigInt!
}

input linea_swap_StableSwapExchange_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: linea_swap_StableSwap_filter
  buyer: linea_swap_Bytes
  buyer_not: linea_swap_Bytes
  buyer_gt: linea_swap_Bytes
  buyer_lt: linea_swap_Bytes
  buyer_gte: linea_swap_Bytes
  buyer_lte: linea_swap_Bytes
  buyer_in: [linea_swap_Bytes!]
  buyer_not_in: [linea_swap_Bytes!]
  buyer_contains: linea_swap_Bytes
  buyer_not_contains: linea_swap_Bytes
  boughtId: BigInt
  boughtId_not: BigInt
  boughtId_gt: BigInt
  boughtId_lt: BigInt
  boughtId_gte: BigInt
  boughtId_lte: BigInt
  boughtId_in: [BigInt!]
  boughtId_not_in: [BigInt!]
  tokensBought: BigInt
  tokensBought_not: BigInt
  tokensBought_gt: BigInt
  tokensBought_lt: BigInt
  tokensBought_gte: BigInt
  tokensBought_lte: BigInt
  tokensBought_in: [BigInt!]
  tokensBought_not_in: [BigInt!]
  soldId: BigInt
  soldId_not: BigInt
  soldId_gt: BigInt
  soldId_lt: BigInt
  soldId_gte: BigInt
  soldId_lte: BigInt
  soldId_in: [BigInt!]
  soldId_not_in: [BigInt!]
  tokensSold: BigInt
  tokensSold_not: BigInt
  tokensSold_gt: BigInt
  tokensSold_lt: BigInt
  tokensSold_gte: BigInt
  tokensSold_lte: BigInt
  tokensSold_in: [BigInt!]
  tokensSold_not_in: [BigInt!]
  balances: [BigInt!]
  balances_not: [BigInt!]
  balances_contains: [BigInt!]
  balances_contains_nocase: [BigInt!]
  balances_not_contains: [BigInt!]
  balances_not_contains_nocase: [BigInt!]
  fee: BigInt
  fee_not: BigInt
  fee_gt: BigInt
  fee_lt: BigInt
  fee_gte: BigInt
  fee_lte: BigInt
  fee_in: [BigInt!]
  fee_not_in: [BigInt!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: linea_swap_Bytes
  transaction_not: linea_swap_Bytes
  transaction_gt: linea_swap_Bytes
  transaction_lt: linea_swap_Bytes
  transaction_gte: linea_swap_Bytes
  transaction_lte: linea_swap_Bytes
  transaction_in: [linea_swap_Bytes!]
  transaction_not_in: [linea_swap_Bytes!]
  transaction_contains: linea_swap_Bytes
  transaction_not_contains: linea_swap_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: linea_swap_BlockChangedFilter
  and: [linea_swap_StableSwapExchange_filter]
  or: [linea_swap_StableSwapExchange_filter]
}

enum linea_swap_StableSwapExchange_orderBy {
  id
  stableSwap
  stableSwap__id
  stableSwap__isActive
  stableSwap__key
  stableSwap__canonicalId
  stableSwap__domain
  stableSwap__swapPool
  stableSwap__lpToken
  stableSwap__initialA
  stableSwap__futureA
  stableSwap__initialATime
  stableSwap__futureATime
  stableSwap__swapFee
  stableSwap__adminFee
  stableSwap__virtualPrice
  stableSwap__invariant
  stableSwap__lpTokenSupply
  buyer
  boughtId
  tokensBought
  soldId
  tokensSold
  balances
  fee
  block
  timestamp
  transaction
  nonce
}

type linea_swap_StableSwapRemoveLiquidityEvent implements linea_swap_StableSwapEvent {
  id: ID!
  stableSwap: linea_swap_StableSwap!
  provider: linea_swap_Bytes!
  tokenAmounts: [BigInt!]!
  fees: [BigInt!]
  invariant: BigInt
  lpTokenSupply: BigInt!
  lpTokenAmount: BigInt!
  balances: [BigInt!]!
  block: BigInt!
  timestamp: BigInt!
  transaction: linea_swap_Bytes!
  nonce: BigInt!
}

input linea_swap_StableSwapRemoveLiquidityEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: linea_swap_StableSwap_filter
  provider: linea_swap_Bytes
  provider_not: linea_swap_Bytes
  provider_gt: linea_swap_Bytes
  provider_lt: linea_swap_Bytes
  provider_gte: linea_swap_Bytes
  provider_lte: linea_swap_Bytes
  provider_in: [linea_swap_Bytes!]
  provider_not_in: [linea_swap_Bytes!]
  provider_contains: linea_swap_Bytes
  provider_not_contains: linea_swap_Bytes
  tokenAmounts: [BigInt!]
  tokenAmounts_not: [BigInt!]
  tokenAmounts_contains: [BigInt!]
  tokenAmounts_contains_nocase: [BigInt!]
  tokenAmounts_not_contains: [BigInt!]
  tokenAmounts_not_contains_nocase: [BigInt!]
  fees: [BigInt!]
  fees_not: [BigInt!]
  fees_contains: [BigInt!]
  fees_contains_nocase: [BigInt!]
  fees_not_contains: [BigInt!]
  fees_not_contains_nocase: [BigInt!]
  invariant: BigInt
  invariant_not: BigInt
  invariant_gt: BigInt
  invariant_lt: BigInt
  invariant_gte: BigInt
  invariant_lte: BigInt
  invariant_in: [BigInt!]
  invariant_not_in: [BigInt!]
  lpTokenSupply: BigInt
  lpTokenSupply_not: BigInt
  lpTokenSupply_gt: BigInt
  lpTokenSupply_lt: BigInt
  lpTokenSupply_gte: BigInt
  lpTokenSupply_lte: BigInt
  lpTokenSupply_in: [BigInt!]
  lpTokenSupply_not_in: [BigInt!]
  lpTokenAmount: BigInt
  lpTokenAmount_not: BigInt
  lpTokenAmount_gt: BigInt
  lpTokenAmount_lt: BigInt
  lpTokenAmount_gte: BigInt
  lpTokenAmount_lte: BigInt
  lpTokenAmount_in: [BigInt!]
  lpTokenAmount_not_in: [BigInt!]
  balances: [BigInt!]
  balances_not: [BigInt!]
  balances_contains: [BigInt!]
  balances_contains_nocase: [BigInt!]
  balances_not_contains: [BigInt!]
  balances_not_contains_nocase: [BigInt!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: linea_swap_Bytes
  transaction_not: linea_swap_Bytes
  transaction_gt: linea_swap_Bytes
  transaction_lt: linea_swap_Bytes
  transaction_gte: linea_swap_Bytes
  transaction_lte: linea_swap_Bytes
  transaction_in: [linea_swap_Bytes!]
  transaction_not_in: [linea_swap_Bytes!]
  transaction_contains: linea_swap_Bytes
  transaction_not_contains: linea_swap_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: linea_swap_BlockChangedFilter
  and: [linea_swap_StableSwapRemoveLiquidityEvent_filter]
  or: [linea_swap_StableSwapRemoveLiquidityEvent_filter]
}

enum linea_swap_StableSwapRemoveLiquidityEvent_orderBy {
  id
  stableSwap
  stableSwap__id
  stableSwap__isActive
  stableSwap__key
  stableSwap__canonicalId
  stableSwap__domain
  stableSwap__swapPool
  stableSwap__lpToken
  stableSwap__initialA
  stableSwap__futureA
  stableSwap__initialATime
  stableSwap__futureATime
  stableSwap__swapFee
  stableSwap__adminFee
  stableSwap__virtualPrice
  stableSwap__invariant
  stableSwap__lpTokenSupply
  provider
  tokenAmounts
  fees
  invariant
  lpTokenSupply
  lpTokenAmount
  balances
  block
  timestamp
  transaction
  nonce
}

input linea_swap_StableSwap_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  isActive: Boolean
  isActive_not: Boolean
  isActive_in: [Boolean!]
  isActive_not_in: [Boolean!]
  key: linea_swap_Bytes
  key_not: linea_swap_Bytes
  key_gt: linea_swap_Bytes
  key_lt: linea_swap_Bytes
  key_gte: linea_swap_Bytes
  key_lte: linea_swap_Bytes
  key_in: [linea_swap_Bytes!]
  key_not_in: [linea_swap_Bytes!]
  key_contains: linea_swap_Bytes
  key_not_contains: linea_swap_Bytes
  canonicalId: linea_swap_Bytes
  canonicalId_not: linea_swap_Bytes
  canonicalId_gt: linea_swap_Bytes
  canonicalId_lt: linea_swap_Bytes
  canonicalId_gte: linea_swap_Bytes
  canonicalId_lte: linea_swap_Bytes
  canonicalId_in: [linea_swap_Bytes!]
  canonicalId_not_in: [linea_swap_Bytes!]
  canonicalId_contains: linea_swap_Bytes
  canonicalId_not_contains: linea_swap_Bytes
  domain: BigInt
  domain_not: BigInt
  domain_gt: BigInt
  domain_lt: BigInt
  domain_gte: BigInt
  domain_lte: BigInt
  domain_in: [BigInt!]
  domain_not_in: [BigInt!]
  swapPool: linea_swap_Bytes
  swapPool_not: linea_swap_Bytes
  swapPool_gt: linea_swap_Bytes
  swapPool_lt: linea_swap_Bytes
  swapPool_gte: linea_swap_Bytes
  swapPool_lte: linea_swap_Bytes
  swapPool_in: [linea_swap_Bytes!]
  swapPool_not_in: [linea_swap_Bytes!]
  swapPool_contains: linea_swap_Bytes
  swapPool_not_contains: linea_swap_Bytes
  lpToken: linea_swap_Bytes
  lpToken_not: linea_swap_Bytes
  lpToken_gt: linea_swap_Bytes
  lpToken_lt: linea_swap_Bytes
  lpToken_gte: linea_swap_Bytes
  lpToken_lte: linea_swap_Bytes
  lpToken_in: [linea_swap_Bytes!]
  lpToken_not_in: [linea_swap_Bytes!]
  lpToken_contains: linea_swap_Bytes
  lpToken_not_contains: linea_swap_Bytes
  initialA: BigInt
  initialA_not: BigInt
  initialA_gt: BigInt
  initialA_lt: BigInt
  initialA_gte: BigInt
  initialA_lte: BigInt
  initialA_in: [BigInt!]
  initialA_not_in: [BigInt!]
  futureA: BigInt
  futureA_not: BigInt
  futureA_gt: BigInt
  futureA_lt: BigInt
  futureA_gte: BigInt
  futureA_lte: BigInt
  futureA_in: [BigInt!]
  futureA_not_in: [BigInt!]
  initialATime: BigInt
  initialATime_not: BigInt
  initialATime_gt: BigInt
  initialATime_lt: BigInt
  initialATime_gte: BigInt
  initialATime_lte: BigInt
  initialATime_in: [BigInt!]
  initialATime_not_in: [BigInt!]
  futureATime: BigInt
  futureATime_not: BigInt
  futureATime_gt: BigInt
  futureATime_lt: BigInt
  futureATime_gte: BigInt
  futureATime_lte: BigInt
  futureATime_in: [BigInt!]
  futureATime_not_in: [BigInt!]
  swapFee: BigInt
  swapFee_not: BigInt
  swapFee_gt: BigInt
  swapFee_lt: BigInt
  swapFee_gte: BigInt
  swapFee_lte: BigInt
  swapFee_in: [BigInt!]
  swapFee_not_in: [BigInt!]
  adminFee: BigInt
  adminFee_not: BigInt
  adminFee_gt: BigInt
  adminFee_lt: BigInt
  adminFee_gte: BigInt
  adminFee_lte: BigInt
  adminFee_in: [BigInt!]
  adminFee_not_in: [BigInt!]
  pooledTokens: [linea_swap_Bytes!]
  pooledTokens_not: [linea_swap_Bytes!]
  pooledTokens_contains: [linea_swap_Bytes!]
  pooledTokens_contains_nocase: [linea_swap_Bytes!]
  pooledTokens_not_contains: [linea_swap_Bytes!]
  pooledTokens_not_contains_nocase: [linea_swap_Bytes!]
  tokenPrecisionMultipliers: [BigInt!]
  tokenPrecisionMultipliers_not: [BigInt!]
  tokenPrecisionMultipliers_contains: [BigInt!]
  tokenPrecisionMultipliers_contains_nocase: [BigInt!]
  tokenPrecisionMultipliers_not_contains: [BigInt!]
  tokenPrecisionMultipliers_not_contains_nocase: [BigInt!]
  balances: [BigInt!]
  balances_not: [BigInt!]
  balances_contains: [BigInt!]
  balances_contains_nocase: [BigInt!]
  balances_not_contains: [BigInt!]
  balances_not_contains_nocase: [BigInt!]
  adminFees: [BigInt!]
  adminFees_not: [BigInt!]
  adminFees_contains: [BigInt!]
  adminFees_contains_nocase: [BigInt!]
  adminFees_not_contains: [BigInt!]
  adminFees_not_contains_nocase: [BigInt!]
  virtualPrice: BigInt
  virtualPrice_not: BigInt
  virtualPrice_gt: BigInt
  virtualPrice_lt: BigInt
  virtualPrice_gte: BigInt
  virtualPrice_lte: BigInt
  virtualPrice_in: [BigInt!]
  virtualPrice_not_in: [BigInt!]
  invariant: BigInt
  invariant_not: BigInt
  invariant_gt: BigInt
  invariant_lt: BigInt
  invariant_gte: BigInt
  invariant_lte: BigInt
  invariant_in: [BigInt!]
  invariant_not_in: [BigInt!]
  lpTokenSupply: BigInt
  lpTokenSupply_not: BigInt
  lpTokenSupply_gt: BigInt
  lpTokenSupply_lt: BigInt
  lpTokenSupply_gte: BigInt
  lpTokenSupply_lte: BigInt
  lpTokenSupply_in: [BigInt!]
  lpTokenSupply_not_in: [BigInt!]
  events_: linea_swap_StableSwapEvent_filter
  exchanges_: linea_swap_StableSwapExchange_filter
  hourlyVolumes_: linea_swap_SwapHourlyVolume_filter
  dailyVolumes_: linea_swap_SwapDailyVolume_filter
  weeklyVolumes_: linea_swap_SwapWeeklyVolume_filter
  """Filter for the block changed event."""
  _change_block: linea_swap_BlockChangedFilter
  and: [linea_swap_StableSwap_filter]
  or: [linea_swap_StableSwap_filter]
}

enum linea_swap_StableSwap_orderBy {
  id
  isActive
  key
  canonicalId
  domain
  swapPool
  lpToken
  initialA
  futureA
  initialATime
  futureATime
  swapFee
  adminFee
  pooledTokens
  tokenPrecisionMultipliers
  balances
  adminFees
  virtualPrice
  invariant
  lpTokenSupply
  events
  exchanges
  hourlyVolumes
  dailyVolumes
  weeklyVolumes
}

type linea_swap_SwapDailyVolume implements linea_swap_SwapTradeVolume {
  id: ID!
  stableSwap: linea_swap_StableSwap!
  timestamp: BigInt!
  volume: linea_swap_BigDecimal!
}

input linea_swap_SwapDailyVolume_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: linea_swap_StableSwap_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  volume: linea_swap_BigDecimal
  volume_not: linea_swap_BigDecimal
  volume_gt: linea_swap_BigDecimal
  volume_lt: linea_swap_BigDecimal
  volume_gte: linea_swap_BigDecimal
  volume_lte: linea_swap_BigDecimal
  volume_in: [linea_swap_BigDecimal!]
  volume_not_in: [linea_swap_BigDecimal!]
  """Filter for the block changed event."""
  _change_block: linea_swap_BlockChangedFilter
  and: [linea_swap_SwapDailyVolume_filter]
  or: [linea_swap_SwapDailyVolume_filter]
}

enum linea_swap_SwapDailyVolume_orderBy {
  id
  stableSwap
  stableSwap__id
  stableSwap__isActive
  stableSwap__key
  stableSwap__canonicalId
  stableSwap__domain
  stableSwap__swapPool
  stableSwap__lpToken
  stableSwap__initialA
  stableSwap__futureA
  stableSwap__initialATime
  stableSwap__futureATime
  stableSwap__swapFee
  stableSwap__adminFee
  stableSwap__virtualPrice
  stableSwap__invariant
  stableSwap__lpTokenSupply
  timestamp
  volume
}

type linea_swap_SwapHourlyVolume implements linea_swap_SwapTradeVolume {
  id: ID!
  stableSwap: linea_swap_StableSwap!
  timestamp: BigInt!
  volume: linea_swap_BigDecimal!
}

input linea_swap_SwapHourlyVolume_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: linea_swap_StableSwap_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  volume: linea_swap_BigDecimal
  volume_not: linea_swap_BigDecimal
  volume_gt: linea_swap_BigDecimal
  volume_lt: linea_swap_BigDecimal
  volume_gte: linea_swap_BigDecimal
  volume_lte: linea_swap_BigDecimal
  volume_in: [linea_swap_BigDecimal!]
  volume_not_in: [linea_swap_BigDecimal!]
  """Filter for the block changed event."""
  _change_block: linea_swap_BlockChangedFilter
  and: [linea_swap_SwapHourlyVolume_filter]
  or: [linea_swap_SwapHourlyVolume_filter]
}

enum linea_swap_SwapHourlyVolume_orderBy {
  id
  stableSwap
  stableSwap__id
  stableSwap__isActive
  stableSwap__key
  stableSwap__canonicalId
  stableSwap__domain
  stableSwap__swapPool
  stableSwap__lpToken
  stableSwap__initialA
  stableSwap__futureA
  stableSwap__initialATime
  stableSwap__futureATime
  stableSwap__swapFee
  stableSwap__adminFee
  stableSwap__virtualPrice
  stableSwap__invariant
  stableSwap__lpTokenSupply
  timestamp
  volume
}

interface linea_swap_SwapTradeVolume {
  stableSwap: linea_swap_StableSwap!
  timestamp: BigInt!
  volume: linea_swap_BigDecimal!
}

input linea_swap_SwapTradeVolume_filter {
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: linea_swap_StableSwap_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  volume: linea_swap_BigDecimal
  volume_not: linea_swap_BigDecimal
  volume_gt: linea_swap_BigDecimal
  volume_lt: linea_swap_BigDecimal
  volume_gte: linea_swap_BigDecimal
  volume_lte: linea_swap_BigDecimal
  volume_in: [linea_swap_BigDecimal!]
  volume_not_in: [linea_swap_BigDecimal!]
  """Filter for the block changed event."""
  _change_block: linea_swap_BlockChangedFilter
  and: [linea_swap_SwapTradeVolume_filter]
  or: [linea_swap_SwapTradeVolume_filter]
}

enum linea_swap_SwapTradeVolume_orderBy {
  stableSwap
  stableSwap__id
  stableSwap__isActive
  stableSwap__key
  stableSwap__canonicalId
  stableSwap__domain
  stableSwap__swapPool
  stableSwap__lpToken
  stableSwap__initialA
  stableSwap__futureA
  stableSwap__initialATime
  stableSwap__futureATime
  stableSwap__swapFee
  stableSwap__adminFee
  stableSwap__virtualPrice
  stableSwap__invariant
  stableSwap__lpTokenSupply
  timestamp
  volume
}

type linea_swap_SwapWeeklyVolume implements linea_swap_SwapTradeVolume {
  id: ID!
  stableSwap: linea_swap_StableSwap!
  timestamp: BigInt!
  volume: linea_swap_BigDecimal!
}

input linea_swap_SwapWeeklyVolume_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: linea_swap_StableSwap_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  volume: linea_swap_BigDecimal
  volume_not: linea_swap_BigDecimal
  volume_gt: linea_swap_BigDecimal
  volume_lt: linea_swap_BigDecimal
  volume_gte: linea_swap_BigDecimal
  volume_lte: linea_swap_BigDecimal
  volume_in: [linea_swap_BigDecimal!]
  volume_not_in: [linea_swap_BigDecimal!]
  """Filter for the block changed event."""
  _change_block: linea_swap_BlockChangedFilter
  and: [linea_swap_SwapWeeklyVolume_filter]
  or: [linea_swap_SwapWeeklyVolume_filter]
}

enum linea_swap_SwapWeeklyVolume_orderBy {
  id
  stableSwap
  stableSwap__id
  stableSwap__isActive
  stableSwap__key
  stableSwap__canonicalId
  stableSwap__domain
  stableSwap__swapPool
  stableSwap__lpToken
  stableSwap__initialA
  stableSwap__futureA
  stableSwap__initialATime
  stableSwap__futureATime
  stableSwap__swapFee
  stableSwap__adminFee
  stableSwap__virtualPrice
  stableSwap__invariant
  stableSwap__lpTokenSupply
  timestamp
  volume
}

type linea_swap_SystemInfo {
  id: ID!
  exchangeCount: BigInt!
  swapCount: BigInt!
}

input linea_swap_SystemInfo_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  exchangeCount: BigInt
  exchangeCount_not: BigInt
  exchangeCount_gt: BigInt
  exchangeCount_lt: BigInt
  exchangeCount_gte: BigInt
  exchangeCount_lte: BigInt
  exchangeCount_in: [BigInt!]
  exchangeCount_not_in: [BigInt!]
  swapCount: BigInt
  swapCount_not: BigInt
  swapCount_gt: BigInt
  swapCount_lt: BigInt
  swapCount_gte: BigInt
  swapCount_lte: BigInt
  swapCount_in: [BigInt!]
  swapCount_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: linea_swap_BlockChangedFilter
  and: [linea_swap_SystemInfo_filter]
  or: [linea_swap_SystemInfo_filter]
}

enum linea_swap_SystemInfo_orderBy {
  id
  exchangeCount
  swapCount
}

type linea_swap__Block_ {
  """The hash of the block"""
  hash: linea_swap_Bytes
  """The block number"""
  number: Int!
  """Integer representation of the timestamp stored in blocks for the chain"""
  timestamp: Int
  """The hash of the parent block"""
  parentHash: linea_swap_Bytes
}

"""The type for the top-level _meta field"""
type linea_swap__Meta_ {
  """
  Information about a specific subgraph block. The hash of the block
  will be null if the _meta field has a block constraint that asks for
  a block number. It will be filled if the _meta field has no block constraint
  and therefore asks for the latest  block
  
  """
  block: linea_swap__Block_!
  """The deployment ID"""
  deployment: String!
  """If `true`, the subgraph encountered indexing errors at some past block"""
  hasIndexingErrors: Boolean!
}

enum base_swap_Aggregation_interval {
  hour
  day
}

scalar base_swap_BigDecimal

input base_swap_BlockChangedFilter {
  number_gte: Int!
}

input base_swap_Block_height {
  hash: base_swap_Bytes
  number: Int
  number_gte: Int
}

scalar base_swap_Bytes

"""
8 bytes signed integer

"""
scalar base_swap_Int8

type base_swap_LpAccount {
  id: ID!
  address: base_swap_Bytes!
  balances(skip: Int = 0, first: Int = 100, orderBy: base_swap_LpAccountBalance_orderBy, orderDirection: base_swap_OrderDirection, where: base_swap_LpAccountBalance_filter): [base_swap_LpAccountBalance!]!
}

type base_swap_LpAccountBalance {
  id: ID!
  account: base_swap_LpAccount!
  token: base_swap_LpToken!
  amount: base_swap_BigDecimal!
  block: BigInt
  modified: BigInt
  transaction: base_swap_Bytes
}

input base_swap_LpAccountBalance_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  account: String
  account_not: String
  account_gt: String
  account_lt: String
  account_gte: String
  account_lte: String
  account_in: [String!]
  account_not_in: [String!]
  account_contains: String
  account_contains_nocase: String
  account_not_contains: String
  account_not_contains_nocase: String
  account_starts_with: String
  account_starts_with_nocase: String
  account_not_starts_with: String
  account_not_starts_with_nocase: String
  account_ends_with: String
  account_ends_with_nocase: String
  account_not_ends_with: String
  account_not_ends_with_nocase: String
  account_: base_swap_LpAccount_filter
  token: String
  token_not: String
  token_gt: String
  token_lt: String
  token_gte: String
  token_lte: String
  token_in: [String!]
  token_not_in: [String!]
  token_contains: String
  token_contains_nocase: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_: base_swap_LpToken_filter
  amount: base_swap_BigDecimal
  amount_not: base_swap_BigDecimal
  amount_gt: base_swap_BigDecimal
  amount_lt: base_swap_BigDecimal
  amount_gte: base_swap_BigDecimal
  amount_lte: base_swap_BigDecimal
  amount_in: [base_swap_BigDecimal!]
  amount_not_in: [base_swap_BigDecimal!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  modified: BigInt
  modified_not: BigInt
  modified_gt: BigInt
  modified_lt: BigInt
  modified_gte: BigInt
  modified_lte: BigInt
  modified_in: [BigInt!]
  modified_not_in: [BigInt!]
  transaction: base_swap_Bytes
  transaction_not: base_swap_Bytes
  transaction_gt: base_swap_Bytes
  transaction_lt: base_swap_Bytes
  transaction_gte: base_swap_Bytes
  transaction_lte: base_swap_Bytes
  transaction_in: [base_swap_Bytes!]
  transaction_not_in: [base_swap_Bytes!]
  transaction_contains: base_swap_Bytes
  transaction_not_contains: base_swap_Bytes
  """Filter for the block changed event."""
  _change_block: base_swap_BlockChangedFilter
  and: [base_swap_LpAccountBalance_filter]
  or: [base_swap_LpAccountBalance_filter]
}

enum base_swap_LpAccountBalance_orderBy {
  id
  account
  account__id
  account__address
  token
  token__id
  token__address
  token__decimals
  token__name
  token__symbol
  token__totalSupply
  amount
  block
  modified
  transaction
}

input base_swap_LpAccount_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  address: base_swap_Bytes
  address_not: base_swap_Bytes
  address_gt: base_swap_Bytes
  address_lt: base_swap_Bytes
  address_gte: base_swap_Bytes
  address_lte: base_swap_Bytes
  address_in: [base_swap_Bytes!]
  address_not_in: [base_swap_Bytes!]
  address_contains: base_swap_Bytes
  address_not_contains: base_swap_Bytes
  balances_: base_swap_LpAccountBalance_filter
  """Filter for the block changed event."""
  _change_block: base_swap_BlockChangedFilter
  and: [base_swap_LpAccount_filter]
  or: [base_swap_LpAccount_filter]
}

enum base_swap_LpAccount_orderBy {
  id
  address
  balances
}

type base_swap_LpToken {
  id: ID!
  address: base_swap_Bytes!
  stableSwap: base_swap_StableSwap!
  decimals: Int!
  name: String!
  symbol: String!
  totalSupply: base_swap_BigDecimal!
  events(skip: Int = 0, first: Int = 100, orderBy: base_swap_LpTokenEvent_orderBy, orderDirection: base_swap_OrderDirection, where: base_swap_LpTokenEvent_filter): [base_swap_LpTokenEvent!]!
}

interface base_swap_LpTokenEvent {
  id: ID!
  token: base_swap_LpToken!
  amount: base_swap_BigDecimal!
  block: BigInt!
  timestamp: BigInt!
  transaction: base_swap_Bytes!
  nonce: BigInt!
}

input base_swap_LpTokenEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  token: String
  token_not: String
  token_gt: String
  token_lt: String
  token_gte: String
  token_lte: String
  token_in: [String!]
  token_not_in: [String!]
  token_contains: String
  token_contains_nocase: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_: base_swap_LpToken_filter
  amount: base_swap_BigDecimal
  amount_not: base_swap_BigDecimal
  amount_gt: base_swap_BigDecimal
  amount_lt: base_swap_BigDecimal
  amount_gte: base_swap_BigDecimal
  amount_lte: base_swap_BigDecimal
  amount_in: [base_swap_BigDecimal!]
  amount_not_in: [base_swap_BigDecimal!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: base_swap_Bytes
  transaction_not: base_swap_Bytes
  transaction_gt: base_swap_Bytes
  transaction_lt: base_swap_Bytes
  transaction_gte: base_swap_Bytes
  transaction_lte: base_swap_Bytes
  transaction_in: [base_swap_Bytes!]
  transaction_not_in: [base_swap_Bytes!]
  transaction_contains: base_swap_Bytes
  transaction_not_contains: base_swap_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: base_swap_BlockChangedFilter
  and: [base_swap_LpTokenEvent_filter]
  or: [base_swap_LpTokenEvent_filter]
}

enum base_swap_LpTokenEvent_orderBy {
  id
  token
  token__id
  token__address
  token__decimals
  token__name
  token__symbol
  token__totalSupply
  amount
  block
  timestamp
  transaction
  nonce
}

input base_swap_LpToken_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  address: base_swap_Bytes
  address_not: base_swap_Bytes
  address_gt: base_swap_Bytes
  address_lt: base_swap_Bytes
  address_gte: base_swap_Bytes
  address_lte: base_swap_Bytes
  address_in: [base_swap_Bytes!]
  address_not_in: [base_swap_Bytes!]
  address_contains: base_swap_Bytes
  address_not_contains: base_swap_Bytes
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: base_swap_StableSwap_filter
  decimals: Int
  decimals_not: Int
  decimals_gt: Int
  decimals_lt: Int
  decimals_gte: Int
  decimals_lte: Int
  decimals_in: [Int!]
  decimals_not_in: [Int!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  symbol: String
  symbol_not: String
  symbol_gt: String
  symbol_lt: String
  symbol_gte: String
  symbol_lte: String
  symbol_in: [String!]
  symbol_not_in: [String!]
  symbol_contains: String
  symbol_contains_nocase: String
  symbol_not_contains: String
  symbol_not_contains_nocase: String
  symbol_starts_with: String
  symbol_starts_with_nocase: String
  symbol_not_starts_with: String
  symbol_not_starts_with_nocase: String
  symbol_ends_with: String
  symbol_ends_with_nocase: String
  symbol_not_ends_with: String
  symbol_not_ends_with_nocase: String
  totalSupply: base_swap_BigDecimal
  totalSupply_not: base_swap_BigDecimal
  totalSupply_gt: base_swap_BigDecimal
  totalSupply_lt: base_swap_BigDecimal
  totalSupply_gte: base_swap_BigDecimal
  totalSupply_lte: base_swap_BigDecimal
  totalSupply_in: [base_swap_BigDecimal!]
  totalSupply_not_in: [base_swap_BigDecimal!]
  events_: base_swap_LpTokenEvent_filter
  """Filter for the block changed event."""
  _change_block: base_swap_BlockChangedFilter
  and: [base_swap_LpToken_filter]
  or: [base_swap_LpToken_filter]
}

enum base_swap_LpToken_orderBy {
  id
  address
  stableSwap
  stableSwap__id
  stableSwap__isActive
  stableSwap__key
  stableSwap__canonicalId
  stableSwap__domain
  stableSwap__swapPool
  stableSwap__lpToken
  stableSwap__initialA
  stableSwap__futureA
  stableSwap__initialATime
  stableSwap__futureATime
  stableSwap__swapFee
  stableSwap__adminFee
  stableSwap__virtualPrice
  stableSwap__invariant
  stableSwap__lpTokenSupply
  decimals
  name
  symbol
  totalSupply
  events
}

type base_swap_LpTransferEvent implements base_swap_LpTokenEvent {
  id: ID!
  token: base_swap_LpToken!
  amount: base_swap_BigDecimal!
  from: base_swap_Bytes!
  to: base_swap_Bytes!
  fromBalance: base_swap_BigDecimal!
  toBalance: base_swap_BigDecimal!
  block: BigInt!
  timestamp: BigInt!
  transaction: base_swap_Bytes!
  nonce: BigInt!
}

input base_swap_LpTransferEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  token: String
  token_not: String
  token_gt: String
  token_lt: String
  token_gte: String
  token_lte: String
  token_in: [String!]
  token_not_in: [String!]
  token_contains: String
  token_contains_nocase: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_: base_swap_LpToken_filter
  amount: base_swap_BigDecimal
  amount_not: base_swap_BigDecimal
  amount_gt: base_swap_BigDecimal
  amount_lt: base_swap_BigDecimal
  amount_gte: base_swap_BigDecimal
  amount_lte: base_swap_BigDecimal
  amount_in: [base_swap_BigDecimal!]
  amount_not_in: [base_swap_BigDecimal!]
  from: base_swap_Bytes
  from_not: base_swap_Bytes
  from_gt: base_swap_Bytes
  from_lt: base_swap_Bytes
  from_gte: base_swap_Bytes
  from_lte: base_swap_Bytes
  from_in: [base_swap_Bytes!]
  from_not_in: [base_swap_Bytes!]
  from_contains: base_swap_Bytes
  from_not_contains: base_swap_Bytes
  to: base_swap_Bytes
  to_not: base_swap_Bytes
  to_gt: base_swap_Bytes
  to_lt: base_swap_Bytes
  to_gte: base_swap_Bytes
  to_lte: base_swap_Bytes
  to_in: [base_swap_Bytes!]
  to_not_in: [base_swap_Bytes!]
  to_contains: base_swap_Bytes
  to_not_contains: base_swap_Bytes
  fromBalance: base_swap_BigDecimal
  fromBalance_not: base_swap_BigDecimal
  fromBalance_gt: base_swap_BigDecimal
  fromBalance_lt: base_swap_BigDecimal
  fromBalance_gte: base_swap_BigDecimal
  fromBalance_lte: base_swap_BigDecimal
  fromBalance_in: [base_swap_BigDecimal!]
  fromBalance_not_in: [base_swap_BigDecimal!]
  toBalance: base_swap_BigDecimal
  toBalance_not: base_swap_BigDecimal
  toBalance_gt: base_swap_BigDecimal
  toBalance_lt: base_swap_BigDecimal
  toBalance_gte: base_swap_BigDecimal
  toBalance_lte: base_swap_BigDecimal
  toBalance_in: [base_swap_BigDecimal!]
  toBalance_not_in: [base_swap_BigDecimal!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: base_swap_Bytes
  transaction_not: base_swap_Bytes
  transaction_gt: base_swap_Bytes
  transaction_lt: base_swap_Bytes
  transaction_gte: base_swap_Bytes
  transaction_lte: base_swap_Bytes
  transaction_in: [base_swap_Bytes!]
  transaction_not_in: [base_swap_Bytes!]
  transaction_contains: base_swap_Bytes
  transaction_not_contains: base_swap_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: base_swap_BlockChangedFilter
  and: [base_swap_LpTransferEvent_filter]
  or: [base_swap_LpTransferEvent_filter]
}

enum base_swap_LpTransferEvent_orderBy {
  id
  token
  token__id
  token__address
  token__decimals
  token__name
  token__symbol
  token__totalSupply
  amount
  from
  to
  fromBalance
  toBalance
  block
  timestamp
  transaction
  nonce
}

"""Defines the order direction, either ascending or descending"""
enum base_swap_OrderDirection {
  asc
  desc
}

type base_swap_PooledToken {
  id: ID!
  asset: base_swap_Bytes!
}

input base_swap_PooledToken_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  asset: base_swap_Bytes
  asset_not: base_swap_Bytes
  asset_gt: base_swap_Bytes
  asset_lt: base_swap_Bytes
  asset_gte: base_swap_Bytes
  asset_lte: base_swap_Bytes
  asset_in: [base_swap_Bytes!]
  asset_not_in: [base_swap_Bytes!]
  asset_contains: base_swap_Bytes
  asset_not_contains: base_swap_Bytes
  """Filter for the block changed event."""
  _change_block: base_swap_BlockChangedFilter
  and: [base_swap_PooledToken_filter]
  or: [base_swap_PooledToken_filter]
}

enum base_swap_PooledToken_orderBy {
  id
  asset
}

type base_swap_StableSwap {
  id: ID!
  isActive: Boolean
  key: base_swap_Bytes!
  canonicalId: base_swap_Bytes
  domain: BigInt
  swapPool: base_swap_Bytes
  lpToken: base_swap_Bytes
  initialA: BigInt
  futureA: BigInt
  initialATime: BigInt
  futureATime: BigInt
  swapFee: BigInt
  adminFee: BigInt
  pooledTokens: [base_swap_Bytes!]!
  tokenPrecisionMultipliers: [BigInt!]!
  balances: [BigInt!]!
  adminFees: [BigInt!]!
  virtualPrice: BigInt!
  invariant: BigInt!
  lpTokenSupply: BigInt!
  events(skip: Int = 0, first: Int = 100, orderBy: base_swap_StableSwapEvent_orderBy, orderDirection: base_swap_OrderDirection, where: base_swap_StableSwapEvent_filter): [base_swap_StableSwapEvent!]
  exchanges(skip: Int = 0, first: Int = 100, orderBy: base_swap_StableSwapExchange_orderBy, orderDirection: base_swap_OrderDirection, where: base_swap_StableSwapExchange_filter): [base_swap_StableSwapExchange!]
  hourlyVolumes(skip: Int = 0, first: Int = 100, orderBy: base_swap_SwapHourlyVolume_orderBy, orderDirection: base_swap_OrderDirection, where: base_swap_SwapHourlyVolume_filter): [base_swap_SwapHourlyVolume!]
  dailyVolumes(skip: Int = 0, first: Int = 100, orderBy: base_swap_SwapDailyVolume_orderBy, orderDirection: base_swap_OrderDirection, where: base_swap_SwapDailyVolume_filter): [base_swap_SwapDailyVolume!]
  weeklyVolumes(skip: Int = 0, first: Int = 100, orderBy: base_swap_SwapWeeklyVolume_orderBy, orderDirection: base_swap_OrderDirection, where: base_swap_SwapWeeklyVolume_filter): [base_swap_SwapWeeklyVolume!]
}

type base_swap_StableSwapAddLiquidityEvent implements base_swap_StableSwapEvent {
  id: ID!
  stableSwap: base_swap_StableSwap!
  provider: base_swap_Bytes!
  tokenAmounts: [BigInt!]!
  fees: [BigInt!]!
  invariant: BigInt
  lpTokenSupply: BigInt!
  lpTokenAmount: BigInt!
  balances: [BigInt!]!
  block: BigInt!
  timestamp: BigInt!
  transaction: base_swap_Bytes!
  nonce: BigInt!
}

input base_swap_StableSwapAddLiquidityEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: base_swap_StableSwap_filter
  provider: base_swap_Bytes
  provider_not: base_swap_Bytes
  provider_gt: base_swap_Bytes
  provider_lt: base_swap_Bytes
  provider_gte: base_swap_Bytes
  provider_lte: base_swap_Bytes
  provider_in: [base_swap_Bytes!]
  provider_not_in: [base_swap_Bytes!]
  provider_contains: base_swap_Bytes
  provider_not_contains: base_swap_Bytes
  tokenAmounts: [BigInt!]
  tokenAmounts_not: [BigInt!]
  tokenAmounts_contains: [BigInt!]
  tokenAmounts_contains_nocase: [BigInt!]
  tokenAmounts_not_contains: [BigInt!]
  tokenAmounts_not_contains_nocase: [BigInt!]
  fees: [BigInt!]
  fees_not: [BigInt!]
  fees_contains: [BigInt!]
  fees_contains_nocase: [BigInt!]
  fees_not_contains: [BigInt!]
  fees_not_contains_nocase: [BigInt!]
  invariant: BigInt
  invariant_not: BigInt
  invariant_gt: BigInt
  invariant_lt: BigInt
  invariant_gte: BigInt
  invariant_lte: BigInt
  invariant_in: [BigInt!]
  invariant_not_in: [BigInt!]
  lpTokenSupply: BigInt
  lpTokenSupply_not: BigInt
  lpTokenSupply_gt: BigInt
  lpTokenSupply_lt: BigInt
  lpTokenSupply_gte: BigInt
  lpTokenSupply_lte: BigInt
  lpTokenSupply_in: [BigInt!]
  lpTokenSupply_not_in: [BigInt!]
  lpTokenAmount: BigInt
  lpTokenAmount_not: BigInt
  lpTokenAmount_gt: BigInt
  lpTokenAmount_lt: BigInt
  lpTokenAmount_gte: BigInt
  lpTokenAmount_lte: BigInt
  lpTokenAmount_in: [BigInt!]
  lpTokenAmount_not_in: [BigInt!]
  balances: [BigInt!]
  balances_not: [BigInt!]
  balances_contains: [BigInt!]
  balances_contains_nocase: [BigInt!]
  balances_not_contains: [BigInt!]
  balances_not_contains_nocase: [BigInt!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: base_swap_Bytes
  transaction_not: base_swap_Bytes
  transaction_gt: base_swap_Bytes
  transaction_lt: base_swap_Bytes
  transaction_gte: base_swap_Bytes
  transaction_lte: base_swap_Bytes
  transaction_in: [base_swap_Bytes!]
  transaction_not_in: [base_swap_Bytes!]
  transaction_contains: base_swap_Bytes
  transaction_not_contains: base_swap_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: base_swap_BlockChangedFilter
  and: [base_swap_StableSwapAddLiquidityEvent_filter]
  or: [base_swap_StableSwapAddLiquidityEvent_filter]
}

enum base_swap_StableSwapAddLiquidityEvent_orderBy {
  id
  stableSwap
  stableSwap__id
  stableSwap__isActive
  stableSwap__key
  stableSwap__canonicalId
  stableSwap__domain
  stableSwap__swapPool
  stableSwap__lpToken
  stableSwap__initialA
  stableSwap__futureA
  stableSwap__initialATime
  stableSwap__futureATime
  stableSwap__swapFee
  stableSwap__adminFee
  stableSwap__virtualPrice
  stableSwap__invariant
  stableSwap__lpTokenSupply
  provider
  tokenAmounts
  fees
  invariant
  lpTokenSupply
  lpTokenAmount
  balances
  block
  timestamp
  transaction
  nonce
}

interface base_swap_StableSwapEvent {
  id: ID!
  stableSwap: base_swap_StableSwap!
  block: BigInt!
  timestamp: BigInt!
  transaction: base_swap_Bytes!
  nonce: BigInt!
}

input base_swap_StableSwapEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: base_swap_StableSwap_filter
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: base_swap_Bytes
  transaction_not: base_swap_Bytes
  transaction_gt: base_swap_Bytes
  transaction_lt: base_swap_Bytes
  transaction_gte: base_swap_Bytes
  transaction_lte: base_swap_Bytes
  transaction_in: [base_swap_Bytes!]
  transaction_not_in: [base_swap_Bytes!]
  transaction_contains: base_swap_Bytes
  transaction_not_contains: base_swap_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: base_swap_BlockChangedFilter
  and: [base_swap_StableSwapEvent_filter]
  or: [base_swap_StableSwapEvent_filter]
}

enum base_swap_StableSwapEvent_orderBy {
  id
  stableSwap
  stableSwap__id
  stableSwap__isActive
  stableSwap__key
  stableSwap__canonicalId
  stableSwap__domain
  stableSwap__swapPool
  stableSwap__lpToken
  stableSwap__initialA
  stableSwap__futureA
  stableSwap__initialATime
  stableSwap__futureATime
  stableSwap__swapFee
  stableSwap__adminFee
  stableSwap__virtualPrice
  stableSwap__invariant
  stableSwap__lpTokenSupply
  block
  timestamp
  transaction
  nonce
}

type base_swap_StableSwapExchange {
  id: ID!
  stableSwap: base_swap_StableSwap!
  buyer: base_swap_Bytes!
  boughtId: BigInt!
  tokensBought: BigInt!
  soldId: BigInt!
  tokensSold: BigInt!
  balances: [BigInt!]!
  fee: BigInt!
  block: BigInt!
  timestamp: BigInt!
  transaction: base_swap_Bytes!
  nonce: BigInt!
}

input base_swap_StableSwapExchange_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: base_swap_StableSwap_filter
  buyer: base_swap_Bytes
  buyer_not: base_swap_Bytes
  buyer_gt: base_swap_Bytes
  buyer_lt: base_swap_Bytes
  buyer_gte: base_swap_Bytes
  buyer_lte: base_swap_Bytes
  buyer_in: [base_swap_Bytes!]
  buyer_not_in: [base_swap_Bytes!]
  buyer_contains: base_swap_Bytes
  buyer_not_contains: base_swap_Bytes
  boughtId: BigInt
  boughtId_not: BigInt
  boughtId_gt: BigInt
  boughtId_lt: BigInt
  boughtId_gte: BigInt
  boughtId_lte: BigInt
  boughtId_in: [BigInt!]
  boughtId_not_in: [BigInt!]
  tokensBought: BigInt
  tokensBought_not: BigInt
  tokensBought_gt: BigInt
  tokensBought_lt: BigInt
  tokensBought_gte: BigInt
  tokensBought_lte: BigInt
  tokensBought_in: [BigInt!]
  tokensBought_not_in: [BigInt!]
  soldId: BigInt
  soldId_not: BigInt
  soldId_gt: BigInt
  soldId_lt: BigInt
  soldId_gte: BigInt
  soldId_lte: BigInt
  soldId_in: [BigInt!]
  soldId_not_in: [BigInt!]
  tokensSold: BigInt
  tokensSold_not: BigInt
  tokensSold_gt: BigInt
  tokensSold_lt: BigInt
  tokensSold_gte: BigInt
  tokensSold_lte: BigInt
  tokensSold_in: [BigInt!]
  tokensSold_not_in: [BigInt!]
  balances: [BigInt!]
  balances_not: [BigInt!]
  balances_contains: [BigInt!]
  balances_contains_nocase: [BigInt!]
  balances_not_contains: [BigInt!]
  balances_not_contains_nocase: [BigInt!]
  fee: BigInt
  fee_not: BigInt
  fee_gt: BigInt
  fee_lt: BigInt
  fee_gte: BigInt
  fee_lte: BigInt
  fee_in: [BigInt!]
  fee_not_in: [BigInt!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: base_swap_Bytes
  transaction_not: base_swap_Bytes
  transaction_gt: base_swap_Bytes
  transaction_lt: base_swap_Bytes
  transaction_gte: base_swap_Bytes
  transaction_lte: base_swap_Bytes
  transaction_in: [base_swap_Bytes!]
  transaction_not_in: [base_swap_Bytes!]
  transaction_contains: base_swap_Bytes
  transaction_not_contains: base_swap_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: base_swap_BlockChangedFilter
  and: [base_swap_StableSwapExchange_filter]
  or: [base_swap_StableSwapExchange_filter]
}

enum base_swap_StableSwapExchange_orderBy {
  id
  stableSwap
  stableSwap__id
  stableSwap__isActive
  stableSwap__key
  stableSwap__canonicalId
  stableSwap__domain
  stableSwap__swapPool
  stableSwap__lpToken
  stableSwap__initialA
  stableSwap__futureA
  stableSwap__initialATime
  stableSwap__futureATime
  stableSwap__swapFee
  stableSwap__adminFee
  stableSwap__virtualPrice
  stableSwap__invariant
  stableSwap__lpTokenSupply
  buyer
  boughtId
  tokensBought
  soldId
  tokensSold
  balances
  fee
  block
  timestamp
  transaction
  nonce
}

type base_swap_StableSwapRemoveLiquidityEvent implements base_swap_StableSwapEvent {
  id: ID!
  stableSwap: base_swap_StableSwap!
  provider: base_swap_Bytes!
  tokenAmounts: [BigInt!]!
  fees: [BigInt!]
  invariant: BigInt
  lpTokenSupply: BigInt!
  lpTokenAmount: BigInt!
  balances: [BigInt!]!
  block: BigInt!
  timestamp: BigInt!
  transaction: base_swap_Bytes!
  nonce: BigInt!
}

input base_swap_StableSwapRemoveLiquidityEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: base_swap_StableSwap_filter
  provider: base_swap_Bytes
  provider_not: base_swap_Bytes
  provider_gt: base_swap_Bytes
  provider_lt: base_swap_Bytes
  provider_gte: base_swap_Bytes
  provider_lte: base_swap_Bytes
  provider_in: [base_swap_Bytes!]
  provider_not_in: [base_swap_Bytes!]
  provider_contains: base_swap_Bytes
  provider_not_contains: base_swap_Bytes
  tokenAmounts: [BigInt!]
  tokenAmounts_not: [BigInt!]
  tokenAmounts_contains: [BigInt!]
  tokenAmounts_contains_nocase: [BigInt!]
  tokenAmounts_not_contains: [BigInt!]
  tokenAmounts_not_contains_nocase: [BigInt!]
  fees: [BigInt!]
  fees_not: [BigInt!]
  fees_contains: [BigInt!]
  fees_contains_nocase: [BigInt!]
  fees_not_contains: [BigInt!]
  fees_not_contains_nocase: [BigInt!]
  invariant: BigInt
  invariant_not: BigInt
  invariant_gt: BigInt
  invariant_lt: BigInt
  invariant_gte: BigInt
  invariant_lte: BigInt
  invariant_in: [BigInt!]
  invariant_not_in: [BigInt!]
  lpTokenSupply: BigInt
  lpTokenSupply_not: BigInt
  lpTokenSupply_gt: BigInt
  lpTokenSupply_lt: BigInt
  lpTokenSupply_gte: BigInt
  lpTokenSupply_lte: BigInt
  lpTokenSupply_in: [BigInt!]
  lpTokenSupply_not_in: [BigInt!]
  lpTokenAmount: BigInt
  lpTokenAmount_not: BigInt
  lpTokenAmount_gt: BigInt
  lpTokenAmount_lt: BigInt
  lpTokenAmount_gte: BigInt
  lpTokenAmount_lte: BigInt
  lpTokenAmount_in: [BigInt!]
  lpTokenAmount_not_in: [BigInt!]
  balances: [BigInt!]
  balances_not: [BigInt!]
  balances_contains: [BigInt!]
  balances_contains_nocase: [BigInt!]
  balances_not_contains: [BigInt!]
  balances_not_contains_nocase: [BigInt!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: base_swap_Bytes
  transaction_not: base_swap_Bytes
  transaction_gt: base_swap_Bytes
  transaction_lt: base_swap_Bytes
  transaction_gte: base_swap_Bytes
  transaction_lte: base_swap_Bytes
  transaction_in: [base_swap_Bytes!]
  transaction_not_in: [base_swap_Bytes!]
  transaction_contains: base_swap_Bytes
  transaction_not_contains: base_swap_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: base_swap_BlockChangedFilter
  and: [base_swap_StableSwapRemoveLiquidityEvent_filter]
  or: [base_swap_StableSwapRemoveLiquidityEvent_filter]
}

enum base_swap_StableSwapRemoveLiquidityEvent_orderBy {
  id
  stableSwap
  stableSwap__id
  stableSwap__isActive
  stableSwap__key
  stableSwap__canonicalId
  stableSwap__domain
  stableSwap__swapPool
  stableSwap__lpToken
  stableSwap__initialA
  stableSwap__futureA
  stableSwap__initialATime
  stableSwap__futureATime
  stableSwap__swapFee
  stableSwap__adminFee
  stableSwap__virtualPrice
  stableSwap__invariant
  stableSwap__lpTokenSupply
  provider
  tokenAmounts
  fees
  invariant
  lpTokenSupply
  lpTokenAmount
  balances
  block
  timestamp
  transaction
  nonce
}

input base_swap_StableSwap_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  isActive: Boolean
  isActive_not: Boolean
  isActive_in: [Boolean!]
  isActive_not_in: [Boolean!]
  key: base_swap_Bytes
  key_not: base_swap_Bytes
  key_gt: base_swap_Bytes
  key_lt: base_swap_Bytes
  key_gte: base_swap_Bytes
  key_lte: base_swap_Bytes
  key_in: [base_swap_Bytes!]
  key_not_in: [base_swap_Bytes!]
  key_contains: base_swap_Bytes
  key_not_contains: base_swap_Bytes
  canonicalId: base_swap_Bytes
  canonicalId_not: base_swap_Bytes
  canonicalId_gt: base_swap_Bytes
  canonicalId_lt: base_swap_Bytes
  canonicalId_gte: base_swap_Bytes
  canonicalId_lte: base_swap_Bytes
  canonicalId_in: [base_swap_Bytes!]
  canonicalId_not_in: [base_swap_Bytes!]
  canonicalId_contains: base_swap_Bytes
  canonicalId_not_contains: base_swap_Bytes
  domain: BigInt
  domain_not: BigInt
  domain_gt: BigInt
  domain_lt: BigInt
  domain_gte: BigInt
  domain_lte: BigInt
  domain_in: [BigInt!]
  domain_not_in: [BigInt!]
  swapPool: base_swap_Bytes
  swapPool_not: base_swap_Bytes
  swapPool_gt: base_swap_Bytes
  swapPool_lt: base_swap_Bytes
  swapPool_gte: base_swap_Bytes
  swapPool_lte: base_swap_Bytes
  swapPool_in: [base_swap_Bytes!]
  swapPool_not_in: [base_swap_Bytes!]
  swapPool_contains: base_swap_Bytes
  swapPool_not_contains: base_swap_Bytes
  lpToken: base_swap_Bytes
  lpToken_not: base_swap_Bytes
  lpToken_gt: base_swap_Bytes
  lpToken_lt: base_swap_Bytes
  lpToken_gte: base_swap_Bytes
  lpToken_lte: base_swap_Bytes
  lpToken_in: [base_swap_Bytes!]
  lpToken_not_in: [base_swap_Bytes!]
  lpToken_contains: base_swap_Bytes
  lpToken_not_contains: base_swap_Bytes
  initialA: BigInt
  initialA_not: BigInt
  initialA_gt: BigInt
  initialA_lt: BigInt
  initialA_gte: BigInt
  initialA_lte: BigInt
  initialA_in: [BigInt!]
  initialA_not_in: [BigInt!]
  futureA: BigInt
  futureA_not: BigInt
  futureA_gt: BigInt
  futureA_lt: BigInt
  futureA_gte: BigInt
  futureA_lte: BigInt
  futureA_in: [BigInt!]
  futureA_not_in: [BigInt!]
  initialATime: BigInt
  initialATime_not: BigInt
  initialATime_gt: BigInt
  initialATime_lt: BigInt
  initialATime_gte: BigInt
  initialATime_lte: BigInt
  initialATime_in: [BigInt!]
  initialATime_not_in: [BigInt!]
  futureATime: BigInt
  futureATime_not: BigInt
  futureATime_gt: BigInt
  futureATime_lt: BigInt
  futureATime_gte: BigInt
  futureATime_lte: BigInt
  futureATime_in: [BigInt!]
  futureATime_not_in: [BigInt!]
  swapFee: BigInt
  swapFee_not: BigInt
  swapFee_gt: BigInt
  swapFee_lt: BigInt
  swapFee_gte: BigInt
  swapFee_lte: BigInt
  swapFee_in: [BigInt!]
  swapFee_not_in: [BigInt!]
  adminFee: BigInt
  adminFee_not: BigInt
  adminFee_gt: BigInt
  adminFee_lt: BigInt
  adminFee_gte: BigInt
  adminFee_lte: BigInt
  adminFee_in: [BigInt!]
  adminFee_not_in: [BigInt!]
  pooledTokens: [base_swap_Bytes!]
  pooledTokens_not: [base_swap_Bytes!]
  pooledTokens_contains: [base_swap_Bytes!]
  pooledTokens_contains_nocase: [base_swap_Bytes!]
  pooledTokens_not_contains: [base_swap_Bytes!]
  pooledTokens_not_contains_nocase: [base_swap_Bytes!]
  tokenPrecisionMultipliers: [BigInt!]
  tokenPrecisionMultipliers_not: [BigInt!]
  tokenPrecisionMultipliers_contains: [BigInt!]
  tokenPrecisionMultipliers_contains_nocase: [BigInt!]
  tokenPrecisionMultipliers_not_contains: [BigInt!]
  tokenPrecisionMultipliers_not_contains_nocase: [BigInt!]
  balances: [BigInt!]
  balances_not: [BigInt!]
  balances_contains: [BigInt!]
  balances_contains_nocase: [BigInt!]
  balances_not_contains: [BigInt!]
  balances_not_contains_nocase: [BigInt!]
  adminFees: [BigInt!]
  adminFees_not: [BigInt!]
  adminFees_contains: [BigInt!]
  adminFees_contains_nocase: [BigInt!]
  adminFees_not_contains: [BigInt!]
  adminFees_not_contains_nocase: [BigInt!]
  virtualPrice: BigInt
  virtualPrice_not: BigInt
  virtualPrice_gt: BigInt
  virtualPrice_lt: BigInt
  virtualPrice_gte: BigInt
  virtualPrice_lte: BigInt
  virtualPrice_in: [BigInt!]
  virtualPrice_not_in: [BigInt!]
  invariant: BigInt
  invariant_not: BigInt
  invariant_gt: BigInt
  invariant_lt: BigInt
  invariant_gte: BigInt
  invariant_lte: BigInt
  invariant_in: [BigInt!]
  invariant_not_in: [BigInt!]
  lpTokenSupply: BigInt
  lpTokenSupply_not: BigInt
  lpTokenSupply_gt: BigInt
  lpTokenSupply_lt: BigInt
  lpTokenSupply_gte: BigInt
  lpTokenSupply_lte: BigInt
  lpTokenSupply_in: [BigInt!]
  lpTokenSupply_not_in: [BigInt!]
  events_: base_swap_StableSwapEvent_filter
  exchanges_: base_swap_StableSwapExchange_filter
  hourlyVolumes_: base_swap_SwapHourlyVolume_filter
  dailyVolumes_: base_swap_SwapDailyVolume_filter
  weeklyVolumes_: base_swap_SwapWeeklyVolume_filter
  """Filter for the block changed event."""
  _change_block: base_swap_BlockChangedFilter
  and: [base_swap_StableSwap_filter]
  or: [base_swap_StableSwap_filter]
}

enum base_swap_StableSwap_orderBy {
  id
  isActive
  key
  canonicalId
  domain
  swapPool
  lpToken
  initialA
  futureA
  initialATime
  futureATime
  swapFee
  adminFee
  pooledTokens
  tokenPrecisionMultipliers
  balances
  adminFees
  virtualPrice
  invariant
  lpTokenSupply
  events
  exchanges
  hourlyVolumes
  dailyVolumes
  weeklyVolumes
}

type base_swap_SwapDailyVolume implements base_swap_SwapTradeVolume {
  id: ID!
  stableSwap: base_swap_StableSwap!
  timestamp: BigInt!
  volume: base_swap_BigDecimal!
}

input base_swap_SwapDailyVolume_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: base_swap_StableSwap_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  volume: base_swap_BigDecimal
  volume_not: base_swap_BigDecimal
  volume_gt: base_swap_BigDecimal
  volume_lt: base_swap_BigDecimal
  volume_gte: base_swap_BigDecimal
  volume_lte: base_swap_BigDecimal
  volume_in: [base_swap_BigDecimal!]
  volume_not_in: [base_swap_BigDecimal!]
  """Filter for the block changed event."""
  _change_block: base_swap_BlockChangedFilter
  and: [base_swap_SwapDailyVolume_filter]
  or: [base_swap_SwapDailyVolume_filter]
}

enum base_swap_SwapDailyVolume_orderBy {
  id
  stableSwap
  stableSwap__id
  stableSwap__isActive
  stableSwap__key
  stableSwap__canonicalId
  stableSwap__domain
  stableSwap__swapPool
  stableSwap__lpToken
  stableSwap__initialA
  stableSwap__futureA
  stableSwap__initialATime
  stableSwap__futureATime
  stableSwap__swapFee
  stableSwap__adminFee
  stableSwap__virtualPrice
  stableSwap__invariant
  stableSwap__lpTokenSupply
  timestamp
  volume
}

type base_swap_SwapHourlyVolume implements base_swap_SwapTradeVolume {
  id: ID!
  stableSwap: base_swap_StableSwap!
  timestamp: BigInt!
  volume: base_swap_BigDecimal!
}

input base_swap_SwapHourlyVolume_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: base_swap_StableSwap_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  volume: base_swap_BigDecimal
  volume_not: base_swap_BigDecimal
  volume_gt: base_swap_BigDecimal
  volume_lt: base_swap_BigDecimal
  volume_gte: base_swap_BigDecimal
  volume_lte: base_swap_BigDecimal
  volume_in: [base_swap_BigDecimal!]
  volume_not_in: [base_swap_BigDecimal!]
  """Filter for the block changed event."""
  _change_block: base_swap_BlockChangedFilter
  and: [base_swap_SwapHourlyVolume_filter]
  or: [base_swap_SwapHourlyVolume_filter]
}

enum base_swap_SwapHourlyVolume_orderBy {
  id
  stableSwap
  stableSwap__id
  stableSwap__isActive
  stableSwap__key
  stableSwap__canonicalId
  stableSwap__domain
  stableSwap__swapPool
  stableSwap__lpToken
  stableSwap__initialA
  stableSwap__futureA
  stableSwap__initialATime
  stableSwap__futureATime
  stableSwap__swapFee
  stableSwap__adminFee
  stableSwap__virtualPrice
  stableSwap__invariant
  stableSwap__lpTokenSupply
  timestamp
  volume
}

interface base_swap_SwapTradeVolume {
  stableSwap: base_swap_StableSwap!
  timestamp: BigInt!
  volume: base_swap_BigDecimal!
}

input base_swap_SwapTradeVolume_filter {
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: base_swap_StableSwap_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  volume: base_swap_BigDecimal
  volume_not: base_swap_BigDecimal
  volume_gt: base_swap_BigDecimal
  volume_lt: base_swap_BigDecimal
  volume_gte: base_swap_BigDecimal
  volume_lte: base_swap_BigDecimal
  volume_in: [base_swap_BigDecimal!]
  volume_not_in: [base_swap_BigDecimal!]
  """Filter for the block changed event."""
  _change_block: base_swap_BlockChangedFilter
  and: [base_swap_SwapTradeVolume_filter]
  or: [base_swap_SwapTradeVolume_filter]
}

enum base_swap_SwapTradeVolume_orderBy {
  stableSwap
  stableSwap__id
  stableSwap__isActive
  stableSwap__key
  stableSwap__canonicalId
  stableSwap__domain
  stableSwap__swapPool
  stableSwap__lpToken
  stableSwap__initialA
  stableSwap__futureA
  stableSwap__initialATime
  stableSwap__futureATime
  stableSwap__swapFee
  stableSwap__adminFee
  stableSwap__virtualPrice
  stableSwap__invariant
  stableSwap__lpTokenSupply
  timestamp
  volume
}

type base_swap_SwapWeeklyVolume implements base_swap_SwapTradeVolume {
  id: ID!
  stableSwap: base_swap_StableSwap!
  timestamp: BigInt!
  volume: base_swap_BigDecimal!
}

input base_swap_SwapWeeklyVolume_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: base_swap_StableSwap_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  volume: base_swap_BigDecimal
  volume_not: base_swap_BigDecimal
  volume_gt: base_swap_BigDecimal
  volume_lt: base_swap_BigDecimal
  volume_gte: base_swap_BigDecimal
  volume_lte: base_swap_BigDecimal
  volume_in: [base_swap_BigDecimal!]
  volume_not_in: [base_swap_BigDecimal!]
  """Filter for the block changed event."""
  _change_block: base_swap_BlockChangedFilter
  and: [base_swap_SwapWeeklyVolume_filter]
  or: [base_swap_SwapWeeklyVolume_filter]
}

enum base_swap_SwapWeeklyVolume_orderBy {
  id
  stableSwap
  stableSwap__id
  stableSwap__isActive
  stableSwap__key
  stableSwap__canonicalId
  stableSwap__domain
  stableSwap__swapPool
  stableSwap__lpToken
  stableSwap__initialA
  stableSwap__futureA
  stableSwap__initialATime
  stableSwap__futureATime
  stableSwap__swapFee
  stableSwap__adminFee
  stableSwap__virtualPrice
  stableSwap__invariant
  stableSwap__lpTokenSupply
  timestamp
  volume
}

type base_swap_SystemInfo {
  id: ID!
  exchangeCount: BigInt!
  swapCount: BigInt!
}

input base_swap_SystemInfo_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  exchangeCount: BigInt
  exchangeCount_not: BigInt
  exchangeCount_gt: BigInt
  exchangeCount_lt: BigInt
  exchangeCount_gte: BigInt
  exchangeCount_lte: BigInt
  exchangeCount_in: [BigInt!]
  exchangeCount_not_in: [BigInt!]
  swapCount: BigInt
  swapCount_not: BigInt
  swapCount_gt: BigInt
  swapCount_lt: BigInt
  swapCount_gte: BigInt
  swapCount_lte: BigInt
  swapCount_in: [BigInt!]
  swapCount_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: base_swap_BlockChangedFilter
  and: [base_swap_SystemInfo_filter]
  or: [base_swap_SystemInfo_filter]
}

enum base_swap_SystemInfo_orderBy {
  id
  exchangeCount
  swapCount
}

type base_swap__Block_ {
  """The hash of the block"""
  hash: base_swap_Bytes
  """The block number"""
  number: Int!
  """Integer representation of the timestamp stored in blocks for the chain"""
  timestamp: Int
  """The hash of the parent block"""
  parentHash: base_swap_Bytes
}

"""The type for the top-level _meta field"""
type base_swap__Meta_ {
  """
  Information about a specific subgraph block. The hash of the block
  will be null if the _meta field has a block constraint that asks for
  a block number. It will be filled if the _meta field has no block constraint
  and therefore asks for the latest  block
  
  """
  block: base_swap__Block_!
  """The deployment ID"""
  deployment: String!
  """If `true`, the subgraph encountered indexing errors at some past block"""
  hasIndexingErrors: Boolean!
}

type polygon_AggregateRoot {
  id: ID!
  root: polygon_Bytes!
  blockNumber: BigInt!
}

type polygon_AggregateRootProposed {
  id: ID!
  aggregateRoot: polygon_Bytes!
  rootTimestamp: BigInt!
  endOfDispute: BigInt!
  domain: BigInt!
  timestamp: BigInt!
  blockNumber: BigInt
}

input polygon_AggregateRootProposed_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  aggregateRoot: polygon_Bytes
  aggregateRoot_not: polygon_Bytes
  aggregateRoot_gt: polygon_Bytes
  aggregateRoot_lt: polygon_Bytes
  aggregateRoot_gte: polygon_Bytes
  aggregateRoot_lte: polygon_Bytes
  aggregateRoot_in: [polygon_Bytes!]
  aggregateRoot_not_in: [polygon_Bytes!]
  aggregateRoot_contains: polygon_Bytes
  aggregateRoot_not_contains: polygon_Bytes
  rootTimestamp: BigInt
  rootTimestamp_not: BigInt
  rootTimestamp_gt: BigInt
  rootTimestamp_lt: BigInt
  rootTimestamp_gte: BigInt
  rootTimestamp_lte: BigInt
  rootTimestamp_in: [BigInt!]
  rootTimestamp_not_in: [BigInt!]
  endOfDispute: BigInt
  endOfDispute_not: BigInt
  endOfDispute_gt: BigInt
  endOfDispute_lt: BigInt
  endOfDispute_gte: BigInt
  endOfDispute_lte: BigInt
  endOfDispute_in: [BigInt!]
  endOfDispute_not_in: [BigInt!]
  domain: BigInt
  domain_not: BigInt
  domain_gt: BigInt
  domain_lt: BigInt
  domain_gte: BigInt
  domain_lte: BigInt
  domain_in: [BigInt!]
  domain_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: polygon_BlockChangedFilter
  and: [polygon_AggregateRootProposed_filter]
  or: [polygon_AggregateRootProposed_filter]
}

enum polygon_AggregateRootProposed_orderBy {
  id
  aggregateRoot
  rootTimestamp
  endOfDispute
  domain
  timestamp
  blockNumber
}

input polygon_AggregateRoot_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  root: polygon_Bytes
  root_not: polygon_Bytes
  root_gt: polygon_Bytes
  root_lt: polygon_Bytes
  root_gte: polygon_Bytes
  root_lte: polygon_Bytes
  root_in: [polygon_Bytes!]
  root_not_in: [polygon_Bytes!]
  root_contains: polygon_Bytes
  root_not_contains: polygon_Bytes
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: polygon_BlockChangedFilter
  and: [polygon_AggregateRoot_filter]
  or: [polygon_AggregateRoot_filter]
}

enum polygon_AggregateRoot_orderBy {
  id
  root
  blockNumber
}

enum polygon_Aggregation_interval {
  hour
  day
}

type polygon_Asset {
  id: ID!
  key: polygon_Bytes
  decimal: BigInt
  adoptedDecimal: BigInt
  canonicalId: polygon_Bytes
  canonicalDomain: BigInt
  adoptedAsset: polygon_Bytes
  localAsset: polygon_Bytes
  blockNumber: BigInt
  status: polygon_AssetStatus
}

type polygon_AssetBalance {
  id: ID!
  amount: BigInt!
  locked: BigInt!
  supplied: BigInt!
  removed: BigInt!
  router: polygon_Router!
  asset: polygon_Asset!
  feesEarned: BigInt!
}

input polygon_AssetBalance_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  locked: BigInt
  locked_not: BigInt
  locked_gt: BigInt
  locked_lt: BigInt
  locked_gte: BigInt
  locked_lte: BigInt
  locked_in: [BigInt!]
  locked_not_in: [BigInt!]
  supplied: BigInt
  supplied_not: BigInt
  supplied_gt: BigInt
  supplied_lt: BigInt
  supplied_gte: BigInt
  supplied_lte: BigInt
  supplied_in: [BigInt!]
  supplied_not_in: [BigInt!]
  removed: BigInt
  removed_not: BigInt
  removed_gt: BigInt
  removed_lt: BigInt
  removed_gte: BigInt
  removed_lte: BigInt
  removed_in: [BigInt!]
  removed_not_in: [BigInt!]
  router: String
  router_not: String
  router_gt: String
  router_lt: String
  router_gte: String
  router_lte: String
  router_in: [String!]
  router_not_in: [String!]
  router_contains: String
  router_contains_nocase: String
  router_not_contains: String
  router_not_contains_nocase: String
  router_starts_with: String
  router_starts_with_nocase: String
  router_not_starts_with: String
  router_not_starts_with_nocase: String
  router_ends_with: String
  router_ends_with_nocase: String
  router_not_ends_with: String
  router_not_ends_with_nocase: String
  router_: polygon_Router_filter
  asset: String
  asset_not: String
  asset_gt: String
  asset_lt: String
  asset_gte: String
  asset_lte: String
  asset_in: [String!]
  asset_not_in: [String!]
  asset_contains: String
  asset_contains_nocase: String
  asset_not_contains: String
  asset_not_contains_nocase: String
  asset_starts_with: String
  asset_starts_with_nocase: String
  asset_not_starts_with: String
  asset_not_starts_with_nocase: String
  asset_ends_with: String
  asset_ends_with_nocase: String
  asset_not_ends_with: String
  asset_not_ends_with_nocase: String
  asset_: polygon_Asset_filter
  feesEarned: BigInt
  feesEarned_not: BigInt
  feesEarned_gt: BigInt
  feesEarned_lt: BigInt
  feesEarned_gte: BigInt
  feesEarned_lte: BigInt
  feesEarned_in: [BigInt!]
  feesEarned_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: polygon_BlockChangedFilter
  and: [polygon_AssetBalance_filter]
  or: [polygon_AssetBalance_filter]
}

enum polygon_AssetBalance_orderBy {
  id
  amount
  locked
  supplied
  removed
  router
  router__id
  router__isActive
  router__owner
  router__recipient
  router__proposedOwner
  router__proposedTimestamp
  asset
  asset__id
  asset__key
  asset__decimal
  asset__adoptedDecimal
  asset__canonicalId
  asset__canonicalDomain
  asset__adoptedAsset
  asset__localAsset
  asset__blockNumber
  feesEarned
}

type polygon_AssetStatus {
  id: ID!
  status: Boolean
}

input polygon_AssetStatus_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  status: Boolean
  status_not: Boolean
  status_in: [Boolean!]
  status_not_in: [Boolean!]
  """Filter for the block changed event."""
  _change_block: polygon_BlockChangedFilter
  and: [polygon_AssetStatus_filter]
  or: [polygon_AssetStatus_filter]
}

enum polygon_AssetStatus_orderBy {
  id
  status
}

input polygon_Asset_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  key: polygon_Bytes
  key_not: polygon_Bytes
  key_gt: polygon_Bytes
  key_lt: polygon_Bytes
  key_gte: polygon_Bytes
  key_lte: polygon_Bytes
  key_in: [polygon_Bytes!]
  key_not_in: [polygon_Bytes!]
  key_contains: polygon_Bytes
  key_not_contains: polygon_Bytes
  decimal: BigInt
  decimal_not: BigInt
  decimal_gt: BigInt
  decimal_lt: BigInt
  decimal_gte: BigInt
  decimal_lte: BigInt
  decimal_in: [BigInt!]
  decimal_not_in: [BigInt!]
  adoptedDecimal: BigInt
  adoptedDecimal_not: BigInt
  adoptedDecimal_gt: BigInt
  adoptedDecimal_lt: BigInt
  adoptedDecimal_gte: BigInt
  adoptedDecimal_lte: BigInt
  adoptedDecimal_in: [BigInt!]
  adoptedDecimal_not_in: [BigInt!]
  canonicalId: polygon_Bytes
  canonicalId_not: polygon_Bytes
  canonicalId_gt: polygon_Bytes
  canonicalId_lt: polygon_Bytes
  canonicalId_gte: polygon_Bytes
  canonicalId_lte: polygon_Bytes
  canonicalId_in: [polygon_Bytes!]
  canonicalId_not_in: [polygon_Bytes!]
  canonicalId_contains: polygon_Bytes
  canonicalId_not_contains: polygon_Bytes
  canonicalDomain: BigInt
  canonicalDomain_not: BigInt
  canonicalDomain_gt: BigInt
  canonicalDomain_lt: BigInt
  canonicalDomain_gte: BigInt
  canonicalDomain_lte: BigInt
  canonicalDomain_in: [BigInt!]
  canonicalDomain_not_in: [BigInt!]
  adoptedAsset: polygon_Bytes
  adoptedAsset_not: polygon_Bytes
  adoptedAsset_gt: polygon_Bytes
  adoptedAsset_lt: polygon_Bytes
  adoptedAsset_gte: polygon_Bytes
  adoptedAsset_lte: polygon_Bytes
  adoptedAsset_in: [polygon_Bytes!]
  adoptedAsset_not_in: [polygon_Bytes!]
  adoptedAsset_contains: polygon_Bytes
  adoptedAsset_not_contains: polygon_Bytes
  localAsset: polygon_Bytes
  localAsset_not: polygon_Bytes
  localAsset_gt: polygon_Bytes
  localAsset_lt: polygon_Bytes
  localAsset_gte: polygon_Bytes
  localAsset_lte: polygon_Bytes
  localAsset_in: [polygon_Bytes!]
  localAsset_not_in: [polygon_Bytes!]
  localAsset_contains: polygon_Bytes
  localAsset_not_contains: polygon_Bytes
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  status: String
  status_not: String
  status_gt: String
  status_lt: String
  status_gte: String
  status_lte: String
  status_in: [String!]
  status_not_in: [String!]
  status_contains: String
  status_contains_nocase: String
  status_not_contains: String
  status_not_contains_nocase: String
  status_starts_with: String
  status_starts_with_nocase: String
  status_not_starts_with: String
  status_not_starts_with_nocase: String
  status_ends_with: String
  status_ends_with_nocase: String
  status_not_ends_with: String
  status_not_ends_with_nocase: String
  status_: polygon_AssetStatus_filter
  """Filter for the block changed event."""
  _change_block: polygon_BlockChangedFilter
  and: [polygon_Asset_filter]
  or: [polygon_Asset_filter]
}

enum polygon_Asset_orderBy {
  id
  key
  decimal
  adoptedDecimal
  canonicalId
  canonicalDomain
  adoptedAsset
  localAsset
  blockNumber
  status
  status__id
  status__status
}

scalar polygon_BigDecimal

input polygon_BlockChangedFilter {
  number_gte: Int!
}

input polygon_Block_height {
  hash: polygon_Bytes
  number: Int
  number_gte: Int
}

scalar polygon_Bytes

type polygon_ConnectorMeta {
  id: ID!
  spokeDomain: BigInt
  hubDomain: BigInt
  amb: polygon_Bytes
  rootManager: polygon_Bytes
  mirrorConnector: polygon_Bytes
}

input polygon_ConnectorMeta_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  spokeDomain: BigInt
  spokeDomain_not: BigInt
  spokeDomain_gt: BigInt
  spokeDomain_lt: BigInt
  spokeDomain_gte: BigInt
  spokeDomain_lte: BigInt
  spokeDomain_in: [BigInt!]
  spokeDomain_not_in: [BigInt!]
  hubDomain: BigInt
  hubDomain_not: BigInt
  hubDomain_gt: BigInt
  hubDomain_lt: BigInt
  hubDomain_gte: BigInt
  hubDomain_lte: BigInt
  hubDomain_in: [BigInt!]
  hubDomain_not_in: [BigInt!]
  amb: polygon_Bytes
  amb_not: polygon_Bytes
  amb_gt: polygon_Bytes
  amb_lt: polygon_Bytes
  amb_gte: polygon_Bytes
  amb_lte: polygon_Bytes
  amb_in: [polygon_Bytes!]
  amb_not_in: [polygon_Bytes!]
  amb_contains: polygon_Bytes
  amb_not_contains: polygon_Bytes
  rootManager: polygon_Bytes
  rootManager_not: polygon_Bytes
  rootManager_gt: polygon_Bytes
  rootManager_lt: polygon_Bytes
  rootManager_gte: polygon_Bytes
  rootManager_lte: polygon_Bytes
  rootManager_in: [polygon_Bytes!]
  rootManager_not_in: [polygon_Bytes!]
  rootManager_contains: polygon_Bytes
  rootManager_not_contains: polygon_Bytes
  mirrorConnector: polygon_Bytes
  mirrorConnector_not: polygon_Bytes
  mirrorConnector_gt: polygon_Bytes
  mirrorConnector_lt: polygon_Bytes
  mirrorConnector_gte: polygon_Bytes
  mirrorConnector_lte: polygon_Bytes
  mirrorConnector_in: [polygon_Bytes!]
  mirrorConnector_not_in: [polygon_Bytes!]
  mirrorConnector_contains: polygon_Bytes
  mirrorConnector_not_contains: polygon_Bytes
  """Filter for the block changed event."""
  _change_block: polygon_BlockChangedFilter
  and: [polygon_ConnectorMeta_filter]
  or: [polygon_ConnectorMeta_filter]
}

enum polygon_ConnectorMeta_orderBy {
  id
  spokeDomain
  hubDomain
  amb
  rootManager
  mirrorConnector
}

type polygon_DestinationTransfer {
  id: ID!
  chainId: BigInt
  transferId: polygon_Bytes
  nonce: BigInt
  status: polygon_TransferStatus
  routers(skip: Int = 0, first: Int = 100, orderBy: polygon_Router_orderBy, orderDirection: polygon_OrderDirection, where: polygon_Router_filter): [polygon_Router!]
  originDomain: BigInt
  destinationDomain: BigInt
  canonicalDomain: BigInt
  to: polygon_Bytes
  delegate: polygon_Bytes
  receiveLocal: Boolean
  callData: polygon_Bytes
  slippage: BigInt
  bumpSlippageCount: BigInt
  originSender: polygon_Bytes
  bridgedAmt: BigInt
  normalizedIn: BigInt
  canonicalId: polygon_Bytes
  asset: polygon_Asset
  amount: BigInt
  routersFee: BigInt
  executedCaller: polygon_Bytes
  executedTransactionHash: polygon_Bytes
  executedTimestamp: BigInt
  executedGasPrice: BigInt
  executedGasLimit: BigInt
  executedBlockNumber: BigInt
  executedTxOrigin: polygon_Bytes
  executedTxNonce: BigInt
  reconciledCaller: polygon_Bytes
  reconciledTransactionHash: polygon_Bytes
  reconciledTimestamp: BigInt
  reconciledGasPrice: BigInt
  reconciledGasLimit: BigInt
  reconciledBlockNumber: BigInt
  reconciledTxOrigin: polygon_Bytes
  reconciledTxNonce: BigInt
}

input polygon_DestinationTransfer_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  chainId: BigInt
  chainId_not: BigInt
  chainId_gt: BigInt
  chainId_lt: BigInt
  chainId_gte: BigInt
  chainId_lte: BigInt
  chainId_in: [BigInt!]
  chainId_not_in: [BigInt!]
  transferId: polygon_Bytes
  transferId_not: polygon_Bytes
  transferId_gt: polygon_Bytes
  transferId_lt: polygon_Bytes
  transferId_gte: polygon_Bytes
  transferId_lte: polygon_Bytes
  transferId_in: [polygon_Bytes!]
  transferId_not_in: [polygon_Bytes!]
  transferId_contains: polygon_Bytes
  transferId_not_contains: polygon_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  status: polygon_TransferStatus
  status_not: polygon_TransferStatus
  status_in: [polygon_TransferStatus!]
  status_not_in: [polygon_TransferStatus!]
  routers: [String!]
  routers_not: [String!]
  routers_contains: [String!]
  routers_contains_nocase: [String!]
  routers_not_contains: [String!]
  routers_not_contains_nocase: [String!]
  routers_: polygon_Router_filter
  originDomain: BigInt
  originDomain_not: BigInt
  originDomain_gt: BigInt
  originDomain_lt: BigInt
  originDomain_gte: BigInt
  originDomain_lte: BigInt
  originDomain_in: [BigInt!]
  originDomain_not_in: [BigInt!]
  destinationDomain: BigInt
  destinationDomain_not: BigInt
  destinationDomain_gt: BigInt
  destinationDomain_lt: BigInt
  destinationDomain_gte: BigInt
  destinationDomain_lte: BigInt
  destinationDomain_in: [BigInt!]
  destinationDomain_not_in: [BigInt!]
  canonicalDomain: BigInt
  canonicalDomain_not: BigInt
  canonicalDomain_gt: BigInt
  canonicalDomain_lt: BigInt
  canonicalDomain_gte: BigInt
  canonicalDomain_lte: BigInt
  canonicalDomain_in: [BigInt!]
  canonicalDomain_not_in: [BigInt!]
  to: polygon_Bytes
  to_not: polygon_Bytes
  to_gt: polygon_Bytes
  to_lt: polygon_Bytes
  to_gte: polygon_Bytes
  to_lte: polygon_Bytes
  to_in: [polygon_Bytes!]
  to_not_in: [polygon_Bytes!]
  to_contains: polygon_Bytes
  to_not_contains: polygon_Bytes
  delegate: polygon_Bytes
  delegate_not: polygon_Bytes
  delegate_gt: polygon_Bytes
  delegate_lt: polygon_Bytes
  delegate_gte: polygon_Bytes
  delegate_lte: polygon_Bytes
  delegate_in: [polygon_Bytes!]
  delegate_not_in: [polygon_Bytes!]
  delegate_contains: polygon_Bytes
  delegate_not_contains: polygon_Bytes
  receiveLocal: Boolean
  receiveLocal_not: Boolean
  receiveLocal_in: [Boolean!]
  receiveLocal_not_in: [Boolean!]
  callData: polygon_Bytes
  callData_not: polygon_Bytes
  callData_gt: polygon_Bytes
  callData_lt: polygon_Bytes
  callData_gte: polygon_Bytes
  callData_lte: polygon_Bytes
  callData_in: [polygon_Bytes!]
  callData_not_in: [polygon_Bytes!]
  callData_contains: polygon_Bytes
  callData_not_contains: polygon_Bytes
  slippage: BigInt
  slippage_not: BigInt
  slippage_gt: BigInt
  slippage_lt: BigInt
  slippage_gte: BigInt
  slippage_lte: BigInt
  slippage_in: [BigInt!]
  slippage_not_in: [BigInt!]
  bumpSlippageCount: BigInt
  bumpSlippageCount_not: BigInt
  bumpSlippageCount_gt: BigInt
  bumpSlippageCount_lt: BigInt
  bumpSlippageCount_gte: BigInt
  bumpSlippageCount_lte: BigInt
  bumpSlippageCount_in: [BigInt!]
  bumpSlippageCount_not_in: [BigInt!]
  originSender: polygon_Bytes
  originSender_not: polygon_Bytes
  originSender_gt: polygon_Bytes
  originSender_lt: polygon_Bytes
  originSender_gte: polygon_Bytes
  originSender_lte: polygon_Bytes
  originSender_in: [polygon_Bytes!]
  originSender_not_in: [polygon_Bytes!]
  originSender_contains: polygon_Bytes
  originSender_not_contains: polygon_Bytes
  bridgedAmt: BigInt
  bridgedAmt_not: BigInt
  bridgedAmt_gt: BigInt
  bridgedAmt_lt: BigInt
  bridgedAmt_gte: BigInt
  bridgedAmt_lte: BigInt
  bridgedAmt_in: [BigInt!]
  bridgedAmt_not_in: [BigInt!]
  normalizedIn: BigInt
  normalizedIn_not: BigInt
  normalizedIn_gt: BigInt
  normalizedIn_lt: BigInt
  normalizedIn_gte: BigInt
  normalizedIn_lte: BigInt
  normalizedIn_in: [BigInt!]
  normalizedIn_not_in: [BigInt!]
  canonicalId: polygon_Bytes
  canonicalId_not: polygon_Bytes
  canonicalId_gt: polygon_Bytes
  canonicalId_lt: polygon_Bytes
  canonicalId_gte: polygon_Bytes
  canonicalId_lte: polygon_Bytes
  canonicalId_in: [polygon_Bytes!]
  canonicalId_not_in: [polygon_Bytes!]
  canonicalId_contains: polygon_Bytes
  canonicalId_not_contains: polygon_Bytes
  asset: String
  asset_not: String
  asset_gt: String
  asset_lt: String
  asset_gte: String
  asset_lte: String
  asset_in: [String!]
  asset_not_in: [String!]
  asset_contains: String
  asset_contains_nocase: String
  asset_not_contains: String
  asset_not_contains_nocase: String
  asset_starts_with: String
  asset_starts_with_nocase: String
  asset_not_starts_with: String
  asset_not_starts_with_nocase: String
  asset_ends_with: String
  asset_ends_with_nocase: String
  asset_not_ends_with: String
  asset_not_ends_with_nocase: String
  asset_: polygon_Asset_filter
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  routersFee: BigInt
  routersFee_not: BigInt
  routersFee_gt: BigInt
  routersFee_lt: BigInt
  routersFee_gte: BigInt
  routersFee_lte: BigInt
  routersFee_in: [BigInt!]
  routersFee_not_in: [BigInt!]
  executedCaller: polygon_Bytes
  executedCaller_not: polygon_Bytes
  executedCaller_gt: polygon_Bytes
  executedCaller_lt: polygon_Bytes
  executedCaller_gte: polygon_Bytes
  executedCaller_lte: polygon_Bytes
  executedCaller_in: [polygon_Bytes!]
  executedCaller_not_in: [polygon_Bytes!]
  executedCaller_contains: polygon_Bytes
  executedCaller_not_contains: polygon_Bytes
  executedTransactionHash: polygon_Bytes
  executedTransactionHash_not: polygon_Bytes
  executedTransactionHash_gt: polygon_Bytes
  executedTransactionHash_lt: polygon_Bytes
  executedTransactionHash_gte: polygon_Bytes
  executedTransactionHash_lte: polygon_Bytes
  executedTransactionHash_in: [polygon_Bytes!]
  executedTransactionHash_not_in: [polygon_Bytes!]
  executedTransactionHash_contains: polygon_Bytes
  executedTransactionHash_not_contains: polygon_Bytes
  executedTimestamp: BigInt
  executedTimestamp_not: BigInt
  executedTimestamp_gt: BigInt
  executedTimestamp_lt: BigInt
  executedTimestamp_gte: BigInt
  executedTimestamp_lte: BigInt
  executedTimestamp_in: [BigInt!]
  executedTimestamp_not_in: [BigInt!]
  executedGasPrice: BigInt
  executedGasPrice_not: BigInt
  executedGasPrice_gt: BigInt
  executedGasPrice_lt: BigInt
  executedGasPrice_gte: BigInt
  executedGasPrice_lte: BigInt
  executedGasPrice_in: [BigInt!]
  executedGasPrice_not_in: [BigInt!]
  executedGasLimit: BigInt
  executedGasLimit_not: BigInt
  executedGasLimit_gt: BigInt
  executedGasLimit_lt: BigInt
  executedGasLimit_gte: BigInt
  executedGasLimit_lte: BigInt
  executedGasLimit_in: [BigInt!]
  executedGasLimit_not_in: [BigInt!]
  executedBlockNumber: BigInt
  executedBlockNumber_not: BigInt
  executedBlockNumber_gt: BigInt
  executedBlockNumber_lt: BigInt
  executedBlockNumber_gte: BigInt
  executedBlockNumber_lte: BigInt
  executedBlockNumber_in: [BigInt!]
  executedBlockNumber_not_in: [BigInt!]
  executedTxOrigin: polygon_Bytes
  executedTxOrigin_not: polygon_Bytes
  executedTxOrigin_gt: polygon_Bytes
  executedTxOrigin_lt: polygon_Bytes
  executedTxOrigin_gte: polygon_Bytes
  executedTxOrigin_lte: polygon_Bytes
  executedTxOrigin_in: [polygon_Bytes!]
  executedTxOrigin_not_in: [polygon_Bytes!]
  executedTxOrigin_contains: polygon_Bytes
  executedTxOrigin_not_contains: polygon_Bytes
  executedTxNonce: BigInt
  executedTxNonce_not: BigInt
  executedTxNonce_gt: BigInt
  executedTxNonce_lt: BigInt
  executedTxNonce_gte: BigInt
  executedTxNonce_lte: BigInt
  executedTxNonce_in: [BigInt!]
  executedTxNonce_not_in: [BigInt!]
  reconciledCaller: polygon_Bytes
  reconciledCaller_not: polygon_Bytes
  reconciledCaller_gt: polygon_Bytes
  reconciledCaller_lt: polygon_Bytes
  reconciledCaller_gte: polygon_Bytes
  reconciledCaller_lte: polygon_Bytes
  reconciledCaller_in: [polygon_Bytes!]
  reconciledCaller_not_in: [polygon_Bytes!]
  reconciledCaller_contains: polygon_Bytes
  reconciledCaller_not_contains: polygon_Bytes
  reconciledTransactionHash: polygon_Bytes
  reconciledTransactionHash_not: polygon_Bytes
  reconciledTransactionHash_gt: polygon_Bytes
  reconciledTransactionHash_lt: polygon_Bytes
  reconciledTransactionHash_gte: polygon_Bytes
  reconciledTransactionHash_lte: polygon_Bytes
  reconciledTransactionHash_in: [polygon_Bytes!]
  reconciledTransactionHash_not_in: [polygon_Bytes!]
  reconciledTransactionHash_contains: polygon_Bytes
  reconciledTransactionHash_not_contains: polygon_Bytes
  reconciledTimestamp: BigInt
  reconciledTimestamp_not: BigInt
  reconciledTimestamp_gt: BigInt
  reconciledTimestamp_lt: BigInt
  reconciledTimestamp_gte: BigInt
  reconciledTimestamp_lte: BigInt
  reconciledTimestamp_in: [BigInt!]
  reconciledTimestamp_not_in: [BigInt!]
  reconciledGasPrice: BigInt
  reconciledGasPrice_not: BigInt
  reconciledGasPrice_gt: BigInt
  reconciledGasPrice_lt: BigInt
  reconciledGasPrice_gte: BigInt
  reconciledGasPrice_lte: BigInt
  reconciledGasPrice_in: [BigInt!]
  reconciledGasPrice_not_in: [BigInt!]
  reconciledGasLimit: BigInt
  reconciledGasLimit_not: BigInt
  reconciledGasLimit_gt: BigInt
  reconciledGasLimit_lt: BigInt
  reconciledGasLimit_gte: BigInt
  reconciledGasLimit_lte: BigInt
  reconciledGasLimit_in: [BigInt!]
  reconciledGasLimit_not_in: [BigInt!]
  reconciledBlockNumber: BigInt
  reconciledBlockNumber_not: BigInt
  reconciledBlockNumber_gt: BigInt
  reconciledBlockNumber_lt: BigInt
  reconciledBlockNumber_gte: BigInt
  reconciledBlockNumber_lte: BigInt
  reconciledBlockNumber_in: [BigInt!]
  reconciledBlockNumber_not_in: [BigInt!]
  reconciledTxOrigin: polygon_Bytes
  reconciledTxOrigin_not: polygon_Bytes
  reconciledTxOrigin_gt: polygon_Bytes
  reconciledTxOrigin_lt: polygon_Bytes
  reconciledTxOrigin_gte: polygon_Bytes
  reconciledTxOrigin_lte: polygon_Bytes
  reconciledTxOrigin_in: [polygon_Bytes!]
  reconciledTxOrigin_not_in: [polygon_Bytes!]
  reconciledTxOrigin_contains: polygon_Bytes
  reconciledTxOrigin_not_contains: polygon_Bytes
  reconciledTxNonce: BigInt
  reconciledTxNonce_not: BigInt
  reconciledTxNonce_gt: BigInt
  reconciledTxNonce_lt: BigInt
  reconciledTxNonce_gte: BigInt
  reconciledTxNonce_lte: BigInt
  reconciledTxNonce_in: [BigInt!]
  reconciledTxNonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: polygon_BlockChangedFilter
  and: [polygon_DestinationTransfer_filter]
  or: [polygon_DestinationTransfer_filter]
}

enum polygon_DestinationTransfer_orderBy {
  id
  chainId
  transferId
  nonce
  status
  routers
  originDomain
  destinationDomain
  canonicalDomain
  to
  delegate
  receiveLocal
  callData
  slippage
  bumpSlippageCount
  originSender
  bridgedAmt
  normalizedIn
  canonicalId
  asset
  asset__id
  asset__key
  asset__decimal
  asset__adoptedDecimal
  asset__canonicalId
  asset__canonicalDomain
  asset__adoptedAsset
  asset__localAsset
  asset__blockNumber
  amount
  routersFee
  executedCaller
  executedTransactionHash
  executedTimestamp
  executedGasPrice
  executedGasLimit
  executedBlockNumber
  executedTxOrigin
  executedTxNonce
  reconciledCaller
  reconciledTransactionHash
  reconciledTimestamp
  reconciledGasPrice
  reconciledGasLimit
  reconciledBlockNumber
  reconciledTxOrigin
  reconciledTxNonce
}

"""
8 bytes signed integer

"""
scalar polygon_Int8

type polygon_OptimisticRootFinalized {
  id: ID!
  aggregateRoot: polygon_Bytes!
  timestamp: BigInt!
  blockNumber: BigInt
}

input polygon_OptimisticRootFinalized_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  aggregateRoot: polygon_Bytes
  aggregateRoot_not: polygon_Bytes
  aggregateRoot_gt: polygon_Bytes
  aggregateRoot_lt: polygon_Bytes
  aggregateRoot_gte: polygon_Bytes
  aggregateRoot_lte: polygon_Bytes
  aggregateRoot_in: [polygon_Bytes!]
  aggregateRoot_not_in: [polygon_Bytes!]
  aggregateRoot_contains: polygon_Bytes
  aggregateRoot_not_contains: polygon_Bytes
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: polygon_BlockChangedFilter
  and: [polygon_OptimisticRootFinalized_filter]
  or: [polygon_OptimisticRootFinalized_filter]
}

enum polygon_OptimisticRootFinalized_orderBy {
  id
  aggregateRoot
  timestamp
  blockNumber
}

"""Defines the order direction, either ascending or descending"""
enum polygon_OrderDirection {
  asc
  desc
}

type polygon_OriginMessage {
  id: ID!
  transferId: polygon_Bytes
  destinationDomain: BigInt
  leaf: polygon_Bytes
  index: BigInt
  message: polygon_Bytes
  root: polygon_Bytes
  transactionHash: polygon_Bytes
  blockNumber: BigInt
  rootCount: polygon_RootCount
}

input polygon_OriginMessage_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transferId: polygon_Bytes
  transferId_not: polygon_Bytes
  transferId_gt: polygon_Bytes
  transferId_lt: polygon_Bytes
  transferId_gte: polygon_Bytes
  transferId_lte: polygon_Bytes
  transferId_in: [polygon_Bytes!]
  transferId_not_in: [polygon_Bytes!]
  transferId_contains: polygon_Bytes
  transferId_not_contains: polygon_Bytes
  destinationDomain: BigInt
  destinationDomain_not: BigInt
  destinationDomain_gt: BigInt
  destinationDomain_lt: BigInt
  destinationDomain_gte: BigInt
  destinationDomain_lte: BigInt
  destinationDomain_in: [BigInt!]
  destinationDomain_not_in: [BigInt!]
  leaf: polygon_Bytes
  leaf_not: polygon_Bytes
  leaf_gt: polygon_Bytes
  leaf_lt: polygon_Bytes
  leaf_gte: polygon_Bytes
  leaf_lte: polygon_Bytes
  leaf_in: [polygon_Bytes!]
  leaf_not_in: [polygon_Bytes!]
  leaf_contains: polygon_Bytes
  leaf_not_contains: polygon_Bytes
  index: BigInt
  index_not: BigInt
  index_gt: BigInt
  index_lt: BigInt
  index_gte: BigInt
  index_lte: BigInt
  index_in: [BigInt!]
  index_not_in: [BigInt!]
  message: polygon_Bytes
  message_not: polygon_Bytes
  message_gt: polygon_Bytes
  message_lt: polygon_Bytes
  message_gte: polygon_Bytes
  message_lte: polygon_Bytes
  message_in: [polygon_Bytes!]
  message_not_in: [polygon_Bytes!]
  message_contains: polygon_Bytes
  message_not_contains: polygon_Bytes
  root: polygon_Bytes
  root_not: polygon_Bytes
  root_gt: polygon_Bytes
  root_lt: polygon_Bytes
  root_gte: polygon_Bytes
  root_lte: polygon_Bytes
  root_in: [polygon_Bytes!]
  root_not_in: [polygon_Bytes!]
  root_contains: polygon_Bytes
  root_not_contains: polygon_Bytes
  transactionHash: polygon_Bytes
  transactionHash_not: polygon_Bytes
  transactionHash_gt: polygon_Bytes
  transactionHash_lt: polygon_Bytes
  transactionHash_gte: polygon_Bytes
  transactionHash_lte: polygon_Bytes
  transactionHash_in: [polygon_Bytes!]
  transactionHash_not_in: [polygon_Bytes!]
  transactionHash_contains: polygon_Bytes
  transactionHash_not_contains: polygon_Bytes
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  rootCount: String
  rootCount_not: String
  rootCount_gt: String
  rootCount_lt: String
  rootCount_gte: String
  rootCount_lte: String
  rootCount_in: [String!]
  rootCount_not_in: [String!]
  rootCount_contains: String
  rootCount_contains_nocase: String
  rootCount_not_contains: String
  rootCount_not_contains_nocase: String
  rootCount_starts_with: String
  rootCount_starts_with_nocase: String
  rootCount_not_starts_with: String
  rootCount_not_starts_with_nocase: String
  rootCount_ends_with: String
  rootCount_ends_with_nocase: String
  rootCount_not_ends_with: String
  rootCount_not_ends_with_nocase: String
  rootCount_: polygon_RootCount_filter
  """Filter for the block changed event."""
  _change_block: polygon_BlockChangedFilter
  and: [polygon_OriginMessage_filter]
  or: [polygon_OriginMessage_filter]
}

enum polygon_OriginMessage_orderBy {
  id
  transferId
  destinationDomain
  leaf
  index
  message
  root
  transactionHash
  blockNumber
  rootCount
  rootCount__id
  rootCount__count
}

type polygon_OriginTransfer {
  id: ID!
  chainId: BigInt
  transferId: polygon_Bytes
  nonce: BigInt
  status: polygon_TransferStatus
  messageHash: polygon_Bytes
  originDomain: BigInt
  destinationDomain: BigInt
  canonicalDomain: BigInt
  to: polygon_Bytes
  delegate: polygon_Bytes
  receiveLocal: Boolean
  callData: polygon_Bytes
  slippage: BigInt
  originSender: polygon_Bytes
  bridgedAmt: BigInt
  normalizedIn: BigInt
  canonicalId: polygon_Bytes
  asset: polygon_Asset
  transactingAsset: polygon_Bytes
  message: polygon_OriginMessage
  bumpRelayerFeeCount: BigInt
  relayerFees(skip: Int = 0, first: Int = 100, orderBy: polygon_RelayerFee_orderBy, orderDirection: polygon_OrderDirection, where: polygon_RelayerFee_filter): [polygon_RelayerFee!]
  initialRelayerFeeAsset: polygon_Bytes
  caller: polygon_Bytes
  transactionHash: polygon_Bytes
  timestamp: BigInt
  gasPrice: BigInt
  gasLimit: BigInt
  blockNumber: BigInt
  txOrigin: polygon_Bytes
  txNonce: BigInt
}

input polygon_OriginTransfer_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  chainId: BigInt
  chainId_not: BigInt
  chainId_gt: BigInt
  chainId_lt: BigInt
  chainId_gte: BigInt
  chainId_lte: BigInt
  chainId_in: [BigInt!]
  chainId_not_in: [BigInt!]
  transferId: polygon_Bytes
  transferId_not: polygon_Bytes
  transferId_gt: polygon_Bytes
  transferId_lt: polygon_Bytes
  transferId_gte: polygon_Bytes
  transferId_lte: polygon_Bytes
  transferId_in: [polygon_Bytes!]
  transferId_not_in: [polygon_Bytes!]
  transferId_contains: polygon_Bytes
  transferId_not_contains: polygon_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  status: polygon_TransferStatus
  status_not: polygon_TransferStatus
  status_in: [polygon_TransferStatus!]
  status_not_in: [polygon_TransferStatus!]
  messageHash: polygon_Bytes
  messageHash_not: polygon_Bytes
  messageHash_gt: polygon_Bytes
  messageHash_lt: polygon_Bytes
  messageHash_gte: polygon_Bytes
  messageHash_lte: polygon_Bytes
  messageHash_in: [polygon_Bytes!]
  messageHash_not_in: [polygon_Bytes!]
  messageHash_contains: polygon_Bytes
  messageHash_not_contains: polygon_Bytes
  originDomain: BigInt
  originDomain_not: BigInt
  originDomain_gt: BigInt
  originDomain_lt: BigInt
  originDomain_gte: BigInt
  originDomain_lte: BigInt
  originDomain_in: [BigInt!]
  originDomain_not_in: [BigInt!]
  destinationDomain: BigInt
  destinationDomain_not: BigInt
  destinationDomain_gt: BigInt
  destinationDomain_lt: BigInt
  destinationDomain_gte: BigInt
  destinationDomain_lte: BigInt
  destinationDomain_in: [BigInt!]
  destinationDomain_not_in: [BigInt!]
  canonicalDomain: BigInt
  canonicalDomain_not: BigInt
  canonicalDomain_gt: BigInt
  canonicalDomain_lt: BigInt
  canonicalDomain_gte: BigInt
  canonicalDomain_lte: BigInt
  canonicalDomain_in: [BigInt!]
  canonicalDomain_not_in: [BigInt!]
  to: polygon_Bytes
  to_not: polygon_Bytes
  to_gt: polygon_Bytes
  to_lt: polygon_Bytes
  to_gte: polygon_Bytes
  to_lte: polygon_Bytes
  to_in: [polygon_Bytes!]
  to_not_in: [polygon_Bytes!]
  to_contains: polygon_Bytes
  to_not_contains: polygon_Bytes
  delegate: polygon_Bytes
  delegate_not: polygon_Bytes
  delegate_gt: polygon_Bytes
  delegate_lt: polygon_Bytes
  delegate_gte: polygon_Bytes
  delegate_lte: polygon_Bytes
  delegate_in: [polygon_Bytes!]
  delegate_not_in: [polygon_Bytes!]
  delegate_contains: polygon_Bytes
  delegate_not_contains: polygon_Bytes
  receiveLocal: Boolean
  receiveLocal_not: Boolean
  receiveLocal_in: [Boolean!]
  receiveLocal_not_in: [Boolean!]
  callData: polygon_Bytes
  callData_not: polygon_Bytes
  callData_gt: polygon_Bytes
  callData_lt: polygon_Bytes
  callData_gte: polygon_Bytes
  callData_lte: polygon_Bytes
  callData_in: [polygon_Bytes!]
  callData_not_in: [polygon_Bytes!]
  callData_contains: polygon_Bytes
  callData_not_contains: polygon_Bytes
  slippage: BigInt
  slippage_not: BigInt
  slippage_gt: BigInt
  slippage_lt: BigInt
  slippage_gte: BigInt
  slippage_lte: BigInt
  slippage_in: [BigInt!]
  slippage_not_in: [BigInt!]
  originSender: polygon_Bytes
  originSender_not: polygon_Bytes
  originSender_gt: polygon_Bytes
  originSender_lt: polygon_Bytes
  originSender_gte: polygon_Bytes
  originSender_lte: polygon_Bytes
  originSender_in: [polygon_Bytes!]
  originSender_not_in: [polygon_Bytes!]
  originSender_contains: polygon_Bytes
  originSender_not_contains: polygon_Bytes
  bridgedAmt: BigInt
  bridgedAmt_not: BigInt
  bridgedAmt_gt: BigInt
  bridgedAmt_lt: BigInt
  bridgedAmt_gte: BigInt
  bridgedAmt_lte: BigInt
  bridgedAmt_in: [BigInt!]
  bridgedAmt_not_in: [BigInt!]
  normalizedIn: BigInt
  normalizedIn_not: BigInt
  normalizedIn_gt: BigInt
  normalizedIn_lt: BigInt
  normalizedIn_gte: BigInt
  normalizedIn_lte: BigInt
  normalizedIn_in: [BigInt!]
  normalizedIn_not_in: [BigInt!]
  canonicalId: polygon_Bytes
  canonicalId_not: polygon_Bytes
  canonicalId_gt: polygon_Bytes
  canonicalId_lt: polygon_Bytes
  canonicalId_gte: polygon_Bytes
  canonicalId_lte: polygon_Bytes
  canonicalId_in: [polygon_Bytes!]
  canonicalId_not_in: [polygon_Bytes!]
  canonicalId_contains: polygon_Bytes
  canonicalId_not_contains: polygon_Bytes
  asset: String
  asset_not: String
  asset_gt: String
  asset_lt: String
  asset_gte: String
  asset_lte: String
  asset_in: [String!]
  asset_not_in: [String!]
  asset_contains: String
  asset_contains_nocase: String
  asset_not_contains: String
  asset_not_contains_nocase: String
  asset_starts_with: String
  asset_starts_with_nocase: String
  asset_not_starts_with: String
  asset_not_starts_with_nocase: String
  asset_ends_with: String
  asset_ends_with_nocase: String
  asset_not_ends_with: String
  asset_not_ends_with_nocase: String
  asset_: polygon_Asset_filter
  transactingAsset: polygon_Bytes
  transactingAsset_not: polygon_Bytes
  transactingAsset_gt: polygon_Bytes
  transactingAsset_lt: polygon_Bytes
  transactingAsset_gte: polygon_Bytes
  transactingAsset_lte: polygon_Bytes
  transactingAsset_in: [polygon_Bytes!]
  transactingAsset_not_in: [polygon_Bytes!]
  transactingAsset_contains: polygon_Bytes
  transactingAsset_not_contains: polygon_Bytes
  message: String
  message_not: String
  message_gt: String
  message_lt: String
  message_gte: String
  message_lte: String
  message_in: [String!]
  message_not_in: [String!]
  message_contains: String
  message_contains_nocase: String
  message_not_contains: String
  message_not_contains_nocase: String
  message_starts_with: String
  message_starts_with_nocase: String
  message_not_starts_with: String
  message_not_starts_with_nocase: String
  message_ends_with: String
  message_ends_with_nocase: String
  message_not_ends_with: String
  message_not_ends_with_nocase: String
  message_: polygon_OriginMessage_filter
  bumpRelayerFeeCount: BigInt
  bumpRelayerFeeCount_not: BigInt
  bumpRelayerFeeCount_gt: BigInt
  bumpRelayerFeeCount_lt: BigInt
  bumpRelayerFeeCount_gte: BigInt
  bumpRelayerFeeCount_lte: BigInt
  bumpRelayerFeeCount_in: [BigInt!]
  bumpRelayerFeeCount_not_in: [BigInt!]
  relayerFees: [String!]
  relayerFees_not: [String!]
  relayerFees_contains: [String!]
  relayerFees_contains_nocase: [String!]
  relayerFees_not_contains: [String!]
  relayerFees_not_contains_nocase: [String!]
  relayerFees_: polygon_RelayerFee_filter
  initialRelayerFeeAsset: polygon_Bytes
  initialRelayerFeeAsset_not: polygon_Bytes
  initialRelayerFeeAsset_gt: polygon_Bytes
  initialRelayerFeeAsset_lt: polygon_Bytes
  initialRelayerFeeAsset_gte: polygon_Bytes
  initialRelayerFeeAsset_lte: polygon_Bytes
  initialRelayerFeeAsset_in: [polygon_Bytes!]
  initialRelayerFeeAsset_not_in: [polygon_Bytes!]
  initialRelayerFeeAsset_contains: polygon_Bytes
  initialRelayerFeeAsset_not_contains: polygon_Bytes
  caller: polygon_Bytes
  caller_not: polygon_Bytes
  caller_gt: polygon_Bytes
  caller_lt: polygon_Bytes
  caller_gte: polygon_Bytes
  caller_lte: polygon_Bytes
  caller_in: [polygon_Bytes!]
  caller_not_in: [polygon_Bytes!]
  caller_contains: polygon_Bytes
  caller_not_contains: polygon_Bytes
  transactionHash: polygon_Bytes
  transactionHash_not: polygon_Bytes
  transactionHash_gt: polygon_Bytes
  transactionHash_lt: polygon_Bytes
  transactionHash_gte: polygon_Bytes
  transactionHash_lte: polygon_Bytes
  transactionHash_in: [polygon_Bytes!]
  transactionHash_not_in: [polygon_Bytes!]
  transactionHash_contains: polygon_Bytes
  transactionHash_not_contains: polygon_Bytes
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  gasLimit: BigInt
  gasLimit_not: BigInt
  gasLimit_gt: BigInt
  gasLimit_lt: BigInt
  gasLimit_gte: BigInt
  gasLimit_lte: BigInt
  gasLimit_in: [BigInt!]
  gasLimit_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  txOrigin: polygon_Bytes
  txOrigin_not: polygon_Bytes
  txOrigin_gt: polygon_Bytes
  txOrigin_lt: polygon_Bytes
  txOrigin_gte: polygon_Bytes
  txOrigin_lte: polygon_Bytes
  txOrigin_in: [polygon_Bytes!]
  txOrigin_not_in: [polygon_Bytes!]
  txOrigin_contains: polygon_Bytes
  txOrigin_not_contains: polygon_Bytes
  txNonce: BigInt
  txNonce_not: BigInt
  txNonce_gt: BigInt
  txNonce_lt: BigInt
  txNonce_gte: BigInt
  txNonce_lte: BigInt
  txNonce_in: [BigInt!]
  txNonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: polygon_BlockChangedFilter
  and: [polygon_OriginTransfer_filter]
  or: [polygon_OriginTransfer_filter]
}

enum polygon_OriginTransfer_orderBy {
  id
  chainId
  transferId
  nonce
  status
  messageHash
  originDomain
  destinationDomain
  canonicalDomain
  to
  delegate
  receiveLocal
  callData
  slippage
  originSender
  bridgedAmt
  normalizedIn
  canonicalId
  asset
  asset__id
  asset__key
  asset__decimal
  asset__adoptedDecimal
  asset__canonicalId
  asset__canonicalDomain
  asset__adoptedAsset
  asset__localAsset
  asset__blockNumber
  transactingAsset
  message
  message__id
  message__transferId
  message__destinationDomain
  message__leaf
  message__index
  message__message
  message__root
  message__transactionHash
  message__blockNumber
  bumpRelayerFeeCount
  relayerFees
  initialRelayerFeeAsset
  caller
  transactionHash
  timestamp
  gasPrice
  gasLimit
  blockNumber
  txOrigin
  txNonce
}

type polygon_Relayer {
  id: ID!
  isActive: Boolean!
  relayer: polygon_Bytes
}

type polygon_RelayerFee {
  id: ID!
  transfer: polygon_OriginTransfer!
  fee: BigInt!
  asset: polygon_Bytes!
}

input polygon_RelayerFee_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transfer: String
  transfer_not: String
  transfer_gt: String
  transfer_lt: String
  transfer_gte: String
  transfer_lte: String
  transfer_in: [String!]
  transfer_not_in: [String!]
  transfer_contains: String
  transfer_contains_nocase: String
  transfer_not_contains: String
  transfer_not_contains_nocase: String
  transfer_starts_with: String
  transfer_starts_with_nocase: String
  transfer_not_starts_with: String
  transfer_not_starts_with_nocase: String
  transfer_ends_with: String
  transfer_ends_with_nocase: String
  transfer_not_ends_with: String
  transfer_not_ends_with_nocase: String
  transfer_: polygon_OriginTransfer_filter
  fee: BigInt
  fee_not: BigInt
  fee_gt: BigInt
  fee_lt: BigInt
  fee_gte: BigInt
  fee_lte: BigInt
  fee_in: [BigInt!]
  fee_not_in: [BigInt!]
  asset: polygon_Bytes
  asset_not: polygon_Bytes
  asset_gt: polygon_Bytes
  asset_lt: polygon_Bytes
  asset_gte: polygon_Bytes
  asset_lte: polygon_Bytes
  asset_in: [polygon_Bytes!]
  asset_not_in: [polygon_Bytes!]
  asset_contains: polygon_Bytes
  asset_not_contains: polygon_Bytes
  """Filter for the block changed event."""
  _change_block: polygon_BlockChangedFilter
  and: [polygon_RelayerFee_filter]
  or: [polygon_RelayerFee_filter]
}

enum polygon_RelayerFee_orderBy {
  id
  transfer
  transfer__id
  transfer__chainId
  transfer__transferId
  transfer__nonce
  transfer__status
  transfer__messageHash
  transfer__originDomain
  transfer__destinationDomain
  transfer__canonicalDomain
  transfer__to
  transfer__delegate
  transfer__receiveLocal
  transfer__callData
  transfer__slippage
  transfer__originSender
  transfer__bridgedAmt
  transfer__normalizedIn
  transfer__canonicalId
  transfer__transactingAsset
  transfer__bumpRelayerFeeCount
  transfer__initialRelayerFeeAsset
  transfer__caller
  transfer__transactionHash
  transfer__timestamp
  transfer__gasPrice
  transfer__gasLimit
  transfer__blockNumber
  transfer__txOrigin
  transfer__txNonce
  fee
  asset
}

type polygon_RelayerFeesIncrease {
  id: ID!
  transfer: polygon_OriginTransfer!
  increase: BigInt
  asset: polygon_Bytes
  caller: polygon_Bytes!
  transactionHash: polygon_Bytes!
  timestamp: BigInt!
  gasPrice: BigInt!
  gasLimit: BigInt!
  blockNumber: BigInt!
}

input polygon_RelayerFeesIncrease_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transfer: String
  transfer_not: String
  transfer_gt: String
  transfer_lt: String
  transfer_gte: String
  transfer_lte: String
  transfer_in: [String!]
  transfer_not_in: [String!]
  transfer_contains: String
  transfer_contains_nocase: String
  transfer_not_contains: String
  transfer_not_contains_nocase: String
  transfer_starts_with: String
  transfer_starts_with_nocase: String
  transfer_not_starts_with: String
  transfer_not_starts_with_nocase: String
  transfer_ends_with: String
  transfer_ends_with_nocase: String
  transfer_not_ends_with: String
  transfer_not_ends_with_nocase: String
  transfer_: polygon_OriginTransfer_filter
  increase: BigInt
  increase_not: BigInt
  increase_gt: BigInt
  increase_lt: BigInt
  increase_gte: BigInt
  increase_lte: BigInt
  increase_in: [BigInt!]
  increase_not_in: [BigInt!]
  asset: polygon_Bytes
  asset_not: polygon_Bytes
  asset_gt: polygon_Bytes
  asset_lt: polygon_Bytes
  asset_gte: polygon_Bytes
  asset_lte: polygon_Bytes
  asset_in: [polygon_Bytes!]
  asset_not_in: [polygon_Bytes!]
  asset_contains: polygon_Bytes
  asset_not_contains: polygon_Bytes
  caller: polygon_Bytes
  caller_not: polygon_Bytes
  caller_gt: polygon_Bytes
  caller_lt: polygon_Bytes
  caller_gte: polygon_Bytes
  caller_lte: polygon_Bytes
  caller_in: [polygon_Bytes!]
  caller_not_in: [polygon_Bytes!]
  caller_contains: polygon_Bytes
  caller_not_contains: polygon_Bytes
  transactionHash: polygon_Bytes
  transactionHash_not: polygon_Bytes
  transactionHash_gt: polygon_Bytes
  transactionHash_lt: polygon_Bytes
  transactionHash_gte: polygon_Bytes
  transactionHash_lte: polygon_Bytes
  transactionHash_in: [polygon_Bytes!]
  transactionHash_not_in: [polygon_Bytes!]
  transactionHash_contains: polygon_Bytes
  transactionHash_not_contains: polygon_Bytes
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  gasLimit: BigInt
  gasLimit_not: BigInt
  gasLimit_gt: BigInt
  gasLimit_lt: BigInt
  gasLimit_gte: BigInt
  gasLimit_lte: BigInt
  gasLimit_in: [BigInt!]
  gasLimit_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: polygon_BlockChangedFilter
  and: [polygon_RelayerFeesIncrease_filter]
  or: [polygon_RelayerFeesIncrease_filter]
}

enum polygon_RelayerFeesIncrease_orderBy {
  id
  transfer
  transfer__id
  transfer__chainId
  transfer__transferId
  transfer__nonce
  transfer__status
  transfer__messageHash
  transfer__originDomain
  transfer__destinationDomain
  transfer__canonicalDomain
  transfer__to
  transfer__delegate
  transfer__receiveLocal
  transfer__callData
  transfer__slippage
  transfer__originSender
  transfer__bridgedAmt
  transfer__normalizedIn
  transfer__canonicalId
  transfer__transactingAsset
  transfer__bumpRelayerFeeCount
  transfer__initialRelayerFeeAsset
  transfer__caller
  transfer__transactionHash
  transfer__timestamp
  transfer__gasPrice
  transfer__gasLimit
  transfer__blockNumber
  transfer__txOrigin
  transfer__txNonce
  increase
  asset
  caller
  transactionHash
  timestamp
  gasPrice
  gasLimit
  blockNumber
}

input polygon_Relayer_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  isActive: Boolean
  isActive_not: Boolean
  isActive_in: [Boolean!]
  isActive_not_in: [Boolean!]
  relayer: polygon_Bytes
  relayer_not: polygon_Bytes
  relayer_gt: polygon_Bytes
  relayer_lt: polygon_Bytes
  relayer_gte: polygon_Bytes
  relayer_lte: polygon_Bytes
  relayer_in: [polygon_Bytes!]
  relayer_not_in: [polygon_Bytes!]
  relayer_contains: polygon_Bytes
  relayer_not_contains: polygon_Bytes
  """Filter for the block changed event."""
  _change_block: polygon_BlockChangedFilter
  and: [polygon_Relayer_filter]
  or: [polygon_Relayer_filter]
}

enum polygon_Relayer_orderBy {
  id
  isActive
  relayer
}

type polygon_RootCount {
  id: ID!
  count: BigInt
}

input polygon_RootCount_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  count: BigInt
  count_not: BigInt
  count_gt: BigInt
  count_lt: BigInt
  count_gte: BigInt
  count_lte: BigInt
  count_in: [BigInt!]
  count_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: polygon_BlockChangedFilter
  and: [polygon_RootCount_filter]
  or: [polygon_RootCount_filter]
}

enum polygon_RootCount_orderBy {
  id
  count
}

type polygon_RootMessageSent {
  id: ID!
  spokeDomain: BigInt
  hubDomain: BigInt
  root: polygon_Bytes
  count: BigInt
  caller: polygon_Bytes
  transactionHash: polygon_Bytes
  timestamp: BigInt
  gasPrice: BigInt
  gasLimit: BigInt
  blockNumber: BigInt
}

input polygon_RootMessageSent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  spokeDomain: BigInt
  spokeDomain_not: BigInt
  spokeDomain_gt: BigInt
  spokeDomain_lt: BigInt
  spokeDomain_gte: BigInt
  spokeDomain_lte: BigInt
  spokeDomain_in: [BigInt!]
  spokeDomain_not_in: [BigInt!]
  hubDomain: BigInt
  hubDomain_not: BigInt
  hubDomain_gt: BigInt
  hubDomain_lt: BigInt
  hubDomain_gte: BigInt
  hubDomain_lte: BigInt
  hubDomain_in: [BigInt!]
  hubDomain_not_in: [BigInt!]
  root: polygon_Bytes
  root_not: polygon_Bytes
  root_gt: polygon_Bytes
  root_lt: polygon_Bytes
  root_gte: polygon_Bytes
  root_lte: polygon_Bytes
  root_in: [polygon_Bytes!]
  root_not_in: [polygon_Bytes!]
  root_contains: polygon_Bytes
  root_not_contains: polygon_Bytes
  count: BigInt
  count_not: BigInt
  count_gt: BigInt
  count_lt: BigInt
  count_gte: BigInt
  count_lte: BigInt
  count_in: [BigInt!]
  count_not_in: [BigInt!]
  caller: polygon_Bytes
  caller_not: polygon_Bytes
  caller_gt: polygon_Bytes
  caller_lt: polygon_Bytes
  caller_gte: polygon_Bytes
  caller_lte: polygon_Bytes
  caller_in: [polygon_Bytes!]
  caller_not_in: [polygon_Bytes!]
  caller_contains: polygon_Bytes
  caller_not_contains: polygon_Bytes
  transactionHash: polygon_Bytes
  transactionHash_not: polygon_Bytes
  transactionHash_gt: polygon_Bytes
  transactionHash_lt: polygon_Bytes
  transactionHash_gte: polygon_Bytes
  transactionHash_lte: polygon_Bytes
  transactionHash_in: [polygon_Bytes!]
  transactionHash_not_in: [polygon_Bytes!]
  transactionHash_contains: polygon_Bytes
  transactionHash_not_contains: polygon_Bytes
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  gasLimit: BigInt
  gasLimit_not: BigInt
  gasLimit_gt: BigInt
  gasLimit_lt: BigInt
  gasLimit_gte: BigInt
  gasLimit_lte: BigInt
  gasLimit_in: [BigInt!]
  gasLimit_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: polygon_BlockChangedFilter
  and: [polygon_RootMessageSent_filter]
  or: [polygon_RootMessageSent_filter]
}

enum polygon_RootMessageSent_orderBy {
  id
  spokeDomain
  hubDomain
  root
  count
  caller
  transactionHash
  timestamp
  gasPrice
  gasLimit
  blockNumber
}

type polygon_Router {
  id: ID!
  isActive: Boolean!
  owner: polygon_Bytes
  recipient: polygon_Bytes
  proposedOwner: polygon_Bytes
  proposedTimestamp: BigInt
  assetBalances(skip: Int = 0, first: Int = 100, orderBy: polygon_AssetBalance_orderBy, orderDirection: polygon_OrderDirection, where: polygon_AssetBalance_filter): [polygon_AssetBalance!]!
}

type polygon_RouterDailyTVL {
  id: ID!
  router: polygon_Router!
  asset: polygon_Asset!
  timestamp: BigInt!
  balance: BigInt!
}

input polygon_RouterDailyTVL_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  router: String
  router_not: String
  router_gt: String
  router_lt: String
  router_gte: String
  router_lte: String
  router_in: [String!]
  router_not_in: [String!]
  router_contains: String
  router_contains_nocase: String
  router_not_contains: String
  router_not_contains_nocase: String
  router_starts_with: String
  router_starts_with_nocase: String
  router_not_starts_with: String
  router_not_starts_with_nocase: String
  router_ends_with: String
  router_ends_with_nocase: String
  router_not_ends_with: String
  router_not_ends_with_nocase: String
  router_: polygon_Router_filter
  asset: String
  asset_not: String
  asset_gt: String
  asset_lt: String
  asset_gte: String
  asset_lte: String
  asset_in: [String!]
  asset_not_in: [String!]
  asset_contains: String
  asset_contains_nocase: String
  asset_not_contains: String
  asset_not_contains_nocase: String
  asset_starts_with: String
  asset_starts_with_nocase: String
  asset_not_starts_with: String
  asset_not_starts_with_nocase: String
  asset_ends_with: String
  asset_ends_with_nocase: String
  asset_not_ends_with: String
  asset_not_ends_with_nocase: String
  asset_: polygon_Asset_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  balance: BigInt
  balance_not: BigInt
  balance_gt: BigInt
  balance_lt: BigInt
  balance_gte: BigInt
  balance_lte: BigInt
  balance_in: [BigInt!]
  balance_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: polygon_BlockChangedFilter
  and: [polygon_RouterDailyTVL_filter]
  or: [polygon_RouterDailyTVL_filter]
}

enum polygon_RouterDailyTVL_orderBy {
  id
  router
  router__id
  router__isActive
  router__owner
  router__recipient
  router__proposedOwner
  router__proposedTimestamp
  asset
  asset__id
  asset__key
  asset__decimal
  asset__adoptedDecimal
  asset__canonicalId
  asset__canonicalDomain
  asset__adoptedAsset
  asset__localAsset
  asset__blockNumber
  timestamp
  balance
}

type polygon_RouterLiquidityEvent {
  id: ID!
  type: polygon_RouterLiquidityEventType
  router: polygon_Router!
  asset: polygon_Asset!
  amount: BigInt!
  balance: BigInt!
  caller: polygon_Bytes
  blockNumber: BigInt!
  timestamp: BigInt!
  transactionHash: polygon_Bytes!
  nonce: BigInt!
}

enum polygon_RouterLiquidityEventType {
  Add
  Remove
}

input polygon_RouterLiquidityEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  type: polygon_RouterLiquidityEventType
  type_not: polygon_RouterLiquidityEventType
  type_in: [polygon_RouterLiquidityEventType!]
  type_not_in: [polygon_RouterLiquidityEventType!]
  router: String
  router_not: String
  router_gt: String
  router_lt: String
  router_gte: String
  router_lte: String
  router_in: [String!]
  router_not_in: [String!]
  router_contains: String
  router_contains_nocase: String
  router_not_contains: String
  router_not_contains_nocase: String
  router_starts_with: String
  router_starts_with_nocase: String
  router_not_starts_with: String
  router_not_starts_with_nocase: String
  router_ends_with: String
  router_ends_with_nocase: String
  router_not_ends_with: String
  router_not_ends_with_nocase: String
  router_: polygon_Router_filter
  asset: String
  asset_not: String
  asset_gt: String
  asset_lt: String
  asset_gte: String
  asset_lte: String
  asset_in: [String!]
  asset_not_in: [String!]
  asset_contains: String
  asset_contains_nocase: String
  asset_not_contains: String
  asset_not_contains_nocase: String
  asset_starts_with: String
  asset_starts_with_nocase: String
  asset_not_starts_with: String
  asset_not_starts_with_nocase: String
  asset_ends_with: String
  asset_ends_with_nocase: String
  asset_not_ends_with: String
  asset_not_ends_with_nocase: String
  asset_: polygon_Asset_filter
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  balance: BigInt
  balance_not: BigInt
  balance_gt: BigInt
  balance_lt: BigInt
  balance_gte: BigInt
  balance_lte: BigInt
  balance_in: [BigInt!]
  balance_not_in: [BigInt!]
  caller: polygon_Bytes
  caller_not: polygon_Bytes
  caller_gt: polygon_Bytes
  caller_lt: polygon_Bytes
  caller_gte: polygon_Bytes
  caller_lte: polygon_Bytes
  caller_in: [polygon_Bytes!]
  caller_not_in: [polygon_Bytes!]
  caller_contains: polygon_Bytes
  caller_not_contains: polygon_Bytes
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transactionHash: polygon_Bytes
  transactionHash_not: polygon_Bytes
  transactionHash_gt: polygon_Bytes
  transactionHash_lt: polygon_Bytes
  transactionHash_gte: polygon_Bytes
  transactionHash_lte: polygon_Bytes
  transactionHash_in: [polygon_Bytes!]
  transactionHash_not_in: [polygon_Bytes!]
  transactionHash_contains: polygon_Bytes
  transactionHash_not_contains: polygon_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: polygon_BlockChangedFilter
  and: [polygon_RouterLiquidityEvent_filter]
  or: [polygon_RouterLiquidityEvent_filter]
}

enum polygon_RouterLiquidityEvent_orderBy {
  id
  type
  router
  router__id
  router__isActive
  router__owner
  router__recipient
  router__proposedOwner
  router__proposedTimestamp
  asset
  asset__id
  asset__key
  asset__decimal
  asset__adoptedDecimal
  asset__canonicalId
  asset__canonicalDomain
  asset__adoptedAsset
  asset__localAsset
  asset__blockNumber
  amount
  balance
  caller
  blockNumber
  timestamp
  transactionHash
  nonce
}

input polygon_Router_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  isActive: Boolean
  isActive_not: Boolean
  isActive_in: [Boolean!]
  isActive_not_in: [Boolean!]
  owner: polygon_Bytes
  owner_not: polygon_Bytes
  owner_gt: polygon_Bytes
  owner_lt: polygon_Bytes
  owner_gte: polygon_Bytes
  owner_lte: polygon_Bytes
  owner_in: [polygon_Bytes!]
  owner_not_in: [polygon_Bytes!]
  owner_contains: polygon_Bytes
  owner_not_contains: polygon_Bytes
  recipient: polygon_Bytes
  recipient_not: polygon_Bytes
  recipient_gt: polygon_Bytes
  recipient_lt: polygon_Bytes
  recipient_gte: polygon_Bytes
  recipient_lte: polygon_Bytes
  recipient_in: [polygon_Bytes!]
  recipient_not_in: [polygon_Bytes!]
  recipient_contains: polygon_Bytes
  recipient_not_contains: polygon_Bytes
  proposedOwner: polygon_Bytes
  proposedOwner_not: polygon_Bytes
  proposedOwner_gt: polygon_Bytes
  proposedOwner_lt: polygon_Bytes
  proposedOwner_gte: polygon_Bytes
  proposedOwner_lte: polygon_Bytes
  proposedOwner_in: [polygon_Bytes!]
  proposedOwner_not_in: [polygon_Bytes!]
  proposedOwner_contains: polygon_Bytes
  proposedOwner_not_contains: polygon_Bytes
  proposedTimestamp: BigInt
  proposedTimestamp_not: BigInt
  proposedTimestamp_gt: BigInt
  proposedTimestamp_lt: BigInt
  proposedTimestamp_gte: BigInt
  proposedTimestamp_lte: BigInt
  proposedTimestamp_in: [BigInt!]
  proposedTimestamp_not_in: [BigInt!]
  assetBalances_: polygon_AssetBalance_filter
  """Filter for the block changed event."""
  _change_block: polygon_BlockChangedFilter
  and: [polygon_Router_filter]
  or: [polygon_Router_filter]
}

enum polygon_Router_orderBy {
  id
  isActive
  owner
  recipient
  proposedOwner
  proposedTimestamp
  assetBalances
}

type polygon_Sequencer {
  id: ID!
  isActive: Boolean!
  sequencer: polygon_Bytes
}

input polygon_Sequencer_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  isActive: Boolean
  isActive_not: Boolean
  isActive_in: [Boolean!]
  isActive_not_in: [Boolean!]
  sequencer: polygon_Bytes
  sequencer_not: polygon_Bytes
  sequencer_gt: polygon_Bytes
  sequencer_lt: polygon_Bytes
  sequencer_gte: polygon_Bytes
  sequencer_lte: polygon_Bytes
  sequencer_in: [polygon_Bytes!]
  sequencer_not_in: [polygon_Bytes!]
  sequencer_contains: polygon_Bytes
  sequencer_not_contains: polygon_Bytes
  """Filter for the block changed event."""
  _change_block: polygon_BlockChangedFilter
  and: [polygon_Sequencer_filter]
  or: [polygon_Sequencer_filter]
}

enum polygon_Sequencer_orderBy {
  id
  isActive
  sequencer
}

type polygon_Setting {
  id: ID!
  maxRoutersPerTransfer: BigInt!
  caller: polygon_Bytes!
}

input polygon_Setting_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  maxRoutersPerTransfer: BigInt
  maxRoutersPerTransfer_not: BigInt
  maxRoutersPerTransfer_gt: BigInt
  maxRoutersPerTransfer_lt: BigInt
  maxRoutersPerTransfer_gte: BigInt
  maxRoutersPerTransfer_lte: BigInt
  maxRoutersPerTransfer_in: [BigInt!]
  maxRoutersPerTransfer_not_in: [BigInt!]
  caller: polygon_Bytes
  caller_not: polygon_Bytes
  caller_gt: polygon_Bytes
  caller_lt: polygon_Bytes
  caller_gte: polygon_Bytes
  caller_lte: polygon_Bytes
  caller_in: [polygon_Bytes!]
  caller_not_in: [polygon_Bytes!]
  caller_contains: polygon_Bytes
  caller_not_contains: polygon_Bytes
  """Filter for the block changed event."""
  _change_block: polygon_BlockChangedFilter
  and: [polygon_Setting_filter]
  or: [polygon_Setting_filter]
}

enum polygon_Setting_orderBy {
  id
  maxRoutersPerTransfer
  caller
}

type polygon_SlippageUpdate {
  id: ID!
  transfer: polygon_DestinationTransfer!
  slippage: BigInt!
  caller: polygon_Bytes!
  transactionHash: polygon_Bytes!
  timestamp: BigInt!
  gasPrice: BigInt!
  gasLimit: BigInt!
  blockNumber: BigInt!
}

input polygon_SlippageUpdate_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transfer: String
  transfer_not: String
  transfer_gt: String
  transfer_lt: String
  transfer_gte: String
  transfer_lte: String
  transfer_in: [String!]
  transfer_not_in: [String!]
  transfer_contains: String
  transfer_contains_nocase: String
  transfer_not_contains: String
  transfer_not_contains_nocase: String
  transfer_starts_with: String
  transfer_starts_with_nocase: String
  transfer_not_starts_with: String
  transfer_not_starts_with_nocase: String
  transfer_ends_with: String
  transfer_ends_with_nocase: String
  transfer_not_ends_with: String
  transfer_not_ends_with_nocase: String
  transfer_: polygon_DestinationTransfer_filter
  slippage: BigInt
  slippage_not: BigInt
  slippage_gt: BigInt
  slippage_lt: BigInt
  slippage_gte: BigInt
  slippage_lte: BigInt
  slippage_in: [BigInt!]
  slippage_not_in: [BigInt!]
  caller: polygon_Bytes
  caller_not: polygon_Bytes
  caller_gt: polygon_Bytes
  caller_lt: polygon_Bytes
  caller_gte: polygon_Bytes
  caller_lte: polygon_Bytes
  caller_in: [polygon_Bytes!]
  caller_not_in: [polygon_Bytes!]
  caller_contains: polygon_Bytes
  caller_not_contains: polygon_Bytes
  transactionHash: polygon_Bytes
  transactionHash_not: polygon_Bytes
  transactionHash_gt: polygon_Bytes
  transactionHash_lt: polygon_Bytes
  transactionHash_gte: polygon_Bytes
  transactionHash_lte: polygon_Bytes
  transactionHash_in: [polygon_Bytes!]
  transactionHash_not_in: [polygon_Bytes!]
  transactionHash_contains: polygon_Bytes
  transactionHash_not_contains: polygon_Bytes
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  gasLimit: BigInt
  gasLimit_not: BigInt
  gasLimit_gt: BigInt
  gasLimit_lt: BigInt
  gasLimit_gte: BigInt
  gasLimit_lte: BigInt
  gasLimit_in: [BigInt!]
  gasLimit_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: polygon_BlockChangedFilter
  and: [polygon_SlippageUpdate_filter]
  or: [polygon_SlippageUpdate_filter]
}

enum polygon_SlippageUpdate_orderBy {
  id
  transfer
  transfer__id
  transfer__chainId
  transfer__transferId
  transfer__nonce
  transfer__status
  transfer__originDomain
  transfer__destinationDomain
  transfer__canonicalDomain
  transfer__to
  transfer__delegate
  transfer__receiveLocal
  transfer__callData
  transfer__slippage
  transfer__bumpSlippageCount
  transfer__originSender
  transfer__bridgedAmt
  transfer__normalizedIn
  transfer__canonicalId
  transfer__amount
  transfer__routersFee
  transfer__executedCaller
  transfer__executedTransactionHash
  transfer__executedTimestamp
  transfer__executedGasPrice
  transfer__executedGasLimit
  transfer__executedBlockNumber
  transfer__executedTxOrigin
  transfer__executedTxNonce
  transfer__reconciledCaller
  transfer__reconciledTransactionHash
  transfer__reconciledTimestamp
  transfer__reconciledGasPrice
  transfer__reconciledGasLimit
  transfer__reconciledBlockNumber
  transfer__reconciledTxOrigin
  transfer__reconciledTxNonce
  slippage
  caller
  transactionHash
  timestamp
  gasPrice
  gasLimit
  blockNumber
}

type polygon_SnapshotRoot {
  id: ID!
  spokeDomain: BigInt
  root: polygon_Bytes!
  count: BigInt!
  timestamp: BigInt!
  blockNumber: BigInt!
}

input polygon_SnapshotRoot_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  spokeDomain: BigInt
  spokeDomain_not: BigInt
  spokeDomain_gt: BigInt
  spokeDomain_lt: BigInt
  spokeDomain_gte: BigInt
  spokeDomain_lte: BigInt
  spokeDomain_in: [BigInt!]
  spokeDomain_not_in: [BigInt!]
  root: polygon_Bytes
  root_not: polygon_Bytes
  root_gt: polygon_Bytes
  root_lt: polygon_Bytes
  root_gte: polygon_Bytes
  root_lte: polygon_Bytes
  root_in: [polygon_Bytes!]
  root_not_in: [polygon_Bytes!]
  root_contains: polygon_Bytes
  root_not_contains: polygon_Bytes
  count: BigInt
  count_not: BigInt
  count_gt: BigInt
  count_lt: BigInt
  count_gte: BigInt
  count_lte: BigInt
  count_in: [BigInt!]
  count_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: polygon_BlockChangedFilter
  and: [polygon_SnapshotRoot_filter]
  or: [polygon_SnapshotRoot_filter]
}

enum polygon_SnapshotRoot_orderBy {
  id
  spokeDomain
  root
  count
  timestamp
  blockNumber
}

type polygon_SpokeConnectorMode {
  id: ID!
  mode: String!
}

input polygon_SpokeConnectorMode_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  mode: String
  mode_not: String
  mode_gt: String
  mode_lt: String
  mode_gte: String
  mode_lte: String
  mode_in: [String!]
  mode_not_in: [String!]
  mode_contains: String
  mode_contains_nocase: String
  mode_not_contains: String
  mode_not_contains_nocase: String
  mode_starts_with: String
  mode_starts_with_nocase: String
  mode_not_starts_with: String
  mode_not_starts_with_nocase: String
  mode_ends_with: String
  mode_ends_with_nocase: String
  mode_not_ends_with: String
  mode_not_ends_with_nocase: String
  """Filter for the block changed event."""
  _change_block: polygon_BlockChangedFilter
  and: [polygon_SpokeConnectorMode_filter]
  or: [polygon_SpokeConnectorMode_filter]
}

enum polygon_SpokeConnectorMode_orderBy {
  id
  mode
}

enum polygon_TransferStatus {
  XCalled
  Executed
  Reconciled
  CompletedSlow
  CompletedFast
}

type polygon__Block_ {
  """The hash of the block"""
  hash: polygon_Bytes
  """The block number"""
  number: Int!
  """Integer representation of the timestamp stored in blocks for the chain"""
  timestamp: Int
  """The hash of the parent block"""
  parentHash: polygon_Bytes
}

"""The type for the top-level _meta field"""
type polygon__Meta_ {
  """
  Information about a specific subgraph block. The hash of the block
  will be null if the _meta field has a block constraint that asks for
  a block number. It will be filled if the _meta field has no block constraint
  and therefore asks for the latest  block
  
  """
  block: polygon__Block_!
  """The deployment ID"""
  deployment: String!
  """If `true`, the subgraph encountered indexing errors at some past block"""
  hasIndexingErrors: Boolean!
}

type polygonzkevm_swap_AggregateRoot {
  id: ID!
  root: polygonzkevm_swap_Bytes!
  blockNumber: BigInt!
}

type polygonzkevm_swap_AggregateRootProposed {
  id: ID!
  aggregateRoot: polygonzkevm_swap_Bytes!
  rootTimestamp: BigInt!
  endOfDispute: BigInt!
  domain: BigInt!
  timestamp: BigInt!
  blockNumber: BigInt
}

input polygonzkevm_swap_AggregateRootProposed_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  aggregateRoot: polygonzkevm_swap_Bytes
  aggregateRoot_not: polygonzkevm_swap_Bytes
  aggregateRoot_gt: polygonzkevm_swap_Bytes
  aggregateRoot_lt: polygonzkevm_swap_Bytes
  aggregateRoot_gte: polygonzkevm_swap_Bytes
  aggregateRoot_lte: polygonzkevm_swap_Bytes
  aggregateRoot_in: [polygonzkevm_swap_Bytes!]
  aggregateRoot_not_in: [polygonzkevm_swap_Bytes!]
  aggregateRoot_contains: polygonzkevm_swap_Bytes
  aggregateRoot_not_contains: polygonzkevm_swap_Bytes
  rootTimestamp: BigInt
  rootTimestamp_not: BigInt
  rootTimestamp_gt: BigInt
  rootTimestamp_lt: BigInt
  rootTimestamp_gte: BigInt
  rootTimestamp_lte: BigInt
  rootTimestamp_in: [BigInt!]
  rootTimestamp_not_in: [BigInt!]
  endOfDispute: BigInt
  endOfDispute_not: BigInt
  endOfDispute_gt: BigInt
  endOfDispute_lt: BigInt
  endOfDispute_gte: BigInt
  endOfDispute_lte: BigInt
  endOfDispute_in: [BigInt!]
  endOfDispute_not_in: [BigInt!]
  domain: BigInt
  domain_not: BigInt
  domain_gt: BigInt
  domain_lt: BigInt
  domain_gte: BigInt
  domain_lte: BigInt
  domain_in: [BigInt!]
  domain_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: polygonzkevm_swap_BlockChangedFilter
  and: [polygonzkevm_swap_AggregateRootProposed_filter]
  or: [polygonzkevm_swap_AggregateRootProposed_filter]
}

enum polygonzkevm_swap_AggregateRootProposed_orderBy {
  id
  aggregateRoot
  rootTimestamp
  endOfDispute
  domain
  timestamp
  blockNumber
}

input polygonzkevm_swap_AggregateRoot_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  root: polygonzkevm_swap_Bytes
  root_not: polygonzkevm_swap_Bytes
  root_gt: polygonzkevm_swap_Bytes
  root_lt: polygonzkevm_swap_Bytes
  root_gte: polygonzkevm_swap_Bytes
  root_lte: polygonzkevm_swap_Bytes
  root_in: [polygonzkevm_swap_Bytes!]
  root_not_in: [polygonzkevm_swap_Bytes!]
  root_contains: polygonzkevm_swap_Bytes
  root_not_contains: polygonzkevm_swap_Bytes
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: polygonzkevm_swap_BlockChangedFilter
  and: [polygonzkevm_swap_AggregateRoot_filter]
  or: [polygonzkevm_swap_AggregateRoot_filter]
}

enum polygonzkevm_swap_AggregateRoot_orderBy {
  id
  root
  blockNumber
}

enum polygonzkevm_swap_Aggregation_interval {
  hour
  day
}

type polygonzkevm_swap_Asset {
  id: ID!
  key: polygonzkevm_swap_Bytes
  decimal: BigInt
  adoptedDecimal: BigInt
  canonicalId: polygonzkevm_swap_Bytes
  canonicalDomain: BigInt
  adoptedAsset: polygonzkevm_swap_Bytes
  localAsset: polygonzkevm_swap_Bytes
  blockNumber: BigInt
  status: polygonzkevm_swap_AssetStatus
}

type polygonzkevm_swap_AssetBalance {
  id: ID!
  amount: BigInt!
  locked: BigInt!
  supplied: BigInt!
  removed: BigInt!
  router: polygonzkevm_swap_Router!
  asset: polygonzkevm_swap_Asset!
  feesEarned: BigInt!
}

input polygonzkevm_swap_AssetBalance_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  locked: BigInt
  locked_not: BigInt
  locked_gt: BigInt
  locked_lt: BigInt
  locked_gte: BigInt
  locked_lte: BigInt
  locked_in: [BigInt!]
  locked_not_in: [BigInt!]
  supplied: BigInt
  supplied_not: BigInt
  supplied_gt: BigInt
  supplied_lt: BigInt
  supplied_gte: BigInt
  supplied_lte: BigInt
  supplied_in: [BigInt!]
  supplied_not_in: [BigInt!]
  removed: BigInt
  removed_not: BigInt
  removed_gt: BigInt
  removed_lt: BigInt
  removed_gte: BigInt
  removed_lte: BigInt
  removed_in: [BigInt!]
  removed_not_in: [BigInt!]
  router: String
  router_not: String
  router_gt: String
  router_lt: String
  router_gte: String
  router_lte: String
  router_in: [String!]
  router_not_in: [String!]
  router_contains: String
  router_contains_nocase: String
  router_not_contains: String
  router_not_contains_nocase: String
  router_starts_with: String
  router_starts_with_nocase: String
  router_not_starts_with: String
  router_not_starts_with_nocase: String
  router_ends_with: String
  router_ends_with_nocase: String
  router_not_ends_with: String
  router_not_ends_with_nocase: String
  router_: polygonzkevm_swap_Router_filter
  asset: String
  asset_not: String
  asset_gt: String
  asset_lt: String
  asset_gte: String
  asset_lte: String
  asset_in: [String!]
  asset_not_in: [String!]
  asset_contains: String
  asset_contains_nocase: String
  asset_not_contains: String
  asset_not_contains_nocase: String
  asset_starts_with: String
  asset_starts_with_nocase: String
  asset_not_starts_with: String
  asset_not_starts_with_nocase: String
  asset_ends_with: String
  asset_ends_with_nocase: String
  asset_not_ends_with: String
  asset_not_ends_with_nocase: String
  asset_: polygonzkevm_swap_Asset_filter
  feesEarned: BigInt
  feesEarned_not: BigInt
  feesEarned_gt: BigInt
  feesEarned_lt: BigInt
  feesEarned_gte: BigInt
  feesEarned_lte: BigInt
  feesEarned_in: [BigInt!]
  feesEarned_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: polygonzkevm_swap_BlockChangedFilter
  and: [polygonzkevm_swap_AssetBalance_filter]
  or: [polygonzkevm_swap_AssetBalance_filter]
}

enum polygonzkevm_swap_AssetBalance_orderBy {
  id
  amount
  locked
  supplied
  removed
  router
  router__id
  router__isActive
  router__owner
  router__recipient
  router__proposedOwner
  router__proposedTimestamp
  asset
  asset__id
  asset__key
  asset__decimal
  asset__adoptedDecimal
  asset__canonicalId
  asset__canonicalDomain
  asset__adoptedAsset
  asset__localAsset
  asset__blockNumber
  feesEarned
}

type polygonzkevm_swap_AssetStatus {
  id: ID!
  status: Boolean
}

input polygonzkevm_swap_AssetStatus_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  status: Boolean
  status_not: Boolean
  status_in: [Boolean!]
  status_not_in: [Boolean!]
  """Filter for the block changed event."""
  _change_block: polygonzkevm_swap_BlockChangedFilter
  and: [polygonzkevm_swap_AssetStatus_filter]
  or: [polygonzkevm_swap_AssetStatus_filter]
}

enum polygonzkevm_swap_AssetStatus_orderBy {
  id
  status
}

input polygonzkevm_swap_Asset_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  key: polygonzkevm_swap_Bytes
  key_not: polygonzkevm_swap_Bytes
  key_gt: polygonzkevm_swap_Bytes
  key_lt: polygonzkevm_swap_Bytes
  key_gte: polygonzkevm_swap_Bytes
  key_lte: polygonzkevm_swap_Bytes
  key_in: [polygonzkevm_swap_Bytes!]
  key_not_in: [polygonzkevm_swap_Bytes!]
  key_contains: polygonzkevm_swap_Bytes
  key_not_contains: polygonzkevm_swap_Bytes
  decimal: BigInt
  decimal_not: BigInt
  decimal_gt: BigInt
  decimal_lt: BigInt
  decimal_gte: BigInt
  decimal_lte: BigInt
  decimal_in: [BigInt!]
  decimal_not_in: [BigInt!]
  adoptedDecimal: BigInt
  adoptedDecimal_not: BigInt
  adoptedDecimal_gt: BigInt
  adoptedDecimal_lt: BigInt
  adoptedDecimal_gte: BigInt
  adoptedDecimal_lte: BigInt
  adoptedDecimal_in: [BigInt!]
  adoptedDecimal_not_in: [BigInt!]
  canonicalId: polygonzkevm_swap_Bytes
  canonicalId_not: polygonzkevm_swap_Bytes
  canonicalId_gt: polygonzkevm_swap_Bytes
  canonicalId_lt: polygonzkevm_swap_Bytes
  canonicalId_gte: polygonzkevm_swap_Bytes
  canonicalId_lte: polygonzkevm_swap_Bytes
  canonicalId_in: [polygonzkevm_swap_Bytes!]
  canonicalId_not_in: [polygonzkevm_swap_Bytes!]
  canonicalId_contains: polygonzkevm_swap_Bytes
  canonicalId_not_contains: polygonzkevm_swap_Bytes
  canonicalDomain: BigInt
  canonicalDomain_not: BigInt
  canonicalDomain_gt: BigInt
  canonicalDomain_lt: BigInt
  canonicalDomain_gte: BigInt
  canonicalDomain_lte: BigInt
  canonicalDomain_in: [BigInt!]
  canonicalDomain_not_in: [BigInt!]
  adoptedAsset: polygonzkevm_swap_Bytes
  adoptedAsset_not: polygonzkevm_swap_Bytes
  adoptedAsset_gt: polygonzkevm_swap_Bytes
  adoptedAsset_lt: polygonzkevm_swap_Bytes
  adoptedAsset_gte: polygonzkevm_swap_Bytes
  adoptedAsset_lte: polygonzkevm_swap_Bytes
  adoptedAsset_in: [polygonzkevm_swap_Bytes!]
  adoptedAsset_not_in: [polygonzkevm_swap_Bytes!]
  adoptedAsset_contains: polygonzkevm_swap_Bytes
  adoptedAsset_not_contains: polygonzkevm_swap_Bytes
  localAsset: polygonzkevm_swap_Bytes
  localAsset_not: polygonzkevm_swap_Bytes
  localAsset_gt: polygonzkevm_swap_Bytes
  localAsset_lt: polygonzkevm_swap_Bytes
  localAsset_gte: polygonzkevm_swap_Bytes
  localAsset_lte: polygonzkevm_swap_Bytes
  localAsset_in: [polygonzkevm_swap_Bytes!]
  localAsset_not_in: [polygonzkevm_swap_Bytes!]
  localAsset_contains: polygonzkevm_swap_Bytes
  localAsset_not_contains: polygonzkevm_swap_Bytes
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  status: String
  status_not: String
  status_gt: String
  status_lt: String
  status_gte: String
  status_lte: String
  status_in: [String!]
  status_not_in: [String!]
  status_contains: String
  status_contains_nocase: String
  status_not_contains: String
  status_not_contains_nocase: String
  status_starts_with: String
  status_starts_with_nocase: String
  status_not_starts_with: String
  status_not_starts_with_nocase: String
  status_ends_with: String
  status_ends_with_nocase: String
  status_not_ends_with: String
  status_not_ends_with_nocase: String
  status_: polygonzkevm_swap_AssetStatus_filter
  """Filter for the block changed event."""
  _change_block: polygonzkevm_swap_BlockChangedFilter
  and: [polygonzkevm_swap_Asset_filter]
  or: [polygonzkevm_swap_Asset_filter]
}

enum polygonzkevm_swap_Asset_orderBy {
  id
  key
  decimal
  adoptedDecimal
  canonicalId
  canonicalDomain
  adoptedAsset
  localAsset
  blockNumber
  status
  status__id
  status__status
}

scalar polygonzkevm_swap_BigDecimal

input polygonzkevm_swap_BlockChangedFilter {
  number_gte: Int!
}

input polygonzkevm_swap_Block_height {
  hash: polygonzkevm_swap_Bytes
  number: Int
  number_gte: Int
}

scalar polygonzkevm_swap_Bytes

type polygonzkevm_swap_ConnectorMeta {
  id: ID!
  spokeDomain: BigInt
  hubDomain: BigInt
  amb: polygonzkevm_swap_Bytes
  rootManager: polygonzkevm_swap_Bytes
  mirrorConnector: polygonzkevm_swap_Bytes
}

input polygonzkevm_swap_ConnectorMeta_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  spokeDomain: BigInt
  spokeDomain_not: BigInt
  spokeDomain_gt: BigInt
  spokeDomain_lt: BigInt
  spokeDomain_gte: BigInt
  spokeDomain_lte: BigInt
  spokeDomain_in: [BigInt!]
  spokeDomain_not_in: [BigInt!]
  hubDomain: BigInt
  hubDomain_not: BigInt
  hubDomain_gt: BigInt
  hubDomain_lt: BigInt
  hubDomain_gte: BigInt
  hubDomain_lte: BigInt
  hubDomain_in: [BigInt!]
  hubDomain_not_in: [BigInt!]
  amb: polygonzkevm_swap_Bytes
  amb_not: polygonzkevm_swap_Bytes
  amb_gt: polygonzkevm_swap_Bytes
  amb_lt: polygonzkevm_swap_Bytes
  amb_gte: polygonzkevm_swap_Bytes
  amb_lte: polygonzkevm_swap_Bytes
  amb_in: [polygonzkevm_swap_Bytes!]
  amb_not_in: [polygonzkevm_swap_Bytes!]
  amb_contains: polygonzkevm_swap_Bytes
  amb_not_contains: polygonzkevm_swap_Bytes
  rootManager: polygonzkevm_swap_Bytes
  rootManager_not: polygonzkevm_swap_Bytes
  rootManager_gt: polygonzkevm_swap_Bytes
  rootManager_lt: polygonzkevm_swap_Bytes
  rootManager_gte: polygonzkevm_swap_Bytes
  rootManager_lte: polygonzkevm_swap_Bytes
  rootManager_in: [polygonzkevm_swap_Bytes!]
  rootManager_not_in: [polygonzkevm_swap_Bytes!]
  rootManager_contains: polygonzkevm_swap_Bytes
  rootManager_not_contains: polygonzkevm_swap_Bytes
  mirrorConnector: polygonzkevm_swap_Bytes
  mirrorConnector_not: polygonzkevm_swap_Bytes
  mirrorConnector_gt: polygonzkevm_swap_Bytes
  mirrorConnector_lt: polygonzkevm_swap_Bytes
  mirrorConnector_gte: polygonzkevm_swap_Bytes
  mirrorConnector_lte: polygonzkevm_swap_Bytes
  mirrorConnector_in: [polygonzkevm_swap_Bytes!]
  mirrorConnector_not_in: [polygonzkevm_swap_Bytes!]
  mirrorConnector_contains: polygonzkevm_swap_Bytes
  mirrorConnector_not_contains: polygonzkevm_swap_Bytes
  """Filter for the block changed event."""
  _change_block: polygonzkevm_swap_BlockChangedFilter
  and: [polygonzkevm_swap_ConnectorMeta_filter]
  or: [polygonzkevm_swap_ConnectorMeta_filter]
}

enum polygonzkevm_swap_ConnectorMeta_orderBy {
  id
  spokeDomain
  hubDomain
  amb
  rootManager
  mirrorConnector
}

type polygonzkevm_swap_DestinationTransfer {
  id: ID!
  chainId: BigInt
  transferId: polygonzkevm_swap_Bytes
  nonce: BigInt
  status: polygonzkevm_swap_TransferStatus
  routers(skip: Int = 0, first: Int = 100, orderBy: polygonzkevm_swap_Router_orderBy, orderDirection: polygonzkevm_swap_OrderDirection, where: polygonzkevm_swap_Router_filter): [polygonzkevm_swap_Router!]
  originDomain: BigInt
  destinationDomain: BigInt
  canonicalDomain: BigInt
  to: polygonzkevm_swap_Bytes
  delegate: polygonzkevm_swap_Bytes
  receiveLocal: Boolean
  callData: polygonzkevm_swap_Bytes
  slippage: BigInt
  bumpSlippageCount: BigInt
  originSender: polygonzkevm_swap_Bytes
  bridgedAmt: BigInt
  normalizedIn: BigInt
  canonicalId: polygonzkevm_swap_Bytes
  asset: polygonzkevm_swap_Asset
  amount: BigInt
  routersFee: BigInt
  executedCaller: polygonzkevm_swap_Bytes
  executedTransactionHash: polygonzkevm_swap_Bytes
  executedTimestamp: BigInt
  executedGasPrice: BigInt
  executedGasLimit: BigInt
  executedBlockNumber: BigInt
  executedTxOrigin: polygonzkevm_swap_Bytes
  executedTxNonce: BigInt
  reconciledCaller: polygonzkevm_swap_Bytes
  reconciledTransactionHash: polygonzkevm_swap_Bytes
  reconciledTimestamp: BigInt
  reconciledGasPrice: BigInt
  reconciledGasLimit: BigInt
  reconciledBlockNumber: BigInt
  reconciledTxOrigin: polygonzkevm_swap_Bytes
  reconciledTxNonce: BigInt
}

input polygonzkevm_swap_DestinationTransfer_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  chainId: BigInt
  chainId_not: BigInt
  chainId_gt: BigInt
  chainId_lt: BigInt
  chainId_gte: BigInt
  chainId_lte: BigInt
  chainId_in: [BigInt!]
  chainId_not_in: [BigInt!]
  transferId: polygonzkevm_swap_Bytes
  transferId_not: polygonzkevm_swap_Bytes
  transferId_gt: polygonzkevm_swap_Bytes
  transferId_lt: polygonzkevm_swap_Bytes
  transferId_gte: polygonzkevm_swap_Bytes
  transferId_lte: polygonzkevm_swap_Bytes
  transferId_in: [polygonzkevm_swap_Bytes!]
  transferId_not_in: [polygonzkevm_swap_Bytes!]
  transferId_contains: polygonzkevm_swap_Bytes
  transferId_not_contains: polygonzkevm_swap_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  status: polygonzkevm_swap_TransferStatus
  status_not: polygonzkevm_swap_TransferStatus
  status_in: [polygonzkevm_swap_TransferStatus!]
  status_not_in: [polygonzkevm_swap_TransferStatus!]
  routers: [String!]
  routers_not: [String!]
  routers_contains: [String!]
  routers_contains_nocase: [String!]
  routers_not_contains: [String!]
  routers_not_contains_nocase: [String!]
  routers_: polygonzkevm_swap_Router_filter
  originDomain: BigInt
  originDomain_not: BigInt
  originDomain_gt: BigInt
  originDomain_lt: BigInt
  originDomain_gte: BigInt
  originDomain_lte: BigInt
  originDomain_in: [BigInt!]
  originDomain_not_in: [BigInt!]
  destinationDomain: BigInt
  destinationDomain_not: BigInt
  destinationDomain_gt: BigInt
  destinationDomain_lt: BigInt
  destinationDomain_gte: BigInt
  destinationDomain_lte: BigInt
  destinationDomain_in: [BigInt!]
  destinationDomain_not_in: [BigInt!]
  canonicalDomain: BigInt
  canonicalDomain_not: BigInt
  canonicalDomain_gt: BigInt
  canonicalDomain_lt: BigInt
  canonicalDomain_gte: BigInt
  canonicalDomain_lte: BigInt
  canonicalDomain_in: [BigInt!]
  canonicalDomain_not_in: [BigInt!]
  to: polygonzkevm_swap_Bytes
  to_not: polygonzkevm_swap_Bytes
  to_gt: polygonzkevm_swap_Bytes
  to_lt: polygonzkevm_swap_Bytes
  to_gte: polygonzkevm_swap_Bytes
  to_lte: polygonzkevm_swap_Bytes
  to_in: [polygonzkevm_swap_Bytes!]
  to_not_in: [polygonzkevm_swap_Bytes!]
  to_contains: polygonzkevm_swap_Bytes
  to_not_contains: polygonzkevm_swap_Bytes
  delegate: polygonzkevm_swap_Bytes
  delegate_not: polygonzkevm_swap_Bytes
  delegate_gt: polygonzkevm_swap_Bytes
  delegate_lt: polygonzkevm_swap_Bytes
  delegate_gte: polygonzkevm_swap_Bytes
  delegate_lte: polygonzkevm_swap_Bytes
  delegate_in: [polygonzkevm_swap_Bytes!]
  delegate_not_in: [polygonzkevm_swap_Bytes!]
  delegate_contains: polygonzkevm_swap_Bytes
  delegate_not_contains: polygonzkevm_swap_Bytes
  receiveLocal: Boolean
  receiveLocal_not: Boolean
  receiveLocal_in: [Boolean!]
  receiveLocal_not_in: [Boolean!]
  callData: polygonzkevm_swap_Bytes
  callData_not: polygonzkevm_swap_Bytes
  callData_gt: polygonzkevm_swap_Bytes
  callData_lt: polygonzkevm_swap_Bytes
  callData_gte: polygonzkevm_swap_Bytes
  callData_lte: polygonzkevm_swap_Bytes
  callData_in: [polygonzkevm_swap_Bytes!]
  callData_not_in: [polygonzkevm_swap_Bytes!]
  callData_contains: polygonzkevm_swap_Bytes
  callData_not_contains: polygonzkevm_swap_Bytes
  slippage: BigInt
  slippage_not: BigInt
  slippage_gt: BigInt
  slippage_lt: BigInt
  slippage_gte: BigInt
  slippage_lte: BigInt
  slippage_in: [BigInt!]
  slippage_not_in: [BigInt!]
  bumpSlippageCount: BigInt
  bumpSlippageCount_not: BigInt
  bumpSlippageCount_gt: BigInt
  bumpSlippageCount_lt: BigInt
  bumpSlippageCount_gte: BigInt
  bumpSlippageCount_lte: BigInt
  bumpSlippageCount_in: [BigInt!]
  bumpSlippageCount_not_in: [BigInt!]
  originSender: polygonzkevm_swap_Bytes
  originSender_not: polygonzkevm_swap_Bytes
  originSender_gt: polygonzkevm_swap_Bytes
  originSender_lt: polygonzkevm_swap_Bytes
  originSender_gte: polygonzkevm_swap_Bytes
  originSender_lte: polygonzkevm_swap_Bytes
  originSender_in: [polygonzkevm_swap_Bytes!]
  originSender_not_in: [polygonzkevm_swap_Bytes!]
  originSender_contains: polygonzkevm_swap_Bytes
  originSender_not_contains: polygonzkevm_swap_Bytes
  bridgedAmt: BigInt
  bridgedAmt_not: BigInt
  bridgedAmt_gt: BigInt
  bridgedAmt_lt: BigInt
  bridgedAmt_gte: BigInt
  bridgedAmt_lte: BigInt
  bridgedAmt_in: [BigInt!]
  bridgedAmt_not_in: [BigInt!]
  normalizedIn: BigInt
  normalizedIn_not: BigInt
  normalizedIn_gt: BigInt
  normalizedIn_lt: BigInt
  normalizedIn_gte: BigInt
  normalizedIn_lte: BigInt
  normalizedIn_in: [BigInt!]
  normalizedIn_not_in: [BigInt!]
  canonicalId: polygonzkevm_swap_Bytes
  canonicalId_not: polygonzkevm_swap_Bytes
  canonicalId_gt: polygonzkevm_swap_Bytes
  canonicalId_lt: polygonzkevm_swap_Bytes
  canonicalId_gte: polygonzkevm_swap_Bytes
  canonicalId_lte: polygonzkevm_swap_Bytes
  canonicalId_in: [polygonzkevm_swap_Bytes!]
  canonicalId_not_in: [polygonzkevm_swap_Bytes!]
  canonicalId_contains: polygonzkevm_swap_Bytes
  canonicalId_not_contains: polygonzkevm_swap_Bytes
  asset: String
  asset_not: String
  asset_gt: String
  asset_lt: String
  asset_gte: String
  asset_lte: String
  asset_in: [String!]
  asset_not_in: [String!]
  asset_contains: String
  asset_contains_nocase: String
  asset_not_contains: String
  asset_not_contains_nocase: String
  asset_starts_with: String
  asset_starts_with_nocase: String
  asset_not_starts_with: String
  asset_not_starts_with_nocase: String
  asset_ends_with: String
  asset_ends_with_nocase: String
  asset_not_ends_with: String
  asset_not_ends_with_nocase: String
  asset_: polygonzkevm_swap_Asset_filter
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  routersFee: BigInt
  routersFee_not: BigInt
  routersFee_gt: BigInt
  routersFee_lt: BigInt
  routersFee_gte: BigInt
  routersFee_lte: BigInt
  routersFee_in: [BigInt!]
  routersFee_not_in: [BigInt!]
  executedCaller: polygonzkevm_swap_Bytes
  executedCaller_not: polygonzkevm_swap_Bytes
  executedCaller_gt: polygonzkevm_swap_Bytes
  executedCaller_lt: polygonzkevm_swap_Bytes
  executedCaller_gte: polygonzkevm_swap_Bytes
  executedCaller_lte: polygonzkevm_swap_Bytes
  executedCaller_in: [polygonzkevm_swap_Bytes!]
  executedCaller_not_in: [polygonzkevm_swap_Bytes!]
  executedCaller_contains: polygonzkevm_swap_Bytes
  executedCaller_not_contains: polygonzkevm_swap_Bytes
  executedTransactionHash: polygonzkevm_swap_Bytes
  executedTransactionHash_not: polygonzkevm_swap_Bytes
  executedTransactionHash_gt: polygonzkevm_swap_Bytes
  executedTransactionHash_lt: polygonzkevm_swap_Bytes
  executedTransactionHash_gte: polygonzkevm_swap_Bytes
  executedTransactionHash_lte: polygonzkevm_swap_Bytes
  executedTransactionHash_in: [polygonzkevm_swap_Bytes!]
  executedTransactionHash_not_in: [polygonzkevm_swap_Bytes!]
  executedTransactionHash_contains: polygonzkevm_swap_Bytes
  executedTransactionHash_not_contains: polygonzkevm_swap_Bytes
  executedTimestamp: BigInt
  executedTimestamp_not: BigInt
  executedTimestamp_gt: BigInt
  executedTimestamp_lt: BigInt
  executedTimestamp_gte: BigInt
  executedTimestamp_lte: BigInt
  executedTimestamp_in: [BigInt!]
  executedTimestamp_not_in: [BigInt!]
  executedGasPrice: BigInt
  executedGasPrice_not: BigInt
  executedGasPrice_gt: BigInt
  executedGasPrice_lt: BigInt
  executedGasPrice_gte: BigInt
  executedGasPrice_lte: BigInt
  executedGasPrice_in: [BigInt!]
  executedGasPrice_not_in: [BigInt!]
  executedGasLimit: BigInt
  executedGasLimit_not: BigInt
  executedGasLimit_gt: BigInt
  executedGasLimit_lt: BigInt
  executedGasLimit_gte: BigInt
  executedGasLimit_lte: BigInt
  executedGasLimit_in: [BigInt!]
  executedGasLimit_not_in: [BigInt!]
  executedBlockNumber: BigInt
  executedBlockNumber_not: BigInt
  executedBlockNumber_gt: BigInt
  executedBlockNumber_lt: BigInt
  executedBlockNumber_gte: BigInt
  executedBlockNumber_lte: BigInt
  executedBlockNumber_in: [BigInt!]
  executedBlockNumber_not_in: [BigInt!]
  executedTxOrigin: polygonzkevm_swap_Bytes
  executedTxOrigin_not: polygonzkevm_swap_Bytes
  executedTxOrigin_gt: polygonzkevm_swap_Bytes
  executedTxOrigin_lt: polygonzkevm_swap_Bytes
  executedTxOrigin_gte: polygonzkevm_swap_Bytes
  executedTxOrigin_lte: polygonzkevm_swap_Bytes
  executedTxOrigin_in: [polygonzkevm_swap_Bytes!]
  executedTxOrigin_not_in: [polygonzkevm_swap_Bytes!]
  executedTxOrigin_contains: polygonzkevm_swap_Bytes
  executedTxOrigin_not_contains: polygonzkevm_swap_Bytes
  executedTxNonce: BigInt
  executedTxNonce_not: BigInt
  executedTxNonce_gt: BigInt
  executedTxNonce_lt: BigInt
  executedTxNonce_gte: BigInt
  executedTxNonce_lte: BigInt
  executedTxNonce_in: [BigInt!]
  executedTxNonce_not_in: [BigInt!]
  reconciledCaller: polygonzkevm_swap_Bytes
  reconciledCaller_not: polygonzkevm_swap_Bytes
  reconciledCaller_gt: polygonzkevm_swap_Bytes
  reconciledCaller_lt: polygonzkevm_swap_Bytes
  reconciledCaller_gte: polygonzkevm_swap_Bytes
  reconciledCaller_lte: polygonzkevm_swap_Bytes
  reconciledCaller_in: [polygonzkevm_swap_Bytes!]
  reconciledCaller_not_in: [polygonzkevm_swap_Bytes!]
  reconciledCaller_contains: polygonzkevm_swap_Bytes
  reconciledCaller_not_contains: polygonzkevm_swap_Bytes
  reconciledTransactionHash: polygonzkevm_swap_Bytes
  reconciledTransactionHash_not: polygonzkevm_swap_Bytes
  reconciledTransactionHash_gt: polygonzkevm_swap_Bytes
  reconciledTransactionHash_lt: polygonzkevm_swap_Bytes
  reconciledTransactionHash_gte: polygonzkevm_swap_Bytes
  reconciledTransactionHash_lte: polygonzkevm_swap_Bytes
  reconciledTransactionHash_in: [polygonzkevm_swap_Bytes!]
  reconciledTransactionHash_not_in: [polygonzkevm_swap_Bytes!]
  reconciledTransactionHash_contains: polygonzkevm_swap_Bytes
  reconciledTransactionHash_not_contains: polygonzkevm_swap_Bytes
  reconciledTimestamp: BigInt
  reconciledTimestamp_not: BigInt
  reconciledTimestamp_gt: BigInt
  reconciledTimestamp_lt: BigInt
  reconciledTimestamp_gte: BigInt
  reconciledTimestamp_lte: BigInt
  reconciledTimestamp_in: [BigInt!]
  reconciledTimestamp_not_in: [BigInt!]
  reconciledGasPrice: BigInt
  reconciledGasPrice_not: BigInt
  reconciledGasPrice_gt: BigInt
  reconciledGasPrice_lt: BigInt
  reconciledGasPrice_gte: BigInt
  reconciledGasPrice_lte: BigInt
  reconciledGasPrice_in: [BigInt!]
  reconciledGasPrice_not_in: [BigInt!]
  reconciledGasLimit: BigInt
  reconciledGasLimit_not: BigInt
  reconciledGasLimit_gt: BigInt
  reconciledGasLimit_lt: BigInt
  reconciledGasLimit_gte: BigInt
  reconciledGasLimit_lte: BigInt
  reconciledGasLimit_in: [BigInt!]
  reconciledGasLimit_not_in: [BigInt!]
  reconciledBlockNumber: BigInt
  reconciledBlockNumber_not: BigInt
  reconciledBlockNumber_gt: BigInt
  reconciledBlockNumber_lt: BigInt
  reconciledBlockNumber_gte: BigInt
  reconciledBlockNumber_lte: BigInt
  reconciledBlockNumber_in: [BigInt!]
  reconciledBlockNumber_not_in: [BigInt!]
  reconciledTxOrigin: polygonzkevm_swap_Bytes
  reconciledTxOrigin_not: polygonzkevm_swap_Bytes
  reconciledTxOrigin_gt: polygonzkevm_swap_Bytes
  reconciledTxOrigin_lt: polygonzkevm_swap_Bytes
  reconciledTxOrigin_gte: polygonzkevm_swap_Bytes
  reconciledTxOrigin_lte: polygonzkevm_swap_Bytes
  reconciledTxOrigin_in: [polygonzkevm_swap_Bytes!]
  reconciledTxOrigin_not_in: [polygonzkevm_swap_Bytes!]
  reconciledTxOrigin_contains: polygonzkevm_swap_Bytes
  reconciledTxOrigin_not_contains: polygonzkevm_swap_Bytes
  reconciledTxNonce: BigInt
  reconciledTxNonce_not: BigInt
  reconciledTxNonce_gt: BigInt
  reconciledTxNonce_lt: BigInt
  reconciledTxNonce_gte: BigInt
  reconciledTxNonce_lte: BigInt
  reconciledTxNonce_in: [BigInt!]
  reconciledTxNonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: polygonzkevm_swap_BlockChangedFilter
  and: [polygonzkevm_swap_DestinationTransfer_filter]
  or: [polygonzkevm_swap_DestinationTransfer_filter]
}

enum polygonzkevm_swap_DestinationTransfer_orderBy {
  id
  chainId
  transferId
  nonce
  status
  routers
  originDomain
  destinationDomain
  canonicalDomain
  to
  delegate
  receiveLocal
  callData
  slippage
  bumpSlippageCount
  originSender
  bridgedAmt
  normalizedIn
  canonicalId
  asset
  asset__id
  asset__key
  asset__decimal
  asset__adoptedDecimal
  asset__canonicalId
  asset__canonicalDomain
  asset__adoptedAsset
  asset__localAsset
  asset__blockNumber
  amount
  routersFee
  executedCaller
  executedTransactionHash
  executedTimestamp
  executedGasPrice
  executedGasLimit
  executedBlockNumber
  executedTxOrigin
  executedTxNonce
  reconciledCaller
  reconciledTransactionHash
  reconciledTimestamp
  reconciledGasPrice
  reconciledGasLimit
  reconciledBlockNumber
  reconciledTxOrigin
  reconciledTxNonce
}

"""
8 bytes signed integer

"""
scalar polygonzkevm_swap_Int8

type polygonzkevm_swap_OptimisticRootFinalized {
  id: ID!
  aggregateRoot: polygonzkevm_swap_Bytes!
  timestamp: BigInt!
  blockNumber: BigInt
}

input polygonzkevm_swap_OptimisticRootFinalized_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  aggregateRoot: polygonzkevm_swap_Bytes
  aggregateRoot_not: polygonzkevm_swap_Bytes
  aggregateRoot_gt: polygonzkevm_swap_Bytes
  aggregateRoot_lt: polygonzkevm_swap_Bytes
  aggregateRoot_gte: polygonzkevm_swap_Bytes
  aggregateRoot_lte: polygonzkevm_swap_Bytes
  aggregateRoot_in: [polygonzkevm_swap_Bytes!]
  aggregateRoot_not_in: [polygonzkevm_swap_Bytes!]
  aggregateRoot_contains: polygonzkevm_swap_Bytes
  aggregateRoot_not_contains: polygonzkevm_swap_Bytes
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: polygonzkevm_swap_BlockChangedFilter
  and: [polygonzkevm_swap_OptimisticRootFinalized_filter]
  or: [polygonzkevm_swap_OptimisticRootFinalized_filter]
}

enum polygonzkevm_swap_OptimisticRootFinalized_orderBy {
  id
  aggregateRoot
  timestamp
  blockNumber
}

"""Defines the order direction, either ascending or descending"""
enum polygonzkevm_swap_OrderDirection {
  asc
  desc
}

type polygonzkevm_swap_OriginMessage {
  id: ID!
  transferId: polygonzkevm_swap_Bytes
  destinationDomain: BigInt
  leaf: polygonzkevm_swap_Bytes
  index: BigInt
  message: polygonzkevm_swap_Bytes
  root: polygonzkevm_swap_Bytes
  transactionHash: polygonzkevm_swap_Bytes
  blockNumber: BigInt
  rootCount: polygonzkevm_swap_RootCount
}

input polygonzkevm_swap_OriginMessage_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transferId: polygonzkevm_swap_Bytes
  transferId_not: polygonzkevm_swap_Bytes
  transferId_gt: polygonzkevm_swap_Bytes
  transferId_lt: polygonzkevm_swap_Bytes
  transferId_gte: polygonzkevm_swap_Bytes
  transferId_lte: polygonzkevm_swap_Bytes
  transferId_in: [polygonzkevm_swap_Bytes!]
  transferId_not_in: [polygonzkevm_swap_Bytes!]
  transferId_contains: polygonzkevm_swap_Bytes
  transferId_not_contains: polygonzkevm_swap_Bytes
  destinationDomain: BigInt
  destinationDomain_not: BigInt
  destinationDomain_gt: BigInt
  destinationDomain_lt: BigInt
  destinationDomain_gte: BigInt
  destinationDomain_lte: BigInt
  destinationDomain_in: [BigInt!]
  destinationDomain_not_in: [BigInt!]
  leaf: polygonzkevm_swap_Bytes
  leaf_not: polygonzkevm_swap_Bytes
  leaf_gt: polygonzkevm_swap_Bytes
  leaf_lt: polygonzkevm_swap_Bytes
  leaf_gte: polygonzkevm_swap_Bytes
  leaf_lte: polygonzkevm_swap_Bytes
  leaf_in: [polygonzkevm_swap_Bytes!]
  leaf_not_in: [polygonzkevm_swap_Bytes!]
  leaf_contains: polygonzkevm_swap_Bytes
  leaf_not_contains: polygonzkevm_swap_Bytes
  index: BigInt
  index_not: BigInt
  index_gt: BigInt
  index_lt: BigInt
  index_gte: BigInt
  index_lte: BigInt
  index_in: [BigInt!]
  index_not_in: [BigInt!]
  message: polygonzkevm_swap_Bytes
  message_not: polygonzkevm_swap_Bytes
  message_gt: polygonzkevm_swap_Bytes
  message_lt: polygonzkevm_swap_Bytes
  message_gte: polygonzkevm_swap_Bytes
  message_lte: polygonzkevm_swap_Bytes
  message_in: [polygonzkevm_swap_Bytes!]
  message_not_in: [polygonzkevm_swap_Bytes!]
  message_contains: polygonzkevm_swap_Bytes
  message_not_contains: polygonzkevm_swap_Bytes
  root: polygonzkevm_swap_Bytes
  root_not: polygonzkevm_swap_Bytes
  root_gt: polygonzkevm_swap_Bytes
  root_lt: polygonzkevm_swap_Bytes
  root_gte: polygonzkevm_swap_Bytes
  root_lte: polygonzkevm_swap_Bytes
  root_in: [polygonzkevm_swap_Bytes!]
  root_not_in: [polygonzkevm_swap_Bytes!]
  root_contains: polygonzkevm_swap_Bytes
  root_not_contains: polygonzkevm_swap_Bytes
  transactionHash: polygonzkevm_swap_Bytes
  transactionHash_not: polygonzkevm_swap_Bytes
  transactionHash_gt: polygonzkevm_swap_Bytes
  transactionHash_lt: polygonzkevm_swap_Bytes
  transactionHash_gte: polygonzkevm_swap_Bytes
  transactionHash_lte: polygonzkevm_swap_Bytes
  transactionHash_in: [polygonzkevm_swap_Bytes!]
  transactionHash_not_in: [polygonzkevm_swap_Bytes!]
  transactionHash_contains: polygonzkevm_swap_Bytes
  transactionHash_not_contains: polygonzkevm_swap_Bytes
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  rootCount: String
  rootCount_not: String
  rootCount_gt: String
  rootCount_lt: String
  rootCount_gte: String
  rootCount_lte: String
  rootCount_in: [String!]
  rootCount_not_in: [String!]
  rootCount_contains: String
  rootCount_contains_nocase: String
  rootCount_not_contains: String
  rootCount_not_contains_nocase: String
  rootCount_starts_with: String
  rootCount_starts_with_nocase: String
  rootCount_not_starts_with: String
  rootCount_not_starts_with_nocase: String
  rootCount_ends_with: String
  rootCount_ends_with_nocase: String
  rootCount_not_ends_with: String
  rootCount_not_ends_with_nocase: String
  rootCount_: polygonzkevm_swap_RootCount_filter
  """Filter for the block changed event."""
  _change_block: polygonzkevm_swap_BlockChangedFilter
  and: [polygonzkevm_swap_OriginMessage_filter]
  or: [polygonzkevm_swap_OriginMessage_filter]
}

enum polygonzkevm_swap_OriginMessage_orderBy {
  id
  transferId
  destinationDomain
  leaf
  index
  message
  root
  transactionHash
  blockNumber
  rootCount
  rootCount__id
  rootCount__count
}

type polygonzkevm_swap_OriginTransfer {
  id: ID!
  chainId: BigInt
  transferId: polygonzkevm_swap_Bytes
  nonce: BigInt
  status: polygonzkevm_swap_TransferStatus
  messageHash: polygonzkevm_swap_Bytes
  originDomain: BigInt
  destinationDomain: BigInt
  canonicalDomain: BigInt
  to: polygonzkevm_swap_Bytes
  delegate: polygonzkevm_swap_Bytes
  receiveLocal: Boolean
  callData: polygonzkevm_swap_Bytes
  slippage: BigInt
  originSender: polygonzkevm_swap_Bytes
  bridgedAmt: BigInt
  normalizedIn: BigInt
  canonicalId: polygonzkevm_swap_Bytes
  asset: polygonzkevm_swap_Asset
  transactingAsset: polygonzkevm_swap_Bytes
  message: polygonzkevm_swap_OriginMessage
  bumpRelayerFeeCount: BigInt
  relayerFees(skip: Int = 0, first: Int = 100, orderBy: polygonzkevm_swap_RelayerFee_orderBy, orderDirection: polygonzkevm_swap_OrderDirection, where: polygonzkevm_swap_RelayerFee_filter): [polygonzkevm_swap_RelayerFee!]
  initialRelayerFeeAsset: polygonzkevm_swap_Bytes
  caller: polygonzkevm_swap_Bytes
  transactionHash: polygonzkevm_swap_Bytes
  timestamp: BigInt
  gasPrice: BigInt
  gasLimit: BigInt
  blockNumber: BigInt
  txOrigin: polygonzkevm_swap_Bytes
  txNonce: BigInt
}

input polygonzkevm_swap_OriginTransfer_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  chainId: BigInt
  chainId_not: BigInt
  chainId_gt: BigInt
  chainId_lt: BigInt
  chainId_gte: BigInt
  chainId_lte: BigInt
  chainId_in: [BigInt!]
  chainId_not_in: [BigInt!]
  transferId: polygonzkevm_swap_Bytes
  transferId_not: polygonzkevm_swap_Bytes
  transferId_gt: polygonzkevm_swap_Bytes
  transferId_lt: polygonzkevm_swap_Bytes
  transferId_gte: polygonzkevm_swap_Bytes
  transferId_lte: polygonzkevm_swap_Bytes
  transferId_in: [polygonzkevm_swap_Bytes!]
  transferId_not_in: [polygonzkevm_swap_Bytes!]
  transferId_contains: polygonzkevm_swap_Bytes
  transferId_not_contains: polygonzkevm_swap_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  status: polygonzkevm_swap_TransferStatus
  status_not: polygonzkevm_swap_TransferStatus
  status_in: [polygonzkevm_swap_TransferStatus!]
  status_not_in: [polygonzkevm_swap_TransferStatus!]
  messageHash: polygonzkevm_swap_Bytes
  messageHash_not: polygonzkevm_swap_Bytes
  messageHash_gt: polygonzkevm_swap_Bytes
  messageHash_lt: polygonzkevm_swap_Bytes
  messageHash_gte: polygonzkevm_swap_Bytes
  messageHash_lte: polygonzkevm_swap_Bytes
  messageHash_in: [polygonzkevm_swap_Bytes!]
  messageHash_not_in: [polygonzkevm_swap_Bytes!]
  messageHash_contains: polygonzkevm_swap_Bytes
  messageHash_not_contains: polygonzkevm_swap_Bytes
  originDomain: BigInt
  originDomain_not: BigInt
  originDomain_gt: BigInt
  originDomain_lt: BigInt
  originDomain_gte: BigInt
  originDomain_lte: BigInt
  originDomain_in: [BigInt!]
  originDomain_not_in: [BigInt!]
  destinationDomain: BigInt
  destinationDomain_not: BigInt
  destinationDomain_gt: BigInt
  destinationDomain_lt: BigInt
  destinationDomain_gte: BigInt
  destinationDomain_lte: BigInt
  destinationDomain_in: [BigInt!]
  destinationDomain_not_in: [BigInt!]
  canonicalDomain: BigInt
  canonicalDomain_not: BigInt
  canonicalDomain_gt: BigInt
  canonicalDomain_lt: BigInt
  canonicalDomain_gte: BigInt
  canonicalDomain_lte: BigInt
  canonicalDomain_in: [BigInt!]
  canonicalDomain_not_in: [BigInt!]
  to: polygonzkevm_swap_Bytes
  to_not: polygonzkevm_swap_Bytes
  to_gt: polygonzkevm_swap_Bytes
  to_lt: polygonzkevm_swap_Bytes
  to_gte: polygonzkevm_swap_Bytes
  to_lte: polygonzkevm_swap_Bytes
  to_in: [polygonzkevm_swap_Bytes!]
  to_not_in: [polygonzkevm_swap_Bytes!]
  to_contains: polygonzkevm_swap_Bytes
  to_not_contains: polygonzkevm_swap_Bytes
  delegate: polygonzkevm_swap_Bytes
  delegate_not: polygonzkevm_swap_Bytes
  delegate_gt: polygonzkevm_swap_Bytes
  delegate_lt: polygonzkevm_swap_Bytes
  delegate_gte: polygonzkevm_swap_Bytes
  delegate_lte: polygonzkevm_swap_Bytes
  delegate_in: [polygonzkevm_swap_Bytes!]
  delegate_not_in: [polygonzkevm_swap_Bytes!]
  delegate_contains: polygonzkevm_swap_Bytes
  delegate_not_contains: polygonzkevm_swap_Bytes
  receiveLocal: Boolean
  receiveLocal_not: Boolean
  receiveLocal_in: [Boolean!]
  receiveLocal_not_in: [Boolean!]
  callData: polygonzkevm_swap_Bytes
  callData_not: polygonzkevm_swap_Bytes
  callData_gt: polygonzkevm_swap_Bytes
  callData_lt: polygonzkevm_swap_Bytes
  callData_gte: polygonzkevm_swap_Bytes
  callData_lte: polygonzkevm_swap_Bytes
  callData_in: [polygonzkevm_swap_Bytes!]
  callData_not_in: [polygonzkevm_swap_Bytes!]
  callData_contains: polygonzkevm_swap_Bytes
  callData_not_contains: polygonzkevm_swap_Bytes
  slippage: BigInt
  slippage_not: BigInt
  slippage_gt: BigInt
  slippage_lt: BigInt
  slippage_gte: BigInt
  slippage_lte: BigInt
  slippage_in: [BigInt!]
  slippage_not_in: [BigInt!]
  originSender: polygonzkevm_swap_Bytes
  originSender_not: polygonzkevm_swap_Bytes
  originSender_gt: polygonzkevm_swap_Bytes
  originSender_lt: polygonzkevm_swap_Bytes
  originSender_gte: polygonzkevm_swap_Bytes
  originSender_lte: polygonzkevm_swap_Bytes
  originSender_in: [polygonzkevm_swap_Bytes!]
  originSender_not_in: [polygonzkevm_swap_Bytes!]
  originSender_contains: polygonzkevm_swap_Bytes
  originSender_not_contains: polygonzkevm_swap_Bytes
  bridgedAmt: BigInt
  bridgedAmt_not: BigInt
  bridgedAmt_gt: BigInt
  bridgedAmt_lt: BigInt
  bridgedAmt_gte: BigInt
  bridgedAmt_lte: BigInt
  bridgedAmt_in: [BigInt!]
  bridgedAmt_not_in: [BigInt!]
  normalizedIn: BigInt
  normalizedIn_not: BigInt
  normalizedIn_gt: BigInt
  normalizedIn_lt: BigInt
  normalizedIn_gte: BigInt
  normalizedIn_lte: BigInt
  normalizedIn_in: [BigInt!]
  normalizedIn_not_in: [BigInt!]
  canonicalId: polygonzkevm_swap_Bytes
  canonicalId_not: polygonzkevm_swap_Bytes
  canonicalId_gt: polygonzkevm_swap_Bytes
  canonicalId_lt: polygonzkevm_swap_Bytes
  canonicalId_gte: polygonzkevm_swap_Bytes
  canonicalId_lte: polygonzkevm_swap_Bytes
  canonicalId_in: [polygonzkevm_swap_Bytes!]
  canonicalId_not_in: [polygonzkevm_swap_Bytes!]
  canonicalId_contains: polygonzkevm_swap_Bytes
  canonicalId_not_contains: polygonzkevm_swap_Bytes
  asset: String
  asset_not: String
  asset_gt: String
  asset_lt: String
  asset_gte: String
  asset_lte: String
  asset_in: [String!]
  asset_not_in: [String!]
  asset_contains: String
  asset_contains_nocase: String
  asset_not_contains: String
  asset_not_contains_nocase: String
  asset_starts_with: String
  asset_starts_with_nocase: String
  asset_not_starts_with: String
  asset_not_starts_with_nocase: String
  asset_ends_with: String
  asset_ends_with_nocase: String
  asset_not_ends_with: String
  asset_not_ends_with_nocase: String
  asset_: polygonzkevm_swap_Asset_filter
  transactingAsset: polygonzkevm_swap_Bytes
  transactingAsset_not: polygonzkevm_swap_Bytes
  transactingAsset_gt: polygonzkevm_swap_Bytes
  transactingAsset_lt: polygonzkevm_swap_Bytes
  transactingAsset_gte: polygonzkevm_swap_Bytes
  transactingAsset_lte: polygonzkevm_swap_Bytes
  transactingAsset_in: [polygonzkevm_swap_Bytes!]
  transactingAsset_not_in: [polygonzkevm_swap_Bytes!]
  transactingAsset_contains: polygonzkevm_swap_Bytes
  transactingAsset_not_contains: polygonzkevm_swap_Bytes
  message: String
  message_not: String
  message_gt: String
  message_lt: String
  message_gte: String
  message_lte: String
  message_in: [String!]
  message_not_in: [String!]
  message_contains: String
  message_contains_nocase: String
  message_not_contains: String
  message_not_contains_nocase: String
  message_starts_with: String
  message_starts_with_nocase: String
  message_not_starts_with: String
  message_not_starts_with_nocase: String
  message_ends_with: String
  message_ends_with_nocase: String
  message_not_ends_with: String
  message_not_ends_with_nocase: String
  message_: polygonzkevm_swap_OriginMessage_filter
  bumpRelayerFeeCount: BigInt
  bumpRelayerFeeCount_not: BigInt
  bumpRelayerFeeCount_gt: BigInt
  bumpRelayerFeeCount_lt: BigInt
  bumpRelayerFeeCount_gte: BigInt
  bumpRelayerFeeCount_lte: BigInt
  bumpRelayerFeeCount_in: [BigInt!]
  bumpRelayerFeeCount_not_in: [BigInt!]
  relayerFees: [String!]
  relayerFees_not: [String!]
  relayerFees_contains: [String!]
  relayerFees_contains_nocase: [String!]
  relayerFees_not_contains: [String!]
  relayerFees_not_contains_nocase: [String!]
  relayerFees_: polygonzkevm_swap_RelayerFee_filter
  initialRelayerFeeAsset: polygonzkevm_swap_Bytes
  initialRelayerFeeAsset_not: polygonzkevm_swap_Bytes
  initialRelayerFeeAsset_gt: polygonzkevm_swap_Bytes
  initialRelayerFeeAsset_lt: polygonzkevm_swap_Bytes
  initialRelayerFeeAsset_gte: polygonzkevm_swap_Bytes
  initialRelayerFeeAsset_lte: polygonzkevm_swap_Bytes
  initialRelayerFeeAsset_in: [polygonzkevm_swap_Bytes!]
  initialRelayerFeeAsset_not_in: [polygonzkevm_swap_Bytes!]
  initialRelayerFeeAsset_contains: polygonzkevm_swap_Bytes
  initialRelayerFeeAsset_not_contains: polygonzkevm_swap_Bytes
  caller: polygonzkevm_swap_Bytes
  caller_not: polygonzkevm_swap_Bytes
  caller_gt: polygonzkevm_swap_Bytes
  caller_lt: polygonzkevm_swap_Bytes
  caller_gte: polygonzkevm_swap_Bytes
  caller_lte: polygonzkevm_swap_Bytes
  caller_in: [polygonzkevm_swap_Bytes!]
  caller_not_in: [polygonzkevm_swap_Bytes!]
  caller_contains: polygonzkevm_swap_Bytes
  caller_not_contains: polygonzkevm_swap_Bytes
  transactionHash: polygonzkevm_swap_Bytes
  transactionHash_not: polygonzkevm_swap_Bytes
  transactionHash_gt: polygonzkevm_swap_Bytes
  transactionHash_lt: polygonzkevm_swap_Bytes
  transactionHash_gte: polygonzkevm_swap_Bytes
  transactionHash_lte: polygonzkevm_swap_Bytes
  transactionHash_in: [polygonzkevm_swap_Bytes!]
  transactionHash_not_in: [polygonzkevm_swap_Bytes!]
  transactionHash_contains: polygonzkevm_swap_Bytes
  transactionHash_not_contains: polygonzkevm_swap_Bytes
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  gasLimit: BigInt
  gasLimit_not: BigInt
  gasLimit_gt: BigInt
  gasLimit_lt: BigInt
  gasLimit_gte: BigInt
  gasLimit_lte: BigInt
  gasLimit_in: [BigInt!]
  gasLimit_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  txOrigin: polygonzkevm_swap_Bytes
  txOrigin_not: polygonzkevm_swap_Bytes
  txOrigin_gt: polygonzkevm_swap_Bytes
  txOrigin_lt: polygonzkevm_swap_Bytes
  txOrigin_gte: polygonzkevm_swap_Bytes
  txOrigin_lte: polygonzkevm_swap_Bytes
  txOrigin_in: [polygonzkevm_swap_Bytes!]
  txOrigin_not_in: [polygonzkevm_swap_Bytes!]
  txOrigin_contains: polygonzkevm_swap_Bytes
  txOrigin_not_contains: polygonzkevm_swap_Bytes
  txNonce: BigInt
  txNonce_not: BigInt
  txNonce_gt: BigInt
  txNonce_lt: BigInt
  txNonce_gte: BigInt
  txNonce_lte: BigInt
  txNonce_in: [BigInt!]
  txNonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: polygonzkevm_swap_BlockChangedFilter
  and: [polygonzkevm_swap_OriginTransfer_filter]
  or: [polygonzkevm_swap_OriginTransfer_filter]
}

enum polygonzkevm_swap_OriginTransfer_orderBy {
  id
  chainId
  transferId
  nonce
  status
  messageHash
  originDomain
  destinationDomain
  canonicalDomain
  to
  delegate
  receiveLocal
  callData
  slippage
  originSender
  bridgedAmt
  normalizedIn
  canonicalId
  asset
  asset__id
  asset__key
  asset__decimal
  asset__adoptedDecimal
  asset__canonicalId
  asset__canonicalDomain
  asset__adoptedAsset
  asset__localAsset
  asset__blockNumber
  transactingAsset
  message
  message__id
  message__transferId
  message__destinationDomain
  message__leaf
  message__index
  message__message
  message__root
  message__transactionHash
  message__blockNumber
  bumpRelayerFeeCount
  relayerFees
  initialRelayerFeeAsset
  caller
  transactionHash
  timestamp
  gasPrice
  gasLimit
  blockNumber
  txOrigin
  txNonce
}

type polygonzkevm_swap_Relayer {
  id: ID!
  isActive: Boolean!
  relayer: polygonzkevm_swap_Bytes
}

type polygonzkevm_swap_RelayerFee {
  id: ID!
  transfer: polygonzkevm_swap_OriginTransfer!
  fee: BigInt!
  asset: polygonzkevm_swap_Bytes!
}

input polygonzkevm_swap_RelayerFee_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transfer: String
  transfer_not: String
  transfer_gt: String
  transfer_lt: String
  transfer_gte: String
  transfer_lte: String
  transfer_in: [String!]
  transfer_not_in: [String!]
  transfer_contains: String
  transfer_contains_nocase: String
  transfer_not_contains: String
  transfer_not_contains_nocase: String
  transfer_starts_with: String
  transfer_starts_with_nocase: String
  transfer_not_starts_with: String
  transfer_not_starts_with_nocase: String
  transfer_ends_with: String
  transfer_ends_with_nocase: String
  transfer_not_ends_with: String
  transfer_not_ends_with_nocase: String
  transfer_: polygonzkevm_swap_OriginTransfer_filter
  fee: BigInt
  fee_not: BigInt
  fee_gt: BigInt
  fee_lt: BigInt
  fee_gte: BigInt
  fee_lte: BigInt
  fee_in: [BigInt!]
  fee_not_in: [BigInt!]
  asset: polygonzkevm_swap_Bytes
  asset_not: polygonzkevm_swap_Bytes
  asset_gt: polygonzkevm_swap_Bytes
  asset_lt: polygonzkevm_swap_Bytes
  asset_gte: polygonzkevm_swap_Bytes
  asset_lte: polygonzkevm_swap_Bytes
  asset_in: [polygonzkevm_swap_Bytes!]
  asset_not_in: [polygonzkevm_swap_Bytes!]
  asset_contains: polygonzkevm_swap_Bytes
  asset_not_contains: polygonzkevm_swap_Bytes
  """Filter for the block changed event."""
  _change_block: polygonzkevm_swap_BlockChangedFilter
  and: [polygonzkevm_swap_RelayerFee_filter]
  or: [polygonzkevm_swap_RelayerFee_filter]
}

enum polygonzkevm_swap_RelayerFee_orderBy {
  id
  transfer
  transfer__id
  transfer__chainId
  transfer__transferId
  transfer__nonce
  transfer__status
  transfer__messageHash
  transfer__originDomain
  transfer__destinationDomain
  transfer__canonicalDomain
  transfer__to
  transfer__delegate
  transfer__receiveLocal
  transfer__callData
  transfer__slippage
  transfer__originSender
  transfer__bridgedAmt
  transfer__normalizedIn
  transfer__canonicalId
  transfer__transactingAsset
  transfer__bumpRelayerFeeCount
  transfer__initialRelayerFeeAsset
  transfer__caller
  transfer__transactionHash
  transfer__timestamp
  transfer__gasPrice
  transfer__gasLimit
  transfer__blockNumber
  transfer__txOrigin
  transfer__txNonce
  fee
  asset
}

type polygonzkevm_swap_RelayerFeesIncrease {
  id: ID!
  transfer: polygonzkevm_swap_OriginTransfer!
  increase: BigInt
  asset: polygonzkevm_swap_Bytes
  caller: polygonzkevm_swap_Bytes!
  transactionHash: polygonzkevm_swap_Bytes!
  timestamp: BigInt!
  gasPrice: BigInt!
  gasLimit: BigInt!
  blockNumber: BigInt!
}

input polygonzkevm_swap_RelayerFeesIncrease_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transfer: String
  transfer_not: String
  transfer_gt: String
  transfer_lt: String
  transfer_gte: String
  transfer_lte: String
  transfer_in: [String!]
  transfer_not_in: [String!]
  transfer_contains: String
  transfer_contains_nocase: String
  transfer_not_contains: String
  transfer_not_contains_nocase: String
  transfer_starts_with: String
  transfer_starts_with_nocase: String
  transfer_not_starts_with: String
  transfer_not_starts_with_nocase: String
  transfer_ends_with: String
  transfer_ends_with_nocase: String
  transfer_not_ends_with: String
  transfer_not_ends_with_nocase: String
  transfer_: polygonzkevm_swap_OriginTransfer_filter
  increase: BigInt
  increase_not: BigInt
  increase_gt: BigInt
  increase_lt: BigInt
  increase_gte: BigInt
  increase_lte: BigInt
  increase_in: [BigInt!]
  increase_not_in: [BigInt!]
  asset: polygonzkevm_swap_Bytes
  asset_not: polygonzkevm_swap_Bytes
  asset_gt: polygonzkevm_swap_Bytes
  asset_lt: polygonzkevm_swap_Bytes
  asset_gte: polygonzkevm_swap_Bytes
  asset_lte: polygonzkevm_swap_Bytes
  asset_in: [polygonzkevm_swap_Bytes!]
  asset_not_in: [polygonzkevm_swap_Bytes!]
  asset_contains: polygonzkevm_swap_Bytes
  asset_not_contains: polygonzkevm_swap_Bytes
  caller: polygonzkevm_swap_Bytes
  caller_not: polygonzkevm_swap_Bytes
  caller_gt: polygonzkevm_swap_Bytes
  caller_lt: polygonzkevm_swap_Bytes
  caller_gte: polygonzkevm_swap_Bytes
  caller_lte: polygonzkevm_swap_Bytes
  caller_in: [polygonzkevm_swap_Bytes!]
  caller_not_in: [polygonzkevm_swap_Bytes!]
  caller_contains: polygonzkevm_swap_Bytes
  caller_not_contains: polygonzkevm_swap_Bytes
  transactionHash: polygonzkevm_swap_Bytes
  transactionHash_not: polygonzkevm_swap_Bytes
  transactionHash_gt: polygonzkevm_swap_Bytes
  transactionHash_lt: polygonzkevm_swap_Bytes
  transactionHash_gte: polygonzkevm_swap_Bytes
  transactionHash_lte: polygonzkevm_swap_Bytes
  transactionHash_in: [polygonzkevm_swap_Bytes!]
  transactionHash_not_in: [polygonzkevm_swap_Bytes!]
  transactionHash_contains: polygonzkevm_swap_Bytes
  transactionHash_not_contains: polygonzkevm_swap_Bytes
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  gasLimit: BigInt
  gasLimit_not: BigInt
  gasLimit_gt: BigInt
  gasLimit_lt: BigInt
  gasLimit_gte: BigInt
  gasLimit_lte: BigInt
  gasLimit_in: [BigInt!]
  gasLimit_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: polygonzkevm_swap_BlockChangedFilter
  and: [polygonzkevm_swap_RelayerFeesIncrease_filter]
  or: [polygonzkevm_swap_RelayerFeesIncrease_filter]
}

enum polygonzkevm_swap_RelayerFeesIncrease_orderBy {
  id
  transfer
  transfer__id
  transfer__chainId
  transfer__transferId
  transfer__nonce
  transfer__status
  transfer__messageHash
  transfer__originDomain
  transfer__destinationDomain
  transfer__canonicalDomain
  transfer__to
  transfer__delegate
  transfer__receiveLocal
  transfer__callData
  transfer__slippage
  transfer__originSender
  transfer__bridgedAmt
  transfer__normalizedIn
  transfer__canonicalId
  transfer__transactingAsset
  transfer__bumpRelayerFeeCount
  transfer__initialRelayerFeeAsset
  transfer__caller
  transfer__transactionHash
  transfer__timestamp
  transfer__gasPrice
  transfer__gasLimit
  transfer__blockNumber
  transfer__txOrigin
  transfer__txNonce
  increase
  asset
  caller
  transactionHash
  timestamp
  gasPrice
  gasLimit
  blockNumber
}

input polygonzkevm_swap_Relayer_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  isActive: Boolean
  isActive_not: Boolean
  isActive_in: [Boolean!]
  isActive_not_in: [Boolean!]
  relayer: polygonzkevm_swap_Bytes
  relayer_not: polygonzkevm_swap_Bytes
  relayer_gt: polygonzkevm_swap_Bytes
  relayer_lt: polygonzkevm_swap_Bytes
  relayer_gte: polygonzkevm_swap_Bytes
  relayer_lte: polygonzkevm_swap_Bytes
  relayer_in: [polygonzkevm_swap_Bytes!]
  relayer_not_in: [polygonzkevm_swap_Bytes!]
  relayer_contains: polygonzkevm_swap_Bytes
  relayer_not_contains: polygonzkevm_swap_Bytes
  """Filter for the block changed event."""
  _change_block: polygonzkevm_swap_BlockChangedFilter
  and: [polygonzkevm_swap_Relayer_filter]
  or: [polygonzkevm_swap_Relayer_filter]
}

enum polygonzkevm_swap_Relayer_orderBy {
  id
  isActive
  relayer
}

type polygonzkevm_swap_RootCount {
  id: ID!
  count: BigInt
}

input polygonzkevm_swap_RootCount_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  count: BigInt
  count_not: BigInt
  count_gt: BigInt
  count_lt: BigInt
  count_gte: BigInt
  count_lte: BigInt
  count_in: [BigInt!]
  count_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: polygonzkevm_swap_BlockChangedFilter
  and: [polygonzkevm_swap_RootCount_filter]
  or: [polygonzkevm_swap_RootCount_filter]
}

enum polygonzkevm_swap_RootCount_orderBy {
  id
  count
}

type polygonzkevm_swap_RootMessageSent {
  id: ID!
  spokeDomain: BigInt
  hubDomain: BigInt
  root: polygonzkevm_swap_Bytes
  count: BigInt
  caller: polygonzkevm_swap_Bytes
  transactionHash: polygonzkevm_swap_Bytes
  timestamp: BigInt
  gasPrice: BigInt
  gasLimit: BigInt
  blockNumber: BigInt
}

input polygonzkevm_swap_RootMessageSent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  spokeDomain: BigInt
  spokeDomain_not: BigInt
  spokeDomain_gt: BigInt
  spokeDomain_lt: BigInt
  spokeDomain_gte: BigInt
  spokeDomain_lte: BigInt
  spokeDomain_in: [BigInt!]
  spokeDomain_not_in: [BigInt!]
  hubDomain: BigInt
  hubDomain_not: BigInt
  hubDomain_gt: BigInt
  hubDomain_lt: BigInt
  hubDomain_gte: BigInt
  hubDomain_lte: BigInt
  hubDomain_in: [BigInt!]
  hubDomain_not_in: [BigInt!]
  root: polygonzkevm_swap_Bytes
  root_not: polygonzkevm_swap_Bytes
  root_gt: polygonzkevm_swap_Bytes
  root_lt: polygonzkevm_swap_Bytes
  root_gte: polygonzkevm_swap_Bytes
  root_lte: polygonzkevm_swap_Bytes
  root_in: [polygonzkevm_swap_Bytes!]
  root_not_in: [polygonzkevm_swap_Bytes!]
  root_contains: polygonzkevm_swap_Bytes
  root_not_contains: polygonzkevm_swap_Bytes
  count: BigInt
  count_not: BigInt
  count_gt: BigInt
  count_lt: BigInt
  count_gte: BigInt
  count_lte: BigInt
  count_in: [BigInt!]
  count_not_in: [BigInt!]
  caller: polygonzkevm_swap_Bytes
  caller_not: polygonzkevm_swap_Bytes
  caller_gt: polygonzkevm_swap_Bytes
  caller_lt: polygonzkevm_swap_Bytes
  caller_gte: polygonzkevm_swap_Bytes
  caller_lte: polygonzkevm_swap_Bytes
  caller_in: [polygonzkevm_swap_Bytes!]
  caller_not_in: [polygonzkevm_swap_Bytes!]
  caller_contains: polygonzkevm_swap_Bytes
  caller_not_contains: polygonzkevm_swap_Bytes
  transactionHash: polygonzkevm_swap_Bytes
  transactionHash_not: polygonzkevm_swap_Bytes
  transactionHash_gt: polygonzkevm_swap_Bytes
  transactionHash_lt: polygonzkevm_swap_Bytes
  transactionHash_gte: polygonzkevm_swap_Bytes
  transactionHash_lte: polygonzkevm_swap_Bytes
  transactionHash_in: [polygonzkevm_swap_Bytes!]
  transactionHash_not_in: [polygonzkevm_swap_Bytes!]
  transactionHash_contains: polygonzkevm_swap_Bytes
  transactionHash_not_contains: polygonzkevm_swap_Bytes
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  gasLimit: BigInt
  gasLimit_not: BigInt
  gasLimit_gt: BigInt
  gasLimit_lt: BigInt
  gasLimit_gte: BigInt
  gasLimit_lte: BigInt
  gasLimit_in: [BigInt!]
  gasLimit_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: polygonzkevm_swap_BlockChangedFilter
  and: [polygonzkevm_swap_RootMessageSent_filter]
  or: [polygonzkevm_swap_RootMessageSent_filter]
}

enum polygonzkevm_swap_RootMessageSent_orderBy {
  id
  spokeDomain
  hubDomain
  root
  count
  caller
  transactionHash
  timestamp
  gasPrice
  gasLimit
  blockNumber
}

type polygonzkevm_swap_Router {
  id: ID!
  isActive: Boolean!
  owner: polygonzkevm_swap_Bytes
  recipient: polygonzkevm_swap_Bytes
  proposedOwner: polygonzkevm_swap_Bytes
  proposedTimestamp: BigInt
  assetBalances(skip: Int = 0, first: Int = 100, orderBy: polygonzkevm_swap_AssetBalance_orderBy, orderDirection: polygonzkevm_swap_OrderDirection, where: polygonzkevm_swap_AssetBalance_filter): [polygonzkevm_swap_AssetBalance!]!
}

type polygonzkevm_swap_RouterDailyTVL {
  id: ID!
  router: polygonzkevm_swap_Router!
  asset: polygonzkevm_swap_Asset!
  timestamp: BigInt!
  balance: BigInt!
}

input polygonzkevm_swap_RouterDailyTVL_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  router: String
  router_not: String
  router_gt: String
  router_lt: String
  router_gte: String
  router_lte: String
  router_in: [String!]
  router_not_in: [String!]
  router_contains: String
  router_contains_nocase: String
  router_not_contains: String
  router_not_contains_nocase: String
  router_starts_with: String
  router_starts_with_nocase: String
  router_not_starts_with: String
  router_not_starts_with_nocase: String
  router_ends_with: String
  router_ends_with_nocase: String
  router_not_ends_with: String
  router_not_ends_with_nocase: String
  router_: polygonzkevm_swap_Router_filter
  asset: String
  asset_not: String
  asset_gt: String
  asset_lt: String
  asset_gte: String
  asset_lte: String
  asset_in: [String!]
  asset_not_in: [String!]
  asset_contains: String
  asset_contains_nocase: String
  asset_not_contains: String
  asset_not_contains_nocase: String
  asset_starts_with: String
  asset_starts_with_nocase: String
  asset_not_starts_with: String
  asset_not_starts_with_nocase: String
  asset_ends_with: String
  asset_ends_with_nocase: String
  asset_not_ends_with: String
  asset_not_ends_with_nocase: String
  asset_: polygonzkevm_swap_Asset_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  balance: BigInt
  balance_not: BigInt
  balance_gt: BigInt
  balance_lt: BigInt
  balance_gte: BigInt
  balance_lte: BigInt
  balance_in: [BigInt!]
  balance_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: polygonzkevm_swap_BlockChangedFilter
  and: [polygonzkevm_swap_RouterDailyTVL_filter]
  or: [polygonzkevm_swap_RouterDailyTVL_filter]
}

enum polygonzkevm_swap_RouterDailyTVL_orderBy {
  id
  router
  router__id
  router__isActive
  router__owner
  router__recipient
  router__proposedOwner
  router__proposedTimestamp
  asset
  asset__id
  asset__key
  asset__decimal
  asset__adoptedDecimal
  asset__canonicalId
  asset__canonicalDomain
  asset__adoptedAsset
  asset__localAsset
  asset__blockNumber
  timestamp
  balance
}

type polygonzkevm_swap_RouterLiquidityEvent {
  id: ID!
  type: polygonzkevm_swap_RouterLiquidityEventType
  router: polygonzkevm_swap_Router!
  asset: polygonzkevm_swap_Asset!
  amount: BigInt!
  balance: BigInt!
  caller: polygonzkevm_swap_Bytes
  blockNumber: BigInt!
  timestamp: BigInt!
  transactionHash: polygonzkevm_swap_Bytes!
  nonce: BigInt!
}

enum polygonzkevm_swap_RouterLiquidityEventType {
  Add
  Remove
}

input polygonzkevm_swap_RouterLiquidityEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  type: polygonzkevm_swap_RouterLiquidityEventType
  type_not: polygonzkevm_swap_RouterLiquidityEventType
  type_in: [polygonzkevm_swap_RouterLiquidityEventType!]
  type_not_in: [polygonzkevm_swap_RouterLiquidityEventType!]
  router: String
  router_not: String
  router_gt: String
  router_lt: String
  router_gte: String
  router_lte: String
  router_in: [String!]
  router_not_in: [String!]
  router_contains: String
  router_contains_nocase: String
  router_not_contains: String
  router_not_contains_nocase: String
  router_starts_with: String
  router_starts_with_nocase: String
  router_not_starts_with: String
  router_not_starts_with_nocase: String
  router_ends_with: String
  router_ends_with_nocase: String
  router_not_ends_with: String
  router_not_ends_with_nocase: String
  router_: polygonzkevm_swap_Router_filter
  asset: String
  asset_not: String
  asset_gt: String
  asset_lt: String
  asset_gte: String
  asset_lte: String
  asset_in: [String!]
  asset_not_in: [String!]
  asset_contains: String
  asset_contains_nocase: String
  asset_not_contains: String
  asset_not_contains_nocase: String
  asset_starts_with: String
  asset_starts_with_nocase: String
  asset_not_starts_with: String
  asset_not_starts_with_nocase: String
  asset_ends_with: String
  asset_ends_with_nocase: String
  asset_not_ends_with: String
  asset_not_ends_with_nocase: String
  asset_: polygonzkevm_swap_Asset_filter
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  balance: BigInt
  balance_not: BigInt
  balance_gt: BigInt
  balance_lt: BigInt
  balance_gte: BigInt
  balance_lte: BigInt
  balance_in: [BigInt!]
  balance_not_in: [BigInt!]
  caller: polygonzkevm_swap_Bytes
  caller_not: polygonzkevm_swap_Bytes
  caller_gt: polygonzkevm_swap_Bytes
  caller_lt: polygonzkevm_swap_Bytes
  caller_gte: polygonzkevm_swap_Bytes
  caller_lte: polygonzkevm_swap_Bytes
  caller_in: [polygonzkevm_swap_Bytes!]
  caller_not_in: [polygonzkevm_swap_Bytes!]
  caller_contains: polygonzkevm_swap_Bytes
  caller_not_contains: polygonzkevm_swap_Bytes
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transactionHash: polygonzkevm_swap_Bytes
  transactionHash_not: polygonzkevm_swap_Bytes
  transactionHash_gt: polygonzkevm_swap_Bytes
  transactionHash_lt: polygonzkevm_swap_Bytes
  transactionHash_gte: polygonzkevm_swap_Bytes
  transactionHash_lte: polygonzkevm_swap_Bytes
  transactionHash_in: [polygonzkevm_swap_Bytes!]
  transactionHash_not_in: [polygonzkevm_swap_Bytes!]
  transactionHash_contains: polygonzkevm_swap_Bytes
  transactionHash_not_contains: polygonzkevm_swap_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: polygonzkevm_swap_BlockChangedFilter
  and: [polygonzkevm_swap_RouterLiquidityEvent_filter]
  or: [polygonzkevm_swap_RouterLiquidityEvent_filter]
}

enum polygonzkevm_swap_RouterLiquidityEvent_orderBy {
  id
  type
  router
  router__id
  router__isActive
  router__owner
  router__recipient
  router__proposedOwner
  router__proposedTimestamp
  asset
  asset__id
  asset__key
  asset__decimal
  asset__adoptedDecimal
  asset__canonicalId
  asset__canonicalDomain
  asset__adoptedAsset
  asset__localAsset
  asset__blockNumber
  amount
  balance
  caller
  blockNumber
  timestamp
  transactionHash
  nonce
}

input polygonzkevm_swap_Router_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  isActive: Boolean
  isActive_not: Boolean
  isActive_in: [Boolean!]
  isActive_not_in: [Boolean!]
  owner: polygonzkevm_swap_Bytes
  owner_not: polygonzkevm_swap_Bytes
  owner_gt: polygonzkevm_swap_Bytes
  owner_lt: polygonzkevm_swap_Bytes
  owner_gte: polygonzkevm_swap_Bytes
  owner_lte: polygonzkevm_swap_Bytes
  owner_in: [polygonzkevm_swap_Bytes!]
  owner_not_in: [polygonzkevm_swap_Bytes!]
  owner_contains: polygonzkevm_swap_Bytes
  owner_not_contains: polygonzkevm_swap_Bytes
  recipient: polygonzkevm_swap_Bytes
  recipient_not: polygonzkevm_swap_Bytes
  recipient_gt: polygonzkevm_swap_Bytes
  recipient_lt: polygonzkevm_swap_Bytes
  recipient_gte: polygonzkevm_swap_Bytes
  recipient_lte: polygonzkevm_swap_Bytes
  recipient_in: [polygonzkevm_swap_Bytes!]
  recipient_not_in: [polygonzkevm_swap_Bytes!]
  recipient_contains: polygonzkevm_swap_Bytes
  recipient_not_contains: polygonzkevm_swap_Bytes
  proposedOwner: polygonzkevm_swap_Bytes
  proposedOwner_not: polygonzkevm_swap_Bytes
  proposedOwner_gt: polygonzkevm_swap_Bytes
  proposedOwner_lt: polygonzkevm_swap_Bytes
  proposedOwner_gte: polygonzkevm_swap_Bytes
  proposedOwner_lte: polygonzkevm_swap_Bytes
  proposedOwner_in: [polygonzkevm_swap_Bytes!]
  proposedOwner_not_in: [polygonzkevm_swap_Bytes!]
  proposedOwner_contains: polygonzkevm_swap_Bytes
  proposedOwner_not_contains: polygonzkevm_swap_Bytes
  proposedTimestamp: BigInt
  proposedTimestamp_not: BigInt
  proposedTimestamp_gt: BigInt
  proposedTimestamp_lt: BigInt
  proposedTimestamp_gte: BigInt
  proposedTimestamp_lte: BigInt
  proposedTimestamp_in: [BigInt!]
  proposedTimestamp_not_in: [BigInt!]
  assetBalances_: polygonzkevm_swap_AssetBalance_filter
  """Filter for the block changed event."""
  _change_block: polygonzkevm_swap_BlockChangedFilter
  and: [polygonzkevm_swap_Router_filter]
  or: [polygonzkevm_swap_Router_filter]
}

enum polygonzkevm_swap_Router_orderBy {
  id
  isActive
  owner
  recipient
  proposedOwner
  proposedTimestamp
  assetBalances
}

type polygonzkevm_swap_Sequencer {
  id: ID!
  isActive: Boolean!
  sequencer: polygonzkevm_swap_Bytes
}

input polygonzkevm_swap_Sequencer_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  isActive: Boolean
  isActive_not: Boolean
  isActive_in: [Boolean!]
  isActive_not_in: [Boolean!]
  sequencer: polygonzkevm_swap_Bytes
  sequencer_not: polygonzkevm_swap_Bytes
  sequencer_gt: polygonzkevm_swap_Bytes
  sequencer_lt: polygonzkevm_swap_Bytes
  sequencer_gte: polygonzkevm_swap_Bytes
  sequencer_lte: polygonzkevm_swap_Bytes
  sequencer_in: [polygonzkevm_swap_Bytes!]
  sequencer_not_in: [polygonzkevm_swap_Bytes!]
  sequencer_contains: polygonzkevm_swap_Bytes
  sequencer_not_contains: polygonzkevm_swap_Bytes
  """Filter for the block changed event."""
  _change_block: polygonzkevm_swap_BlockChangedFilter
  and: [polygonzkevm_swap_Sequencer_filter]
  or: [polygonzkevm_swap_Sequencer_filter]
}

enum polygonzkevm_swap_Sequencer_orderBy {
  id
  isActive
  sequencer
}

type polygonzkevm_swap_Setting {
  id: ID!
  maxRoutersPerTransfer: BigInt!
  caller: polygonzkevm_swap_Bytes!
}

input polygonzkevm_swap_Setting_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  maxRoutersPerTransfer: BigInt
  maxRoutersPerTransfer_not: BigInt
  maxRoutersPerTransfer_gt: BigInt
  maxRoutersPerTransfer_lt: BigInt
  maxRoutersPerTransfer_gte: BigInt
  maxRoutersPerTransfer_lte: BigInt
  maxRoutersPerTransfer_in: [BigInt!]
  maxRoutersPerTransfer_not_in: [BigInt!]
  caller: polygonzkevm_swap_Bytes
  caller_not: polygonzkevm_swap_Bytes
  caller_gt: polygonzkevm_swap_Bytes
  caller_lt: polygonzkevm_swap_Bytes
  caller_gte: polygonzkevm_swap_Bytes
  caller_lte: polygonzkevm_swap_Bytes
  caller_in: [polygonzkevm_swap_Bytes!]
  caller_not_in: [polygonzkevm_swap_Bytes!]
  caller_contains: polygonzkevm_swap_Bytes
  caller_not_contains: polygonzkevm_swap_Bytes
  """Filter for the block changed event."""
  _change_block: polygonzkevm_swap_BlockChangedFilter
  and: [polygonzkevm_swap_Setting_filter]
  or: [polygonzkevm_swap_Setting_filter]
}

enum polygonzkevm_swap_Setting_orderBy {
  id
  maxRoutersPerTransfer
  caller
}

type polygonzkevm_swap_SlippageUpdate {
  id: ID!
  transfer: polygonzkevm_swap_DestinationTransfer!
  slippage: BigInt!
  caller: polygonzkevm_swap_Bytes!
  transactionHash: polygonzkevm_swap_Bytes!
  timestamp: BigInt!
  gasPrice: BigInt!
  gasLimit: BigInt!
  blockNumber: BigInt!
}

input polygonzkevm_swap_SlippageUpdate_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transfer: String
  transfer_not: String
  transfer_gt: String
  transfer_lt: String
  transfer_gte: String
  transfer_lte: String
  transfer_in: [String!]
  transfer_not_in: [String!]
  transfer_contains: String
  transfer_contains_nocase: String
  transfer_not_contains: String
  transfer_not_contains_nocase: String
  transfer_starts_with: String
  transfer_starts_with_nocase: String
  transfer_not_starts_with: String
  transfer_not_starts_with_nocase: String
  transfer_ends_with: String
  transfer_ends_with_nocase: String
  transfer_not_ends_with: String
  transfer_not_ends_with_nocase: String
  transfer_: polygonzkevm_swap_DestinationTransfer_filter
  slippage: BigInt
  slippage_not: BigInt
  slippage_gt: BigInt
  slippage_lt: BigInt
  slippage_gte: BigInt
  slippage_lte: BigInt
  slippage_in: [BigInt!]
  slippage_not_in: [BigInt!]
  caller: polygonzkevm_swap_Bytes
  caller_not: polygonzkevm_swap_Bytes
  caller_gt: polygonzkevm_swap_Bytes
  caller_lt: polygonzkevm_swap_Bytes
  caller_gte: polygonzkevm_swap_Bytes
  caller_lte: polygonzkevm_swap_Bytes
  caller_in: [polygonzkevm_swap_Bytes!]
  caller_not_in: [polygonzkevm_swap_Bytes!]
  caller_contains: polygonzkevm_swap_Bytes
  caller_not_contains: polygonzkevm_swap_Bytes
  transactionHash: polygonzkevm_swap_Bytes
  transactionHash_not: polygonzkevm_swap_Bytes
  transactionHash_gt: polygonzkevm_swap_Bytes
  transactionHash_lt: polygonzkevm_swap_Bytes
  transactionHash_gte: polygonzkevm_swap_Bytes
  transactionHash_lte: polygonzkevm_swap_Bytes
  transactionHash_in: [polygonzkevm_swap_Bytes!]
  transactionHash_not_in: [polygonzkevm_swap_Bytes!]
  transactionHash_contains: polygonzkevm_swap_Bytes
  transactionHash_not_contains: polygonzkevm_swap_Bytes
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  gasLimit: BigInt
  gasLimit_not: BigInt
  gasLimit_gt: BigInt
  gasLimit_lt: BigInt
  gasLimit_gte: BigInt
  gasLimit_lte: BigInt
  gasLimit_in: [BigInt!]
  gasLimit_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: polygonzkevm_swap_BlockChangedFilter
  and: [polygonzkevm_swap_SlippageUpdate_filter]
  or: [polygonzkevm_swap_SlippageUpdate_filter]
}

enum polygonzkevm_swap_SlippageUpdate_orderBy {
  id
  transfer
  transfer__id
  transfer__chainId
  transfer__transferId
  transfer__nonce
  transfer__status
  transfer__originDomain
  transfer__destinationDomain
  transfer__canonicalDomain
  transfer__to
  transfer__delegate
  transfer__receiveLocal
  transfer__callData
  transfer__slippage
  transfer__bumpSlippageCount
  transfer__originSender
  transfer__bridgedAmt
  transfer__normalizedIn
  transfer__canonicalId
  transfer__amount
  transfer__routersFee
  transfer__executedCaller
  transfer__executedTransactionHash
  transfer__executedTimestamp
  transfer__executedGasPrice
  transfer__executedGasLimit
  transfer__executedBlockNumber
  transfer__executedTxOrigin
  transfer__executedTxNonce
  transfer__reconciledCaller
  transfer__reconciledTransactionHash
  transfer__reconciledTimestamp
  transfer__reconciledGasPrice
  transfer__reconciledGasLimit
  transfer__reconciledBlockNumber
  transfer__reconciledTxOrigin
  transfer__reconciledTxNonce
  slippage
  caller
  transactionHash
  timestamp
  gasPrice
  gasLimit
  blockNumber
}

type polygonzkevm_swap_SnapshotRoot {
  id: ID!
  spokeDomain: BigInt
  root: polygonzkevm_swap_Bytes!
  count: BigInt!
  timestamp: BigInt!
  blockNumber: BigInt!
}

input polygonzkevm_swap_SnapshotRoot_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  spokeDomain: BigInt
  spokeDomain_not: BigInt
  spokeDomain_gt: BigInt
  spokeDomain_lt: BigInt
  spokeDomain_gte: BigInt
  spokeDomain_lte: BigInt
  spokeDomain_in: [BigInt!]
  spokeDomain_not_in: [BigInt!]
  root: polygonzkevm_swap_Bytes
  root_not: polygonzkevm_swap_Bytes
  root_gt: polygonzkevm_swap_Bytes
  root_lt: polygonzkevm_swap_Bytes
  root_gte: polygonzkevm_swap_Bytes
  root_lte: polygonzkevm_swap_Bytes
  root_in: [polygonzkevm_swap_Bytes!]
  root_not_in: [polygonzkevm_swap_Bytes!]
  root_contains: polygonzkevm_swap_Bytes
  root_not_contains: polygonzkevm_swap_Bytes
  count: BigInt
  count_not: BigInt
  count_gt: BigInt
  count_lt: BigInt
  count_gte: BigInt
  count_lte: BigInt
  count_in: [BigInt!]
  count_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: polygonzkevm_swap_BlockChangedFilter
  and: [polygonzkevm_swap_SnapshotRoot_filter]
  or: [polygonzkevm_swap_SnapshotRoot_filter]
}

enum polygonzkevm_swap_SnapshotRoot_orderBy {
  id
  spokeDomain
  root
  count
  timestamp
  blockNumber
}

type polygonzkevm_swap_SpokeConnectorMode {
  id: ID!
  mode: String!
}

input polygonzkevm_swap_SpokeConnectorMode_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  mode: String
  mode_not: String
  mode_gt: String
  mode_lt: String
  mode_gte: String
  mode_lte: String
  mode_in: [String!]
  mode_not_in: [String!]
  mode_contains: String
  mode_contains_nocase: String
  mode_not_contains: String
  mode_not_contains_nocase: String
  mode_starts_with: String
  mode_starts_with_nocase: String
  mode_not_starts_with: String
  mode_not_starts_with_nocase: String
  mode_ends_with: String
  mode_ends_with_nocase: String
  mode_not_ends_with: String
  mode_not_ends_with_nocase: String
  """Filter for the block changed event."""
  _change_block: polygonzkevm_swap_BlockChangedFilter
  and: [polygonzkevm_swap_SpokeConnectorMode_filter]
  or: [polygonzkevm_swap_SpokeConnectorMode_filter]
}

enum polygonzkevm_swap_SpokeConnectorMode_orderBy {
  id
  mode
}

enum polygonzkevm_swap_TransferStatus {
  XCalled
  Executed
  Reconciled
  CompletedSlow
  CompletedFast
}

type polygonzkevm_swap__Block_ {
  """The hash of the block"""
  hash: polygonzkevm_swap_Bytes
  """The block number"""
  number: Int!
  """Integer representation of the timestamp stored in blocks for the chain"""
  timestamp: Int
  """The hash of the parent block"""
  parentHash: polygonzkevm_swap_Bytes
}

"""The type for the top-level _meta field"""
type polygonzkevm_swap__Meta_ {
  """
  Information about a specific subgraph block. The hash of the block
  will be null if the _meta field has a block constraint that asks for
  a block number. It will be filled if the _meta field has no block constraint
  and therefore asks for the latest  block
  
  """
  block: polygonzkevm_swap__Block_!
  """The deployment ID"""
  deployment: String!
  """If `true`, the subgraph encountered indexing errors at some past block"""
  hasIndexingErrors: Boolean!
}

type zksync_AggregateRoot {
  id: ID!
  root: zksync_Bytes!
  blockNumber: BigInt!
}

type zksync_AggregateRootProposed {
  id: ID!
  aggregateRoot: zksync_Bytes!
  rootTimestamp: BigInt!
  endOfDispute: BigInt!
  domain: BigInt!
  timestamp: BigInt!
  blockNumber: BigInt
}

input zksync_AggregateRootProposed_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  aggregateRoot: zksync_Bytes
  aggregateRoot_not: zksync_Bytes
  aggregateRoot_gt: zksync_Bytes
  aggregateRoot_lt: zksync_Bytes
  aggregateRoot_gte: zksync_Bytes
  aggregateRoot_lte: zksync_Bytes
  aggregateRoot_in: [zksync_Bytes!]
  aggregateRoot_not_in: [zksync_Bytes!]
  aggregateRoot_contains: zksync_Bytes
  aggregateRoot_not_contains: zksync_Bytes
  rootTimestamp: BigInt
  rootTimestamp_not: BigInt
  rootTimestamp_gt: BigInt
  rootTimestamp_lt: BigInt
  rootTimestamp_gte: BigInt
  rootTimestamp_lte: BigInt
  rootTimestamp_in: [BigInt!]
  rootTimestamp_not_in: [BigInt!]
  endOfDispute: BigInt
  endOfDispute_not: BigInt
  endOfDispute_gt: BigInt
  endOfDispute_lt: BigInt
  endOfDispute_gte: BigInt
  endOfDispute_lte: BigInt
  endOfDispute_in: [BigInt!]
  endOfDispute_not_in: [BigInt!]
  domain: BigInt
  domain_not: BigInt
  domain_gt: BigInt
  domain_lt: BigInt
  domain_gte: BigInt
  domain_lte: BigInt
  domain_in: [BigInt!]
  domain_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: zksync_BlockChangedFilter
  and: [zksync_AggregateRootProposed_filter]
  or: [zksync_AggregateRootProposed_filter]
}

enum zksync_AggregateRootProposed_orderBy {
  id
  aggregateRoot
  rootTimestamp
  endOfDispute
  domain
  timestamp
  blockNumber
}

input zksync_AggregateRoot_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  root: zksync_Bytes
  root_not: zksync_Bytes
  root_gt: zksync_Bytes
  root_lt: zksync_Bytes
  root_gte: zksync_Bytes
  root_lte: zksync_Bytes
  root_in: [zksync_Bytes!]
  root_not_in: [zksync_Bytes!]
  root_contains: zksync_Bytes
  root_not_contains: zksync_Bytes
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: zksync_BlockChangedFilter
  and: [zksync_AggregateRoot_filter]
  or: [zksync_AggregateRoot_filter]
}

enum zksync_AggregateRoot_orderBy {
  id
  root
  blockNumber
}

enum zksync_Aggregation_interval {
  hour
  day
}

type zksync_Asset {
  id: ID!
  key: zksync_Bytes
  decimal: BigInt
  adoptedDecimal: BigInt
  canonicalId: zksync_Bytes
  canonicalDomain: BigInt
  adoptedAsset: zksync_Bytes
  localAsset: zksync_Bytes
  blockNumber: BigInt
  status: zksync_AssetStatus
}

type zksync_AssetBalance {
  id: ID!
  amount: BigInt!
  locked: BigInt!
  supplied: BigInt!
  removed: BigInt!
  router: zksync_Router!
  asset: zksync_Asset!
  feesEarned: BigInt!
}

input zksync_AssetBalance_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  locked: BigInt
  locked_not: BigInt
  locked_gt: BigInt
  locked_lt: BigInt
  locked_gte: BigInt
  locked_lte: BigInt
  locked_in: [BigInt!]
  locked_not_in: [BigInt!]
  supplied: BigInt
  supplied_not: BigInt
  supplied_gt: BigInt
  supplied_lt: BigInt
  supplied_gte: BigInt
  supplied_lte: BigInt
  supplied_in: [BigInt!]
  supplied_not_in: [BigInt!]
  removed: BigInt
  removed_not: BigInt
  removed_gt: BigInt
  removed_lt: BigInt
  removed_gte: BigInt
  removed_lte: BigInt
  removed_in: [BigInt!]
  removed_not_in: [BigInt!]
  router: String
  router_not: String
  router_gt: String
  router_lt: String
  router_gte: String
  router_lte: String
  router_in: [String!]
  router_not_in: [String!]
  router_contains: String
  router_contains_nocase: String
  router_not_contains: String
  router_not_contains_nocase: String
  router_starts_with: String
  router_starts_with_nocase: String
  router_not_starts_with: String
  router_not_starts_with_nocase: String
  router_ends_with: String
  router_ends_with_nocase: String
  router_not_ends_with: String
  router_not_ends_with_nocase: String
  router_: zksync_Router_filter
  asset: String
  asset_not: String
  asset_gt: String
  asset_lt: String
  asset_gte: String
  asset_lte: String
  asset_in: [String!]
  asset_not_in: [String!]
  asset_contains: String
  asset_contains_nocase: String
  asset_not_contains: String
  asset_not_contains_nocase: String
  asset_starts_with: String
  asset_starts_with_nocase: String
  asset_not_starts_with: String
  asset_not_starts_with_nocase: String
  asset_ends_with: String
  asset_ends_with_nocase: String
  asset_not_ends_with: String
  asset_not_ends_with_nocase: String
  asset_: zksync_Asset_filter
  feesEarned: BigInt
  feesEarned_not: BigInt
  feesEarned_gt: BigInt
  feesEarned_lt: BigInt
  feesEarned_gte: BigInt
  feesEarned_lte: BigInt
  feesEarned_in: [BigInt!]
  feesEarned_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: zksync_BlockChangedFilter
  and: [zksync_AssetBalance_filter]
  or: [zksync_AssetBalance_filter]
}

enum zksync_AssetBalance_orderBy {
  id
  amount
  locked
  supplied
  removed
  router
  router__id
  router__isActive
  router__owner
  router__recipient
  router__proposedOwner
  router__proposedTimestamp
  asset
  asset__id
  asset__key
  asset__decimal
  asset__adoptedDecimal
  asset__canonicalId
  asset__canonicalDomain
  asset__adoptedAsset
  asset__localAsset
  asset__blockNumber
  feesEarned
}

type zksync_AssetStatus {
  id: ID!
  status: Boolean
}

input zksync_AssetStatus_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  status: Boolean
  status_not: Boolean
  status_in: [Boolean!]
  status_not_in: [Boolean!]
  """Filter for the block changed event."""
  _change_block: zksync_BlockChangedFilter
  and: [zksync_AssetStatus_filter]
  or: [zksync_AssetStatus_filter]
}

enum zksync_AssetStatus_orderBy {
  id
  status
}

input zksync_Asset_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  key: zksync_Bytes
  key_not: zksync_Bytes
  key_gt: zksync_Bytes
  key_lt: zksync_Bytes
  key_gte: zksync_Bytes
  key_lte: zksync_Bytes
  key_in: [zksync_Bytes!]
  key_not_in: [zksync_Bytes!]
  key_contains: zksync_Bytes
  key_not_contains: zksync_Bytes
  decimal: BigInt
  decimal_not: BigInt
  decimal_gt: BigInt
  decimal_lt: BigInt
  decimal_gte: BigInt
  decimal_lte: BigInt
  decimal_in: [BigInt!]
  decimal_not_in: [BigInt!]
  adoptedDecimal: BigInt
  adoptedDecimal_not: BigInt
  adoptedDecimal_gt: BigInt
  adoptedDecimal_lt: BigInt
  adoptedDecimal_gte: BigInt
  adoptedDecimal_lte: BigInt
  adoptedDecimal_in: [BigInt!]
  adoptedDecimal_not_in: [BigInt!]
  canonicalId: zksync_Bytes
  canonicalId_not: zksync_Bytes
  canonicalId_gt: zksync_Bytes
  canonicalId_lt: zksync_Bytes
  canonicalId_gte: zksync_Bytes
  canonicalId_lte: zksync_Bytes
  canonicalId_in: [zksync_Bytes!]
  canonicalId_not_in: [zksync_Bytes!]
  canonicalId_contains: zksync_Bytes
  canonicalId_not_contains: zksync_Bytes
  canonicalDomain: BigInt
  canonicalDomain_not: BigInt
  canonicalDomain_gt: BigInt
  canonicalDomain_lt: BigInt
  canonicalDomain_gte: BigInt
  canonicalDomain_lte: BigInt
  canonicalDomain_in: [BigInt!]
  canonicalDomain_not_in: [BigInt!]
  adoptedAsset: zksync_Bytes
  adoptedAsset_not: zksync_Bytes
  adoptedAsset_gt: zksync_Bytes
  adoptedAsset_lt: zksync_Bytes
  adoptedAsset_gte: zksync_Bytes
  adoptedAsset_lte: zksync_Bytes
  adoptedAsset_in: [zksync_Bytes!]
  adoptedAsset_not_in: [zksync_Bytes!]
  adoptedAsset_contains: zksync_Bytes
  adoptedAsset_not_contains: zksync_Bytes
  localAsset: zksync_Bytes
  localAsset_not: zksync_Bytes
  localAsset_gt: zksync_Bytes
  localAsset_lt: zksync_Bytes
  localAsset_gte: zksync_Bytes
  localAsset_lte: zksync_Bytes
  localAsset_in: [zksync_Bytes!]
  localAsset_not_in: [zksync_Bytes!]
  localAsset_contains: zksync_Bytes
  localAsset_not_contains: zksync_Bytes
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  status: String
  status_not: String
  status_gt: String
  status_lt: String
  status_gte: String
  status_lte: String
  status_in: [String!]
  status_not_in: [String!]
  status_contains: String
  status_contains_nocase: String
  status_not_contains: String
  status_not_contains_nocase: String
  status_starts_with: String
  status_starts_with_nocase: String
  status_not_starts_with: String
  status_not_starts_with_nocase: String
  status_ends_with: String
  status_ends_with_nocase: String
  status_not_ends_with: String
  status_not_ends_with_nocase: String
  status_: zksync_AssetStatus_filter
  """Filter for the block changed event."""
  _change_block: zksync_BlockChangedFilter
  and: [zksync_Asset_filter]
  or: [zksync_Asset_filter]
}

enum zksync_Asset_orderBy {
  id
  key
  decimal
  adoptedDecimal
  canonicalId
  canonicalDomain
  adoptedAsset
  localAsset
  blockNumber
  status
  status__id
  status__status
}

scalar zksync_BigDecimal

input zksync_BlockChangedFilter {
  number_gte: Int!
}

input zksync_Block_height {
  hash: zksync_Bytes
  number: Int
  number_gte: Int
}

scalar zksync_Bytes

type zksync_ConnectorMeta {
  id: ID!
  spokeDomain: BigInt
  hubDomain: BigInt
  amb: zksync_Bytes
  rootManager: zksync_Bytes
  mirrorConnector: zksync_Bytes
}

input zksync_ConnectorMeta_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  spokeDomain: BigInt
  spokeDomain_not: BigInt
  spokeDomain_gt: BigInt
  spokeDomain_lt: BigInt
  spokeDomain_gte: BigInt
  spokeDomain_lte: BigInt
  spokeDomain_in: [BigInt!]
  spokeDomain_not_in: [BigInt!]
  hubDomain: BigInt
  hubDomain_not: BigInt
  hubDomain_gt: BigInt
  hubDomain_lt: BigInt
  hubDomain_gte: BigInt
  hubDomain_lte: BigInt
  hubDomain_in: [BigInt!]
  hubDomain_not_in: [BigInt!]
  amb: zksync_Bytes
  amb_not: zksync_Bytes
  amb_gt: zksync_Bytes
  amb_lt: zksync_Bytes
  amb_gte: zksync_Bytes
  amb_lte: zksync_Bytes
  amb_in: [zksync_Bytes!]
  amb_not_in: [zksync_Bytes!]
  amb_contains: zksync_Bytes
  amb_not_contains: zksync_Bytes
  rootManager: zksync_Bytes
  rootManager_not: zksync_Bytes
  rootManager_gt: zksync_Bytes
  rootManager_lt: zksync_Bytes
  rootManager_gte: zksync_Bytes
  rootManager_lte: zksync_Bytes
  rootManager_in: [zksync_Bytes!]
  rootManager_not_in: [zksync_Bytes!]
  rootManager_contains: zksync_Bytes
  rootManager_not_contains: zksync_Bytes
  mirrorConnector: zksync_Bytes
  mirrorConnector_not: zksync_Bytes
  mirrorConnector_gt: zksync_Bytes
  mirrorConnector_lt: zksync_Bytes
  mirrorConnector_gte: zksync_Bytes
  mirrorConnector_lte: zksync_Bytes
  mirrorConnector_in: [zksync_Bytes!]
  mirrorConnector_not_in: [zksync_Bytes!]
  mirrorConnector_contains: zksync_Bytes
  mirrorConnector_not_contains: zksync_Bytes
  """Filter for the block changed event."""
  _change_block: zksync_BlockChangedFilter
  and: [zksync_ConnectorMeta_filter]
  or: [zksync_ConnectorMeta_filter]
}

enum zksync_ConnectorMeta_orderBy {
  id
  spokeDomain
  hubDomain
  amb
  rootManager
  mirrorConnector
}

type zksync_DestinationTransfer {
  id: ID!
  chainId: BigInt
  transferId: zksync_Bytes
  nonce: BigInt
  status: zksync_TransferStatus
  routers(skip: Int = 0, first: Int = 100, orderBy: zksync_Router_orderBy, orderDirection: zksync_OrderDirection, where: zksync_Router_filter): [zksync_Router!]
  originDomain: BigInt
  destinationDomain: BigInt
  canonicalDomain: BigInt
  to: zksync_Bytes
  delegate: zksync_Bytes
  receiveLocal: Boolean
  callData: zksync_Bytes
  slippage: BigInt
  bumpSlippageCount: BigInt
  originSender: zksync_Bytes
  bridgedAmt: BigInt
  normalizedIn: BigInt
  canonicalId: zksync_Bytes
  asset: zksync_Asset
  amount: BigInt
  routersFee: BigInt
  executedCaller: zksync_Bytes
  executedTransactionHash: zksync_Bytes
  executedTimestamp: BigInt
  executedGasPrice: BigInt
  executedGasLimit: BigInt
  executedBlockNumber: BigInt
  executedTxOrigin: zksync_Bytes
  executedTxNonce: BigInt
  reconciledCaller: zksync_Bytes
  reconciledTransactionHash: zksync_Bytes
  reconciledTimestamp: BigInt
  reconciledGasPrice: BigInt
  reconciledGasLimit: BigInt
  reconciledBlockNumber: BigInt
  reconciledTxOrigin: zksync_Bytes
  reconciledTxNonce: BigInt
}

input zksync_DestinationTransfer_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  chainId: BigInt
  chainId_not: BigInt
  chainId_gt: BigInt
  chainId_lt: BigInt
  chainId_gte: BigInt
  chainId_lte: BigInt
  chainId_in: [BigInt!]
  chainId_not_in: [BigInt!]
  transferId: zksync_Bytes
  transferId_not: zksync_Bytes
  transferId_gt: zksync_Bytes
  transferId_lt: zksync_Bytes
  transferId_gte: zksync_Bytes
  transferId_lte: zksync_Bytes
  transferId_in: [zksync_Bytes!]
  transferId_not_in: [zksync_Bytes!]
  transferId_contains: zksync_Bytes
  transferId_not_contains: zksync_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  status: zksync_TransferStatus
  status_not: zksync_TransferStatus
  status_in: [zksync_TransferStatus!]
  status_not_in: [zksync_TransferStatus!]
  routers: [String!]
  routers_not: [String!]
  routers_contains: [String!]
  routers_contains_nocase: [String!]
  routers_not_contains: [String!]
  routers_not_contains_nocase: [String!]
  routers_: zksync_Router_filter
  originDomain: BigInt
  originDomain_not: BigInt
  originDomain_gt: BigInt
  originDomain_lt: BigInt
  originDomain_gte: BigInt
  originDomain_lte: BigInt
  originDomain_in: [BigInt!]
  originDomain_not_in: [BigInt!]
  destinationDomain: BigInt
  destinationDomain_not: BigInt
  destinationDomain_gt: BigInt
  destinationDomain_lt: BigInt
  destinationDomain_gte: BigInt
  destinationDomain_lte: BigInt
  destinationDomain_in: [BigInt!]
  destinationDomain_not_in: [BigInt!]
  canonicalDomain: BigInt
  canonicalDomain_not: BigInt
  canonicalDomain_gt: BigInt
  canonicalDomain_lt: BigInt
  canonicalDomain_gte: BigInt
  canonicalDomain_lte: BigInt
  canonicalDomain_in: [BigInt!]
  canonicalDomain_not_in: [BigInt!]
  to: zksync_Bytes
  to_not: zksync_Bytes
  to_gt: zksync_Bytes
  to_lt: zksync_Bytes
  to_gte: zksync_Bytes
  to_lte: zksync_Bytes
  to_in: [zksync_Bytes!]
  to_not_in: [zksync_Bytes!]
  to_contains: zksync_Bytes
  to_not_contains: zksync_Bytes
  delegate: zksync_Bytes
  delegate_not: zksync_Bytes
  delegate_gt: zksync_Bytes
  delegate_lt: zksync_Bytes
  delegate_gte: zksync_Bytes
  delegate_lte: zksync_Bytes
  delegate_in: [zksync_Bytes!]
  delegate_not_in: [zksync_Bytes!]
  delegate_contains: zksync_Bytes
  delegate_not_contains: zksync_Bytes
  receiveLocal: Boolean
  receiveLocal_not: Boolean
  receiveLocal_in: [Boolean!]
  receiveLocal_not_in: [Boolean!]
  callData: zksync_Bytes
  callData_not: zksync_Bytes
  callData_gt: zksync_Bytes
  callData_lt: zksync_Bytes
  callData_gte: zksync_Bytes
  callData_lte: zksync_Bytes
  callData_in: [zksync_Bytes!]
  callData_not_in: [zksync_Bytes!]
  callData_contains: zksync_Bytes
  callData_not_contains: zksync_Bytes
  slippage: BigInt
  slippage_not: BigInt
  slippage_gt: BigInt
  slippage_lt: BigInt
  slippage_gte: BigInt
  slippage_lte: BigInt
  slippage_in: [BigInt!]
  slippage_not_in: [BigInt!]
  bumpSlippageCount: BigInt
  bumpSlippageCount_not: BigInt
  bumpSlippageCount_gt: BigInt
  bumpSlippageCount_lt: BigInt
  bumpSlippageCount_gte: BigInt
  bumpSlippageCount_lte: BigInt
  bumpSlippageCount_in: [BigInt!]
  bumpSlippageCount_not_in: [BigInt!]
  originSender: zksync_Bytes
  originSender_not: zksync_Bytes
  originSender_gt: zksync_Bytes
  originSender_lt: zksync_Bytes
  originSender_gte: zksync_Bytes
  originSender_lte: zksync_Bytes
  originSender_in: [zksync_Bytes!]
  originSender_not_in: [zksync_Bytes!]
  originSender_contains: zksync_Bytes
  originSender_not_contains: zksync_Bytes
  bridgedAmt: BigInt
  bridgedAmt_not: BigInt
  bridgedAmt_gt: BigInt
  bridgedAmt_lt: BigInt
  bridgedAmt_gte: BigInt
  bridgedAmt_lte: BigInt
  bridgedAmt_in: [BigInt!]
  bridgedAmt_not_in: [BigInt!]
  normalizedIn: BigInt
  normalizedIn_not: BigInt
  normalizedIn_gt: BigInt
  normalizedIn_lt: BigInt
  normalizedIn_gte: BigInt
  normalizedIn_lte: BigInt
  normalizedIn_in: [BigInt!]
  normalizedIn_not_in: [BigInt!]
  canonicalId: zksync_Bytes
  canonicalId_not: zksync_Bytes
  canonicalId_gt: zksync_Bytes
  canonicalId_lt: zksync_Bytes
  canonicalId_gte: zksync_Bytes
  canonicalId_lte: zksync_Bytes
  canonicalId_in: [zksync_Bytes!]
  canonicalId_not_in: [zksync_Bytes!]
  canonicalId_contains: zksync_Bytes
  canonicalId_not_contains: zksync_Bytes
  asset: String
  asset_not: String
  asset_gt: String
  asset_lt: String
  asset_gte: String
  asset_lte: String
  asset_in: [String!]
  asset_not_in: [String!]
  asset_contains: String
  asset_contains_nocase: String
  asset_not_contains: String
  asset_not_contains_nocase: String
  asset_starts_with: String
  asset_starts_with_nocase: String
  asset_not_starts_with: String
  asset_not_starts_with_nocase: String
  asset_ends_with: String
  asset_ends_with_nocase: String
  asset_not_ends_with: String
  asset_not_ends_with_nocase: String
  asset_: zksync_Asset_filter
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  routersFee: BigInt
  routersFee_not: BigInt
  routersFee_gt: BigInt
  routersFee_lt: BigInt
  routersFee_gte: BigInt
  routersFee_lte: BigInt
  routersFee_in: [BigInt!]
  routersFee_not_in: [BigInt!]
  executedCaller: zksync_Bytes
  executedCaller_not: zksync_Bytes
  executedCaller_gt: zksync_Bytes
  executedCaller_lt: zksync_Bytes
  executedCaller_gte: zksync_Bytes
  executedCaller_lte: zksync_Bytes
  executedCaller_in: [zksync_Bytes!]
  executedCaller_not_in: [zksync_Bytes!]
  executedCaller_contains: zksync_Bytes
  executedCaller_not_contains: zksync_Bytes
  executedTransactionHash: zksync_Bytes
  executedTransactionHash_not: zksync_Bytes
  executedTransactionHash_gt: zksync_Bytes
  executedTransactionHash_lt: zksync_Bytes
  executedTransactionHash_gte: zksync_Bytes
  executedTransactionHash_lte: zksync_Bytes
  executedTransactionHash_in: [zksync_Bytes!]
  executedTransactionHash_not_in: [zksync_Bytes!]
  executedTransactionHash_contains: zksync_Bytes
  executedTransactionHash_not_contains: zksync_Bytes
  executedTimestamp: BigInt
  executedTimestamp_not: BigInt
  executedTimestamp_gt: BigInt
  executedTimestamp_lt: BigInt
  executedTimestamp_gte: BigInt
  executedTimestamp_lte: BigInt
  executedTimestamp_in: [BigInt!]
  executedTimestamp_not_in: [BigInt!]
  executedGasPrice: BigInt
  executedGasPrice_not: BigInt
  executedGasPrice_gt: BigInt
  executedGasPrice_lt: BigInt
  executedGasPrice_gte: BigInt
  executedGasPrice_lte: BigInt
  executedGasPrice_in: [BigInt!]
  executedGasPrice_not_in: [BigInt!]
  executedGasLimit: BigInt
  executedGasLimit_not: BigInt
  executedGasLimit_gt: BigInt
  executedGasLimit_lt: BigInt
  executedGasLimit_gte: BigInt
  executedGasLimit_lte: BigInt
  executedGasLimit_in: [BigInt!]
  executedGasLimit_not_in: [BigInt!]
  executedBlockNumber: BigInt
  executedBlockNumber_not: BigInt
  executedBlockNumber_gt: BigInt
  executedBlockNumber_lt: BigInt
  executedBlockNumber_gte: BigInt
  executedBlockNumber_lte: BigInt
  executedBlockNumber_in: [BigInt!]
  executedBlockNumber_not_in: [BigInt!]
  executedTxOrigin: zksync_Bytes
  executedTxOrigin_not: zksync_Bytes
  executedTxOrigin_gt: zksync_Bytes
  executedTxOrigin_lt: zksync_Bytes
  executedTxOrigin_gte: zksync_Bytes
  executedTxOrigin_lte: zksync_Bytes
  executedTxOrigin_in: [zksync_Bytes!]
  executedTxOrigin_not_in: [zksync_Bytes!]
  executedTxOrigin_contains: zksync_Bytes
  executedTxOrigin_not_contains: zksync_Bytes
  executedTxNonce: BigInt
  executedTxNonce_not: BigInt
  executedTxNonce_gt: BigInt
  executedTxNonce_lt: BigInt
  executedTxNonce_gte: BigInt
  executedTxNonce_lte: BigInt
  executedTxNonce_in: [BigInt!]
  executedTxNonce_not_in: [BigInt!]
  reconciledCaller: zksync_Bytes
  reconciledCaller_not: zksync_Bytes
  reconciledCaller_gt: zksync_Bytes
  reconciledCaller_lt: zksync_Bytes
  reconciledCaller_gte: zksync_Bytes
  reconciledCaller_lte: zksync_Bytes
  reconciledCaller_in: [zksync_Bytes!]
  reconciledCaller_not_in: [zksync_Bytes!]
  reconciledCaller_contains: zksync_Bytes
  reconciledCaller_not_contains: zksync_Bytes
  reconciledTransactionHash: zksync_Bytes
  reconciledTransactionHash_not: zksync_Bytes
  reconciledTransactionHash_gt: zksync_Bytes
  reconciledTransactionHash_lt: zksync_Bytes
  reconciledTransactionHash_gte: zksync_Bytes
  reconciledTransactionHash_lte: zksync_Bytes
  reconciledTransactionHash_in: [zksync_Bytes!]
  reconciledTransactionHash_not_in: [zksync_Bytes!]
  reconciledTransactionHash_contains: zksync_Bytes
  reconciledTransactionHash_not_contains: zksync_Bytes
  reconciledTimestamp: BigInt
  reconciledTimestamp_not: BigInt
  reconciledTimestamp_gt: BigInt
  reconciledTimestamp_lt: BigInt
  reconciledTimestamp_gte: BigInt
  reconciledTimestamp_lte: BigInt
  reconciledTimestamp_in: [BigInt!]
  reconciledTimestamp_not_in: [BigInt!]
  reconciledGasPrice: BigInt
  reconciledGasPrice_not: BigInt
  reconciledGasPrice_gt: BigInt
  reconciledGasPrice_lt: BigInt
  reconciledGasPrice_gte: BigInt
  reconciledGasPrice_lte: BigInt
  reconciledGasPrice_in: [BigInt!]
  reconciledGasPrice_not_in: [BigInt!]
  reconciledGasLimit: BigInt
  reconciledGasLimit_not: BigInt
  reconciledGasLimit_gt: BigInt
  reconciledGasLimit_lt: BigInt
  reconciledGasLimit_gte: BigInt
  reconciledGasLimit_lte: BigInt
  reconciledGasLimit_in: [BigInt!]
  reconciledGasLimit_not_in: [BigInt!]
  reconciledBlockNumber: BigInt
  reconciledBlockNumber_not: BigInt
  reconciledBlockNumber_gt: BigInt
  reconciledBlockNumber_lt: BigInt
  reconciledBlockNumber_gte: BigInt
  reconciledBlockNumber_lte: BigInt
  reconciledBlockNumber_in: [BigInt!]
  reconciledBlockNumber_not_in: [BigInt!]
  reconciledTxOrigin: zksync_Bytes
  reconciledTxOrigin_not: zksync_Bytes
  reconciledTxOrigin_gt: zksync_Bytes
  reconciledTxOrigin_lt: zksync_Bytes
  reconciledTxOrigin_gte: zksync_Bytes
  reconciledTxOrigin_lte: zksync_Bytes
  reconciledTxOrigin_in: [zksync_Bytes!]
  reconciledTxOrigin_not_in: [zksync_Bytes!]
  reconciledTxOrigin_contains: zksync_Bytes
  reconciledTxOrigin_not_contains: zksync_Bytes
  reconciledTxNonce: BigInt
  reconciledTxNonce_not: BigInt
  reconciledTxNonce_gt: BigInt
  reconciledTxNonce_lt: BigInt
  reconciledTxNonce_gte: BigInt
  reconciledTxNonce_lte: BigInt
  reconciledTxNonce_in: [BigInt!]
  reconciledTxNonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: zksync_BlockChangedFilter
  and: [zksync_DestinationTransfer_filter]
  or: [zksync_DestinationTransfer_filter]
}

enum zksync_DestinationTransfer_orderBy {
  id
  chainId
  transferId
  nonce
  status
  routers
  originDomain
  destinationDomain
  canonicalDomain
  to
  delegate
  receiveLocal
  callData
  slippage
  bumpSlippageCount
  originSender
  bridgedAmt
  normalizedIn
  canonicalId
  asset
  asset__id
  asset__key
  asset__decimal
  asset__adoptedDecimal
  asset__canonicalId
  asset__canonicalDomain
  asset__adoptedAsset
  asset__localAsset
  asset__blockNumber
  amount
  routersFee
  executedCaller
  executedTransactionHash
  executedTimestamp
  executedGasPrice
  executedGasLimit
  executedBlockNumber
  executedTxOrigin
  executedTxNonce
  reconciledCaller
  reconciledTransactionHash
  reconciledTimestamp
  reconciledGasPrice
  reconciledGasLimit
  reconciledBlockNumber
  reconciledTxOrigin
  reconciledTxNonce
}

"""
8 bytes signed integer

"""
scalar zksync_Int8

type zksync_OptimisticRootFinalized {
  id: ID!
  aggregateRoot: zksync_Bytes!
  timestamp: BigInt!
  blockNumber: BigInt
}

input zksync_OptimisticRootFinalized_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  aggregateRoot: zksync_Bytes
  aggregateRoot_not: zksync_Bytes
  aggregateRoot_gt: zksync_Bytes
  aggregateRoot_lt: zksync_Bytes
  aggregateRoot_gte: zksync_Bytes
  aggregateRoot_lte: zksync_Bytes
  aggregateRoot_in: [zksync_Bytes!]
  aggregateRoot_not_in: [zksync_Bytes!]
  aggregateRoot_contains: zksync_Bytes
  aggregateRoot_not_contains: zksync_Bytes
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: zksync_BlockChangedFilter
  and: [zksync_OptimisticRootFinalized_filter]
  or: [zksync_OptimisticRootFinalized_filter]
}

enum zksync_OptimisticRootFinalized_orderBy {
  id
  aggregateRoot
  timestamp
  blockNumber
}

"""Defines the order direction, either ascending or descending"""
enum zksync_OrderDirection {
  asc
  desc
}

type zksync_OriginMessage {
  id: ID!
  transferId: zksync_Bytes
  destinationDomain: BigInt
  leaf: zksync_Bytes
  index: BigInt
  message: zksync_Bytes
  root: zksync_Bytes
  transactionHash: zksync_Bytes
  blockNumber: BigInt
  rootCount: zksync_RootCount
}

input zksync_OriginMessage_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transferId: zksync_Bytes
  transferId_not: zksync_Bytes
  transferId_gt: zksync_Bytes
  transferId_lt: zksync_Bytes
  transferId_gte: zksync_Bytes
  transferId_lte: zksync_Bytes
  transferId_in: [zksync_Bytes!]
  transferId_not_in: [zksync_Bytes!]
  transferId_contains: zksync_Bytes
  transferId_not_contains: zksync_Bytes
  destinationDomain: BigInt
  destinationDomain_not: BigInt
  destinationDomain_gt: BigInt
  destinationDomain_lt: BigInt
  destinationDomain_gte: BigInt
  destinationDomain_lte: BigInt
  destinationDomain_in: [BigInt!]
  destinationDomain_not_in: [BigInt!]
  leaf: zksync_Bytes
  leaf_not: zksync_Bytes
  leaf_gt: zksync_Bytes
  leaf_lt: zksync_Bytes
  leaf_gte: zksync_Bytes
  leaf_lte: zksync_Bytes
  leaf_in: [zksync_Bytes!]
  leaf_not_in: [zksync_Bytes!]
  leaf_contains: zksync_Bytes
  leaf_not_contains: zksync_Bytes
  index: BigInt
  index_not: BigInt
  index_gt: BigInt
  index_lt: BigInt
  index_gte: BigInt
  index_lte: BigInt
  index_in: [BigInt!]
  index_not_in: [BigInt!]
  message: zksync_Bytes
  message_not: zksync_Bytes
  message_gt: zksync_Bytes
  message_lt: zksync_Bytes
  message_gte: zksync_Bytes
  message_lte: zksync_Bytes
  message_in: [zksync_Bytes!]
  message_not_in: [zksync_Bytes!]
  message_contains: zksync_Bytes
  message_not_contains: zksync_Bytes
  root: zksync_Bytes
  root_not: zksync_Bytes
  root_gt: zksync_Bytes
  root_lt: zksync_Bytes
  root_gte: zksync_Bytes
  root_lte: zksync_Bytes
  root_in: [zksync_Bytes!]
  root_not_in: [zksync_Bytes!]
  root_contains: zksync_Bytes
  root_not_contains: zksync_Bytes
  transactionHash: zksync_Bytes
  transactionHash_not: zksync_Bytes
  transactionHash_gt: zksync_Bytes
  transactionHash_lt: zksync_Bytes
  transactionHash_gte: zksync_Bytes
  transactionHash_lte: zksync_Bytes
  transactionHash_in: [zksync_Bytes!]
  transactionHash_not_in: [zksync_Bytes!]
  transactionHash_contains: zksync_Bytes
  transactionHash_not_contains: zksync_Bytes
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  rootCount: String
  rootCount_not: String
  rootCount_gt: String
  rootCount_lt: String
  rootCount_gte: String
  rootCount_lte: String
  rootCount_in: [String!]
  rootCount_not_in: [String!]
  rootCount_contains: String
  rootCount_contains_nocase: String
  rootCount_not_contains: String
  rootCount_not_contains_nocase: String
  rootCount_starts_with: String
  rootCount_starts_with_nocase: String
  rootCount_not_starts_with: String
  rootCount_not_starts_with_nocase: String
  rootCount_ends_with: String
  rootCount_ends_with_nocase: String
  rootCount_not_ends_with: String
  rootCount_not_ends_with_nocase: String
  rootCount_: zksync_RootCount_filter
  """Filter for the block changed event."""
  _change_block: zksync_BlockChangedFilter
  and: [zksync_OriginMessage_filter]
  or: [zksync_OriginMessage_filter]
}

enum zksync_OriginMessage_orderBy {
  id
  transferId
  destinationDomain
  leaf
  index
  message
  root
  transactionHash
  blockNumber
  rootCount
  rootCount__id
  rootCount__count
}

type zksync_OriginTransfer {
  id: ID!
  chainId: BigInt
  transferId: zksync_Bytes
  nonce: BigInt
  status: zksync_TransferStatus
  messageHash: zksync_Bytes
  originDomain: BigInt
  destinationDomain: BigInt
  canonicalDomain: BigInt
  to: zksync_Bytes
  delegate: zksync_Bytes
  receiveLocal: Boolean
  callData: zksync_Bytes
  slippage: BigInt
  originSender: zksync_Bytes
  bridgedAmt: BigInt
  normalizedIn: BigInt
  canonicalId: zksync_Bytes
  asset: zksync_Asset
  transactingAsset: zksync_Bytes
  message: zksync_OriginMessage
  bumpRelayerFeeCount: BigInt
  relayerFees(skip: Int = 0, first: Int = 100, orderBy: zksync_RelayerFee_orderBy, orderDirection: zksync_OrderDirection, where: zksync_RelayerFee_filter): [zksync_RelayerFee!]
  initialRelayerFeeAsset: zksync_Bytes
  caller: zksync_Bytes
  transactionHash: zksync_Bytes
  timestamp: BigInt
  gasPrice: BigInt
  gasLimit: BigInt
  blockNumber: BigInt
  txOrigin: zksync_Bytes
  txNonce: BigInt
}

input zksync_OriginTransfer_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  chainId: BigInt
  chainId_not: BigInt
  chainId_gt: BigInt
  chainId_lt: BigInt
  chainId_gte: BigInt
  chainId_lte: BigInt
  chainId_in: [BigInt!]
  chainId_not_in: [BigInt!]
  transferId: zksync_Bytes
  transferId_not: zksync_Bytes
  transferId_gt: zksync_Bytes
  transferId_lt: zksync_Bytes
  transferId_gte: zksync_Bytes
  transferId_lte: zksync_Bytes
  transferId_in: [zksync_Bytes!]
  transferId_not_in: [zksync_Bytes!]
  transferId_contains: zksync_Bytes
  transferId_not_contains: zksync_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  status: zksync_TransferStatus
  status_not: zksync_TransferStatus
  status_in: [zksync_TransferStatus!]
  status_not_in: [zksync_TransferStatus!]
  messageHash: zksync_Bytes
  messageHash_not: zksync_Bytes
  messageHash_gt: zksync_Bytes
  messageHash_lt: zksync_Bytes
  messageHash_gte: zksync_Bytes
  messageHash_lte: zksync_Bytes
  messageHash_in: [zksync_Bytes!]
  messageHash_not_in: [zksync_Bytes!]
  messageHash_contains: zksync_Bytes
  messageHash_not_contains: zksync_Bytes
  originDomain: BigInt
  originDomain_not: BigInt
  originDomain_gt: BigInt
  originDomain_lt: BigInt
  originDomain_gte: BigInt
  originDomain_lte: BigInt
  originDomain_in: [BigInt!]
  originDomain_not_in: [BigInt!]
  destinationDomain: BigInt
  destinationDomain_not: BigInt
  destinationDomain_gt: BigInt
  destinationDomain_lt: BigInt
  destinationDomain_gte: BigInt
  destinationDomain_lte: BigInt
  destinationDomain_in: [BigInt!]
  destinationDomain_not_in: [BigInt!]
  canonicalDomain: BigInt
  canonicalDomain_not: BigInt
  canonicalDomain_gt: BigInt
  canonicalDomain_lt: BigInt
  canonicalDomain_gte: BigInt
  canonicalDomain_lte: BigInt
  canonicalDomain_in: [BigInt!]
  canonicalDomain_not_in: [BigInt!]
  to: zksync_Bytes
  to_not: zksync_Bytes
  to_gt: zksync_Bytes
  to_lt: zksync_Bytes
  to_gte: zksync_Bytes
  to_lte: zksync_Bytes
  to_in: [zksync_Bytes!]
  to_not_in: [zksync_Bytes!]
  to_contains: zksync_Bytes
  to_not_contains: zksync_Bytes
  delegate: zksync_Bytes
  delegate_not: zksync_Bytes
  delegate_gt: zksync_Bytes
  delegate_lt: zksync_Bytes
  delegate_gte: zksync_Bytes
  delegate_lte: zksync_Bytes
  delegate_in: [zksync_Bytes!]
  delegate_not_in: [zksync_Bytes!]
  delegate_contains: zksync_Bytes
  delegate_not_contains: zksync_Bytes
  receiveLocal: Boolean
  receiveLocal_not: Boolean
  receiveLocal_in: [Boolean!]
  receiveLocal_not_in: [Boolean!]
  callData: zksync_Bytes
  callData_not: zksync_Bytes
  callData_gt: zksync_Bytes
  callData_lt: zksync_Bytes
  callData_gte: zksync_Bytes
  callData_lte: zksync_Bytes
  callData_in: [zksync_Bytes!]
  callData_not_in: [zksync_Bytes!]
  callData_contains: zksync_Bytes
  callData_not_contains: zksync_Bytes
  slippage: BigInt
  slippage_not: BigInt
  slippage_gt: BigInt
  slippage_lt: BigInt
  slippage_gte: BigInt
  slippage_lte: BigInt
  slippage_in: [BigInt!]
  slippage_not_in: [BigInt!]
  originSender: zksync_Bytes
  originSender_not: zksync_Bytes
  originSender_gt: zksync_Bytes
  originSender_lt: zksync_Bytes
  originSender_gte: zksync_Bytes
  originSender_lte: zksync_Bytes
  originSender_in: [zksync_Bytes!]
  originSender_not_in: [zksync_Bytes!]
  originSender_contains: zksync_Bytes
  originSender_not_contains: zksync_Bytes
  bridgedAmt: BigInt
  bridgedAmt_not: BigInt
  bridgedAmt_gt: BigInt
  bridgedAmt_lt: BigInt
  bridgedAmt_gte: BigInt
  bridgedAmt_lte: BigInt
  bridgedAmt_in: [BigInt!]
  bridgedAmt_not_in: [BigInt!]
  normalizedIn: BigInt
  normalizedIn_not: BigInt
  normalizedIn_gt: BigInt
  normalizedIn_lt: BigInt
  normalizedIn_gte: BigInt
  normalizedIn_lte: BigInt
  normalizedIn_in: [BigInt!]
  normalizedIn_not_in: [BigInt!]
  canonicalId: zksync_Bytes
  canonicalId_not: zksync_Bytes
  canonicalId_gt: zksync_Bytes
  canonicalId_lt: zksync_Bytes
  canonicalId_gte: zksync_Bytes
  canonicalId_lte: zksync_Bytes
  canonicalId_in: [zksync_Bytes!]
  canonicalId_not_in: [zksync_Bytes!]
  canonicalId_contains: zksync_Bytes
  canonicalId_not_contains: zksync_Bytes
  asset: String
  asset_not: String
  asset_gt: String
  asset_lt: String
  asset_gte: String
  asset_lte: String
  asset_in: [String!]
  asset_not_in: [String!]
  asset_contains: String
  asset_contains_nocase: String
  asset_not_contains: String
  asset_not_contains_nocase: String
  asset_starts_with: String
  asset_starts_with_nocase: String
  asset_not_starts_with: String
  asset_not_starts_with_nocase: String
  asset_ends_with: String
  asset_ends_with_nocase: String
  asset_not_ends_with: String
  asset_not_ends_with_nocase: String
  asset_: zksync_Asset_filter
  transactingAsset: zksync_Bytes
  transactingAsset_not: zksync_Bytes
  transactingAsset_gt: zksync_Bytes
  transactingAsset_lt: zksync_Bytes
  transactingAsset_gte: zksync_Bytes
  transactingAsset_lte: zksync_Bytes
  transactingAsset_in: [zksync_Bytes!]
  transactingAsset_not_in: [zksync_Bytes!]
  transactingAsset_contains: zksync_Bytes
  transactingAsset_not_contains: zksync_Bytes
  message: String
  message_not: String
  message_gt: String
  message_lt: String
  message_gte: String
  message_lte: String
  message_in: [String!]
  message_not_in: [String!]
  message_contains: String
  message_contains_nocase: String
  message_not_contains: String
  message_not_contains_nocase: String
  message_starts_with: String
  message_starts_with_nocase: String
  message_not_starts_with: String
  message_not_starts_with_nocase: String
  message_ends_with: String
  message_ends_with_nocase: String
  message_not_ends_with: String
  message_not_ends_with_nocase: String
  message_: zksync_OriginMessage_filter
  bumpRelayerFeeCount: BigInt
  bumpRelayerFeeCount_not: BigInt
  bumpRelayerFeeCount_gt: BigInt
  bumpRelayerFeeCount_lt: BigInt
  bumpRelayerFeeCount_gte: BigInt
  bumpRelayerFeeCount_lte: BigInt
  bumpRelayerFeeCount_in: [BigInt!]
  bumpRelayerFeeCount_not_in: [BigInt!]
  relayerFees: [String!]
  relayerFees_not: [String!]
  relayerFees_contains: [String!]
  relayerFees_contains_nocase: [String!]
  relayerFees_not_contains: [String!]
  relayerFees_not_contains_nocase: [String!]
  relayerFees_: zksync_RelayerFee_filter
  initialRelayerFeeAsset: zksync_Bytes
  initialRelayerFeeAsset_not: zksync_Bytes
  initialRelayerFeeAsset_gt: zksync_Bytes
  initialRelayerFeeAsset_lt: zksync_Bytes
  initialRelayerFeeAsset_gte: zksync_Bytes
  initialRelayerFeeAsset_lte: zksync_Bytes
  initialRelayerFeeAsset_in: [zksync_Bytes!]
  initialRelayerFeeAsset_not_in: [zksync_Bytes!]
  initialRelayerFeeAsset_contains: zksync_Bytes
  initialRelayerFeeAsset_not_contains: zksync_Bytes
  caller: zksync_Bytes
  caller_not: zksync_Bytes
  caller_gt: zksync_Bytes
  caller_lt: zksync_Bytes
  caller_gte: zksync_Bytes
  caller_lte: zksync_Bytes
  caller_in: [zksync_Bytes!]
  caller_not_in: [zksync_Bytes!]
  caller_contains: zksync_Bytes
  caller_not_contains: zksync_Bytes
  transactionHash: zksync_Bytes
  transactionHash_not: zksync_Bytes
  transactionHash_gt: zksync_Bytes
  transactionHash_lt: zksync_Bytes
  transactionHash_gte: zksync_Bytes
  transactionHash_lte: zksync_Bytes
  transactionHash_in: [zksync_Bytes!]
  transactionHash_not_in: [zksync_Bytes!]
  transactionHash_contains: zksync_Bytes
  transactionHash_not_contains: zksync_Bytes
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  gasLimit: BigInt
  gasLimit_not: BigInt
  gasLimit_gt: BigInt
  gasLimit_lt: BigInt
  gasLimit_gte: BigInt
  gasLimit_lte: BigInt
  gasLimit_in: [BigInt!]
  gasLimit_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  txOrigin: zksync_Bytes
  txOrigin_not: zksync_Bytes
  txOrigin_gt: zksync_Bytes
  txOrigin_lt: zksync_Bytes
  txOrigin_gte: zksync_Bytes
  txOrigin_lte: zksync_Bytes
  txOrigin_in: [zksync_Bytes!]
  txOrigin_not_in: [zksync_Bytes!]
  txOrigin_contains: zksync_Bytes
  txOrigin_not_contains: zksync_Bytes
  txNonce: BigInt
  txNonce_not: BigInt
  txNonce_gt: BigInt
  txNonce_lt: BigInt
  txNonce_gte: BigInt
  txNonce_lte: BigInt
  txNonce_in: [BigInt!]
  txNonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: zksync_BlockChangedFilter
  and: [zksync_OriginTransfer_filter]
  or: [zksync_OriginTransfer_filter]
}

enum zksync_OriginTransfer_orderBy {
  id
  chainId
  transferId
  nonce
  status
  messageHash
  originDomain
  destinationDomain
  canonicalDomain
  to
  delegate
  receiveLocal
  callData
  slippage
  originSender
  bridgedAmt
  normalizedIn
  canonicalId
  asset
  asset__id
  asset__key
  asset__decimal
  asset__adoptedDecimal
  asset__canonicalId
  asset__canonicalDomain
  asset__adoptedAsset
  asset__localAsset
  asset__blockNumber
  transactingAsset
  message
  message__id
  message__transferId
  message__destinationDomain
  message__leaf
  message__index
  message__message
  message__root
  message__transactionHash
  message__blockNumber
  bumpRelayerFeeCount
  relayerFees
  initialRelayerFeeAsset
  caller
  transactionHash
  timestamp
  gasPrice
  gasLimit
  blockNumber
  txOrigin
  txNonce
}

type zksync_Relayer {
  id: ID!
  isActive: Boolean!
  relayer: zksync_Bytes
}

type zksync_RelayerFee {
  id: ID!
  transfer: zksync_OriginTransfer!
  fee: BigInt!
  asset: zksync_Bytes!
}

input zksync_RelayerFee_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transfer: String
  transfer_not: String
  transfer_gt: String
  transfer_lt: String
  transfer_gte: String
  transfer_lte: String
  transfer_in: [String!]
  transfer_not_in: [String!]
  transfer_contains: String
  transfer_contains_nocase: String
  transfer_not_contains: String
  transfer_not_contains_nocase: String
  transfer_starts_with: String
  transfer_starts_with_nocase: String
  transfer_not_starts_with: String
  transfer_not_starts_with_nocase: String
  transfer_ends_with: String
  transfer_ends_with_nocase: String
  transfer_not_ends_with: String
  transfer_not_ends_with_nocase: String
  transfer_: zksync_OriginTransfer_filter
  fee: BigInt
  fee_not: BigInt
  fee_gt: BigInt
  fee_lt: BigInt
  fee_gte: BigInt
  fee_lte: BigInt
  fee_in: [BigInt!]
  fee_not_in: [BigInt!]
  asset: zksync_Bytes
  asset_not: zksync_Bytes
  asset_gt: zksync_Bytes
  asset_lt: zksync_Bytes
  asset_gte: zksync_Bytes
  asset_lte: zksync_Bytes
  asset_in: [zksync_Bytes!]
  asset_not_in: [zksync_Bytes!]
  asset_contains: zksync_Bytes
  asset_not_contains: zksync_Bytes
  """Filter for the block changed event."""
  _change_block: zksync_BlockChangedFilter
  and: [zksync_RelayerFee_filter]
  or: [zksync_RelayerFee_filter]
}

enum zksync_RelayerFee_orderBy {
  id
  transfer
  transfer__id
  transfer__chainId
  transfer__transferId
  transfer__nonce
  transfer__status
  transfer__messageHash
  transfer__originDomain
  transfer__destinationDomain
  transfer__canonicalDomain
  transfer__to
  transfer__delegate
  transfer__receiveLocal
  transfer__callData
  transfer__slippage
  transfer__originSender
  transfer__bridgedAmt
  transfer__normalizedIn
  transfer__canonicalId
  transfer__transactingAsset
  transfer__bumpRelayerFeeCount
  transfer__initialRelayerFeeAsset
  transfer__caller
  transfer__transactionHash
  transfer__timestamp
  transfer__gasPrice
  transfer__gasLimit
  transfer__blockNumber
  transfer__txOrigin
  transfer__txNonce
  fee
  asset
}

type zksync_RelayerFeesIncrease {
  id: ID!
  transfer: zksync_OriginTransfer!
  increase: BigInt
  asset: zksync_Bytes
  caller: zksync_Bytes!
  transactionHash: zksync_Bytes!
  timestamp: BigInt!
  gasPrice: BigInt!
  gasLimit: BigInt!
  blockNumber: BigInt!
}

input zksync_RelayerFeesIncrease_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transfer: String
  transfer_not: String
  transfer_gt: String
  transfer_lt: String
  transfer_gte: String
  transfer_lte: String
  transfer_in: [String!]
  transfer_not_in: [String!]
  transfer_contains: String
  transfer_contains_nocase: String
  transfer_not_contains: String
  transfer_not_contains_nocase: String
  transfer_starts_with: String
  transfer_starts_with_nocase: String
  transfer_not_starts_with: String
  transfer_not_starts_with_nocase: String
  transfer_ends_with: String
  transfer_ends_with_nocase: String
  transfer_not_ends_with: String
  transfer_not_ends_with_nocase: String
  transfer_: zksync_OriginTransfer_filter
  increase: BigInt
  increase_not: BigInt
  increase_gt: BigInt
  increase_lt: BigInt
  increase_gte: BigInt
  increase_lte: BigInt
  increase_in: [BigInt!]
  increase_not_in: [BigInt!]
  asset: zksync_Bytes
  asset_not: zksync_Bytes
  asset_gt: zksync_Bytes
  asset_lt: zksync_Bytes
  asset_gte: zksync_Bytes
  asset_lte: zksync_Bytes
  asset_in: [zksync_Bytes!]
  asset_not_in: [zksync_Bytes!]
  asset_contains: zksync_Bytes
  asset_not_contains: zksync_Bytes
  caller: zksync_Bytes
  caller_not: zksync_Bytes
  caller_gt: zksync_Bytes
  caller_lt: zksync_Bytes
  caller_gte: zksync_Bytes
  caller_lte: zksync_Bytes
  caller_in: [zksync_Bytes!]
  caller_not_in: [zksync_Bytes!]
  caller_contains: zksync_Bytes
  caller_not_contains: zksync_Bytes
  transactionHash: zksync_Bytes
  transactionHash_not: zksync_Bytes
  transactionHash_gt: zksync_Bytes
  transactionHash_lt: zksync_Bytes
  transactionHash_gte: zksync_Bytes
  transactionHash_lte: zksync_Bytes
  transactionHash_in: [zksync_Bytes!]
  transactionHash_not_in: [zksync_Bytes!]
  transactionHash_contains: zksync_Bytes
  transactionHash_not_contains: zksync_Bytes
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  gasLimit: BigInt
  gasLimit_not: BigInt
  gasLimit_gt: BigInt
  gasLimit_lt: BigInt
  gasLimit_gte: BigInt
  gasLimit_lte: BigInt
  gasLimit_in: [BigInt!]
  gasLimit_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: zksync_BlockChangedFilter
  and: [zksync_RelayerFeesIncrease_filter]
  or: [zksync_RelayerFeesIncrease_filter]
}

enum zksync_RelayerFeesIncrease_orderBy {
  id
  transfer
  transfer__id
  transfer__chainId
  transfer__transferId
  transfer__nonce
  transfer__status
  transfer__messageHash
  transfer__originDomain
  transfer__destinationDomain
  transfer__canonicalDomain
  transfer__to
  transfer__delegate
  transfer__receiveLocal
  transfer__callData
  transfer__slippage
  transfer__originSender
  transfer__bridgedAmt
  transfer__normalizedIn
  transfer__canonicalId
  transfer__transactingAsset
  transfer__bumpRelayerFeeCount
  transfer__initialRelayerFeeAsset
  transfer__caller
  transfer__transactionHash
  transfer__timestamp
  transfer__gasPrice
  transfer__gasLimit
  transfer__blockNumber
  transfer__txOrigin
  transfer__txNonce
  increase
  asset
  caller
  transactionHash
  timestamp
  gasPrice
  gasLimit
  blockNumber
}

input zksync_Relayer_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  isActive: Boolean
  isActive_not: Boolean
  isActive_in: [Boolean!]
  isActive_not_in: [Boolean!]
  relayer: zksync_Bytes
  relayer_not: zksync_Bytes
  relayer_gt: zksync_Bytes
  relayer_lt: zksync_Bytes
  relayer_gte: zksync_Bytes
  relayer_lte: zksync_Bytes
  relayer_in: [zksync_Bytes!]
  relayer_not_in: [zksync_Bytes!]
  relayer_contains: zksync_Bytes
  relayer_not_contains: zksync_Bytes
  """Filter for the block changed event."""
  _change_block: zksync_BlockChangedFilter
  and: [zksync_Relayer_filter]
  or: [zksync_Relayer_filter]
}

enum zksync_Relayer_orderBy {
  id
  isActive
  relayer
}

type zksync_RootCount {
  id: ID!
  count: BigInt
}

input zksync_RootCount_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  count: BigInt
  count_not: BigInt
  count_gt: BigInt
  count_lt: BigInt
  count_gte: BigInt
  count_lte: BigInt
  count_in: [BigInt!]
  count_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: zksync_BlockChangedFilter
  and: [zksync_RootCount_filter]
  or: [zksync_RootCount_filter]
}

enum zksync_RootCount_orderBy {
  id
  count
}

type zksync_RootMessageSent {
  id: ID!
  spokeDomain: BigInt
  hubDomain: BigInt
  root: zksync_Bytes
  count: BigInt
  caller: zksync_Bytes
  transactionHash: zksync_Bytes
  timestamp: BigInt
  gasPrice: BigInt
  gasLimit: BigInt
  blockNumber: BigInt
}

input zksync_RootMessageSent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  spokeDomain: BigInt
  spokeDomain_not: BigInt
  spokeDomain_gt: BigInt
  spokeDomain_lt: BigInt
  spokeDomain_gte: BigInt
  spokeDomain_lte: BigInt
  spokeDomain_in: [BigInt!]
  spokeDomain_not_in: [BigInt!]
  hubDomain: BigInt
  hubDomain_not: BigInt
  hubDomain_gt: BigInt
  hubDomain_lt: BigInt
  hubDomain_gte: BigInt
  hubDomain_lte: BigInt
  hubDomain_in: [BigInt!]
  hubDomain_not_in: [BigInt!]
  root: zksync_Bytes
  root_not: zksync_Bytes
  root_gt: zksync_Bytes
  root_lt: zksync_Bytes
  root_gte: zksync_Bytes
  root_lte: zksync_Bytes
  root_in: [zksync_Bytes!]
  root_not_in: [zksync_Bytes!]
  root_contains: zksync_Bytes
  root_not_contains: zksync_Bytes
  count: BigInt
  count_not: BigInt
  count_gt: BigInt
  count_lt: BigInt
  count_gte: BigInt
  count_lte: BigInt
  count_in: [BigInt!]
  count_not_in: [BigInt!]
  caller: zksync_Bytes
  caller_not: zksync_Bytes
  caller_gt: zksync_Bytes
  caller_lt: zksync_Bytes
  caller_gte: zksync_Bytes
  caller_lte: zksync_Bytes
  caller_in: [zksync_Bytes!]
  caller_not_in: [zksync_Bytes!]
  caller_contains: zksync_Bytes
  caller_not_contains: zksync_Bytes
  transactionHash: zksync_Bytes
  transactionHash_not: zksync_Bytes
  transactionHash_gt: zksync_Bytes
  transactionHash_lt: zksync_Bytes
  transactionHash_gte: zksync_Bytes
  transactionHash_lte: zksync_Bytes
  transactionHash_in: [zksync_Bytes!]
  transactionHash_not_in: [zksync_Bytes!]
  transactionHash_contains: zksync_Bytes
  transactionHash_not_contains: zksync_Bytes
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  gasLimit: BigInt
  gasLimit_not: BigInt
  gasLimit_gt: BigInt
  gasLimit_lt: BigInt
  gasLimit_gte: BigInt
  gasLimit_lte: BigInt
  gasLimit_in: [BigInt!]
  gasLimit_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: zksync_BlockChangedFilter
  and: [zksync_RootMessageSent_filter]
  or: [zksync_RootMessageSent_filter]
}

enum zksync_RootMessageSent_orderBy {
  id
  spokeDomain
  hubDomain
  root
  count
  caller
  transactionHash
  timestamp
  gasPrice
  gasLimit
  blockNumber
}

type zksync_Router {
  id: ID!
  isActive: Boolean!
  owner: zksync_Bytes
  recipient: zksync_Bytes
  proposedOwner: zksync_Bytes
  proposedTimestamp: BigInt
  assetBalances(skip: Int = 0, first: Int = 100, orderBy: zksync_AssetBalance_orderBy, orderDirection: zksync_OrderDirection, where: zksync_AssetBalance_filter): [zksync_AssetBalance!]!
}

type zksync_RouterDailyTVL {
  id: ID!
  router: zksync_Router!
  asset: zksync_Asset!
  timestamp: BigInt!
  balance: BigInt!
}

input zksync_RouterDailyTVL_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  router: String
  router_not: String
  router_gt: String
  router_lt: String
  router_gte: String
  router_lte: String
  router_in: [String!]
  router_not_in: [String!]
  router_contains: String
  router_contains_nocase: String
  router_not_contains: String
  router_not_contains_nocase: String
  router_starts_with: String
  router_starts_with_nocase: String
  router_not_starts_with: String
  router_not_starts_with_nocase: String
  router_ends_with: String
  router_ends_with_nocase: String
  router_not_ends_with: String
  router_not_ends_with_nocase: String
  router_: zksync_Router_filter
  asset: String
  asset_not: String
  asset_gt: String
  asset_lt: String
  asset_gte: String
  asset_lte: String
  asset_in: [String!]
  asset_not_in: [String!]
  asset_contains: String
  asset_contains_nocase: String
  asset_not_contains: String
  asset_not_contains_nocase: String
  asset_starts_with: String
  asset_starts_with_nocase: String
  asset_not_starts_with: String
  asset_not_starts_with_nocase: String
  asset_ends_with: String
  asset_ends_with_nocase: String
  asset_not_ends_with: String
  asset_not_ends_with_nocase: String
  asset_: zksync_Asset_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  balance: BigInt
  balance_not: BigInt
  balance_gt: BigInt
  balance_lt: BigInt
  balance_gte: BigInt
  balance_lte: BigInt
  balance_in: [BigInt!]
  balance_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: zksync_BlockChangedFilter
  and: [zksync_RouterDailyTVL_filter]
  or: [zksync_RouterDailyTVL_filter]
}

enum zksync_RouterDailyTVL_orderBy {
  id
  router
  router__id
  router__isActive
  router__owner
  router__recipient
  router__proposedOwner
  router__proposedTimestamp
  asset
  asset__id
  asset__key
  asset__decimal
  asset__adoptedDecimal
  asset__canonicalId
  asset__canonicalDomain
  asset__adoptedAsset
  asset__localAsset
  asset__blockNumber
  timestamp
  balance
}

type zksync_RouterLiquidityEvent {
  id: ID!
  type: zksync_RouterLiquidityEventType
  router: zksync_Router!
  asset: zksync_Asset!
  amount: BigInt!
  balance: BigInt!
  caller: zksync_Bytes
  blockNumber: BigInt!
  timestamp: BigInt!
  transactionHash: zksync_Bytes!
  nonce: BigInt!
}

enum zksync_RouterLiquidityEventType {
  Add
  Remove
}

input zksync_RouterLiquidityEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  type: zksync_RouterLiquidityEventType
  type_not: zksync_RouterLiquidityEventType
  type_in: [zksync_RouterLiquidityEventType!]
  type_not_in: [zksync_RouterLiquidityEventType!]
  router: String
  router_not: String
  router_gt: String
  router_lt: String
  router_gte: String
  router_lte: String
  router_in: [String!]
  router_not_in: [String!]
  router_contains: String
  router_contains_nocase: String
  router_not_contains: String
  router_not_contains_nocase: String
  router_starts_with: String
  router_starts_with_nocase: String
  router_not_starts_with: String
  router_not_starts_with_nocase: String
  router_ends_with: String
  router_ends_with_nocase: String
  router_not_ends_with: String
  router_not_ends_with_nocase: String
  router_: zksync_Router_filter
  asset: String
  asset_not: String
  asset_gt: String
  asset_lt: String
  asset_gte: String
  asset_lte: String
  asset_in: [String!]
  asset_not_in: [String!]
  asset_contains: String
  asset_contains_nocase: String
  asset_not_contains: String
  asset_not_contains_nocase: String
  asset_starts_with: String
  asset_starts_with_nocase: String
  asset_not_starts_with: String
  asset_not_starts_with_nocase: String
  asset_ends_with: String
  asset_ends_with_nocase: String
  asset_not_ends_with: String
  asset_not_ends_with_nocase: String
  asset_: zksync_Asset_filter
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  balance: BigInt
  balance_not: BigInt
  balance_gt: BigInt
  balance_lt: BigInt
  balance_gte: BigInt
  balance_lte: BigInt
  balance_in: [BigInt!]
  balance_not_in: [BigInt!]
  caller: zksync_Bytes
  caller_not: zksync_Bytes
  caller_gt: zksync_Bytes
  caller_lt: zksync_Bytes
  caller_gte: zksync_Bytes
  caller_lte: zksync_Bytes
  caller_in: [zksync_Bytes!]
  caller_not_in: [zksync_Bytes!]
  caller_contains: zksync_Bytes
  caller_not_contains: zksync_Bytes
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transactionHash: zksync_Bytes
  transactionHash_not: zksync_Bytes
  transactionHash_gt: zksync_Bytes
  transactionHash_lt: zksync_Bytes
  transactionHash_gte: zksync_Bytes
  transactionHash_lte: zksync_Bytes
  transactionHash_in: [zksync_Bytes!]
  transactionHash_not_in: [zksync_Bytes!]
  transactionHash_contains: zksync_Bytes
  transactionHash_not_contains: zksync_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: zksync_BlockChangedFilter
  and: [zksync_RouterLiquidityEvent_filter]
  or: [zksync_RouterLiquidityEvent_filter]
}

enum zksync_RouterLiquidityEvent_orderBy {
  id
  type
  router
  router__id
  router__isActive
  router__owner
  router__recipient
  router__proposedOwner
  router__proposedTimestamp
  asset
  asset__id
  asset__key
  asset__decimal
  asset__adoptedDecimal
  asset__canonicalId
  asset__canonicalDomain
  asset__adoptedAsset
  asset__localAsset
  asset__blockNumber
  amount
  balance
  caller
  blockNumber
  timestamp
  transactionHash
  nonce
}

input zksync_Router_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  isActive: Boolean
  isActive_not: Boolean
  isActive_in: [Boolean!]
  isActive_not_in: [Boolean!]
  owner: zksync_Bytes
  owner_not: zksync_Bytes
  owner_gt: zksync_Bytes
  owner_lt: zksync_Bytes
  owner_gte: zksync_Bytes
  owner_lte: zksync_Bytes
  owner_in: [zksync_Bytes!]
  owner_not_in: [zksync_Bytes!]
  owner_contains: zksync_Bytes
  owner_not_contains: zksync_Bytes
  recipient: zksync_Bytes
  recipient_not: zksync_Bytes
  recipient_gt: zksync_Bytes
  recipient_lt: zksync_Bytes
  recipient_gte: zksync_Bytes
  recipient_lte: zksync_Bytes
  recipient_in: [zksync_Bytes!]
  recipient_not_in: [zksync_Bytes!]
  recipient_contains: zksync_Bytes
  recipient_not_contains: zksync_Bytes
  proposedOwner: zksync_Bytes
  proposedOwner_not: zksync_Bytes
  proposedOwner_gt: zksync_Bytes
  proposedOwner_lt: zksync_Bytes
  proposedOwner_gte: zksync_Bytes
  proposedOwner_lte: zksync_Bytes
  proposedOwner_in: [zksync_Bytes!]
  proposedOwner_not_in: [zksync_Bytes!]
  proposedOwner_contains: zksync_Bytes
  proposedOwner_not_contains: zksync_Bytes
  proposedTimestamp: BigInt
  proposedTimestamp_not: BigInt
  proposedTimestamp_gt: BigInt
  proposedTimestamp_lt: BigInt
  proposedTimestamp_gte: BigInt
  proposedTimestamp_lte: BigInt
  proposedTimestamp_in: [BigInt!]
  proposedTimestamp_not_in: [BigInt!]
  assetBalances_: zksync_AssetBalance_filter
  """Filter for the block changed event."""
  _change_block: zksync_BlockChangedFilter
  and: [zksync_Router_filter]
  or: [zksync_Router_filter]
}

enum zksync_Router_orderBy {
  id
  isActive
  owner
  recipient
  proposedOwner
  proposedTimestamp
  assetBalances
}

type zksync_Sequencer {
  id: ID!
  isActive: Boolean!
  sequencer: zksync_Bytes
}

input zksync_Sequencer_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  isActive: Boolean
  isActive_not: Boolean
  isActive_in: [Boolean!]
  isActive_not_in: [Boolean!]
  sequencer: zksync_Bytes
  sequencer_not: zksync_Bytes
  sequencer_gt: zksync_Bytes
  sequencer_lt: zksync_Bytes
  sequencer_gte: zksync_Bytes
  sequencer_lte: zksync_Bytes
  sequencer_in: [zksync_Bytes!]
  sequencer_not_in: [zksync_Bytes!]
  sequencer_contains: zksync_Bytes
  sequencer_not_contains: zksync_Bytes
  """Filter for the block changed event."""
  _change_block: zksync_BlockChangedFilter
  and: [zksync_Sequencer_filter]
  or: [zksync_Sequencer_filter]
}

enum zksync_Sequencer_orderBy {
  id
  isActive
  sequencer
}

type zksync_Setting {
  id: ID!
  maxRoutersPerTransfer: BigInt!
  caller: zksync_Bytes!
}

input zksync_Setting_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  maxRoutersPerTransfer: BigInt
  maxRoutersPerTransfer_not: BigInt
  maxRoutersPerTransfer_gt: BigInt
  maxRoutersPerTransfer_lt: BigInt
  maxRoutersPerTransfer_gte: BigInt
  maxRoutersPerTransfer_lte: BigInt
  maxRoutersPerTransfer_in: [BigInt!]
  maxRoutersPerTransfer_not_in: [BigInt!]
  caller: zksync_Bytes
  caller_not: zksync_Bytes
  caller_gt: zksync_Bytes
  caller_lt: zksync_Bytes
  caller_gte: zksync_Bytes
  caller_lte: zksync_Bytes
  caller_in: [zksync_Bytes!]
  caller_not_in: [zksync_Bytes!]
  caller_contains: zksync_Bytes
  caller_not_contains: zksync_Bytes
  """Filter for the block changed event."""
  _change_block: zksync_BlockChangedFilter
  and: [zksync_Setting_filter]
  or: [zksync_Setting_filter]
}

enum zksync_Setting_orderBy {
  id
  maxRoutersPerTransfer
  caller
}

type zksync_SlippageUpdate {
  id: ID!
  transfer: zksync_DestinationTransfer!
  slippage: BigInt!
  caller: zksync_Bytes!
  transactionHash: zksync_Bytes!
  timestamp: BigInt!
  gasPrice: BigInt!
  gasLimit: BigInt!
  blockNumber: BigInt!
}

input zksync_SlippageUpdate_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transfer: String
  transfer_not: String
  transfer_gt: String
  transfer_lt: String
  transfer_gte: String
  transfer_lte: String
  transfer_in: [String!]
  transfer_not_in: [String!]
  transfer_contains: String
  transfer_contains_nocase: String
  transfer_not_contains: String
  transfer_not_contains_nocase: String
  transfer_starts_with: String
  transfer_starts_with_nocase: String
  transfer_not_starts_with: String
  transfer_not_starts_with_nocase: String
  transfer_ends_with: String
  transfer_ends_with_nocase: String
  transfer_not_ends_with: String
  transfer_not_ends_with_nocase: String
  transfer_: zksync_DestinationTransfer_filter
  slippage: BigInt
  slippage_not: BigInt
  slippage_gt: BigInt
  slippage_lt: BigInt
  slippage_gte: BigInt
  slippage_lte: BigInt
  slippage_in: [BigInt!]
  slippage_not_in: [BigInt!]
  caller: zksync_Bytes
  caller_not: zksync_Bytes
  caller_gt: zksync_Bytes
  caller_lt: zksync_Bytes
  caller_gte: zksync_Bytes
  caller_lte: zksync_Bytes
  caller_in: [zksync_Bytes!]
  caller_not_in: [zksync_Bytes!]
  caller_contains: zksync_Bytes
  caller_not_contains: zksync_Bytes
  transactionHash: zksync_Bytes
  transactionHash_not: zksync_Bytes
  transactionHash_gt: zksync_Bytes
  transactionHash_lt: zksync_Bytes
  transactionHash_gte: zksync_Bytes
  transactionHash_lte: zksync_Bytes
  transactionHash_in: [zksync_Bytes!]
  transactionHash_not_in: [zksync_Bytes!]
  transactionHash_contains: zksync_Bytes
  transactionHash_not_contains: zksync_Bytes
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  gasLimit: BigInt
  gasLimit_not: BigInt
  gasLimit_gt: BigInt
  gasLimit_lt: BigInt
  gasLimit_gte: BigInt
  gasLimit_lte: BigInt
  gasLimit_in: [BigInt!]
  gasLimit_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: zksync_BlockChangedFilter
  and: [zksync_SlippageUpdate_filter]
  or: [zksync_SlippageUpdate_filter]
}

enum zksync_SlippageUpdate_orderBy {
  id
  transfer
  transfer__id
  transfer__chainId
  transfer__transferId
  transfer__nonce
  transfer__status
  transfer__originDomain
  transfer__destinationDomain
  transfer__canonicalDomain
  transfer__to
  transfer__delegate
  transfer__receiveLocal
  transfer__callData
  transfer__slippage
  transfer__bumpSlippageCount
  transfer__originSender
  transfer__bridgedAmt
  transfer__normalizedIn
  transfer__canonicalId
  transfer__amount
  transfer__routersFee
  transfer__executedCaller
  transfer__executedTransactionHash
  transfer__executedTimestamp
  transfer__executedGasPrice
  transfer__executedGasLimit
  transfer__executedBlockNumber
  transfer__executedTxOrigin
  transfer__executedTxNonce
  transfer__reconciledCaller
  transfer__reconciledTransactionHash
  transfer__reconciledTimestamp
  transfer__reconciledGasPrice
  transfer__reconciledGasLimit
  transfer__reconciledBlockNumber
  transfer__reconciledTxOrigin
  transfer__reconciledTxNonce
  slippage
  caller
  transactionHash
  timestamp
  gasPrice
  gasLimit
  blockNumber
}

type zksync_SnapshotRoot {
  id: ID!
  spokeDomain: BigInt
  root: zksync_Bytes!
  count: BigInt!
  timestamp: BigInt!
  blockNumber: BigInt!
}

input zksync_SnapshotRoot_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  spokeDomain: BigInt
  spokeDomain_not: BigInt
  spokeDomain_gt: BigInt
  spokeDomain_lt: BigInt
  spokeDomain_gte: BigInt
  spokeDomain_lte: BigInt
  spokeDomain_in: [BigInt!]
  spokeDomain_not_in: [BigInt!]
  root: zksync_Bytes
  root_not: zksync_Bytes
  root_gt: zksync_Bytes
  root_lt: zksync_Bytes
  root_gte: zksync_Bytes
  root_lte: zksync_Bytes
  root_in: [zksync_Bytes!]
  root_not_in: [zksync_Bytes!]
  root_contains: zksync_Bytes
  root_not_contains: zksync_Bytes
  count: BigInt
  count_not: BigInt
  count_gt: BigInt
  count_lt: BigInt
  count_gte: BigInt
  count_lte: BigInt
  count_in: [BigInt!]
  count_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: zksync_BlockChangedFilter
  and: [zksync_SnapshotRoot_filter]
  or: [zksync_SnapshotRoot_filter]
}

enum zksync_SnapshotRoot_orderBy {
  id
  spokeDomain
  root
  count
  timestamp
  blockNumber
}

type zksync_SpokeConnectorMode {
  id: ID!
  mode: String!
}

input zksync_SpokeConnectorMode_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  mode: String
  mode_not: String
  mode_gt: String
  mode_lt: String
  mode_gte: String
  mode_lte: String
  mode_in: [String!]
  mode_not_in: [String!]
  mode_contains: String
  mode_contains_nocase: String
  mode_not_contains: String
  mode_not_contains_nocase: String
  mode_starts_with: String
  mode_starts_with_nocase: String
  mode_not_starts_with: String
  mode_not_starts_with_nocase: String
  mode_ends_with: String
  mode_ends_with_nocase: String
  mode_not_ends_with: String
  mode_not_ends_with_nocase: String
  """Filter for the block changed event."""
  _change_block: zksync_BlockChangedFilter
  and: [zksync_SpokeConnectorMode_filter]
  or: [zksync_SpokeConnectorMode_filter]
}

enum zksync_SpokeConnectorMode_orderBy {
  id
  mode
}

enum zksync_TransferStatus {
  XCalled
  Executed
  Reconciled
  CompletedSlow
  CompletedFast
}

type zksync__Block_ {
  """The hash of the block"""
  hash: zksync_Bytes
  """The block number"""
  number: Int!
  """Integer representation of the timestamp stored in blocks for the chain"""
  timestamp: Int
  """The hash of the parent block"""
  parentHash: zksync_Bytes
}

"""The type for the top-level _meta field"""
type zksync__Meta_ {
  """
  Information about a specific subgraph block. The hash of the block
  will be null if the _meta field has a block constraint that asks for
  a block number. It will be filled if the _meta field has no block constraint
  and therefore asks for the latest  block
  
  """
  block: zksync__Block_!
  """The deployment ID"""
  deployment: String!
  """If `true`, the subgraph encountered indexing errors at some past block"""
  hasIndexingErrors: Boolean!
}

type linea_AggregateRoot {
  id: ID!
  root: linea_Bytes!
  blockNumber: BigInt!
}

type linea_AggregateRootProposed {
  id: ID!
  aggregateRoot: linea_Bytes!
  rootTimestamp: BigInt!
  endOfDispute: BigInt!
  domain: BigInt!
  timestamp: BigInt!
  blockNumber: BigInt
}

input linea_AggregateRootProposed_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  aggregateRoot: linea_Bytes
  aggregateRoot_not: linea_Bytes
  aggregateRoot_gt: linea_Bytes
  aggregateRoot_lt: linea_Bytes
  aggregateRoot_gte: linea_Bytes
  aggregateRoot_lte: linea_Bytes
  aggregateRoot_in: [linea_Bytes!]
  aggregateRoot_not_in: [linea_Bytes!]
  aggregateRoot_contains: linea_Bytes
  aggregateRoot_not_contains: linea_Bytes
  rootTimestamp: BigInt
  rootTimestamp_not: BigInt
  rootTimestamp_gt: BigInt
  rootTimestamp_lt: BigInt
  rootTimestamp_gte: BigInt
  rootTimestamp_lte: BigInt
  rootTimestamp_in: [BigInt!]
  rootTimestamp_not_in: [BigInt!]
  endOfDispute: BigInt
  endOfDispute_not: BigInt
  endOfDispute_gt: BigInt
  endOfDispute_lt: BigInt
  endOfDispute_gte: BigInt
  endOfDispute_lte: BigInt
  endOfDispute_in: [BigInt!]
  endOfDispute_not_in: [BigInt!]
  domain: BigInt
  domain_not: BigInt
  domain_gt: BigInt
  domain_lt: BigInt
  domain_gte: BigInt
  domain_lte: BigInt
  domain_in: [BigInt!]
  domain_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: linea_BlockChangedFilter
  and: [linea_AggregateRootProposed_filter]
  or: [linea_AggregateRootProposed_filter]
}

enum linea_AggregateRootProposed_orderBy {
  id
  aggregateRoot
  rootTimestamp
  endOfDispute
  domain
  timestamp
  blockNumber
}

input linea_AggregateRoot_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  root: linea_Bytes
  root_not: linea_Bytes
  root_gt: linea_Bytes
  root_lt: linea_Bytes
  root_gte: linea_Bytes
  root_lte: linea_Bytes
  root_in: [linea_Bytes!]
  root_not_in: [linea_Bytes!]
  root_contains: linea_Bytes
  root_not_contains: linea_Bytes
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: linea_BlockChangedFilter
  and: [linea_AggregateRoot_filter]
  or: [linea_AggregateRoot_filter]
}

enum linea_AggregateRoot_orderBy {
  id
  root
  blockNumber
}

enum linea_Aggregation_interval {
  hour
  day
}

type linea_Asset {
  id: ID!
  key: linea_Bytes
  decimal: BigInt
  adoptedDecimal: BigInt
  canonicalId: linea_Bytes
  canonicalDomain: BigInt
  adoptedAsset: linea_Bytes
  localAsset: linea_Bytes
  blockNumber: BigInt
  status: linea_AssetStatus
}

type linea_AssetBalance {
  id: ID!
  amount: BigInt!
  locked: BigInt!
  supplied: BigInt!
  removed: BigInt!
  router: linea_Router!
  asset: linea_Asset!
  feesEarned: BigInt!
}

input linea_AssetBalance_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  locked: BigInt
  locked_not: BigInt
  locked_gt: BigInt
  locked_lt: BigInt
  locked_gte: BigInt
  locked_lte: BigInt
  locked_in: [BigInt!]
  locked_not_in: [BigInt!]
  supplied: BigInt
  supplied_not: BigInt
  supplied_gt: BigInt
  supplied_lt: BigInt
  supplied_gte: BigInt
  supplied_lte: BigInt
  supplied_in: [BigInt!]
  supplied_not_in: [BigInt!]
  removed: BigInt
  removed_not: BigInt
  removed_gt: BigInt
  removed_lt: BigInt
  removed_gte: BigInt
  removed_lte: BigInt
  removed_in: [BigInt!]
  removed_not_in: [BigInt!]
  router: String
  router_not: String
  router_gt: String
  router_lt: String
  router_gte: String
  router_lte: String
  router_in: [String!]
  router_not_in: [String!]
  router_contains: String
  router_contains_nocase: String
  router_not_contains: String
  router_not_contains_nocase: String
  router_starts_with: String
  router_starts_with_nocase: String
  router_not_starts_with: String
  router_not_starts_with_nocase: String
  router_ends_with: String
  router_ends_with_nocase: String
  router_not_ends_with: String
  router_not_ends_with_nocase: String
  router_: linea_Router_filter
  asset: String
  asset_not: String
  asset_gt: String
  asset_lt: String
  asset_gte: String
  asset_lte: String
  asset_in: [String!]
  asset_not_in: [String!]
  asset_contains: String
  asset_contains_nocase: String
  asset_not_contains: String
  asset_not_contains_nocase: String
  asset_starts_with: String
  asset_starts_with_nocase: String
  asset_not_starts_with: String
  asset_not_starts_with_nocase: String
  asset_ends_with: String
  asset_ends_with_nocase: String
  asset_not_ends_with: String
  asset_not_ends_with_nocase: String
  asset_: linea_Asset_filter
  feesEarned: BigInt
  feesEarned_not: BigInt
  feesEarned_gt: BigInt
  feesEarned_lt: BigInt
  feesEarned_gte: BigInt
  feesEarned_lte: BigInt
  feesEarned_in: [BigInt!]
  feesEarned_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: linea_BlockChangedFilter
  and: [linea_AssetBalance_filter]
  or: [linea_AssetBalance_filter]
}

enum linea_AssetBalance_orderBy {
  id
  amount
  locked
  supplied
  removed
  router
  router__id
  router__isActive
  router__owner
  router__recipient
  router__proposedOwner
  router__proposedTimestamp
  asset
  asset__id
  asset__key
  asset__decimal
  asset__adoptedDecimal
  asset__canonicalId
  asset__canonicalDomain
  asset__adoptedAsset
  asset__localAsset
  asset__blockNumber
  feesEarned
}

type linea_AssetStatus {
  id: ID!
  status: Boolean
}

input linea_AssetStatus_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  status: Boolean
  status_not: Boolean
  status_in: [Boolean!]
  status_not_in: [Boolean!]
  """Filter for the block changed event."""
  _change_block: linea_BlockChangedFilter
  and: [linea_AssetStatus_filter]
  or: [linea_AssetStatus_filter]
}

enum linea_AssetStatus_orderBy {
  id
  status
}

input linea_Asset_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  key: linea_Bytes
  key_not: linea_Bytes
  key_gt: linea_Bytes
  key_lt: linea_Bytes
  key_gte: linea_Bytes
  key_lte: linea_Bytes
  key_in: [linea_Bytes!]
  key_not_in: [linea_Bytes!]
  key_contains: linea_Bytes
  key_not_contains: linea_Bytes
  decimal: BigInt
  decimal_not: BigInt
  decimal_gt: BigInt
  decimal_lt: BigInt
  decimal_gte: BigInt
  decimal_lte: BigInt
  decimal_in: [BigInt!]
  decimal_not_in: [BigInt!]
  adoptedDecimal: BigInt
  adoptedDecimal_not: BigInt
  adoptedDecimal_gt: BigInt
  adoptedDecimal_lt: BigInt
  adoptedDecimal_gte: BigInt
  adoptedDecimal_lte: BigInt
  adoptedDecimal_in: [BigInt!]
  adoptedDecimal_not_in: [BigInt!]
  canonicalId: linea_Bytes
  canonicalId_not: linea_Bytes
  canonicalId_gt: linea_Bytes
  canonicalId_lt: linea_Bytes
  canonicalId_gte: linea_Bytes
  canonicalId_lte: linea_Bytes
  canonicalId_in: [linea_Bytes!]
  canonicalId_not_in: [linea_Bytes!]
  canonicalId_contains: linea_Bytes
  canonicalId_not_contains: linea_Bytes
  canonicalDomain: BigInt
  canonicalDomain_not: BigInt
  canonicalDomain_gt: BigInt
  canonicalDomain_lt: BigInt
  canonicalDomain_gte: BigInt
  canonicalDomain_lte: BigInt
  canonicalDomain_in: [BigInt!]
  canonicalDomain_not_in: [BigInt!]
  adoptedAsset: linea_Bytes
  adoptedAsset_not: linea_Bytes
  adoptedAsset_gt: linea_Bytes
  adoptedAsset_lt: linea_Bytes
  adoptedAsset_gte: linea_Bytes
  adoptedAsset_lte: linea_Bytes
  adoptedAsset_in: [linea_Bytes!]
  adoptedAsset_not_in: [linea_Bytes!]
  adoptedAsset_contains: linea_Bytes
  adoptedAsset_not_contains: linea_Bytes
  localAsset: linea_Bytes
  localAsset_not: linea_Bytes
  localAsset_gt: linea_Bytes
  localAsset_lt: linea_Bytes
  localAsset_gte: linea_Bytes
  localAsset_lte: linea_Bytes
  localAsset_in: [linea_Bytes!]
  localAsset_not_in: [linea_Bytes!]
  localAsset_contains: linea_Bytes
  localAsset_not_contains: linea_Bytes
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  status: String
  status_not: String
  status_gt: String
  status_lt: String
  status_gte: String
  status_lte: String
  status_in: [String!]
  status_not_in: [String!]
  status_contains: String
  status_contains_nocase: String
  status_not_contains: String
  status_not_contains_nocase: String
  status_starts_with: String
  status_starts_with_nocase: String
  status_not_starts_with: String
  status_not_starts_with_nocase: String
  status_ends_with: String
  status_ends_with_nocase: String
  status_not_ends_with: String
  status_not_ends_with_nocase: String
  status_: linea_AssetStatus_filter
  """Filter for the block changed event."""
  _change_block: linea_BlockChangedFilter
  and: [linea_Asset_filter]
  or: [linea_Asset_filter]
}

enum linea_Asset_orderBy {
  id
  key
  decimal
  adoptedDecimal
  canonicalId
  canonicalDomain
  adoptedAsset
  localAsset
  blockNumber
  status
  status__id
  status__status
}

scalar linea_BigDecimal

input linea_BlockChangedFilter {
  number_gte: Int!
}

input linea_Block_height {
  hash: linea_Bytes
  number: Int
  number_gte: Int
}

scalar linea_Bytes

type linea_ConnectorMeta {
  id: ID!
  spokeDomain: BigInt
  hubDomain: BigInt
  amb: linea_Bytes
  rootManager: linea_Bytes
  mirrorConnector: linea_Bytes
}

input linea_ConnectorMeta_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  spokeDomain: BigInt
  spokeDomain_not: BigInt
  spokeDomain_gt: BigInt
  spokeDomain_lt: BigInt
  spokeDomain_gte: BigInt
  spokeDomain_lte: BigInt
  spokeDomain_in: [BigInt!]
  spokeDomain_not_in: [BigInt!]
  hubDomain: BigInt
  hubDomain_not: BigInt
  hubDomain_gt: BigInt
  hubDomain_lt: BigInt
  hubDomain_gte: BigInt
  hubDomain_lte: BigInt
  hubDomain_in: [BigInt!]
  hubDomain_not_in: [BigInt!]
  amb: linea_Bytes
  amb_not: linea_Bytes
  amb_gt: linea_Bytes
  amb_lt: linea_Bytes
  amb_gte: linea_Bytes
  amb_lte: linea_Bytes
  amb_in: [linea_Bytes!]
  amb_not_in: [linea_Bytes!]
  amb_contains: linea_Bytes
  amb_not_contains: linea_Bytes
  rootManager: linea_Bytes
  rootManager_not: linea_Bytes
  rootManager_gt: linea_Bytes
  rootManager_lt: linea_Bytes
  rootManager_gte: linea_Bytes
  rootManager_lte: linea_Bytes
  rootManager_in: [linea_Bytes!]
  rootManager_not_in: [linea_Bytes!]
  rootManager_contains: linea_Bytes
  rootManager_not_contains: linea_Bytes
  mirrorConnector: linea_Bytes
  mirrorConnector_not: linea_Bytes
  mirrorConnector_gt: linea_Bytes
  mirrorConnector_lt: linea_Bytes
  mirrorConnector_gte: linea_Bytes
  mirrorConnector_lte: linea_Bytes
  mirrorConnector_in: [linea_Bytes!]
  mirrorConnector_not_in: [linea_Bytes!]
  mirrorConnector_contains: linea_Bytes
  mirrorConnector_not_contains: linea_Bytes
  """Filter for the block changed event."""
  _change_block: linea_BlockChangedFilter
  and: [linea_ConnectorMeta_filter]
  or: [linea_ConnectorMeta_filter]
}

enum linea_ConnectorMeta_orderBy {
  id
  spokeDomain
  hubDomain
  amb
  rootManager
  mirrorConnector
}

type linea_DestinationTransfer {
  id: ID!
  chainId: BigInt
  transferId: linea_Bytes
  nonce: BigInt
  status: linea_TransferStatus
  routers(skip: Int = 0, first: Int = 100, orderBy: linea_Router_orderBy, orderDirection: linea_OrderDirection, where: linea_Router_filter): [linea_Router!]
  originDomain: BigInt
  destinationDomain: BigInt
  canonicalDomain: BigInt
  to: linea_Bytes
  delegate: linea_Bytes
  receiveLocal: Boolean
  callData: linea_Bytes
  slippage: BigInt
  bumpSlippageCount: BigInt
  originSender: linea_Bytes
  bridgedAmt: BigInt
  normalizedIn: BigInt
  canonicalId: linea_Bytes
  asset: linea_Asset
  amount: BigInt
  routersFee: BigInt
  executedCaller: linea_Bytes
  executedTransactionHash: linea_Bytes
  executedTimestamp: BigInt
  executedGasPrice: BigInt
  executedGasLimit: BigInt
  executedBlockNumber: BigInt
  executedTxOrigin: linea_Bytes
  executedTxNonce: BigInt
  reconciledCaller: linea_Bytes
  reconciledTransactionHash: linea_Bytes
  reconciledTimestamp: BigInt
  reconciledGasPrice: BigInt
  reconciledGasLimit: BigInt
  reconciledBlockNumber: BigInt
  reconciledTxOrigin: linea_Bytes
  reconciledTxNonce: BigInt
}

input linea_DestinationTransfer_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  chainId: BigInt
  chainId_not: BigInt
  chainId_gt: BigInt
  chainId_lt: BigInt
  chainId_gte: BigInt
  chainId_lte: BigInt
  chainId_in: [BigInt!]
  chainId_not_in: [BigInt!]
  transferId: linea_Bytes
  transferId_not: linea_Bytes
  transferId_gt: linea_Bytes
  transferId_lt: linea_Bytes
  transferId_gte: linea_Bytes
  transferId_lte: linea_Bytes
  transferId_in: [linea_Bytes!]
  transferId_not_in: [linea_Bytes!]
  transferId_contains: linea_Bytes
  transferId_not_contains: linea_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  status: linea_TransferStatus
  status_not: linea_TransferStatus
  status_in: [linea_TransferStatus!]
  status_not_in: [linea_TransferStatus!]
  routers: [String!]
  routers_not: [String!]
  routers_contains: [String!]
  routers_contains_nocase: [String!]
  routers_not_contains: [String!]
  routers_not_contains_nocase: [String!]
  routers_: linea_Router_filter
  originDomain: BigInt
  originDomain_not: BigInt
  originDomain_gt: BigInt
  originDomain_lt: BigInt
  originDomain_gte: BigInt
  originDomain_lte: BigInt
  originDomain_in: [BigInt!]
  originDomain_not_in: [BigInt!]
  destinationDomain: BigInt
  destinationDomain_not: BigInt
  destinationDomain_gt: BigInt
  destinationDomain_lt: BigInt
  destinationDomain_gte: BigInt
  destinationDomain_lte: BigInt
  destinationDomain_in: [BigInt!]
  destinationDomain_not_in: [BigInt!]
  canonicalDomain: BigInt
  canonicalDomain_not: BigInt
  canonicalDomain_gt: BigInt
  canonicalDomain_lt: BigInt
  canonicalDomain_gte: BigInt
  canonicalDomain_lte: BigInt
  canonicalDomain_in: [BigInt!]
  canonicalDomain_not_in: [BigInt!]
  to: linea_Bytes
  to_not: linea_Bytes
  to_gt: linea_Bytes
  to_lt: linea_Bytes
  to_gte: linea_Bytes
  to_lte: linea_Bytes
  to_in: [linea_Bytes!]
  to_not_in: [linea_Bytes!]
  to_contains: linea_Bytes
  to_not_contains: linea_Bytes
  delegate: linea_Bytes
  delegate_not: linea_Bytes
  delegate_gt: linea_Bytes
  delegate_lt: linea_Bytes
  delegate_gte: linea_Bytes
  delegate_lte: linea_Bytes
  delegate_in: [linea_Bytes!]
  delegate_not_in: [linea_Bytes!]
  delegate_contains: linea_Bytes
  delegate_not_contains: linea_Bytes
  receiveLocal: Boolean
  receiveLocal_not: Boolean
  receiveLocal_in: [Boolean!]
  receiveLocal_not_in: [Boolean!]
  callData: linea_Bytes
  callData_not: linea_Bytes
  callData_gt: linea_Bytes
  callData_lt: linea_Bytes
  callData_gte: linea_Bytes
  callData_lte: linea_Bytes
  callData_in: [linea_Bytes!]
  callData_not_in: [linea_Bytes!]
  callData_contains: linea_Bytes
  callData_not_contains: linea_Bytes
  slippage: BigInt
  slippage_not: BigInt
  slippage_gt: BigInt
  slippage_lt: BigInt
  slippage_gte: BigInt
  slippage_lte: BigInt
  slippage_in: [BigInt!]
  slippage_not_in: [BigInt!]
  bumpSlippageCount: BigInt
  bumpSlippageCount_not: BigInt
  bumpSlippageCount_gt: BigInt
  bumpSlippageCount_lt: BigInt
  bumpSlippageCount_gte: BigInt
  bumpSlippageCount_lte: BigInt
  bumpSlippageCount_in: [BigInt!]
  bumpSlippageCount_not_in: [BigInt!]
  originSender: linea_Bytes
  originSender_not: linea_Bytes
  originSender_gt: linea_Bytes
  originSender_lt: linea_Bytes
  originSender_gte: linea_Bytes
  originSender_lte: linea_Bytes
  originSender_in: [linea_Bytes!]
  originSender_not_in: [linea_Bytes!]
  originSender_contains: linea_Bytes
  originSender_not_contains: linea_Bytes
  bridgedAmt: BigInt
  bridgedAmt_not: BigInt
  bridgedAmt_gt: BigInt
  bridgedAmt_lt: BigInt
  bridgedAmt_gte: BigInt
  bridgedAmt_lte: BigInt
  bridgedAmt_in: [BigInt!]
  bridgedAmt_not_in: [BigInt!]
  normalizedIn: BigInt
  normalizedIn_not: BigInt
  normalizedIn_gt: BigInt
  normalizedIn_lt: BigInt
  normalizedIn_gte: BigInt
  normalizedIn_lte: BigInt
  normalizedIn_in: [BigInt!]
  normalizedIn_not_in: [BigInt!]
  canonicalId: linea_Bytes
  canonicalId_not: linea_Bytes
  canonicalId_gt: linea_Bytes
  canonicalId_lt: linea_Bytes
  canonicalId_gte: linea_Bytes
  canonicalId_lte: linea_Bytes
  canonicalId_in: [linea_Bytes!]
  canonicalId_not_in: [linea_Bytes!]
  canonicalId_contains: linea_Bytes
  canonicalId_not_contains: linea_Bytes
  asset: String
  asset_not: String
  asset_gt: String
  asset_lt: String
  asset_gte: String
  asset_lte: String
  asset_in: [String!]
  asset_not_in: [String!]
  asset_contains: String
  asset_contains_nocase: String
  asset_not_contains: String
  asset_not_contains_nocase: String
  asset_starts_with: String
  asset_starts_with_nocase: String
  asset_not_starts_with: String
  asset_not_starts_with_nocase: String
  asset_ends_with: String
  asset_ends_with_nocase: String
  asset_not_ends_with: String
  asset_not_ends_with_nocase: String
  asset_: linea_Asset_filter
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  routersFee: BigInt
  routersFee_not: BigInt
  routersFee_gt: BigInt
  routersFee_lt: BigInt
  routersFee_gte: BigInt
  routersFee_lte: BigInt
  routersFee_in: [BigInt!]
  routersFee_not_in: [BigInt!]
  executedCaller: linea_Bytes
  executedCaller_not: linea_Bytes
  executedCaller_gt: linea_Bytes
  executedCaller_lt: linea_Bytes
  executedCaller_gte: linea_Bytes
  executedCaller_lte: linea_Bytes
  executedCaller_in: [linea_Bytes!]
  executedCaller_not_in: [linea_Bytes!]
  executedCaller_contains: linea_Bytes
  executedCaller_not_contains: linea_Bytes
  executedTransactionHash: linea_Bytes
  executedTransactionHash_not: linea_Bytes
  executedTransactionHash_gt: linea_Bytes
  executedTransactionHash_lt: linea_Bytes
  executedTransactionHash_gte: linea_Bytes
  executedTransactionHash_lte: linea_Bytes
  executedTransactionHash_in: [linea_Bytes!]
  executedTransactionHash_not_in: [linea_Bytes!]
  executedTransactionHash_contains: linea_Bytes
  executedTransactionHash_not_contains: linea_Bytes
  executedTimestamp: BigInt
  executedTimestamp_not: BigInt
  executedTimestamp_gt: BigInt
  executedTimestamp_lt: BigInt
  executedTimestamp_gte: BigInt
  executedTimestamp_lte: BigInt
  executedTimestamp_in: [BigInt!]
  executedTimestamp_not_in: [BigInt!]
  executedGasPrice: BigInt
  executedGasPrice_not: BigInt
  executedGasPrice_gt: BigInt
  executedGasPrice_lt: BigInt
  executedGasPrice_gte: BigInt
  executedGasPrice_lte: BigInt
  executedGasPrice_in: [BigInt!]
  executedGasPrice_not_in: [BigInt!]
  executedGasLimit: BigInt
  executedGasLimit_not: BigInt
  executedGasLimit_gt: BigInt
  executedGasLimit_lt: BigInt
  executedGasLimit_gte: BigInt
  executedGasLimit_lte: BigInt
  executedGasLimit_in: [BigInt!]
  executedGasLimit_not_in: [BigInt!]
  executedBlockNumber: BigInt
  executedBlockNumber_not: BigInt
  executedBlockNumber_gt: BigInt
  executedBlockNumber_lt: BigInt
  executedBlockNumber_gte: BigInt
  executedBlockNumber_lte: BigInt
  executedBlockNumber_in: [BigInt!]
  executedBlockNumber_not_in: [BigInt!]
  executedTxOrigin: linea_Bytes
  executedTxOrigin_not: linea_Bytes
  executedTxOrigin_gt: linea_Bytes
  executedTxOrigin_lt: linea_Bytes
  executedTxOrigin_gte: linea_Bytes
  executedTxOrigin_lte: linea_Bytes
  executedTxOrigin_in: [linea_Bytes!]
  executedTxOrigin_not_in: [linea_Bytes!]
  executedTxOrigin_contains: linea_Bytes
  executedTxOrigin_not_contains: linea_Bytes
  executedTxNonce: BigInt
  executedTxNonce_not: BigInt
  executedTxNonce_gt: BigInt
  executedTxNonce_lt: BigInt
  executedTxNonce_gte: BigInt
  executedTxNonce_lte: BigInt
  executedTxNonce_in: [BigInt!]
  executedTxNonce_not_in: [BigInt!]
  reconciledCaller: linea_Bytes
  reconciledCaller_not: linea_Bytes
  reconciledCaller_gt: linea_Bytes
  reconciledCaller_lt: linea_Bytes
  reconciledCaller_gte: linea_Bytes
  reconciledCaller_lte: linea_Bytes
  reconciledCaller_in: [linea_Bytes!]
  reconciledCaller_not_in: [linea_Bytes!]
  reconciledCaller_contains: linea_Bytes
  reconciledCaller_not_contains: linea_Bytes
  reconciledTransactionHash: linea_Bytes
  reconciledTransactionHash_not: linea_Bytes
  reconciledTransactionHash_gt: linea_Bytes
  reconciledTransactionHash_lt: linea_Bytes
  reconciledTransactionHash_gte: linea_Bytes
  reconciledTransactionHash_lte: linea_Bytes
  reconciledTransactionHash_in: [linea_Bytes!]
  reconciledTransactionHash_not_in: [linea_Bytes!]
  reconciledTransactionHash_contains: linea_Bytes
  reconciledTransactionHash_not_contains: linea_Bytes
  reconciledTimestamp: BigInt
  reconciledTimestamp_not: BigInt
  reconciledTimestamp_gt: BigInt
  reconciledTimestamp_lt: BigInt
  reconciledTimestamp_gte: BigInt
  reconciledTimestamp_lte: BigInt
  reconciledTimestamp_in: [BigInt!]
  reconciledTimestamp_not_in: [BigInt!]
  reconciledGasPrice: BigInt
  reconciledGasPrice_not: BigInt
  reconciledGasPrice_gt: BigInt
  reconciledGasPrice_lt: BigInt
  reconciledGasPrice_gte: BigInt
  reconciledGasPrice_lte: BigInt
  reconciledGasPrice_in: [BigInt!]
  reconciledGasPrice_not_in: [BigInt!]
  reconciledGasLimit: BigInt
  reconciledGasLimit_not: BigInt
  reconciledGasLimit_gt: BigInt
  reconciledGasLimit_lt: BigInt
  reconciledGasLimit_gte: BigInt
  reconciledGasLimit_lte: BigInt
  reconciledGasLimit_in: [BigInt!]
  reconciledGasLimit_not_in: [BigInt!]
  reconciledBlockNumber: BigInt
  reconciledBlockNumber_not: BigInt
  reconciledBlockNumber_gt: BigInt
  reconciledBlockNumber_lt: BigInt
  reconciledBlockNumber_gte: BigInt
  reconciledBlockNumber_lte: BigInt
  reconciledBlockNumber_in: [BigInt!]
  reconciledBlockNumber_not_in: [BigInt!]
  reconciledTxOrigin: linea_Bytes
  reconciledTxOrigin_not: linea_Bytes
  reconciledTxOrigin_gt: linea_Bytes
  reconciledTxOrigin_lt: linea_Bytes
  reconciledTxOrigin_gte: linea_Bytes
  reconciledTxOrigin_lte: linea_Bytes
  reconciledTxOrigin_in: [linea_Bytes!]
  reconciledTxOrigin_not_in: [linea_Bytes!]
  reconciledTxOrigin_contains: linea_Bytes
  reconciledTxOrigin_not_contains: linea_Bytes
  reconciledTxNonce: BigInt
  reconciledTxNonce_not: BigInt
  reconciledTxNonce_gt: BigInt
  reconciledTxNonce_lt: BigInt
  reconciledTxNonce_gte: BigInt
  reconciledTxNonce_lte: BigInt
  reconciledTxNonce_in: [BigInt!]
  reconciledTxNonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: linea_BlockChangedFilter
  and: [linea_DestinationTransfer_filter]
  or: [linea_DestinationTransfer_filter]
}

enum linea_DestinationTransfer_orderBy {
  id
  chainId
  transferId
  nonce
  status
  routers
  originDomain
  destinationDomain
  canonicalDomain
  to
  delegate
  receiveLocal
  callData
  slippage
  bumpSlippageCount
  originSender
  bridgedAmt
  normalizedIn
  canonicalId
  asset
  asset__id
  asset__key
  asset__decimal
  asset__adoptedDecimal
  asset__canonicalId
  asset__canonicalDomain
  asset__adoptedAsset
  asset__localAsset
  asset__blockNumber
  amount
  routersFee
  executedCaller
  executedTransactionHash
  executedTimestamp
  executedGasPrice
  executedGasLimit
  executedBlockNumber
  executedTxOrigin
  executedTxNonce
  reconciledCaller
  reconciledTransactionHash
  reconciledTimestamp
  reconciledGasPrice
  reconciledGasLimit
  reconciledBlockNumber
  reconciledTxOrigin
  reconciledTxNonce
}

"""
8 bytes signed integer

"""
scalar linea_Int8

type linea_OptimisticRootFinalized {
  id: ID!
  aggregateRoot: linea_Bytes!
  timestamp: BigInt!
  blockNumber: BigInt
}

input linea_OptimisticRootFinalized_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  aggregateRoot: linea_Bytes
  aggregateRoot_not: linea_Bytes
  aggregateRoot_gt: linea_Bytes
  aggregateRoot_lt: linea_Bytes
  aggregateRoot_gte: linea_Bytes
  aggregateRoot_lte: linea_Bytes
  aggregateRoot_in: [linea_Bytes!]
  aggregateRoot_not_in: [linea_Bytes!]
  aggregateRoot_contains: linea_Bytes
  aggregateRoot_not_contains: linea_Bytes
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: linea_BlockChangedFilter
  and: [linea_OptimisticRootFinalized_filter]
  or: [linea_OptimisticRootFinalized_filter]
}

enum linea_OptimisticRootFinalized_orderBy {
  id
  aggregateRoot
  timestamp
  blockNumber
}

"""Defines the order direction, either ascending or descending"""
enum linea_OrderDirection {
  asc
  desc
}

type linea_OriginMessage {
  id: ID!
  transferId: linea_Bytes
  destinationDomain: BigInt
  leaf: linea_Bytes
  index: BigInt
  message: linea_Bytes
  root: linea_Bytes
  transactionHash: linea_Bytes
  blockNumber: BigInt
  rootCount: linea_RootCount
}

input linea_OriginMessage_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transferId: linea_Bytes
  transferId_not: linea_Bytes
  transferId_gt: linea_Bytes
  transferId_lt: linea_Bytes
  transferId_gte: linea_Bytes
  transferId_lte: linea_Bytes
  transferId_in: [linea_Bytes!]
  transferId_not_in: [linea_Bytes!]
  transferId_contains: linea_Bytes
  transferId_not_contains: linea_Bytes
  destinationDomain: BigInt
  destinationDomain_not: BigInt
  destinationDomain_gt: BigInt
  destinationDomain_lt: BigInt
  destinationDomain_gte: BigInt
  destinationDomain_lte: BigInt
  destinationDomain_in: [BigInt!]
  destinationDomain_not_in: [BigInt!]
  leaf: linea_Bytes
  leaf_not: linea_Bytes
  leaf_gt: linea_Bytes
  leaf_lt: linea_Bytes
  leaf_gte: linea_Bytes
  leaf_lte: linea_Bytes
  leaf_in: [linea_Bytes!]
  leaf_not_in: [linea_Bytes!]
  leaf_contains: linea_Bytes
  leaf_not_contains: linea_Bytes
  index: BigInt
  index_not: BigInt
  index_gt: BigInt
  index_lt: BigInt
  index_gte: BigInt
  index_lte: BigInt
  index_in: [BigInt!]
  index_not_in: [BigInt!]
  message: linea_Bytes
  message_not: linea_Bytes
  message_gt: linea_Bytes
  message_lt: linea_Bytes
  message_gte: linea_Bytes
  message_lte: linea_Bytes
  message_in: [linea_Bytes!]
  message_not_in: [linea_Bytes!]
  message_contains: linea_Bytes
  message_not_contains: linea_Bytes
  root: linea_Bytes
  root_not: linea_Bytes
  root_gt: linea_Bytes
  root_lt: linea_Bytes
  root_gte: linea_Bytes
  root_lte: linea_Bytes
  root_in: [linea_Bytes!]
  root_not_in: [linea_Bytes!]
  root_contains: linea_Bytes
  root_not_contains: linea_Bytes
  transactionHash: linea_Bytes
  transactionHash_not: linea_Bytes
  transactionHash_gt: linea_Bytes
  transactionHash_lt: linea_Bytes
  transactionHash_gte: linea_Bytes
  transactionHash_lte: linea_Bytes
  transactionHash_in: [linea_Bytes!]
  transactionHash_not_in: [linea_Bytes!]
  transactionHash_contains: linea_Bytes
  transactionHash_not_contains: linea_Bytes
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  rootCount: String
  rootCount_not: String
  rootCount_gt: String
  rootCount_lt: String
  rootCount_gte: String
  rootCount_lte: String
  rootCount_in: [String!]
  rootCount_not_in: [String!]
  rootCount_contains: String
  rootCount_contains_nocase: String
  rootCount_not_contains: String
  rootCount_not_contains_nocase: String
  rootCount_starts_with: String
  rootCount_starts_with_nocase: String
  rootCount_not_starts_with: String
  rootCount_not_starts_with_nocase: String
  rootCount_ends_with: String
  rootCount_ends_with_nocase: String
  rootCount_not_ends_with: String
  rootCount_not_ends_with_nocase: String
  rootCount_: linea_RootCount_filter
  """Filter for the block changed event."""
  _change_block: linea_BlockChangedFilter
  and: [linea_OriginMessage_filter]
  or: [linea_OriginMessage_filter]
}

enum linea_OriginMessage_orderBy {
  id
  transferId
  destinationDomain
  leaf
  index
  message
  root
  transactionHash
  blockNumber
  rootCount
  rootCount__id
  rootCount__count
}

type linea_OriginTransfer {
  id: ID!
  chainId: BigInt
  transferId: linea_Bytes
  nonce: BigInt
  status: linea_TransferStatus
  messageHash: linea_Bytes
  originDomain: BigInt
  destinationDomain: BigInt
  canonicalDomain: BigInt
  to: linea_Bytes
  delegate: linea_Bytes
  receiveLocal: Boolean
  callData: linea_Bytes
  slippage: BigInt
  originSender: linea_Bytes
  bridgedAmt: BigInt
  normalizedIn: BigInt
  canonicalId: linea_Bytes
  asset: linea_Asset
  transactingAsset: linea_Bytes
  message: linea_OriginMessage
  bumpRelayerFeeCount: BigInt
  relayerFees(skip: Int = 0, first: Int = 100, orderBy: linea_RelayerFee_orderBy, orderDirection: linea_OrderDirection, where: linea_RelayerFee_filter): [linea_RelayerFee!]
  initialRelayerFeeAsset: linea_Bytes
  caller: linea_Bytes
  transactionHash: linea_Bytes
  timestamp: BigInt
  gasPrice: BigInt
  gasLimit: BigInt
  blockNumber: BigInt
  txOrigin: linea_Bytes
  txNonce: BigInt
}

input linea_OriginTransfer_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  chainId: BigInt
  chainId_not: BigInt
  chainId_gt: BigInt
  chainId_lt: BigInt
  chainId_gte: BigInt
  chainId_lte: BigInt
  chainId_in: [BigInt!]
  chainId_not_in: [BigInt!]
  transferId: linea_Bytes
  transferId_not: linea_Bytes
  transferId_gt: linea_Bytes
  transferId_lt: linea_Bytes
  transferId_gte: linea_Bytes
  transferId_lte: linea_Bytes
  transferId_in: [linea_Bytes!]
  transferId_not_in: [linea_Bytes!]
  transferId_contains: linea_Bytes
  transferId_not_contains: linea_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  status: linea_TransferStatus
  status_not: linea_TransferStatus
  status_in: [linea_TransferStatus!]
  status_not_in: [linea_TransferStatus!]
  messageHash: linea_Bytes
  messageHash_not: linea_Bytes
  messageHash_gt: linea_Bytes
  messageHash_lt: linea_Bytes
  messageHash_gte: linea_Bytes
  messageHash_lte: linea_Bytes
  messageHash_in: [linea_Bytes!]
  messageHash_not_in: [linea_Bytes!]
  messageHash_contains: linea_Bytes
  messageHash_not_contains: linea_Bytes
  originDomain: BigInt
  originDomain_not: BigInt
  originDomain_gt: BigInt
  originDomain_lt: BigInt
  originDomain_gte: BigInt
  originDomain_lte: BigInt
  originDomain_in: [BigInt!]
  originDomain_not_in: [BigInt!]
  destinationDomain: BigInt
  destinationDomain_not: BigInt
  destinationDomain_gt: BigInt
  destinationDomain_lt: BigInt
  destinationDomain_gte: BigInt
  destinationDomain_lte: BigInt
  destinationDomain_in: [BigInt!]
  destinationDomain_not_in: [BigInt!]
  canonicalDomain: BigInt
  canonicalDomain_not: BigInt
  canonicalDomain_gt: BigInt
  canonicalDomain_lt: BigInt
  canonicalDomain_gte: BigInt
  canonicalDomain_lte: BigInt
  canonicalDomain_in: [BigInt!]
  canonicalDomain_not_in: [BigInt!]
  to: linea_Bytes
  to_not: linea_Bytes
  to_gt: linea_Bytes
  to_lt: linea_Bytes
  to_gte: linea_Bytes
  to_lte: linea_Bytes
  to_in: [linea_Bytes!]
  to_not_in: [linea_Bytes!]
  to_contains: linea_Bytes
  to_not_contains: linea_Bytes
  delegate: linea_Bytes
  delegate_not: linea_Bytes
  delegate_gt: linea_Bytes
  delegate_lt: linea_Bytes
  delegate_gte: linea_Bytes
  delegate_lte: linea_Bytes
  delegate_in: [linea_Bytes!]
  delegate_not_in: [linea_Bytes!]
  delegate_contains: linea_Bytes
  delegate_not_contains: linea_Bytes
  receiveLocal: Boolean
  receiveLocal_not: Boolean
  receiveLocal_in: [Boolean!]
  receiveLocal_not_in: [Boolean!]
  callData: linea_Bytes
  callData_not: linea_Bytes
  callData_gt: linea_Bytes
  callData_lt: linea_Bytes
  callData_gte: linea_Bytes
  callData_lte: linea_Bytes
  callData_in: [linea_Bytes!]
  callData_not_in: [linea_Bytes!]
  callData_contains: linea_Bytes
  callData_not_contains: linea_Bytes
  slippage: BigInt
  slippage_not: BigInt
  slippage_gt: BigInt
  slippage_lt: BigInt
  slippage_gte: BigInt
  slippage_lte: BigInt
  slippage_in: [BigInt!]
  slippage_not_in: [BigInt!]
  originSender: linea_Bytes
  originSender_not: linea_Bytes
  originSender_gt: linea_Bytes
  originSender_lt: linea_Bytes
  originSender_gte: linea_Bytes
  originSender_lte: linea_Bytes
  originSender_in: [linea_Bytes!]
  originSender_not_in: [linea_Bytes!]
  originSender_contains: linea_Bytes
  originSender_not_contains: linea_Bytes
  bridgedAmt: BigInt
  bridgedAmt_not: BigInt
  bridgedAmt_gt: BigInt
  bridgedAmt_lt: BigInt
  bridgedAmt_gte: BigInt
  bridgedAmt_lte: BigInt
  bridgedAmt_in: [BigInt!]
  bridgedAmt_not_in: [BigInt!]
  normalizedIn: BigInt
  normalizedIn_not: BigInt
  normalizedIn_gt: BigInt
  normalizedIn_lt: BigInt
  normalizedIn_gte: BigInt
  normalizedIn_lte: BigInt
  normalizedIn_in: [BigInt!]
  normalizedIn_not_in: [BigInt!]
  canonicalId: linea_Bytes
  canonicalId_not: linea_Bytes
  canonicalId_gt: linea_Bytes
  canonicalId_lt: linea_Bytes
  canonicalId_gte: linea_Bytes
  canonicalId_lte: linea_Bytes
  canonicalId_in: [linea_Bytes!]
  canonicalId_not_in: [linea_Bytes!]
  canonicalId_contains: linea_Bytes
  canonicalId_not_contains: linea_Bytes
  asset: String
  asset_not: String
  asset_gt: String
  asset_lt: String
  asset_gte: String
  asset_lte: String
  asset_in: [String!]
  asset_not_in: [String!]
  asset_contains: String
  asset_contains_nocase: String
  asset_not_contains: String
  asset_not_contains_nocase: String
  asset_starts_with: String
  asset_starts_with_nocase: String
  asset_not_starts_with: String
  asset_not_starts_with_nocase: String
  asset_ends_with: String
  asset_ends_with_nocase: String
  asset_not_ends_with: String
  asset_not_ends_with_nocase: String
  asset_: linea_Asset_filter
  transactingAsset: linea_Bytes
  transactingAsset_not: linea_Bytes
  transactingAsset_gt: linea_Bytes
  transactingAsset_lt: linea_Bytes
  transactingAsset_gte: linea_Bytes
  transactingAsset_lte: linea_Bytes
  transactingAsset_in: [linea_Bytes!]
  transactingAsset_not_in: [linea_Bytes!]
  transactingAsset_contains: linea_Bytes
  transactingAsset_not_contains: linea_Bytes
  message: String
  message_not: String
  message_gt: String
  message_lt: String
  message_gte: String
  message_lte: String
  message_in: [String!]
  message_not_in: [String!]
  message_contains: String
  message_contains_nocase: String
  message_not_contains: String
  message_not_contains_nocase: String
  message_starts_with: String
  message_starts_with_nocase: String
  message_not_starts_with: String
  message_not_starts_with_nocase: String
  message_ends_with: String
  message_ends_with_nocase: String
  message_not_ends_with: String
  message_not_ends_with_nocase: String
  message_: linea_OriginMessage_filter
  bumpRelayerFeeCount: BigInt
  bumpRelayerFeeCount_not: BigInt
  bumpRelayerFeeCount_gt: BigInt
  bumpRelayerFeeCount_lt: BigInt
  bumpRelayerFeeCount_gte: BigInt
  bumpRelayerFeeCount_lte: BigInt
  bumpRelayerFeeCount_in: [BigInt!]
  bumpRelayerFeeCount_not_in: [BigInt!]
  relayerFees: [String!]
  relayerFees_not: [String!]
  relayerFees_contains: [String!]
  relayerFees_contains_nocase: [String!]
  relayerFees_not_contains: [String!]
  relayerFees_not_contains_nocase: [String!]
  relayerFees_: linea_RelayerFee_filter
  initialRelayerFeeAsset: linea_Bytes
  initialRelayerFeeAsset_not: linea_Bytes
  initialRelayerFeeAsset_gt: linea_Bytes
  initialRelayerFeeAsset_lt: linea_Bytes
  initialRelayerFeeAsset_gte: linea_Bytes
  initialRelayerFeeAsset_lte: linea_Bytes
  initialRelayerFeeAsset_in: [linea_Bytes!]
  initialRelayerFeeAsset_not_in: [linea_Bytes!]
  initialRelayerFeeAsset_contains: linea_Bytes
  initialRelayerFeeAsset_not_contains: linea_Bytes
  caller: linea_Bytes
  caller_not: linea_Bytes
  caller_gt: linea_Bytes
  caller_lt: linea_Bytes
  caller_gte: linea_Bytes
  caller_lte: linea_Bytes
  caller_in: [linea_Bytes!]
  caller_not_in: [linea_Bytes!]
  caller_contains: linea_Bytes
  caller_not_contains: linea_Bytes
  transactionHash: linea_Bytes
  transactionHash_not: linea_Bytes
  transactionHash_gt: linea_Bytes
  transactionHash_lt: linea_Bytes
  transactionHash_gte: linea_Bytes
  transactionHash_lte: linea_Bytes
  transactionHash_in: [linea_Bytes!]
  transactionHash_not_in: [linea_Bytes!]
  transactionHash_contains: linea_Bytes
  transactionHash_not_contains: linea_Bytes
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  gasLimit: BigInt
  gasLimit_not: BigInt
  gasLimit_gt: BigInt
  gasLimit_lt: BigInt
  gasLimit_gte: BigInt
  gasLimit_lte: BigInt
  gasLimit_in: [BigInt!]
  gasLimit_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  txOrigin: linea_Bytes
  txOrigin_not: linea_Bytes
  txOrigin_gt: linea_Bytes
  txOrigin_lt: linea_Bytes
  txOrigin_gte: linea_Bytes
  txOrigin_lte: linea_Bytes
  txOrigin_in: [linea_Bytes!]
  txOrigin_not_in: [linea_Bytes!]
  txOrigin_contains: linea_Bytes
  txOrigin_not_contains: linea_Bytes
  txNonce: BigInt
  txNonce_not: BigInt
  txNonce_gt: BigInt
  txNonce_lt: BigInt
  txNonce_gte: BigInt
  txNonce_lte: BigInt
  txNonce_in: [BigInt!]
  txNonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: linea_BlockChangedFilter
  and: [linea_OriginTransfer_filter]
  or: [linea_OriginTransfer_filter]
}

enum linea_OriginTransfer_orderBy {
  id
  chainId
  transferId
  nonce
  status
  messageHash
  originDomain
  destinationDomain
  canonicalDomain
  to
  delegate
  receiveLocal
  callData
  slippage
  originSender
  bridgedAmt
  normalizedIn
  canonicalId
  asset
  asset__id
  asset__key
  asset__decimal
  asset__adoptedDecimal
  asset__canonicalId
  asset__canonicalDomain
  asset__adoptedAsset
  asset__localAsset
  asset__blockNumber
  transactingAsset
  message
  message__id
  message__transferId
  message__destinationDomain
  message__leaf
  message__index
  message__message
  message__root
  message__transactionHash
  message__blockNumber
  bumpRelayerFeeCount
  relayerFees
  initialRelayerFeeAsset
  caller
  transactionHash
  timestamp
  gasPrice
  gasLimit
  blockNumber
  txOrigin
  txNonce
}

type linea_Relayer {
  id: ID!
  isActive: Boolean!
  relayer: linea_Bytes
}

type linea_RelayerFee {
  id: ID!
  transfer: linea_OriginTransfer!
  fee: BigInt!
  asset: linea_Bytes!
}

input linea_RelayerFee_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transfer: String
  transfer_not: String
  transfer_gt: String
  transfer_lt: String
  transfer_gte: String
  transfer_lte: String
  transfer_in: [String!]
  transfer_not_in: [String!]
  transfer_contains: String
  transfer_contains_nocase: String
  transfer_not_contains: String
  transfer_not_contains_nocase: String
  transfer_starts_with: String
  transfer_starts_with_nocase: String
  transfer_not_starts_with: String
  transfer_not_starts_with_nocase: String
  transfer_ends_with: String
  transfer_ends_with_nocase: String
  transfer_not_ends_with: String
  transfer_not_ends_with_nocase: String
  transfer_: linea_OriginTransfer_filter
  fee: BigInt
  fee_not: BigInt
  fee_gt: BigInt
  fee_lt: BigInt
  fee_gte: BigInt
  fee_lte: BigInt
  fee_in: [BigInt!]
  fee_not_in: [BigInt!]
  asset: linea_Bytes
  asset_not: linea_Bytes
  asset_gt: linea_Bytes
  asset_lt: linea_Bytes
  asset_gte: linea_Bytes
  asset_lte: linea_Bytes
  asset_in: [linea_Bytes!]
  asset_not_in: [linea_Bytes!]
  asset_contains: linea_Bytes
  asset_not_contains: linea_Bytes
  """Filter for the block changed event."""
  _change_block: linea_BlockChangedFilter
  and: [linea_RelayerFee_filter]
  or: [linea_RelayerFee_filter]
}

enum linea_RelayerFee_orderBy {
  id
  transfer
  transfer__id
  transfer__chainId
  transfer__transferId
  transfer__nonce
  transfer__status
  transfer__messageHash
  transfer__originDomain
  transfer__destinationDomain
  transfer__canonicalDomain
  transfer__to
  transfer__delegate
  transfer__receiveLocal
  transfer__callData
  transfer__slippage
  transfer__originSender
  transfer__bridgedAmt
  transfer__normalizedIn
  transfer__canonicalId
  transfer__transactingAsset
  transfer__bumpRelayerFeeCount
  transfer__initialRelayerFeeAsset
  transfer__caller
  transfer__transactionHash
  transfer__timestamp
  transfer__gasPrice
  transfer__gasLimit
  transfer__blockNumber
  transfer__txOrigin
  transfer__txNonce
  fee
  asset
}

type linea_RelayerFeesIncrease {
  id: ID!
  transfer: linea_OriginTransfer!
  increase: BigInt
  asset: linea_Bytes
  caller: linea_Bytes!
  transactionHash: linea_Bytes!
  timestamp: BigInt!
  gasPrice: BigInt!
  gasLimit: BigInt!
  blockNumber: BigInt!
}

input linea_RelayerFeesIncrease_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transfer: String
  transfer_not: String
  transfer_gt: String
  transfer_lt: String
  transfer_gte: String
  transfer_lte: String
  transfer_in: [String!]
  transfer_not_in: [String!]
  transfer_contains: String
  transfer_contains_nocase: String
  transfer_not_contains: String
  transfer_not_contains_nocase: String
  transfer_starts_with: String
  transfer_starts_with_nocase: String
  transfer_not_starts_with: String
  transfer_not_starts_with_nocase: String
  transfer_ends_with: String
  transfer_ends_with_nocase: String
  transfer_not_ends_with: String
  transfer_not_ends_with_nocase: String
  transfer_: linea_OriginTransfer_filter
  increase: BigInt
  increase_not: BigInt
  increase_gt: BigInt
  increase_lt: BigInt
  increase_gte: BigInt
  increase_lte: BigInt
  increase_in: [BigInt!]
  increase_not_in: [BigInt!]
  asset: linea_Bytes
  asset_not: linea_Bytes
  asset_gt: linea_Bytes
  asset_lt: linea_Bytes
  asset_gte: linea_Bytes
  asset_lte: linea_Bytes
  asset_in: [linea_Bytes!]
  asset_not_in: [linea_Bytes!]
  asset_contains: linea_Bytes
  asset_not_contains: linea_Bytes
  caller: linea_Bytes
  caller_not: linea_Bytes
  caller_gt: linea_Bytes
  caller_lt: linea_Bytes
  caller_gte: linea_Bytes
  caller_lte: linea_Bytes
  caller_in: [linea_Bytes!]
  caller_not_in: [linea_Bytes!]
  caller_contains: linea_Bytes
  caller_not_contains: linea_Bytes
  transactionHash: linea_Bytes
  transactionHash_not: linea_Bytes
  transactionHash_gt: linea_Bytes
  transactionHash_lt: linea_Bytes
  transactionHash_gte: linea_Bytes
  transactionHash_lte: linea_Bytes
  transactionHash_in: [linea_Bytes!]
  transactionHash_not_in: [linea_Bytes!]
  transactionHash_contains: linea_Bytes
  transactionHash_not_contains: linea_Bytes
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  gasLimit: BigInt
  gasLimit_not: BigInt
  gasLimit_gt: BigInt
  gasLimit_lt: BigInt
  gasLimit_gte: BigInt
  gasLimit_lte: BigInt
  gasLimit_in: [BigInt!]
  gasLimit_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: linea_BlockChangedFilter
  and: [linea_RelayerFeesIncrease_filter]
  or: [linea_RelayerFeesIncrease_filter]
}

enum linea_RelayerFeesIncrease_orderBy {
  id
  transfer
  transfer__id
  transfer__chainId
  transfer__transferId
  transfer__nonce
  transfer__status
  transfer__messageHash
  transfer__originDomain
  transfer__destinationDomain
  transfer__canonicalDomain
  transfer__to
  transfer__delegate
  transfer__receiveLocal
  transfer__callData
  transfer__slippage
  transfer__originSender
  transfer__bridgedAmt
  transfer__normalizedIn
  transfer__canonicalId
  transfer__transactingAsset
  transfer__bumpRelayerFeeCount
  transfer__initialRelayerFeeAsset
  transfer__caller
  transfer__transactionHash
  transfer__timestamp
  transfer__gasPrice
  transfer__gasLimit
  transfer__blockNumber
  transfer__txOrigin
  transfer__txNonce
  increase
  asset
  caller
  transactionHash
  timestamp
  gasPrice
  gasLimit
  blockNumber
}

input linea_Relayer_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  isActive: Boolean
  isActive_not: Boolean
  isActive_in: [Boolean!]
  isActive_not_in: [Boolean!]
  relayer: linea_Bytes
  relayer_not: linea_Bytes
  relayer_gt: linea_Bytes
  relayer_lt: linea_Bytes
  relayer_gte: linea_Bytes
  relayer_lte: linea_Bytes
  relayer_in: [linea_Bytes!]
  relayer_not_in: [linea_Bytes!]
  relayer_contains: linea_Bytes
  relayer_not_contains: linea_Bytes
  """Filter for the block changed event."""
  _change_block: linea_BlockChangedFilter
  and: [linea_Relayer_filter]
  or: [linea_Relayer_filter]
}

enum linea_Relayer_orderBy {
  id
  isActive
  relayer
}

type linea_RootCount {
  id: ID!
  count: BigInt
}

input linea_RootCount_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  count: BigInt
  count_not: BigInt
  count_gt: BigInt
  count_lt: BigInt
  count_gte: BigInt
  count_lte: BigInt
  count_in: [BigInt!]
  count_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: linea_BlockChangedFilter
  and: [linea_RootCount_filter]
  or: [linea_RootCount_filter]
}

enum linea_RootCount_orderBy {
  id
  count
}

type linea_RootMessageSent {
  id: ID!
  spokeDomain: BigInt
  hubDomain: BigInt
  root: linea_Bytes
  count: BigInt
  caller: linea_Bytes
  transactionHash: linea_Bytes
  timestamp: BigInt
  gasPrice: BigInt
  gasLimit: BigInt
  blockNumber: BigInt
}

input linea_RootMessageSent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  spokeDomain: BigInt
  spokeDomain_not: BigInt
  spokeDomain_gt: BigInt
  spokeDomain_lt: BigInt
  spokeDomain_gte: BigInt
  spokeDomain_lte: BigInt
  spokeDomain_in: [BigInt!]
  spokeDomain_not_in: [BigInt!]
  hubDomain: BigInt
  hubDomain_not: BigInt
  hubDomain_gt: BigInt
  hubDomain_lt: BigInt
  hubDomain_gte: BigInt
  hubDomain_lte: BigInt
  hubDomain_in: [BigInt!]
  hubDomain_not_in: [BigInt!]
  root: linea_Bytes
  root_not: linea_Bytes
  root_gt: linea_Bytes
  root_lt: linea_Bytes
  root_gte: linea_Bytes
  root_lte: linea_Bytes
  root_in: [linea_Bytes!]
  root_not_in: [linea_Bytes!]
  root_contains: linea_Bytes
  root_not_contains: linea_Bytes
  count: BigInt
  count_not: BigInt
  count_gt: BigInt
  count_lt: BigInt
  count_gte: BigInt
  count_lte: BigInt
  count_in: [BigInt!]
  count_not_in: [BigInt!]
  caller: linea_Bytes
  caller_not: linea_Bytes
  caller_gt: linea_Bytes
  caller_lt: linea_Bytes
  caller_gte: linea_Bytes
  caller_lte: linea_Bytes
  caller_in: [linea_Bytes!]
  caller_not_in: [linea_Bytes!]
  caller_contains: linea_Bytes
  caller_not_contains: linea_Bytes
  transactionHash: linea_Bytes
  transactionHash_not: linea_Bytes
  transactionHash_gt: linea_Bytes
  transactionHash_lt: linea_Bytes
  transactionHash_gte: linea_Bytes
  transactionHash_lte: linea_Bytes
  transactionHash_in: [linea_Bytes!]
  transactionHash_not_in: [linea_Bytes!]
  transactionHash_contains: linea_Bytes
  transactionHash_not_contains: linea_Bytes
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  gasLimit: BigInt
  gasLimit_not: BigInt
  gasLimit_gt: BigInt
  gasLimit_lt: BigInt
  gasLimit_gte: BigInt
  gasLimit_lte: BigInt
  gasLimit_in: [BigInt!]
  gasLimit_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: linea_BlockChangedFilter
  and: [linea_RootMessageSent_filter]
  or: [linea_RootMessageSent_filter]
}

enum linea_RootMessageSent_orderBy {
  id
  spokeDomain
  hubDomain
  root
  count
  caller
  transactionHash
  timestamp
  gasPrice
  gasLimit
  blockNumber
}

type linea_Router {
  id: ID!
  isActive: Boolean!
  owner: linea_Bytes
  recipient: linea_Bytes
  proposedOwner: linea_Bytes
  proposedTimestamp: BigInt
  assetBalances(skip: Int = 0, first: Int = 100, orderBy: linea_AssetBalance_orderBy, orderDirection: linea_OrderDirection, where: linea_AssetBalance_filter): [linea_AssetBalance!]!
}

type linea_RouterDailyTVL {
  id: ID!
  router: linea_Router!
  asset: linea_Asset!
  timestamp: BigInt!
  balance: BigInt!
}

input linea_RouterDailyTVL_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  router: String
  router_not: String
  router_gt: String
  router_lt: String
  router_gte: String
  router_lte: String
  router_in: [String!]
  router_not_in: [String!]
  router_contains: String
  router_contains_nocase: String
  router_not_contains: String
  router_not_contains_nocase: String
  router_starts_with: String
  router_starts_with_nocase: String
  router_not_starts_with: String
  router_not_starts_with_nocase: String
  router_ends_with: String
  router_ends_with_nocase: String
  router_not_ends_with: String
  router_not_ends_with_nocase: String
  router_: linea_Router_filter
  asset: String
  asset_not: String
  asset_gt: String
  asset_lt: String
  asset_gte: String
  asset_lte: String
  asset_in: [String!]
  asset_not_in: [String!]
  asset_contains: String
  asset_contains_nocase: String
  asset_not_contains: String
  asset_not_contains_nocase: String
  asset_starts_with: String
  asset_starts_with_nocase: String
  asset_not_starts_with: String
  asset_not_starts_with_nocase: String
  asset_ends_with: String
  asset_ends_with_nocase: String
  asset_not_ends_with: String
  asset_not_ends_with_nocase: String
  asset_: linea_Asset_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  balance: BigInt
  balance_not: BigInt
  balance_gt: BigInt
  balance_lt: BigInt
  balance_gte: BigInt
  balance_lte: BigInt
  balance_in: [BigInt!]
  balance_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: linea_BlockChangedFilter
  and: [linea_RouterDailyTVL_filter]
  or: [linea_RouterDailyTVL_filter]
}

enum linea_RouterDailyTVL_orderBy {
  id
  router
  router__id
  router__isActive
  router__owner
  router__recipient
  router__proposedOwner
  router__proposedTimestamp
  asset
  asset__id
  asset__key
  asset__decimal
  asset__adoptedDecimal
  asset__canonicalId
  asset__canonicalDomain
  asset__adoptedAsset
  asset__localAsset
  asset__blockNumber
  timestamp
  balance
}

type linea_RouterLiquidityEvent {
  id: ID!
  type: linea_RouterLiquidityEventType
  router: linea_Router!
  asset: linea_Asset!
  amount: BigInt!
  balance: BigInt!
  caller: linea_Bytes
  blockNumber: BigInt!
  timestamp: BigInt!
  transactionHash: linea_Bytes!
  nonce: BigInt!
}

enum linea_RouterLiquidityEventType {
  Add
  Remove
}

input linea_RouterLiquidityEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  type: linea_RouterLiquidityEventType
  type_not: linea_RouterLiquidityEventType
  type_in: [linea_RouterLiquidityEventType!]
  type_not_in: [linea_RouterLiquidityEventType!]
  router: String
  router_not: String
  router_gt: String
  router_lt: String
  router_gte: String
  router_lte: String
  router_in: [String!]
  router_not_in: [String!]
  router_contains: String
  router_contains_nocase: String
  router_not_contains: String
  router_not_contains_nocase: String
  router_starts_with: String
  router_starts_with_nocase: String
  router_not_starts_with: String
  router_not_starts_with_nocase: String
  router_ends_with: String
  router_ends_with_nocase: String
  router_not_ends_with: String
  router_not_ends_with_nocase: String
  router_: linea_Router_filter
  asset: String
  asset_not: String
  asset_gt: String
  asset_lt: String
  asset_gte: String
  asset_lte: String
  asset_in: [String!]
  asset_not_in: [String!]
  asset_contains: String
  asset_contains_nocase: String
  asset_not_contains: String
  asset_not_contains_nocase: String
  asset_starts_with: String
  asset_starts_with_nocase: String
  asset_not_starts_with: String
  asset_not_starts_with_nocase: String
  asset_ends_with: String
  asset_ends_with_nocase: String
  asset_not_ends_with: String
  asset_not_ends_with_nocase: String
  asset_: linea_Asset_filter
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  balance: BigInt
  balance_not: BigInt
  balance_gt: BigInt
  balance_lt: BigInt
  balance_gte: BigInt
  balance_lte: BigInt
  balance_in: [BigInt!]
  balance_not_in: [BigInt!]
  caller: linea_Bytes
  caller_not: linea_Bytes
  caller_gt: linea_Bytes
  caller_lt: linea_Bytes
  caller_gte: linea_Bytes
  caller_lte: linea_Bytes
  caller_in: [linea_Bytes!]
  caller_not_in: [linea_Bytes!]
  caller_contains: linea_Bytes
  caller_not_contains: linea_Bytes
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transactionHash: linea_Bytes
  transactionHash_not: linea_Bytes
  transactionHash_gt: linea_Bytes
  transactionHash_lt: linea_Bytes
  transactionHash_gte: linea_Bytes
  transactionHash_lte: linea_Bytes
  transactionHash_in: [linea_Bytes!]
  transactionHash_not_in: [linea_Bytes!]
  transactionHash_contains: linea_Bytes
  transactionHash_not_contains: linea_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: linea_BlockChangedFilter
  and: [linea_RouterLiquidityEvent_filter]
  or: [linea_RouterLiquidityEvent_filter]
}

enum linea_RouterLiquidityEvent_orderBy {
  id
  type
  router
  router__id
  router__isActive
  router__owner
  router__recipient
  router__proposedOwner
  router__proposedTimestamp
  asset
  asset__id
  asset__key
  asset__decimal
  asset__adoptedDecimal
  asset__canonicalId
  asset__canonicalDomain
  asset__adoptedAsset
  asset__localAsset
  asset__blockNumber
  amount
  balance
  caller
  blockNumber
  timestamp
  transactionHash
  nonce
}

input linea_Router_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  isActive: Boolean
  isActive_not: Boolean
  isActive_in: [Boolean!]
  isActive_not_in: [Boolean!]
  owner: linea_Bytes
  owner_not: linea_Bytes
  owner_gt: linea_Bytes
  owner_lt: linea_Bytes
  owner_gte: linea_Bytes
  owner_lte: linea_Bytes
  owner_in: [linea_Bytes!]
  owner_not_in: [linea_Bytes!]
  owner_contains: linea_Bytes
  owner_not_contains: linea_Bytes
  recipient: linea_Bytes
  recipient_not: linea_Bytes
  recipient_gt: linea_Bytes
  recipient_lt: linea_Bytes
  recipient_gte: linea_Bytes
  recipient_lte: linea_Bytes
  recipient_in: [linea_Bytes!]
  recipient_not_in: [linea_Bytes!]
  recipient_contains: linea_Bytes
  recipient_not_contains: linea_Bytes
  proposedOwner: linea_Bytes
  proposedOwner_not: linea_Bytes
  proposedOwner_gt: linea_Bytes
  proposedOwner_lt: linea_Bytes
  proposedOwner_gte: linea_Bytes
  proposedOwner_lte: linea_Bytes
  proposedOwner_in: [linea_Bytes!]
  proposedOwner_not_in: [linea_Bytes!]
  proposedOwner_contains: linea_Bytes
  proposedOwner_not_contains: linea_Bytes
  proposedTimestamp: BigInt
  proposedTimestamp_not: BigInt
  proposedTimestamp_gt: BigInt
  proposedTimestamp_lt: BigInt
  proposedTimestamp_gte: BigInt
  proposedTimestamp_lte: BigInt
  proposedTimestamp_in: [BigInt!]
  proposedTimestamp_not_in: [BigInt!]
  assetBalances_: linea_AssetBalance_filter
  """Filter for the block changed event."""
  _change_block: linea_BlockChangedFilter
  and: [linea_Router_filter]
  or: [linea_Router_filter]
}

enum linea_Router_orderBy {
  id
  isActive
  owner
  recipient
  proposedOwner
  proposedTimestamp
  assetBalances
}

type linea_Sequencer {
  id: ID!
  isActive: Boolean!
  sequencer: linea_Bytes
}

input linea_Sequencer_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  isActive: Boolean
  isActive_not: Boolean
  isActive_in: [Boolean!]
  isActive_not_in: [Boolean!]
  sequencer: linea_Bytes
  sequencer_not: linea_Bytes
  sequencer_gt: linea_Bytes
  sequencer_lt: linea_Bytes
  sequencer_gte: linea_Bytes
  sequencer_lte: linea_Bytes
  sequencer_in: [linea_Bytes!]
  sequencer_not_in: [linea_Bytes!]
  sequencer_contains: linea_Bytes
  sequencer_not_contains: linea_Bytes
  """Filter for the block changed event."""
  _change_block: linea_BlockChangedFilter
  and: [linea_Sequencer_filter]
  or: [linea_Sequencer_filter]
}

enum linea_Sequencer_orderBy {
  id
  isActive
  sequencer
}

type linea_Setting {
  id: ID!
  maxRoutersPerTransfer: BigInt!
  caller: linea_Bytes!
}

input linea_Setting_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  maxRoutersPerTransfer: BigInt
  maxRoutersPerTransfer_not: BigInt
  maxRoutersPerTransfer_gt: BigInt
  maxRoutersPerTransfer_lt: BigInt
  maxRoutersPerTransfer_gte: BigInt
  maxRoutersPerTransfer_lte: BigInt
  maxRoutersPerTransfer_in: [BigInt!]
  maxRoutersPerTransfer_not_in: [BigInt!]
  caller: linea_Bytes
  caller_not: linea_Bytes
  caller_gt: linea_Bytes
  caller_lt: linea_Bytes
  caller_gte: linea_Bytes
  caller_lte: linea_Bytes
  caller_in: [linea_Bytes!]
  caller_not_in: [linea_Bytes!]
  caller_contains: linea_Bytes
  caller_not_contains: linea_Bytes
  """Filter for the block changed event."""
  _change_block: linea_BlockChangedFilter
  and: [linea_Setting_filter]
  or: [linea_Setting_filter]
}

enum linea_Setting_orderBy {
  id
  maxRoutersPerTransfer
  caller
}

type linea_SlippageUpdate {
  id: ID!
  transfer: linea_DestinationTransfer!
  slippage: BigInt!
  caller: linea_Bytes!
  transactionHash: linea_Bytes!
  timestamp: BigInt!
  gasPrice: BigInt!
  gasLimit: BigInt!
  blockNumber: BigInt!
}

input linea_SlippageUpdate_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transfer: String
  transfer_not: String
  transfer_gt: String
  transfer_lt: String
  transfer_gte: String
  transfer_lte: String
  transfer_in: [String!]
  transfer_not_in: [String!]
  transfer_contains: String
  transfer_contains_nocase: String
  transfer_not_contains: String
  transfer_not_contains_nocase: String
  transfer_starts_with: String
  transfer_starts_with_nocase: String
  transfer_not_starts_with: String
  transfer_not_starts_with_nocase: String
  transfer_ends_with: String
  transfer_ends_with_nocase: String
  transfer_not_ends_with: String
  transfer_not_ends_with_nocase: String
  transfer_: linea_DestinationTransfer_filter
  slippage: BigInt
  slippage_not: BigInt
  slippage_gt: BigInt
  slippage_lt: BigInt
  slippage_gte: BigInt
  slippage_lte: BigInt
  slippage_in: [BigInt!]
  slippage_not_in: [BigInt!]
  caller: linea_Bytes
  caller_not: linea_Bytes
  caller_gt: linea_Bytes
  caller_lt: linea_Bytes
  caller_gte: linea_Bytes
  caller_lte: linea_Bytes
  caller_in: [linea_Bytes!]
  caller_not_in: [linea_Bytes!]
  caller_contains: linea_Bytes
  caller_not_contains: linea_Bytes
  transactionHash: linea_Bytes
  transactionHash_not: linea_Bytes
  transactionHash_gt: linea_Bytes
  transactionHash_lt: linea_Bytes
  transactionHash_gte: linea_Bytes
  transactionHash_lte: linea_Bytes
  transactionHash_in: [linea_Bytes!]
  transactionHash_not_in: [linea_Bytes!]
  transactionHash_contains: linea_Bytes
  transactionHash_not_contains: linea_Bytes
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  gasLimit: BigInt
  gasLimit_not: BigInt
  gasLimit_gt: BigInt
  gasLimit_lt: BigInt
  gasLimit_gte: BigInt
  gasLimit_lte: BigInt
  gasLimit_in: [BigInt!]
  gasLimit_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: linea_BlockChangedFilter
  and: [linea_SlippageUpdate_filter]
  or: [linea_SlippageUpdate_filter]
}

enum linea_SlippageUpdate_orderBy {
  id
  transfer
  transfer__id
  transfer__chainId
  transfer__transferId
  transfer__nonce
  transfer__status
  transfer__originDomain
  transfer__destinationDomain
  transfer__canonicalDomain
  transfer__to
  transfer__delegate
  transfer__receiveLocal
  transfer__callData
  transfer__slippage
  transfer__bumpSlippageCount
  transfer__originSender
  transfer__bridgedAmt
  transfer__normalizedIn
  transfer__canonicalId
  transfer__amount
  transfer__routersFee
  transfer__executedCaller
  transfer__executedTransactionHash
  transfer__executedTimestamp
  transfer__executedGasPrice
  transfer__executedGasLimit
  transfer__executedBlockNumber
  transfer__executedTxOrigin
  transfer__executedTxNonce
  transfer__reconciledCaller
  transfer__reconciledTransactionHash
  transfer__reconciledTimestamp
  transfer__reconciledGasPrice
  transfer__reconciledGasLimit
  transfer__reconciledBlockNumber
  transfer__reconciledTxOrigin
  transfer__reconciledTxNonce
  slippage
  caller
  transactionHash
  timestamp
  gasPrice
  gasLimit
  blockNumber
}

type linea_SnapshotRoot {
  id: ID!
  spokeDomain: BigInt
  root: linea_Bytes!
  count: BigInt!
  timestamp: BigInt!
  blockNumber: BigInt!
}

input linea_SnapshotRoot_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  spokeDomain: BigInt
  spokeDomain_not: BigInt
  spokeDomain_gt: BigInt
  spokeDomain_lt: BigInt
  spokeDomain_gte: BigInt
  spokeDomain_lte: BigInt
  spokeDomain_in: [BigInt!]
  spokeDomain_not_in: [BigInt!]
  root: linea_Bytes
  root_not: linea_Bytes
  root_gt: linea_Bytes
  root_lt: linea_Bytes
  root_gte: linea_Bytes
  root_lte: linea_Bytes
  root_in: [linea_Bytes!]
  root_not_in: [linea_Bytes!]
  root_contains: linea_Bytes
  root_not_contains: linea_Bytes
  count: BigInt
  count_not: BigInt
  count_gt: BigInt
  count_lt: BigInt
  count_gte: BigInt
  count_lte: BigInt
  count_in: [BigInt!]
  count_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: linea_BlockChangedFilter
  and: [linea_SnapshotRoot_filter]
  or: [linea_SnapshotRoot_filter]
}

enum linea_SnapshotRoot_orderBy {
  id
  spokeDomain
  root
  count
  timestamp
  blockNumber
}

type linea_SpokeConnectorMode {
  id: ID!
  mode: String!
}

input linea_SpokeConnectorMode_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  mode: String
  mode_not: String
  mode_gt: String
  mode_lt: String
  mode_gte: String
  mode_lte: String
  mode_in: [String!]
  mode_not_in: [String!]
  mode_contains: String
  mode_contains_nocase: String
  mode_not_contains: String
  mode_not_contains_nocase: String
  mode_starts_with: String
  mode_starts_with_nocase: String
  mode_not_starts_with: String
  mode_not_starts_with_nocase: String
  mode_ends_with: String
  mode_ends_with_nocase: String
  mode_not_ends_with: String
  mode_not_ends_with_nocase: String
  """Filter for the block changed event."""
  _change_block: linea_BlockChangedFilter
  and: [linea_SpokeConnectorMode_filter]
  or: [linea_SpokeConnectorMode_filter]
}

enum linea_SpokeConnectorMode_orderBy {
  id
  mode
}

enum linea_TransferStatus {
  XCalled
  Executed
  Reconciled
  CompletedSlow
  CompletedFast
}

type linea__Block_ {
  """The hash of the block"""
  hash: linea_Bytes
  """The block number"""
  number: Int!
  """Integer representation of the timestamp stored in blocks for the chain"""
  timestamp: Int
  """The hash of the parent block"""
  parentHash: linea_Bytes
}

"""The type for the top-level _meta field"""
type linea__Meta_ {
  """
  Information about a specific subgraph block. The hash of the block
  will be null if the _meta field has a block constraint that asks for
  a block number. It will be filled if the _meta field has no block constraint
  and therefore asks for the latest  block
  
  """
  block: linea__Block_!
  """The deployment ID"""
  deployment: String!
  """If `true`, the subgraph encountered indexing errors at some past block"""
  hasIndexingErrors: Boolean!
}

type metis_AggregateRoot {
  id: ID!
  root: metis_Bytes!
  blockNumber: BigInt!
}

type metis_AggregateRootProposed {
  id: ID!
  aggregateRoot: metis_Bytes!
  rootTimestamp: BigInt!
  endOfDispute: BigInt!
  domain: BigInt!
  timestamp: BigInt!
  blockNumber: BigInt
}

input metis_AggregateRootProposed_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  aggregateRoot: metis_Bytes
  aggregateRoot_not: metis_Bytes
  aggregateRoot_gt: metis_Bytes
  aggregateRoot_lt: metis_Bytes
  aggregateRoot_gte: metis_Bytes
  aggregateRoot_lte: metis_Bytes
  aggregateRoot_in: [metis_Bytes!]
  aggregateRoot_not_in: [metis_Bytes!]
  aggregateRoot_contains: metis_Bytes
  aggregateRoot_not_contains: metis_Bytes
  rootTimestamp: BigInt
  rootTimestamp_not: BigInt
  rootTimestamp_gt: BigInt
  rootTimestamp_lt: BigInt
  rootTimestamp_gte: BigInt
  rootTimestamp_lte: BigInt
  rootTimestamp_in: [BigInt!]
  rootTimestamp_not_in: [BigInt!]
  endOfDispute: BigInt
  endOfDispute_not: BigInt
  endOfDispute_gt: BigInt
  endOfDispute_lt: BigInt
  endOfDispute_gte: BigInt
  endOfDispute_lte: BigInt
  endOfDispute_in: [BigInt!]
  endOfDispute_not_in: [BigInt!]
  domain: BigInt
  domain_not: BigInt
  domain_gt: BigInt
  domain_lt: BigInt
  domain_gte: BigInt
  domain_lte: BigInt
  domain_in: [BigInt!]
  domain_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: metis_BlockChangedFilter
  and: [metis_AggregateRootProposed_filter]
  or: [metis_AggregateRootProposed_filter]
}

enum metis_AggregateRootProposed_orderBy {
  id
  aggregateRoot
  rootTimestamp
  endOfDispute
  domain
  timestamp
  blockNumber
}

input metis_AggregateRoot_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  root: metis_Bytes
  root_not: metis_Bytes
  root_gt: metis_Bytes
  root_lt: metis_Bytes
  root_gte: metis_Bytes
  root_lte: metis_Bytes
  root_in: [metis_Bytes!]
  root_not_in: [metis_Bytes!]
  root_contains: metis_Bytes
  root_not_contains: metis_Bytes
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: metis_BlockChangedFilter
  and: [metis_AggregateRoot_filter]
  or: [metis_AggregateRoot_filter]
}

enum metis_AggregateRoot_orderBy {
  id
  root
  blockNumber
}

enum metis_Aggregation_interval {
  hour
  day
}

type metis_Asset {
  id: ID!
  key: metis_Bytes
  decimal: BigInt
  adoptedDecimal: BigInt
  canonicalId: metis_Bytes
  canonicalDomain: BigInt
  adoptedAsset: metis_Bytes
  localAsset: metis_Bytes
  blockNumber: BigInt
  status: metis_AssetStatus
}

type metis_AssetBalance {
  id: ID!
  amount: BigInt!
  locked: BigInt!
  supplied: BigInt!
  removed: BigInt!
  router: metis_Router!
  asset: metis_Asset!
  feesEarned: BigInt!
}

input metis_AssetBalance_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  locked: BigInt
  locked_not: BigInt
  locked_gt: BigInt
  locked_lt: BigInt
  locked_gte: BigInt
  locked_lte: BigInt
  locked_in: [BigInt!]
  locked_not_in: [BigInt!]
  supplied: BigInt
  supplied_not: BigInt
  supplied_gt: BigInt
  supplied_lt: BigInt
  supplied_gte: BigInt
  supplied_lte: BigInt
  supplied_in: [BigInt!]
  supplied_not_in: [BigInt!]
  removed: BigInt
  removed_not: BigInt
  removed_gt: BigInt
  removed_lt: BigInt
  removed_gte: BigInt
  removed_lte: BigInt
  removed_in: [BigInt!]
  removed_not_in: [BigInt!]
  router: String
  router_not: String
  router_gt: String
  router_lt: String
  router_gte: String
  router_lte: String
  router_in: [String!]
  router_not_in: [String!]
  router_contains: String
  router_contains_nocase: String
  router_not_contains: String
  router_not_contains_nocase: String
  router_starts_with: String
  router_starts_with_nocase: String
  router_not_starts_with: String
  router_not_starts_with_nocase: String
  router_ends_with: String
  router_ends_with_nocase: String
  router_not_ends_with: String
  router_not_ends_with_nocase: String
  router_: metis_Router_filter
  asset: String
  asset_not: String
  asset_gt: String
  asset_lt: String
  asset_gte: String
  asset_lte: String
  asset_in: [String!]
  asset_not_in: [String!]
  asset_contains: String
  asset_contains_nocase: String
  asset_not_contains: String
  asset_not_contains_nocase: String
  asset_starts_with: String
  asset_starts_with_nocase: String
  asset_not_starts_with: String
  asset_not_starts_with_nocase: String
  asset_ends_with: String
  asset_ends_with_nocase: String
  asset_not_ends_with: String
  asset_not_ends_with_nocase: String
  asset_: metis_Asset_filter
  feesEarned: BigInt
  feesEarned_not: BigInt
  feesEarned_gt: BigInt
  feesEarned_lt: BigInt
  feesEarned_gte: BigInt
  feesEarned_lte: BigInt
  feesEarned_in: [BigInt!]
  feesEarned_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: metis_BlockChangedFilter
  and: [metis_AssetBalance_filter]
  or: [metis_AssetBalance_filter]
}

enum metis_AssetBalance_orderBy {
  id
  amount
  locked
  supplied
  removed
  router
  router__id
  router__isActive
  router__owner
  router__recipient
  router__proposedOwner
  router__proposedTimestamp
  asset
  asset__id
  asset__key
  asset__decimal
  asset__adoptedDecimal
  asset__canonicalId
  asset__canonicalDomain
  asset__adoptedAsset
  asset__localAsset
  asset__blockNumber
  feesEarned
}

type metis_AssetStatus {
  id: ID!
  status: Boolean
}

input metis_AssetStatus_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  status: Boolean
  status_not: Boolean
  status_in: [Boolean!]
  status_not_in: [Boolean!]
  """Filter for the block changed event."""
  _change_block: metis_BlockChangedFilter
  and: [metis_AssetStatus_filter]
  or: [metis_AssetStatus_filter]
}

enum metis_AssetStatus_orderBy {
  id
  status
}

input metis_Asset_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  key: metis_Bytes
  key_not: metis_Bytes
  key_gt: metis_Bytes
  key_lt: metis_Bytes
  key_gte: metis_Bytes
  key_lte: metis_Bytes
  key_in: [metis_Bytes!]
  key_not_in: [metis_Bytes!]
  key_contains: metis_Bytes
  key_not_contains: metis_Bytes
  decimal: BigInt
  decimal_not: BigInt
  decimal_gt: BigInt
  decimal_lt: BigInt
  decimal_gte: BigInt
  decimal_lte: BigInt
  decimal_in: [BigInt!]
  decimal_not_in: [BigInt!]
  adoptedDecimal: BigInt
  adoptedDecimal_not: BigInt
  adoptedDecimal_gt: BigInt
  adoptedDecimal_lt: BigInt
  adoptedDecimal_gte: BigInt
  adoptedDecimal_lte: BigInt
  adoptedDecimal_in: [BigInt!]
  adoptedDecimal_not_in: [BigInt!]
  canonicalId: metis_Bytes
  canonicalId_not: metis_Bytes
  canonicalId_gt: metis_Bytes
  canonicalId_lt: metis_Bytes
  canonicalId_gte: metis_Bytes
  canonicalId_lte: metis_Bytes
  canonicalId_in: [metis_Bytes!]
  canonicalId_not_in: [metis_Bytes!]
  canonicalId_contains: metis_Bytes
  canonicalId_not_contains: metis_Bytes
  canonicalDomain: BigInt
  canonicalDomain_not: BigInt
  canonicalDomain_gt: BigInt
  canonicalDomain_lt: BigInt
  canonicalDomain_gte: BigInt
  canonicalDomain_lte: BigInt
  canonicalDomain_in: [BigInt!]
  canonicalDomain_not_in: [BigInt!]
  adoptedAsset: metis_Bytes
  adoptedAsset_not: metis_Bytes
  adoptedAsset_gt: metis_Bytes
  adoptedAsset_lt: metis_Bytes
  adoptedAsset_gte: metis_Bytes
  adoptedAsset_lte: metis_Bytes
  adoptedAsset_in: [metis_Bytes!]
  adoptedAsset_not_in: [metis_Bytes!]
  adoptedAsset_contains: metis_Bytes
  adoptedAsset_not_contains: metis_Bytes
  localAsset: metis_Bytes
  localAsset_not: metis_Bytes
  localAsset_gt: metis_Bytes
  localAsset_lt: metis_Bytes
  localAsset_gte: metis_Bytes
  localAsset_lte: metis_Bytes
  localAsset_in: [metis_Bytes!]
  localAsset_not_in: [metis_Bytes!]
  localAsset_contains: metis_Bytes
  localAsset_not_contains: metis_Bytes
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  status: String
  status_not: String
  status_gt: String
  status_lt: String
  status_gte: String
  status_lte: String
  status_in: [String!]
  status_not_in: [String!]
  status_contains: String
  status_contains_nocase: String
  status_not_contains: String
  status_not_contains_nocase: String
  status_starts_with: String
  status_starts_with_nocase: String
  status_not_starts_with: String
  status_not_starts_with_nocase: String
  status_ends_with: String
  status_ends_with_nocase: String
  status_not_ends_with: String
  status_not_ends_with_nocase: String
  status_: metis_AssetStatus_filter
  """Filter for the block changed event."""
  _change_block: metis_BlockChangedFilter
  and: [metis_Asset_filter]
  or: [metis_Asset_filter]
}

enum metis_Asset_orderBy {
  id
  key
  decimal
  adoptedDecimal
  canonicalId
  canonicalDomain
  adoptedAsset
  localAsset
  blockNumber
  status
  status__id
  status__status
}

scalar metis_BigDecimal

input metis_BlockChangedFilter {
  number_gte: Int!
}

input metis_Block_height {
  hash: metis_Bytes
  number: Int
  number_gte: Int
}

scalar metis_Bytes

type metis_ConnectorMeta {
  id: ID!
  spokeDomain: BigInt
  hubDomain: BigInt
  amb: metis_Bytes
  rootManager: metis_Bytes
  mirrorConnector: metis_Bytes
}

input metis_ConnectorMeta_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  spokeDomain: BigInt
  spokeDomain_not: BigInt
  spokeDomain_gt: BigInt
  spokeDomain_lt: BigInt
  spokeDomain_gte: BigInt
  spokeDomain_lte: BigInt
  spokeDomain_in: [BigInt!]
  spokeDomain_not_in: [BigInt!]
  hubDomain: BigInt
  hubDomain_not: BigInt
  hubDomain_gt: BigInt
  hubDomain_lt: BigInt
  hubDomain_gte: BigInt
  hubDomain_lte: BigInt
  hubDomain_in: [BigInt!]
  hubDomain_not_in: [BigInt!]
  amb: metis_Bytes
  amb_not: metis_Bytes
  amb_gt: metis_Bytes
  amb_lt: metis_Bytes
  amb_gte: metis_Bytes
  amb_lte: metis_Bytes
  amb_in: [metis_Bytes!]
  amb_not_in: [metis_Bytes!]
  amb_contains: metis_Bytes
  amb_not_contains: metis_Bytes
  rootManager: metis_Bytes
  rootManager_not: metis_Bytes
  rootManager_gt: metis_Bytes
  rootManager_lt: metis_Bytes
  rootManager_gte: metis_Bytes
  rootManager_lte: metis_Bytes
  rootManager_in: [metis_Bytes!]
  rootManager_not_in: [metis_Bytes!]
  rootManager_contains: metis_Bytes
  rootManager_not_contains: metis_Bytes
  mirrorConnector: metis_Bytes
  mirrorConnector_not: metis_Bytes
  mirrorConnector_gt: metis_Bytes
  mirrorConnector_lt: metis_Bytes
  mirrorConnector_gte: metis_Bytes
  mirrorConnector_lte: metis_Bytes
  mirrorConnector_in: [metis_Bytes!]
  mirrorConnector_not_in: [metis_Bytes!]
  mirrorConnector_contains: metis_Bytes
  mirrorConnector_not_contains: metis_Bytes
  """Filter for the block changed event."""
  _change_block: metis_BlockChangedFilter
  and: [metis_ConnectorMeta_filter]
  or: [metis_ConnectorMeta_filter]
}

enum metis_ConnectorMeta_orderBy {
  id
  spokeDomain
  hubDomain
  amb
  rootManager
  mirrorConnector
}

type metis_DestinationTransfer {
  id: ID!
  chainId: BigInt
  transferId: metis_Bytes
  nonce: BigInt
  status: metis_TransferStatus
  routers(skip: Int = 0, first: Int = 100, orderBy: metis_Router_orderBy, orderDirection: metis_OrderDirection, where: metis_Router_filter): [metis_Router!]
  originDomain: BigInt
  destinationDomain: BigInt
  canonicalDomain: BigInt
  to: metis_Bytes
  delegate: metis_Bytes
  receiveLocal: Boolean
  callData: metis_Bytes
  slippage: BigInt
  bumpSlippageCount: BigInt
  originSender: metis_Bytes
  bridgedAmt: BigInt
  normalizedIn: BigInt
  canonicalId: metis_Bytes
  asset: metis_Asset
  amount: BigInt
  routersFee: BigInt
  executedCaller: metis_Bytes
  executedTransactionHash: metis_Bytes
  executedTimestamp: BigInt
  executedGasPrice: BigInt
  executedGasLimit: BigInt
  executedBlockNumber: BigInt
  executedTxOrigin: metis_Bytes
  executedTxNonce: BigInt
  reconciledCaller: metis_Bytes
  reconciledTransactionHash: metis_Bytes
  reconciledTimestamp: BigInt
  reconciledGasPrice: BigInt
  reconciledGasLimit: BigInt
  reconciledBlockNumber: BigInt
  reconciledTxOrigin: metis_Bytes
  reconciledTxNonce: BigInt
}

input metis_DestinationTransfer_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  chainId: BigInt
  chainId_not: BigInt
  chainId_gt: BigInt
  chainId_lt: BigInt
  chainId_gte: BigInt
  chainId_lte: BigInt
  chainId_in: [BigInt!]
  chainId_not_in: [BigInt!]
  transferId: metis_Bytes
  transferId_not: metis_Bytes
  transferId_gt: metis_Bytes
  transferId_lt: metis_Bytes
  transferId_gte: metis_Bytes
  transferId_lte: metis_Bytes
  transferId_in: [metis_Bytes!]
  transferId_not_in: [metis_Bytes!]
  transferId_contains: metis_Bytes
  transferId_not_contains: metis_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  status: metis_TransferStatus
  status_not: metis_TransferStatus
  status_in: [metis_TransferStatus!]
  status_not_in: [metis_TransferStatus!]
  routers: [String!]
  routers_not: [String!]
  routers_contains: [String!]
  routers_contains_nocase: [String!]
  routers_not_contains: [String!]
  routers_not_contains_nocase: [String!]
  routers_: metis_Router_filter
  originDomain: BigInt
  originDomain_not: BigInt
  originDomain_gt: BigInt
  originDomain_lt: BigInt
  originDomain_gte: BigInt
  originDomain_lte: BigInt
  originDomain_in: [BigInt!]
  originDomain_not_in: [BigInt!]
  destinationDomain: BigInt
  destinationDomain_not: BigInt
  destinationDomain_gt: BigInt
  destinationDomain_lt: BigInt
  destinationDomain_gte: BigInt
  destinationDomain_lte: BigInt
  destinationDomain_in: [BigInt!]
  destinationDomain_not_in: [BigInt!]
  canonicalDomain: BigInt
  canonicalDomain_not: BigInt
  canonicalDomain_gt: BigInt
  canonicalDomain_lt: BigInt
  canonicalDomain_gte: BigInt
  canonicalDomain_lte: BigInt
  canonicalDomain_in: [BigInt!]
  canonicalDomain_not_in: [BigInt!]
  to: metis_Bytes
  to_not: metis_Bytes
  to_gt: metis_Bytes
  to_lt: metis_Bytes
  to_gte: metis_Bytes
  to_lte: metis_Bytes
  to_in: [metis_Bytes!]
  to_not_in: [metis_Bytes!]
  to_contains: metis_Bytes
  to_not_contains: metis_Bytes
  delegate: metis_Bytes
  delegate_not: metis_Bytes
  delegate_gt: metis_Bytes
  delegate_lt: metis_Bytes
  delegate_gte: metis_Bytes
  delegate_lte: metis_Bytes
  delegate_in: [metis_Bytes!]
  delegate_not_in: [metis_Bytes!]
  delegate_contains: metis_Bytes
  delegate_not_contains: metis_Bytes
  receiveLocal: Boolean
  receiveLocal_not: Boolean
  receiveLocal_in: [Boolean!]
  receiveLocal_not_in: [Boolean!]
  callData: metis_Bytes
  callData_not: metis_Bytes
  callData_gt: metis_Bytes
  callData_lt: metis_Bytes
  callData_gte: metis_Bytes
  callData_lte: metis_Bytes
  callData_in: [metis_Bytes!]
  callData_not_in: [metis_Bytes!]
  callData_contains: metis_Bytes
  callData_not_contains: metis_Bytes
  slippage: BigInt
  slippage_not: BigInt
  slippage_gt: BigInt
  slippage_lt: BigInt
  slippage_gte: BigInt
  slippage_lte: BigInt
  slippage_in: [BigInt!]
  slippage_not_in: [BigInt!]
  bumpSlippageCount: BigInt
  bumpSlippageCount_not: BigInt
  bumpSlippageCount_gt: BigInt
  bumpSlippageCount_lt: BigInt
  bumpSlippageCount_gte: BigInt
  bumpSlippageCount_lte: BigInt
  bumpSlippageCount_in: [BigInt!]
  bumpSlippageCount_not_in: [BigInt!]
  originSender: metis_Bytes
  originSender_not: metis_Bytes
  originSender_gt: metis_Bytes
  originSender_lt: metis_Bytes
  originSender_gte: metis_Bytes
  originSender_lte: metis_Bytes
  originSender_in: [metis_Bytes!]
  originSender_not_in: [metis_Bytes!]
  originSender_contains: metis_Bytes
  originSender_not_contains: metis_Bytes
  bridgedAmt: BigInt
  bridgedAmt_not: BigInt
  bridgedAmt_gt: BigInt
  bridgedAmt_lt: BigInt
  bridgedAmt_gte: BigInt
  bridgedAmt_lte: BigInt
  bridgedAmt_in: [BigInt!]
  bridgedAmt_not_in: [BigInt!]
  normalizedIn: BigInt
  normalizedIn_not: BigInt
  normalizedIn_gt: BigInt
  normalizedIn_lt: BigInt
  normalizedIn_gte: BigInt
  normalizedIn_lte: BigInt
  normalizedIn_in: [BigInt!]
  normalizedIn_not_in: [BigInt!]
  canonicalId: metis_Bytes
  canonicalId_not: metis_Bytes
  canonicalId_gt: metis_Bytes
  canonicalId_lt: metis_Bytes
  canonicalId_gte: metis_Bytes
  canonicalId_lte: metis_Bytes
  canonicalId_in: [metis_Bytes!]
  canonicalId_not_in: [metis_Bytes!]
  canonicalId_contains: metis_Bytes
  canonicalId_not_contains: metis_Bytes
  asset: String
  asset_not: String
  asset_gt: String
  asset_lt: String
  asset_gte: String
  asset_lte: String
  asset_in: [String!]
  asset_not_in: [String!]
  asset_contains: String
  asset_contains_nocase: String
  asset_not_contains: String
  asset_not_contains_nocase: String
  asset_starts_with: String
  asset_starts_with_nocase: String
  asset_not_starts_with: String
  asset_not_starts_with_nocase: String
  asset_ends_with: String
  asset_ends_with_nocase: String
  asset_not_ends_with: String
  asset_not_ends_with_nocase: String
  asset_: metis_Asset_filter
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  routersFee: BigInt
  routersFee_not: BigInt
  routersFee_gt: BigInt
  routersFee_lt: BigInt
  routersFee_gte: BigInt
  routersFee_lte: BigInt
  routersFee_in: [BigInt!]
  routersFee_not_in: [BigInt!]
  executedCaller: metis_Bytes
  executedCaller_not: metis_Bytes
  executedCaller_gt: metis_Bytes
  executedCaller_lt: metis_Bytes
  executedCaller_gte: metis_Bytes
  executedCaller_lte: metis_Bytes
  executedCaller_in: [metis_Bytes!]
  executedCaller_not_in: [metis_Bytes!]
  executedCaller_contains: metis_Bytes
  executedCaller_not_contains: metis_Bytes
  executedTransactionHash: metis_Bytes
  executedTransactionHash_not: metis_Bytes
  executedTransactionHash_gt: metis_Bytes
  executedTransactionHash_lt: metis_Bytes
  executedTransactionHash_gte: metis_Bytes
  executedTransactionHash_lte: metis_Bytes
  executedTransactionHash_in: [metis_Bytes!]
  executedTransactionHash_not_in: [metis_Bytes!]
  executedTransactionHash_contains: metis_Bytes
  executedTransactionHash_not_contains: metis_Bytes
  executedTimestamp: BigInt
  executedTimestamp_not: BigInt
  executedTimestamp_gt: BigInt
  executedTimestamp_lt: BigInt
  executedTimestamp_gte: BigInt
  executedTimestamp_lte: BigInt
  executedTimestamp_in: [BigInt!]
  executedTimestamp_not_in: [BigInt!]
  executedGasPrice: BigInt
  executedGasPrice_not: BigInt
  executedGasPrice_gt: BigInt
  executedGasPrice_lt: BigInt
  executedGasPrice_gte: BigInt
  executedGasPrice_lte: BigInt
  executedGasPrice_in: [BigInt!]
  executedGasPrice_not_in: [BigInt!]
  executedGasLimit: BigInt
  executedGasLimit_not: BigInt
  executedGasLimit_gt: BigInt
  executedGasLimit_lt: BigInt
  executedGasLimit_gte: BigInt
  executedGasLimit_lte: BigInt
  executedGasLimit_in: [BigInt!]
  executedGasLimit_not_in: [BigInt!]
  executedBlockNumber: BigInt
  executedBlockNumber_not: BigInt
  executedBlockNumber_gt: BigInt
  executedBlockNumber_lt: BigInt
  executedBlockNumber_gte: BigInt
  executedBlockNumber_lte: BigInt
  executedBlockNumber_in: [BigInt!]
  executedBlockNumber_not_in: [BigInt!]
  executedTxOrigin: metis_Bytes
  executedTxOrigin_not: metis_Bytes
  executedTxOrigin_gt: metis_Bytes
  executedTxOrigin_lt: metis_Bytes
  executedTxOrigin_gte: metis_Bytes
  executedTxOrigin_lte: metis_Bytes
  executedTxOrigin_in: [metis_Bytes!]
  executedTxOrigin_not_in: [metis_Bytes!]
  executedTxOrigin_contains: metis_Bytes
  executedTxOrigin_not_contains: metis_Bytes
  executedTxNonce: BigInt
  executedTxNonce_not: BigInt
  executedTxNonce_gt: BigInt
  executedTxNonce_lt: BigInt
  executedTxNonce_gte: BigInt
  executedTxNonce_lte: BigInt
  executedTxNonce_in: [BigInt!]
  executedTxNonce_not_in: [BigInt!]
  reconciledCaller: metis_Bytes
  reconciledCaller_not: metis_Bytes
  reconciledCaller_gt: metis_Bytes
  reconciledCaller_lt: metis_Bytes
  reconciledCaller_gte: metis_Bytes
  reconciledCaller_lte: metis_Bytes
  reconciledCaller_in: [metis_Bytes!]
  reconciledCaller_not_in: [metis_Bytes!]
  reconciledCaller_contains: metis_Bytes
  reconciledCaller_not_contains: metis_Bytes
  reconciledTransactionHash: metis_Bytes
  reconciledTransactionHash_not: metis_Bytes
  reconciledTransactionHash_gt: metis_Bytes
  reconciledTransactionHash_lt: metis_Bytes
  reconciledTransactionHash_gte: metis_Bytes
  reconciledTransactionHash_lte: metis_Bytes
  reconciledTransactionHash_in: [metis_Bytes!]
  reconciledTransactionHash_not_in: [metis_Bytes!]
  reconciledTransactionHash_contains: metis_Bytes
  reconciledTransactionHash_not_contains: metis_Bytes
  reconciledTimestamp: BigInt
  reconciledTimestamp_not: BigInt
  reconciledTimestamp_gt: BigInt
  reconciledTimestamp_lt: BigInt
  reconciledTimestamp_gte: BigInt
  reconciledTimestamp_lte: BigInt
  reconciledTimestamp_in: [BigInt!]
  reconciledTimestamp_not_in: [BigInt!]
  reconciledGasPrice: BigInt
  reconciledGasPrice_not: BigInt
  reconciledGasPrice_gt: BigInt
  reconciledGasPrice_lt: BigInt
  reconciledGasPrice_gte: BigInt
  reconciledGasPrice_lte: BigInt
  reconciledGasPrice_in: [BigInt!]
  reconciledGasPrice_not_in: [BigInt!]
  reconciledGasLimit: BigInt
  reconciledGasLimit_not: BigInt
  reconciledGasLimit_gt: BigInt
  reconciledGasLimit_lt: BigInt
  reconciledGasLimit_gte: BigInt
  reconciledGasLimit_lte: BigInt
  reconciledGasLimit_in: [BigInt!]
  reconciledGasLimit_not_in: [BigInt!]
  reconciledBlockNumber: BigInt
  reconciledBlockNumber_not: BigInt
  reconciledBlockNumber_gt: BigInt
  reconciledBlockNumber_lt: BigInt
  reconciledBlockNumber_gte: BigInt
  reconciledBlockNumber_lte: BigInt
  reconciledBlockNumber_in: [BigInt!]
  reconciledBlockNumber_not_in: [BigInt!]
  reconciledTxOrigin: metis_Bytes
  reconciledTxOrigin_not: metis_Bytes
  reconciledTxOrigin_gt: metis_Bytes
  reconciledTxOrigin_lt: metis_Bytes
  reconciledTxOrigin_gte: metis_Bytes
  reconciledTxOrigin_lte: metis_Bytes
  reconciledTxOrigin_in: [metis_Bytes!]
  reconciledTxOrigin_not_in: [metis_Bytes!]
  reconciledTxOrigin_contains: metis_Bytes
  reconciledTxOrigin_not_contains: metis_Bytes
  reconciledTxNonce: BigInt
  reconciledTxNonce_not: BigInt
  reconciledTxNonce_gt: BigInt
  reconciledTxNonce_lt: BigInt
  reconciledTxNonce_gte: BigInt
  reconciledTxNonce_lte: BigInt
  reconciledTxNonce_in: [BigInt!]
  reconciledTxNonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: metis_BlockChangedFilter
  and: [metis_DestinationTransfer_filter]
  or: [metis_DestinationTransfer_filter]
}

enum metis_DestinationTransfer_orderBy {
  id
  chainId
  transferId
  nonce
  status
  routers
  originDomain
  destinationDomain
  canonicalDomain
  to
  delegate
  receiveLocal
  callData
  slippage
  bumpSlippageCount
  originSender
  bridgedAmt
  normalizedIn
  canonicalId
  asset
  asset__id
  asset__key
  asset__decimal
  asset__adoptedDecimal
  asset__canonicalId
  asset__canonicalDomain
  asset__adoptedAsset
  asset__localAsset
  asset__blockNumber
  amount
  routersFee
  executedCaller
  executedTransactionHash
  executedTimestamp
  executedGasPrice
  executedGasLimit
  executedBlockNumber
  executedTxOrigin
  executedTxNonce
  reconciledCaller
  reconciledTransactionHash
  reconciledTimestamp
  reconciledGasPrice
  reconciledGasLimit
  reconciledBlockNumber
  reconciledTxOrigin
  reconciledTxNonce
}

"""
8 bytes signed integer

"""
scalar metis_Int8

type metis_OptimisticRootFinalized {
  id: ID!
  aggregateRoot: metis_Bytes!
  timestamp: BigInt!
  blockNumber: BigInt
}

input metis_OptimisticRootFinalized_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  aggregateRoot: metis_Bytes
  aggregateRoot_not: metis_Bytes
  aggregateRoot_gt: metis_Bytes
  aggregateRoot_lt: metis_Bytes
  aggregateRoot_gte: metis_Bytes
  aggregateRoot_lte: metis_Bytes
  aggregateRoot_in: [metis_Bytes!]
  aggregateRoot_not_in: [metis_Bytes!]
  aggregateRoot_contains: metis_Bytes
  aggregateRoot_not_contains: metis_Bytes
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: metis_BlockChangedFilter
  and: [metis_OptimisticRootFinalized_filter]
  or: [metis_OptimisticRootFinalized_filter]
}

enum metis_OptimisticRootFinalized_orderBy {
  id
  aggregateRoot
  timestamp
  blockNumber
}

"""Defines the order direction, either ascending or descending"""
enum metis_OrderDirection {
  asc
  desc
}

type metis_OriginMessage {
  id: ID!
  transferId: metis_Bytes
  destinationDomain: BigInt
  leaf: metis_Bytes
  index: BigInt
  message: metis_Bytes
  root: metis_Bytes
  transactionHash: metis_Bytes
  blockNumber: BigInt
  rootCount: metis_RootCount
}

input metis_OriginMessage_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transferId: metis_Bytes
  transferId_not: metis_Bytes
  transferId_gt: metis_Bytes
  transferId_lt: metis_Bytes
  transferId_gte: metis_Bytes
  transferId_lte: metis_Bytes
  transferId_in: [metis_Bytes!]
  transferId_not_in: [metis_Bytes!]
  transferId_contains: metis_Bytes
  transferId_not_contains: metis_Bytes
  destinationDomain: BigInt
  destinationDomain_not: BigInt
  destinationDomain_gt: BigInt
  destinationDomain_lt: BigInt
  destinationDomain_gte: BigInt
  destinationDomain_lte: BigInt
  destinationDomain_in: [BigInt!]
  destinationDomain_not_in: [BigInt!]
  leaf: metis_Bytes
  leaf_not: metis_Bytes
  leaf_gt: metis_Bytes
  leaf_lt: metis_Bytes
  leaf_gte: metis_Bytes
  leaf_lte: metis_Bytes
  leaf_in: [metis_Bytes!]
  leaf_not_in: [metis_Bytes!]
  leaf_contains: metis_Bytes
  leaf_not_contains: metis_Bytes
  index: BigInt
  index_not: BigInt
  index_gt: BigInt
  index_lt: BigInt
  index_gte: BigInt
  index_lte: BigInt
  index_in: [BigInt!]
  index_not_in: [BigInt!]
  message: metis_Bytes
  message_not: metis_Bytes
  message_gt: metis_Bytes
  message_lt: metis_Bytes
  message_gte: metis_Bytes
  message_lte: metis_Bytes
  message_in: [metis_Bytes!]
  message_not_in: [metis_Bytes!]
  message_contains: metis_Bytes
  message_not_contains: metis_Bytes
  root: metis_Bytes
  root_not: metis_Bytes
  root_gt: metis_Bytes
  root_lt: metis_Bytes
  root_gte: metis_Bytes
  root_lte: metis_Bytes
  root_in: [metis_Bytes!]
  root_not_in: [metis_Bytes!]
  root_contains: metis_Bytes
  root_not_contains: metis_Bytes
  transactionHash: metis_Bytes
  transactionHash_not: metis_Bytes
  transactionHash_gt: metis_Bytes
  transactionHash_lt: metis_Bytes
  transactionHash_gte: metis_Bytes
  transactionHash_lte: metis_Bytes
  transactionHash_in: [metis_Bytes!]
  transactionHash_not_in: [metis_Bytes!]
  transactionHash_contains: metis_Bytes
  transactionHash_not_contains: metis_Bytes
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  rootCount: String
  rootCount_not: String
  rootCount_gt: String
  rootCount_lt: String
  rootCount_gte: String
  rootCount_lte: String
  rootCount_in: [String!]
  rootCount_not_in: [String!]
  rootCount_contains: String
  rootCount_contains_nocase: String
  rootCount_not_contains: String
  rootCount_not_contains_nocase: String
  rootCount_starts_with: String
  rootCount_starts_with_nocase: String
  rootCount_not_starts_with: String
  rootCount_not_starts_with_nocase: String
  rootCount_ends_with: String
  rootCount_ends_with_nocase: String
  rootCount_not_ends_with: String
  rootCount_not_ends_with_nocase: String
  rootCount_: metis_RootCount_filter
  """Filter for the block changed event."""
  _change_block: metis_BlockChangedFilter
  and: [metis_OriginMessage_filter]
  or: [metis_OriginMessage_filter]
}

enum metis_OriginMessage_orderBy {
  id
  transferId
  destinationDomain
  leaf
  index
  message
  root
  transactionHash
  blockNumber
  rootCount
  rootCount__id
  rootCount__count
}

type metis_OriginTransfer {
  id: ID!
  chainId: BigInt
  transferId: metis_Bytes
  nonce: BigInt
  status: metis_TransferStatus
  messageHash: metis_Bytes
  originDomain: BigInt
  destinationDomain: BigInt
  canonicalDomain: BigInt
  to: metis_Bytes
  delegate: metis_Bytes
  receiveLocal: Boolean
  callData: metis_Bytes
  slippage: BigInt
  originSender: metis_Bytes
  bridgedAmt: BigInt
  normalizedIn: BigInt
  canonicalId: metis_Bytes
  asset: metis_Asset
  transactingAsset: metis_Bytes
  message: metis_OriginMessage
  bumpRelayerFeeCount: BigInt
  relayerFees(skip: Int = 0, first: Int = 100, orderBy: metis_RelayerFee_orderBy, orderDirection: metis_OrderDirection, where: metis_RelayerFee_filter): [metis_RelayerFee!]
  initialRelayerFeeAsset: metis_Bytes
  caller: metis_Bytes
  transactionHash: metis_Bytes
  timestamp: BigInt
  gasPrice: BigInt
  gasLimit: BigInt
  blockNumber: BigInt
  txOrigin: metis_Bytes
  txNonce: BigInt
}

input metis_OriginTransfer_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  chainId: BigInt
  chainId_not: BigInt
  chainId_gt: BigInt
  chainId_lt: BigInt
  chainId_gte: BigInt
  chainId_lte: BigInt
  chainId_in: [BigInt!]
  chainId_not_in: [BigInt!]
  transferId: metis_Bytes
  transferId_not: metis_Bytes
  transferId_gt: metis_Bytes
  transferId_lt: metis_Bytes
  transferId_gte: metis_Bytes
  transferId_lte: metis_Bytes
  transferId_in: [metis_Bytes!]
  transferId_not_in: [metis_Bytes!]
  transferId_contains: metis_Bytes
  transferId_not_contains: metis_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  status: metis_TransferStatus
  status_not: metis_TransferStatus
  status_in: [metis_TransferStatus!]
  status_not_in: [metis_TransferStatus!]
  messageHash: metis_Bytes
  messageHash_not: metis_Bytes
  messageHash_gt: metis_Bytes
  messageHash_lt: metis_Bytes
  messageHash_gte: metis_Bytes
  messageHash_lte: metis_Bytes
  messageHash_in: [metis_Bytes!]
  messageHash_not_in: [metis_Bytes!]
  messageHash_contains: metis_Bytes
  messageHash_not_contains: metis_Bytes
  originDomain: BigInt
  originDomain_not: BigInt
  originDomain_gt: BigInt
  originDomain_lt: BigInt
  originDomain_gte: BigInt
  originDomain_lte: BigInt
  originDomain_in: [BigInt!]
  originDomain_not_in: [BigInt!]
  destinationDomain: BigInt
  destinationDomain_not: BigInt
  destinationDomain_gt: BigInt
  destinationDomain_lt: BigInt
  destinationDomain_gte: BigInt
  destinationDomain_lte: BigInt
  destinationDomain_in: [BigInt!]
  destinationDomain_not_in: [BigInt!]
  canonicalDomain: BigInt
  canonicalDomain_not: BigInt
  canonicalDomain_gt: BigInt
  canonicalDomain_lt: BigInt
  canonicalDomain_gte: BigInt
  canonicalDomain_lte: BigInt
  canonicalDomain_in: [BigInt!]
  canonicalDomain_not_in: [BigInt!]
  to: metis_Bytes
  to_not: metis_Bytes
  to_gt: metis_Bytes
  to_lt: metis_Bytes
  to_gte: metis_Bytes
  to_lte: metis_Bytes
  to_in: [metis_Bytes!]
  to_not_in: [metis_Bytes!]
  to_contains: metis_Bytes
  to_not_contains: metis_Bytes
  delegate: metis_Bytes
  delegate_not: metis_Bytes
  delegate_gt: metis_Bytes
  delegate_lt: metis_Bytes
  delegate_gte: metis_Bytes
  delegate_lte: metis_Bytes
  delegate_in: [metis_Bytes!]
  delegate_not_in: [metis_Bytes!]
  delegate_contains: metis_Bytes
  delegate_not_contains: metis_Bytes
  receiveLocal: Boolean
  receiveLocal_not: Boolean
  receiveLocal_in: [Boolean!]
  receiveLocal_not_in: [Boolean!]
  callData: metis_Bytes
  callData_not: metis_Bytes
  callData_gt: metis_Bytes
  callData_lt: metis_Bytes
  callData_gte: metis_Bytes
  callData_lte: metis_Bytes
  callData_in: [metis_Bytes!]
  callData_not_in: [metis_Bytes!]
  callData_contains: metis_Bytes
  callData_not_contains: metis_Bytes
  slippage: BigInt
  slippage_not: BigInt
  slippage_gt: BigInt
  slippage_lt: BigInt
  slippage_gte: BigInt
  slippage_lte: BigInt
  slippage_in: [BigInt!]
  slippage_not_in: [BigInt!]
  originSender: metis_Bytes
  originSender_not: metis_Bytes
  originSender_gt: metis_Bytes
  originSender_lt: metis_Bytes
  originSender_gte: metis_Bytes
  originSender_lte: metis_Bytes
  originSender_in: [metis_Bytes!]
  originSender_not_in: [metis_Bytes!]
  originSender_contains: metis_Bytes
  originSender_not_contains: metis_Bytes
  bridgedAmt: BigInt
  bridgedAmt_not: BigInt
  bridgedAmt_gt: BigInt
  bridgedAmt_lt: BigInt
  bridgedAmt_gte: BigInt
  bridgedAmt_lte: BigInt
  bridgedAmt_in: [BigInt!]
  bridgedAmt_not_in: [BigInt!]
  normalizedIn: BigInt
  normalizedIn_not: BigInt
  normalizedIn_gt: BigInt
  normalizedIn_lt: BigInt
  normalizedIn_gte: BigInt
  normalizedIn_lte: BigInt
  normalizedIn_in: [BigInt!]
  normalizedIn_not_in: [BigInt!]
  canonicalId: metis_Bytes
  canonicalId_not: metis_Bytes
  canonicalId_gt: metis_Bytes
  canonicalId_lt: metis_Bytes
  canonicalId_gte: metis_Bytes
  canonicalId_lte: metis_Bytes
  canonicalId_in: [metis_Bytes!]
  canonicalId_not_in: [metis_Bytes!]
  canonicalId_contains: metis_Bytes
  canonicalId_not_contains: metis_Bytes
  asset: String
  asset_not: String
  asset_gt: String
  asset_lt: String
  asset_gte: String
  asset_lte: String
  asset_in: [String!]
  asset_not_in: [String!]
  asset_contains: String
  asset_contains_nocase: String
  asset_not_contains: String
  asset_not_contains_nocase: String
  asset_starts_with: String
  asset_starts_with_nocase: String
  asset_not_starts_with: String
  asset_not_starts_with_nocase: String
  asset_ends_with: String
  asset_ends_with_nocase: String
  asset_not_ends_with: String
  asset_not_ends_with_nocase: String
  asset_: metis_Asset_filter
  transactingAsset: metis_Bytes
  transactingAsset_not: metis_Bytes
  transactingAsset_gt: metis_Bytes
  transactingAsset_lt: metis_Bytes
  transactingAsset_gte: metis_Bytes
  transactingAsset_lte: metis_Bytes
  transactingAsset_in: [metis_Bytes!]
  transactingAsset_not_in: [metis_Bytes!]
  transactingAsset_contains: metis_Bytes
  transactingAsset_not_contains: metis_Bytes
  message: String
  message_not: String
  message_gt: String
  message_lt: String
  message_gte: String
  message_lte: String
  message_in: [String!]
  message_not_in: [String!]
  message_contains: String
  message_contains_nocase: String
  message_not_contains: String
  message_not_contains_nocase: String
  message_starts_with: String
  message_starts_with_nocase: String
  message_not_starts_with: String
  message_not_starts_with_nocase: String
  message_ends_with: String
  message_ends_with_nocase: String
  message_not_ends_with: String
  message_not_ends_with_nocase: String
  message_: metis_OriginMessage_filter
  bumpRelayerFeeCount: BigInt
  bumpRelayerFeeCount_not: BigInt
  bumpRelayerFeeCount_gt: BigInt
  bumpRelayerFeeCount_lt: BigInt
  bumpRelayerFeeCount_gte: BigInt
  bumpRelayerFeeCount_lte: BigInt
  bumpRelayerFeeCount_in: [BigInt!]
  bumpRelayerFeeCount_not_in: [BigInt!]
  relayerFees: [String!]
  relayerFees_not: [String!]
  relayerFees_contains: [String!]
  relayerFees_contains_nocase: [String!]
  relayerFees_not_contains: [String!]
  relayerFees_not_contains_nocase: [String!]
  relayerFees_: metis_RelayerFee_filter
  initialRelayerFeeAsset: metis_Bytes
  initialRelayerFeeAsset_not: metis_Bytes
  initialRelayerFeeAsset_gt: metis_Bytes
  initialRelayerFeeAsset_lt: metis_Bytes
  initialRelayerFeeAsset_gte: metis_Bytes
  initialRelayerFeeAsset_lte: metis_Bytes
  initialRelayerFeeAsset_in: [metis_Bytes!]
  initialRelayerFeeAsset_not_in: [metis_Bytes!]
  initialRelayerFeeAsset_contains: metis_Bytes
  initialRelayerFeeAsset_not_contains: metis_Bytes
  caller: metis_Bytes
  caller_not: metis_Bytes
  caller_gt: metis_Bytes
  caller_lt: metis_Bytes
  caller_gte: metis_Bytes
  caller_lte: metis_Bytes
  caller_in: [metis_Bytes!]
  caller_not_in: [metis_Bytes!]
  caller_contains: metis_Bytes
  caller_not_contains: metis_Bytes
  transactionHash: metis_Bytes
  transactionHash_not: metis_Bytes
  transactionHash_gt: metis_Bytes
  transactionHash_lt: metis_Bytes
  transactionHash_gte: metis_Bytes
  transactionHash_lte: metis_Bytes
  transactionHash_in: [metis_Bytes!]
  transactionHash_not_in: [metis_Bytes!]
  transactionHash_contains: metis_Bytes
  transactionHash_not_contains: metis_Bytes
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  gasLimit: BigInt
  gasLimit_not: BigInt
  gasLimit_gt: BigInt
  gasLimit_lt: BigInt
  gasLimit_gte: BigInt
  gasLimit_lte: BigInt
  gasLimit_in: [BigInt!]
  gasLimit_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  txOrigin: metis_Bytes
  txOrigin_not: metis_Bytes
  txOrigin_gt: metis_Bytes
  txOrigin_lt: metis_Bytes
  txOrigin_gte: metis_Bytes
  txOrigin_lte: metis_Bytes
  txOrigin_in: [metis_Bytes!]
  txOrigin_not_in: [metis_Bytes!]
  txOrigin_contains: metis_Bytes
  txOrigin_not_contains: metis_Bytes
  txNonce: BigInt
  txNonce_not: BigInt
  txNonce_gt: BigInt
  txNonce_lt: BigInt
  txNonce_gte: BigInt
  txNonce_lte: BigInt
  txNonce_in: [BigInt!]
  txNonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: metis_BlockChangedFilter
  and: [metis_OriginTransfer_filter]
  or: [metis_OriginTransfer_filter]
}

enum metis_OriginTransfer_orderBy {
  id
  chainId
  transferId
  nonce
  status
  messageHash
  originDomain
  destinationDomain
  canonicalDomain
  to
  delegate
  receiveLocal
  callData
  slippage
  originSender
  bridgedAmt
  normalizedIn
  canonicalId
  asset
  asset__id
  asset__key
  asset__decimal
  asset__adoptedDecimal
  asset__canonicalId
  asset__canonicalDomain
  asset__adoptedAsset
  asset__localAsset
  asset__blockNumber
  transactingAsset
  message
  message__id
  message__transferId
  message__destinationDomain
  message__leaf
  message__index
  message__message
  message__root
  message__transactionHash
  message__blockNumber
  bumpRelayerFeeCount
  relayerFees
  initialRelayerFeeAsset
  caller
  transactionHash
  timestamp
  gasPrice
  gasLimit
  blockNumber
  txOrigin
  txNonce
}

type metis_Relayer {
  id: ID!
  isActive: Boolean!
  relayer: metis_Bytes
}

type metis_RelayerFee {
  id: ID!
  transfer: metis_OriginTransfer!
  fee: BigInt!
  asset: metis_Bytes!
}

input metis_RelayerFee_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transfer: String
  transfer_not: String
  transfer_gt: String
  transfer_lt: String
  transfer_gte: String
  transfer_lte: String
  transfer_in: [String!]
  transfer_not_in: [String!]
  transfer_contains: String
  transfer_contains_nocase: String
  transfer_not_contains: String
  transfer_not_contains_nocase: String
  transfer_starts_with: String
  transfer_starts_with_nocase: String
  transfer_not_starts_with: String
  transfer_not_starts_with_nocase: String
  transfer_ends_with: String
  transfer_ends_with_nocase: String
  transfer_not_ends_with: String
  transfer_not_ends_with_nocase: String
  transfer_: metis_OriginTransfer_filter
  fee: BigInt
  fee_not: BigInt
  fee_gt: BigInt
  fee_lt: BigInt
  fee_gte: BigInt
  fee_lte: BigInt
  fee_in: [BigInt!]
  fee_not_in: [BigInt!]
  asset: metis_Bytes
  asset_not: metis_Bytes
  asset_gt: metis_Bytes
  asset_lt: metis_Bytes
  asset_gte: metis_Bytes
  asset_lte: metis_Bytes
  asset_in: [metis_Bytes!]
  asset_not_in: [metis_Bytes!]
  asset_contains: metis_Bytes
  asset_not_contains: metis_Bytes
  """Filter for the block changed event."""
  _change_block: metis_BlockChangedFilter
  and: [metis_RelayerFee_filter]
  or: [metis_RelayerFee_filter]
}

enum metis_RelayerFee_orderBy {
  id
  transfer
  transfer__id
  transfer__chainId
  transfer__transferId
  transfer__nonce
  transfer__status
  transfer__messageHash
  transfer__originDomain
  transfer__destinationDomain
  transfer__canonicalDomain
  transfer__to
  transfer__delegate
  transfer__receiveLocal
  transfer__callData
  transfer__slippage
  transfer__originSender
  transfer__bridgedAmt
  transfer__normalizedIn
  transfer__canonicalId
  transfer__transactingAsset
  transfer__bumpRelayerFeeCount
  transfer__initialRelayerFeeAsset
  transfer__caller
  transfer__transactionHash
  transfer__timestamp
  transfer__gasPrice
  transfer__gasLimit
  transfer__blockNumber
  transfer__txOrigin
  transfer__txNonce
  fee
  asset
}

type metis_RelayerFeesIncrease {
  id: ID!
  transfer: metis_OriginTransfer!
  increase: BigInt
  asset: metis_Bytes
  caller: metis_Bytes!
  transactionHash: metis_Bytes!
  timestamp: BigInt!
  gasPrice: BigInt!
  gasLimit: BigInt!
  blockNumber: BigInt!
}

input metis_RelayerFeesIncrease_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transfer: String
  transfer_not: String
  transfer_gt: String
  transfer_lt: String
  transfer_gte: String
  transfer_lte: String
  transfer_in: [String!]
  transfer_not_in: [String!]
  transfer_contains: String
  transfer_contains_nocase: String
  transfer_not_contains: String
  transfer_not_contains_nocase: String
  transfer_starts_with: String
  transfer_starts_with_nocase: String
  transfer_not_starts_with: String
  transfer_not_starts_with_nocase: String
  transfer_ends_with: String
  transfer_ends_with_nocase: String
  transfer_not_ends_with: String
  transfer_not_ends_with_nocase: String
  transfer_: metis_OriginTransfer_filter
  increase: BigInt
  increase_not: BigInt
  increase_gt: BigInt
  increase_lt: BigInt
  increase_gte: BigInt
  increase_lte: BigInt
  increase_in: [BigInt!]
  increase_not_in: [BigInt!]
  asset: metis_Bytes
  asset_not: metis_Bytes
  asset_gt: metis_Bytes
  asset_lt: metis_Bytes
  asset_gte: metis_Bytes
  asset_lte: metis_Bytes
  asset_in: [metis_Bytes!]
  asset_not_in: [metis_Bytes!]
  asset_contains: metis_Bytes
  asset_not_contains: metis_Bytes
  caller: metis_Bytes
  caller_not: metis_Bytes
  caller_gt: metis_Bytes
  caller_lt: metis_Bytes
  caller_gte: metis_Bytes
  caller_lte: metis_Bytes
  caller_in: [metis_Bytes!]
  caller_not_in: [metis_Bytes!]
  caller_contains: metis_Bytes
  caller_not_contains: metis_Bytes
  transactionHash: metis_Bytes
  transactionHash_not: metis_Bytes
  transactionHash_gt: metis_Bytes
  transactionHash_lt: metis_Bytes
  transactionHash_gte: metis_Bytes
  transactionHash_lte: metis_Bytes
  transactionHash_in: [metis_Bytes!]
  transactionHash_not_in: [metis_Bytes!]
  transactionHash_contains: metis_Bytes
  transactionHash_not_contains: metis_Bytes
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  gasLimit: BigInt
  gasLimit_not: BigInt
  gasLimit_gt: BigInt
  gasLimit_lt: BigInt
  gasLimit_gte: BigInt
  gasLimit_lte: BigInt
  gasLimit_in: [BigInt!]
  gasLimit_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: metis_BlockChangedFilter
  and: [metis_RelayerFeesIncrease_filter]
  or: [metis_RelayerFeesIncrease_filter]
}

enum metis_RelayerFeesIncrease_orderBy {
  id
  transfer
  transfer__id
  transfer__chainId
  transfer__transferId
  transfer__nonce
  transfer__status
  transfer__messageHash
  transfer__originDomain
  transfer__destinationDomain
  transfer__canonicalDomain
  transfer__to
  transfer__delegate
  transfer__receiveLocal
  transfer__callData
  transfer__slippage
  transfer__originSender
  transfer__bridgedAmt
  transfer__normalizedIn
  transfer__canonicalId
  transfer__transactingAsset
  transfer__bumpRelayerFeeCount
  transfer__initialRelayerFeeAsset
  transfer__caller
  transfer__transactionHash
  transfer__timestamp
  transfer__gasPrice
  transfer__gasLimit
  transfer__blockNumber
  transfer__txOrigin
  transfer__txNonce
  increase
  asset
  caller
  transactionHash
  timestamp
  gasPrice
  gasLimit
  blockNumber
}

input metis_Relayer_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  isActive: Boolean
  isActive_not: Boolean
  isActive_in: [Boolean!]
  isActive_not_in: [Boolean!]
  relayer: metis_Bytes
  relayer_not: metis_Bytes
  relayer_gt: metis_Bytes
  relayer_lt: metis_Bytes
  relayer_gte: metis_Bytes
  relayer_lte: metis_Bytes
  relayer_in: [metis_Bytes!]
  relayer_not_in: [metis_Bytes!]
  relayer_contains: metis_Bytes
  relayer_not_contains: metis_Bytes
  """Filter for the block changed event."""
  _change_block: metis_BlockChangedFilter
  and: [metis_Relayer_filter]
  or: [metis_Relayer_filter]
}

enum metis_Relayer_orderBy {
  id
  isActive
  relayer
}

type metis_RootCount {
  id: ID!
  count: BigInt
}

input metis_RootCount_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  count: BigInt
  count_not: BigInt
  count_gt: BigInt
  count_lt: BigInt
  count_gte: BigInt
  count_lte: BigInt
  count_in: [BigInt!]
  count_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: metis_BlockChangedFilter
  and: [metis_RootCount_filter]
  or: [metis_RootCount_filter]
}

enum metis_RootCount_orderBy {
  id
  count
}

type metis_RootMessageSent {
  id: ID!
  spokeDomain: BigInt
  hubDomain: BigInt
  root: metis_Bytes
  count: BigInt
  caller: metis_Bytes
  transactionHash: metis_Bytes
  timestamp: BigInt
  gasPrice: BigInt
  gasLimit: BigInt
  blockNumber: BigInt
}

input metis_RootMessageSent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  spokeDomain: BigInt
  spokeDomain_not: BigInt
  spokeDomain_gt: BigInt
  spokeDomain_lt: BigInt
  spokeDomain_gte: BigInt
  spokeDomain_lte: BigInt
  spokeDomain_in: [BigInt!]
  spokeDomain_not_in: [BigInt!]
  hubDomain: BigInt
  hubDomain_not: BigInt
  hubDomain_gt: BigInt
  hubDomain_lt: BigInt
  hubDomain_gte: BigInt
  hubDomain_lte: BigInt
  hubDomain_in: [BigInt!]
  hubDomain_not_in: [BigInt!]
  root: metis_Bytes
  root_not: metis_Bytes
  root_gt: metis_Bytes
  root_lt: metis_Bytes
  root_gte: metis_Bytes
  root_lte: metis_Bytes
  root_in: [metis_Bytes!]
  root_not_in: [metis_Bytes!]
  root_contains: metis_Bytes
  root_not_contains: metis_Bytes
  count: BigInt
  count_not: BigInt
  count_gt: BigInt
  count_lt: BigInt
  count_gte: BigInt
  count_lte: BigInt
  count_in: [BigInt!]
  count_not_in: [BigInt!]
  caller: metis_Bytes
  caller_not: metis_Bytes
  caller_gt: metis_Bytes
  caller_lt: metis_Bytes
  caller_gte: metis_Bytes
  caller_lte: metis_Bytes
  caller_in: [metis_Bytes!]
  caller_not_in: [metis_Bytes!]
  caller_contains: metis_Bytes
  caller_not_contains: metis_Bytes
  transactionHash: metis_Bytes
  transactionHash_not: metis_Bytes
  transactionHash_gt: metis_Bytes
  transactionHash_lt: metis_Bytes
  transactionHash_gte: metis_Bytes
  transactionHash_lte: metis_Bytes
  transactionHash_in: [metis_Bytes!]
  transactionHash_not_in: [metis_Bytes!]
  transactionHash_contains: metis_Bytes
  transactionHash_not_contains: metis_Bytes
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  gasLimit: BigInt
  gasLimit_not: BigInt
  gasLimit_gt: BigInt
  gasLimit_lt: BigInt
  gasLimit_gte: BigInt
  gasLimit_lte: BigInt
  gasLimit_in: [BigInt!]
  gasLimit_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: metis_BlockChangedFilter
  and: [metis_RootMessageSent_filter]
  or: [metis_RootMessageSent_filter]
}

enum metis_RootMessageSent_orderBy {
  id
  spokeDomain
  hubDomain
  root
  count
  caller
  transactionHash
  timestamp
  gasPrice
  gasLimit
  blockNumber
}

type metis_Router {
  id: ID!
  isActive: Boolean!
  owner: metis_Bytes
  recipient: metis_Bytes
  proposedOwner: metis_Bytes
  proposedTimestamp: BigInt
  assetBalances(skip: Int = 0, first: Int = 100, orderBy: metis_AssetBalance_orderBy, orderDirection: metis_OrderDirection, where: metis_AssetBalance_filter): [metis_AssetBalance!]!
}

type metis_RouterDailyTVL {
  id: ID!
  router: metis_Router!
  asset: metis_Asset!
  timestamp: BigInt!
  balance: BigInt!
}

input metis_RouterDailyTVL_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  router: String
  router_not: String
  router_gt: String
  router_lt: String
  router_gte: String
  router_lte: String
  router_in: [String!]
  router_not_in: [String!]
  router_contains: String
  router_contains_nocase: String
  router_not_contains: String
  router_not_contains_nocase: String
  router_starts_with: String
  router_starts_with_nocase: String
  router_not_starts_with: String
  router_not_starts_with_nocase: String
  router_ends_with: String
  router_ends_with_nocase: String
  router_not_ends_with: String
  router_not_ends_with_nocase: String
  router_: metis_Router_filter
  asset: String
  asset_not: String
  asset_gt: String
  asset_lt: String
  asset_gte: String
  asset_lte: String
  asset_in: [String!]
  asset_not_in: [String!]
  asset_contains: String
  asset_contains_nocase: String
  asset_not_contains: String
  asset_not_contains_nocase: String
  asset_starts_with: String
  asset_starts_with_nocase: String
  asset_not_starts_with: String
  asset_not_starts_with_nocase: String
  asset_ends_with: String
  asset_ends_with_nocase: String
  asset_not_ends_with: String
  asset_not_ends_with_nocase: String
  asset_: metis_Asset_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  balance: BigInt
  balance_not: BigInt
  balance_gt: BigInt
  balance_lt: BigInt
  balance_gte: BigInt
  balance_lte: BigInt
  balance_in: [BigInt!]
  balance_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: metis_BlockChangedFilter
  and: [metis_RouterDailyTVL_filter]
  or: [metis_RouterDailyTVL_filter]
}

enum metis_RouterDailyTVL_orderBy {
  id
  router
  router__id
  router__isActive
  router__owner
  router__recipient
  router__proposedOwner
  router__proposedTimestamp
  asset
  asset__id
  asset__key
  asset__decimal
  asset__adoptedDecimal
  asset__canonicalId
  asset__canonicalDomain
  asset__adoptedAsset
  asset__localAsset
  asset__blockNumber
  timestamp
  balance
}

type metis_RouterLiquidityEvent {
  id: ID!
  type: metis_RouterLiquidityEventType
  router: metis_Router!
  asset: metis_Asset!
  amount: BigInt!
  balance: BigInt!
  caller: metis_Bytes
  blockNumber: BigInt!
  timestamp: BigInt!
  transactionHash: metis_Bytes!
  nonce: BigInt!
}

enum metis_RouterLiquidityEventType {
  Add
  Remove
}

input metis_RouterLiquidityEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  type: metis_RouterLiquidityEventType
  type_not: metis_RouterLiquidityEventType
  type_in: [metis_RouterLiquidityEventType!]
  type_not_in: [metis_RouterLiquidityEventType!]
  router: String
  router_not: String
  router_gt: String
  router_lt: String
  router_gte: String
  router_lte: String
  router_in: [String!]
  router_not_in: [String!]
  router_contains: String
  router_contains_nocase: String
  router_not_contains: String
  router_not_contains_nocase: String
  router_starts_with: String
  router_starts_with_nocase: String
  router_not_starts_with: String
  router_not_starts_with_nocase: String
  router_ends_with: String
  router_ends_with_nocase: String
  router_not_ends_with: String
  router_not_ends_with_nocase: String
  router_: metis_Router_filter
  asset: String
  asset_not: String
  asset_gt: String
  asset_lt: String
  asset_gte: String
  asset_lte: String
  asset_in: [String!]
  asset_not_in: [String!]
  asset_contains: String
  asset_contains_nocase: String
  asset_not_contains: String
  asset_not_contains_nocase: String
  asset_starts_with: String
  asset_starts_with_nocase: String
  asset_not_starts_with: String
  asset_not_starts_with_nocase: String
  asset_ends_with: String
  asset_ends_with_nocase: String
  asset_not_ends_with: String
  asset_not_ends_with_nocase: String
  asset_: metis_Asset_filter
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  balance: BigInt
  balance_not: BigInt
  balance_gt: BigInt
  balance_lt: BigInt
  balance_gte: BigInt
  balance_lte: BigInt
  balance_in: [BigInt!]
  balance_not_in: [BigInt!]
  caller: metis_Bytes
  caller_not: metis_Bytes
  caller_gt: metis_Bytes
  caller_lt: metis_Bytes
  caller_gte: metis_Bytes
  caller_lte: metis_Bytes
  caller_in: [metis_Bytes!]
  caller_not_in: [metis_Bytes!]
  caller_contains: metis_Bytes
  caller_not_contains: metis_Bytes
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transactionHash: metis_Bytes
  transactionHash_not: metis_Bytes
  transactionHash_gt: metis_Bytes
  transactionHash_lt: metis_Bytes
  transactionHash_gte: metis_Bytes
  transactionHash_lte: metis_Bytes
  transactionHash_in: [metis_Bytes!]
  transactionHash_not_in: [metis_Bytes!]
  transactionHash_contains: metis_Bytes
  transactionHash_not_contains: metis_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: metis_BlockChangedFilter
  and: [metis_RouterLiquidityEvent_filter]
  or: [metis_RouterLiquidityEvent_filter]
}

enum metis_RouterLiquidityEvent_orderBy {
  id
  type
  router
  router__id
  router__isActive
  router__owner
  router__recipient
  router__proposedOwner
  router__proposedTimestamp
  asset
  asset__id
  asset__key
  asset__decimal
  asset__adoptedDecimal
  asset__canonicalId
  asset__canonicalDomain
  asset__adoptedAsset
  asset__localAsset
  asset__blockNumber
  amount
  balance
  caller
  blockNumber
  timestamp
  transactionHash
  nonce
}

input metis_Router_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  isActive: Boolean
  isActive_not: Boolean
  isActive_in: [Boolean!]
  isActive_not_in: [Boolean!]
  owner: metis_Bytes
  owner_not: metis_Bytes
  owner_gt: metis_Bytes
  owner_lt: metis_Bytes
  owner_gte: metis_Bytes
  owner_lte: metis_Bytes
  owner_in: [metis_Bytes!]
  owner_not_in: [metis_Bytes!]
  owner_contains: metis_Bytes
  owner_not_contains: metis_Bytes
  recipient: metis_Bytes
  recipient_not: metis_Bytes
  recipient_gt: metis_Bytes
  recipient_lt: metis_Bytes
  recipient_gte: metis_Bytes
  recipient_lte: metis_Bytes
  recipient_in: [metis_Bytes!]
  recipient_not_in: [metis_Bytes!]
  recipient_contains: metis_Bytes
  recipient_not_contains: metis_Bytes
  proposedOwner: metis_Bytes
  proposedOwner_not: metis_Bytes
  proposedOwner_gt: metis_Bytes
  proposedOwner_lt: metis_Bytes
  proposedOwner_gte: metis_Bytes
  proposedOwner_lte: metis_Bytes
  proposedOwner_in: [metis_Bytes!]
  proposedOwner_not_in: [metis_Bytes!]
  proposedOwner_contains: metis_Bytes
  proposedOwner_not_contains: metis_Bytes
  proposedTimestamp: BigInt
  proposedTimestamp_not: BigInt
  proposedTimestamp_gt: BigInt
  proposedTimestamp_lt: BigInt
  proposedTimestamp_gte: BigInt
  proposedTimestamp_lte: BigInt
  proposedTimestamp_in: [BigInt!]
  proposedTimestamp_not_in: [BigInt!]
  assetBalances_: metis_AssetBalance_filter
  """Filter for the block changed event."""
  _change_block: metis_BlockChangedFilter
  and: [metis_Router_filter]
  or: [metis_Router_filter]
}

enum metis_Router_orderBy {
  id
  isActive
  owner
  recipient
  proposedOwner
  proposedTimestamp
  assetBalances
}

type metis_Sequencer {
  id: ID!
  isActive: Boolean!
  sequencer: metis_Bytes
}

input metis_Sequencer_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  isActive: Boolean
  isActive_not: Boolean
  isActive_in: [Boolean!]
  isActive_not_in: [Boolean!]
  sequencer: metis_Bytes
  sequencer_not: metis_Bytes
  sequencer_gt: metis_Bytes
  sequencer_lt: metis_Bytes
  sequencer_gte: metis_Bytes
  sequencer_lte: metis_Bytes
  sequencer_in: [metis_Bytes!]
  sequencer_not_in: [metis_Bytes!]
  sequencer_contains: metis_Bytes
  sequencer_not_contains: metis_Bytes
  """Filter for the block changed event."""
  _change_block: metis_BlockChangedFilter
  and: [metis_Sequencer_filter]
  or: [metis_Sequencer_filter]
}

enum metis_Sequencer_orderBy {
  id
  isActive
  sequencer
}

type metis_Setting {
  id: ID!
  maxRoutersPerTransfer: BigInt!
  caller: metis_Bytes!
}

input metis_Setting_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  maxRoutersPerTransfer: BigInt
  maxRoutersPerTransfer_not: BigInt
  maxRoutersPerTransfer_gt: BigInt
  maxRoutersPerTransfer_lt: BigInt
  maxRoutersPerTransfer_gte: BigInt
  maxRoutersPerTransfer_lte: BigInt
  maxRoutersPerTransfer_in: [BigInt!]
  maxRoutersPerTransfer_not_in: [BigInt!]
  caller: metis_Bytes
  caller_not: metis_Bytes
  caller_gt: metis_Bytes
  caller_lt: metis_Bytes
  caller_gte: metis_Bytes
  caller_lte: metis_Bytes
  caller_in: [metis_Bytes!]
  caller_not_in: [metis_Bytes!]
  caller_contains: metis_Bytes
  caller_not_contains: metis_Bytes
  """Filter for the block changed event."""
  _change_block: metis_BlockChangedFilter
  and: [metis_Setting_filter]
  or: [metis_Setting_filter]
}

enum metis_Setting_orderBy {
  id
  maxRoutersPerTransfer
  caller
}

type metis_SlippageUpdate {
  id: ID!
  transfer: metis_DestinationTransfer!
  slippage: BigInt!
  caller: metis_Bytes!
  transactionHash: metis_Bytes!
  timestamp: BigInt!
  gasPrice: BigInt!
  gasLimit: BigInt!
  blockNumber: BigInt!
}

input metis_SlippageUpdate_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transfer: String
  transfer_not: String
  transfer_gt: String
  transfer_lt: String
  transfer_gte: String
  transfer_lte: String
  transfer_in: [String!]
  transfer_not_in: [String!]
  transfer_contains: String
  transfer_contains_nocase: String
  transfer_not_contains: String
  transfer_not_contains_nocase: String
  transfer_starts_with: String
  transfer_starts_with_nocase: String
  transfer_not_starts_with: String
  transfer_not_starts_with_nocase: String
  transfer_ends_with: String
  transfer_ends_with_nocase: String
  transfer_not_ends_with: String
  transfer_not_ends_with_nocase: String
  transfer_: metis_DestinationTransfer_filter
  slippage: BigInt
  slippage_not: BigInt
  slippage_gt: BigInt
  slippage_lt: BigInt
  slippage_gte: BigInt
  slippage_lte: BigInt
  slippage_in: [BigInt!]
  slippage_not_in: [BigInt!]
  caller: metis_Bytes
  caller_not: metis_Bytes
  caller_gt: metis_Bytes
  caller_lt: metis_Bytes
  caller_gte: metis_Bytes
  caller_lte: metis_Bytes
  caller_in: [metis_Bytes!]
  caller_not_in: [metis_Bytes!]
  caller_contains: metis_Bytes
  caller_not_contains: metis_Bytes
  transactionHash: metis_Bytes
  transactionHash_not: metis_Bytes
  transactionHash_gt: metis_Bytes
  transactionHash_lt: metis_Bytes
  transactionHash_gte: metis_Bytes
  transactionHash_lte: metis_Bytes
  transactionHash_in: [metis_Bytes!]
  transactionHash_not_in: [metis_Bytes!]
  transactionHash_contains: metis_Bytes
  transactionHash_not_contains: metis_Bytes
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  gasLimit: BigInt
  gasLimit_not: BigInt
  gasLimit_gt: BigInt
  gasLimit_lt: BigInt
  gasLimit_gte: BigInt
  gasLimit_lte: BigInt
  gasLimit_in: [BigInt!]
  gasLimit_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: metis_BlockChangedFilter
  and: [metis_SlippageUpdate_filter]
  or: [metis_SlippageUpdate_filter]
}

enum metis_SlippageUpdate_orderBy {
  id
  transfer
  transfer__id
  transfer__chainId
  transfer__transferId
  transfer__nonce
  transfer__status
  transfer__originDomain
  transfer__destinationDomain
  transfer__canonicalDomain
  transfer__to
  transfer__delegate
  transfer__receiveLocal
  transfer__callData
  transfer__slippage
  transfer__bumpSlippageCount
  transfer__originSender
  transfer__bridgedAmt
  transfer__normalizedIn
  transfer__canonicalId
  transfer__amount
  transfer__routersFee
  transfer__executedCaller
  transfer__executedTransactionHash
  transfer__executedTimestamp
  transfer__executedGasPrice
  transfer__executedGasLimit
  transfer__executedBlockNumber
  transfer__executedTxOrigin
  transfer__executedTxNonce
  transfer__reconciledCaller
  transfer__reconciledTransactionHash
  transfer__reconciledTimestamp
  transfer__reconciledGasPrice
  transfer__reconciledGasLimit
  transfer__reconciledBlockNumber
  transfer__reconciledTxOrigin
  transfer__reconciledTxNonce
  slippage
  caller
  transactionHash
  timestamp
  gasPrice
  gasLimit
  blockNumber
}

type metis_SnapshotRoot {
  id: ID!
  spokeDomain: BigInt
  root: metis_Bytes!
  count: BigInt!
  timestamp: BigInt!
  blockNumber: BigInt!
}

input metis_SnapshotRoot_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  spokeDomain: BigInt
  spokeDomain_not: BigInt
  spokeDomain_gt: BigInt
  spokeDomain_lt: BigInt
  spokeDomain_gte: BigInt
  spokeDomain_lte: BigInt
  spokeDomain_in: [BigInt!]
  spokeDomain_not_in: [BigInt!]
  root: metis_Bytes
  root_not: metis_Bytes
  root_gt: metis_Bytes
  root_lt: metis_Bytes
  root_gte: metis_Bytes
  root_lte: metis_Bytes
  root_in: [metis_Bytes!]
  root_not_in: [metis_Bytes!]
  root_contains: metis_Bytes
  root_not_contains: metis_Bytes
  count: BigInt
  count_not: BigInt
  count_gt: BigInt
  count_lt: BigInt
  count_gte: BigInt
  count_lte: BigInt
  count_in: [BigInt!]
  count_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: metis_BlockChangedFilter
  and: [metis_SnapshotRoot_filter]
  or: [metis_SnapshotRoot_filter]
}

enum metis_SnapshotRoot_orderBy {
  id
  spokeDomain
  root
  count
  timestamp
  blockNumber
}

type metis_SpokeConnectorMode {
  id: ID!
  mode: String!
}

input metis_SpokeConnectorMode_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  mode: String
  mode_not: String
  mode_gt: String
  mode_lt: String
  mode_gte: String
  mode_lte: String
  mode_in: [String!]
  mode_not_in: [String!]
  mode_contains: String
  mode_contains_nocase: String
  mode_not_contains: String
  mode_not_contains_nocase: String
  mode_starts_with: String
  mode_starts_with_nocase: String
  mode_not_starts_with: String
  mode_not_starts_with_nocase: String
  mode_ends_with: String
  mode_ends_with_nocase: String
  mode_not_ends_with: String
  mode_not_ends_with_nocase: String
  """Filter for the block changed event."""
  _change_block: metis_BlockChangedFilter
  and: [metis_SpokeConnectorMode_filter]
  or: [metis_SpokeConnectorMode_filter]
}

enum metis_SpokeConnectorMode_orderBy {
  id
  mode
}

enum metis_TransferStatus {
  XCalled
  Executed
  Reconciled
  CompletedSlow
  CompletedFast
}

type metis__Block_ {
  """The hash of the block"""
  hash: metis_Bytes
  """The block number"""
  number: Int!
  """Integer representation of the timestamp stored in blocks for the chain"""
  timestamp: Int
  """The hash of the parent block"""
  parentHash: metis_Bytes
}

"""The type for the top-level _meta field"""
type metis__Meta_ {
  """
  Information about a specific subgraph block. The hash of the block
  will be null if the _meta field has a block constraint that asks for
  a block number. It will be filled if the _meta field has no block constraint
  and therefore asks for the latest  block
  
  """
  block: metis__Block_!
  """The deployment ID"""
  deployment: String!
  """If `true`, the subgraph encountered indexing errors at some past block"""
  hasIndexingErrors: Boolean!
}

type optimism_AggregateRoot {
  id: ID!
  root: optimism_Bytes!
  blockNumber: BigInt!
}

type optimism_AggregateRootProposed {
  id: ID!
  aggregateRoot: optimism_Bytes!
  rootTimestamp: BigInt!
  endOfDispute: BigInt!
  domain: BigInt!
  timestamp: BigInt!
  blockNumber: BigInt
}

input optimism_AggregateRootProposed_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  aggregateRoot: optimism_Bytes
  aggregateRoot_not: optimism_Bytes
  aggregateRoot_gt: optimism_Bytes
  aggregateRoot_lt: optimism_Bytes
  aggregateRoot_gte: optimism_Bytes
  aggregateRoot_lte: optimism_Bytes
  aggregateRoot_in: [optimism_Bytes!]
  aggregateRoot_not_in: [optimism_Bytes!]
  aggregateRoot_contains: optimism_Bytes
  aggregateRoot_not_contains: optimism_Bytes
  rootTimestamp: BigInt
  rootTimestamp_not: BigInt
  rootTimestamp_gt: BigInt
  rootTimestamp_lt: BigInt
  rootTimestamp_gte: BigInt
  rootTimestamp_lte: BigInt
  rootTimestamp_in: [BigInt!]
  rootTimestamp_not_in: [BigInt!]
  endOfDispute: BigInt
  endOfDispute_not: BigInt
  endOfDispute_gt: BigInt
  endOfDispute_lt: BigInt
  endOfDispute_gte: BigInt
  endOfDispute_lte: BigInt
  endOfDispute_in: [BigInt!]
  endOfDispute_not_in: [BigInt!]
  domain: BigInt
  domain_not: BigInt
  domain_gt: BigInt
  domain_lt: BigInt
  domain_gte: BigInt
  domain_lte: BigInt
  domain_in: [BigInt!]
  domain_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: optimism_BlockChangedFilter
  and: [optimism_AggregateRootProposed_filter]
  or: [optimism_AggregateRootProposed_filter]
}

enum optimism_AggregateRootProposed_orderBy {
  id
  aggregateRoot
  rootTimestamp
  endOfDispute
  domain
  timestamp
  blockNumber
}

input optimism_AggregateRoot_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  root: optimism_Bytes
  root_not: optimism_Bytes
  root_gt: optimism_Bytes
  root_lt: optimism_Bytes
  root_gte: optimism_Bytes
  root_lte: optimism_Bytes
  root_in: [optimism_Bytes!]
  root_not_in: [optimism_Bytes!]
  root_contains: optimism_Bytes
  root_not_contains: optimism_Bytes
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: optimism_BlockChangedFilter
  and: [optimism_AggregateRoot_filter]
  or: [optimism_AggregateRoot_filter]
}

enum optimism_AggregateRoot_orderBy {
  id
  root
  blockNumber
}

enum optimism_Aggregation_interval {
  hour
  day
}

type optimism_Asset {
  id: ID!
  key: optimism_Bytes
  decimal: BigInt
  adoptedDecimal: BigInt
  canonicalId: optimism_Bytes
  canonicalDomain: BigInt
  adoptedAsset: optimism_Bytes
  localAsset: optimism_Bytes
  blockNumber: BigInt
  status: optimism_AssetStatus
}

type optimism_AssetBalance {
  id: ID!
  amount: BigInt!
  locked: BigInt!
  supplied: BigInt!
  removed: BigInt!
  router: optimism_Router!
  asset: optimism_Asset!
  feesEarned: BigInt!
}

input optimism_AssetBalance_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  locked: BigInt
  locked_not: BigInt
  locked_gt: BigInt
  locked_lt: BigInt
  locked_gte: BigInt
  locked_lte: BigInt
  locked_in: [BigInt!]
  locked_not_in: [BigInt!]
  supplied: BigInt
  supplied_not: BigInt
  supplied_gt: BigInt
  supplied_lt: BigInt
  supplied_gte: BigInt
  supplied_lte: BigInt
  supplied_in: [BigInt!]
  supplied_not_in: [BigInt!]
  removed: BigInt
  removed_not: BigInt
  removed_gt: BigInt
  removed_lt: BigInt
  removed_gte: BigInt
  removed_lte: BigInt
  removed_in: [BigInt!]
  removed_not_in: [BigInt!]
  router: String
  router_not: String
  router_gt: String
  router_lt: String
  router_gte: String
  router_lte: String
  router_in: [String!]
  router_not_in: [String!]
  router_contains: String
  router_contains_nocase: String
  router_not_contains: String
  router_not_contains_nocase: String
  router_starts_with: String
  router_starts_with_nocase: String
  router_not_starts_with: String
  router_not_starts_with_nocase: String
  router_ends_with: String
  router_ends_with_nocase: String
  router_not_ends_with: String
  router_not_ends_with_nocase: String
  router_: optimism_Router_filter
  asset: String
  asset_not: String
  asset_gt: String
  asset_lt: String
  asset_gte: String
  asset_lte: String
  asset_in: [String!]
  asset_not_in: [String!]
  asset_contains: String
  asset_contains_nocase: String
  asset_not_contains: String
  asset_not_contains_nocase: String
  asset_starts_with: String
  asset_starts_with_nocase: String
  asset_not_starts_with: String
  asset_not_starts_with_nocase: String
  asset_ends_with: String
  asset_ends_with_nocase: String
  asset_not_ends_with: String
  asset_not_ends_with_nocase: String
  asset_: optimism_Asset_filter
  feesEarned: BigInt
  feesEarned_not: BigInt
  feesEarned_gt: BigInt
  feesEarned_lt: BigInt
  feesEarned_gte: BigInt
  feesEarned_lte: BigInt
  feesEarned_in: [BigInt!]
  feesEarned_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: optimism_BlockChangedFilter
  and: [optimism_AssetBalance_filter]
  or: [optimism_AssetBalance_filter]
}

enum optimism_AssetBalance_orderBy {
  id
  amount
  locked
  supplied
  removed
  router
  router__id
  router__isActive
  router__owner
  router__recipient
  router__proposedOwner
  router__proposedTimestamp
  asset
  asset__id
  asset__key
  asset__decimal
  asset__adoptedDecimal
  asset__canonicalId
  asset__canonicalDomain
  asset__adoptedAsset
  asset__localAsset
  asset__blockNumber
  feesEarned
}

type optimism_AssetStatus {
  id: ID!
  status: Boolean
}

input optimism_AssetStatus_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  status: Boolean
  status_not: Boolean
  status_in: [Boolean!]
  status_not_in: [Boolean!]
  """Filter for the block changed event."""
  _change_block: optimism_BlockChangedFilter
  and: [optimism_AssetStatus_filter]
  or: [optimism_AssetStatus_filter]
}

enum optimism_AssetStatus_orderBy {
  id
  status
}

input optimism_Asset_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  key: optimism_Bytes
  key_not: optimism_Bytes
  key_gt: optimism_Bytes
  key_lt: optimism_Bytes
  key_gte: optimism_Bytes
  key_lte: optimism_Bytes
  key_in: [optimism_Bytes!]
  key_not_in: [optimism_Bytes!]
  key_contains: optimism_Bytes
  key_not_contains: optimism_Bytes
  decimal: BigInt
  decimal_not: BigInt
  decimal_gt: BigInt
  decimal_lt: BigInt
  decimal_gte: BigInt
  decimal_lte: BigInt
  decimal_in: [BigInt!]
  decimal_not_in: [BigInt!]
  adoptedDecimal: BigInt
  adoptedDecimal_not: BigInt
  adoptedDecimal_gt: BigInt
  adoptedDecimal_lt: BigInt
  adoptedDecimal_gte: BigInt
  adoptedDecimal_lte: BigInt
  adoptedDecimal_in: [BigInt!]
  adoptedDecimal_not_in: [BigInt!]
  canonicalId: optimism_Bytes
  canonicalId_not: optimism_Bytes
  canonicalId_gt: optimism_Bytes
  canonicalId_lt: optimism_Bytes
  canonicalId_gte: optimism_Bytes
  canonicalId_lte: optimism_Bytes
  canonicalId_in: [optimism_Bytes!]
  canonicalId_not_in: [optimism_Bytes!]
  canonicalId_contains: optimism_Bytes
  canonicalId_not_contains: optimism_Bytes
  canonicalDomain: BigInt
  canonicalDomain_not: BigInt
  canonicalDomain_gt: BigInt
  canonicalDomain_lt: BigInt
  canonicalDomain_gte: BigInt
  canonicalDomain_lte: BigInt
  canonicalDomain_in: [BigInt!]
  canonicalDomain_not_in: [BigInt!]
  adoptedAsset: optimism_Bytes
  adoptedAsset_not: optimism_Bytes
  adoptedAsset_gt: optimism_Bytes
  adoptedAsset_lt: optimism_Bytes
  adoptedAsset_gte: optimism_Bytes
  adoptedAsset_lte: optimism_Bytes
  adoptedAsset_in: [optimism_Bytes!]
  adoptedAsset_not_in: [optimism_Bytes!]
  adoptedAsset_contains: optimism_Bytes
  adoptedAsset_not_contains: optimism_Bytes
  localAsset: optimism_Bytes
  localAsset_not: optimism_Bytes
  localAsset_gt: optimism_Bytes
  localAsset_lt: optimism_Bytes
  localAsset_gte: optimism_Bytes
  localAsset_lte: optimism_Bytes
  localAsset_in: [optimism_Bytes!]
  localAsset_not_in: [optimism_Bytes!]
  localAsset_contains: optimism_Bytes
  localAsset_not_contains: optimism_Bytes
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  status: String
  status_not: String
  status_gt: String
  status_lt: String
  status_gte: String
  status_lte: String
  status_in: [String!]
  status_not_in: [String!]
  status_contains: String
  status_contains_nocase: String
  status_not_contains: String
  status_not_contains_nocase: String
  status_starts_with: String
  status_starts_with_nocase: String
  status_not_starts_with: String
  status_not_starts_with_nocase: String
  status_ends_with: String
  status_ends_with_nocase: String
  status_not_ends_with: String
  status_not_ends_with_nocase: String
  status_: optimism_AssetStatus_filter
  """Filter for the block changed event."""
  _change_block: optimism_BlockChangedFilter
  and: [optimism_Asset_filter]
  or: [optimism_Asset_filter]
}

enum optimism_Asset_orderBy {
  id
  key
  decimal
  adoptedDecimal
  canonicalId
  canonicalDomain
  adoptedAsset
  localAsset
  blockNumber
  status
  status__id
  status__status
}

scalar optimism_BigDecimal

input optimism_BlockChangedFilter {
  number_gte: Int!
}

input optimism_Block_height {
  hash: optimism_Bytes
  number: Int
  number_gte: Int
}

scalar optimism_Bytes

type optimism_ConnectorMeta {
  id: ID!
  spokeDomain: BigInt
  hubDomain: BigInt
  amb: optimism_Bytes
  rootManager: optimism_Bytes
  mirrorConnector: optimism_Bytes
}

input optimism_ConnectorMeta_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  spokeDomain: BigInt
  spokeDomain_not: BigInt
  spokeDomain_gt: BigInt
  spokeDomain_lt: BigInt
  spokeDomain_gte: BigInt
  spokeDomain_lte: BigInt
  spokeDomain_in: [BigInt!]
  spokeDomain_not_in: [BigInt!]
  hubDomain: BigInt
  hubDomain_not: BigInt
  hubDomain_gt: BigInt
  hubDomain_lt: BigInt
  hubDomain_gte: BigInt
  hubDomain_lte: BigInt
  hubDomain_in: [BigInt!]
  hubDomain_not_in: [BigInt!]
  amb: optimism_Bytes
  amb_not: optimism_Bytes
  amb_gt: optimism_Bytes
  amb_lt: optimism_Bytes
  amb_gte: optimism_Bytes
  amb_lte: optimism_Bytes
  amb_in: [optimism_Bytes!]
  amb_not_in: [optimism_Bytes!]
  amb_contains: optimism_Bytes
  amb_not_contains: optimism_Bytes
  rootManager: optimism_Bytes
  rootManager_not: optimism_Bytes
  rootManager_gt: optimism_Bytes
  rootManager_lt: optimism_Bytes
  rootManager_gte: optimism_Bytes
  rootManager_lte: optimism_Bytes
  rootManager_in: [optimism_Bytes!]
  rootManager_not_in: [optimism_Bytes!]
  rootManager_contains: optimism_Bytes
  rootManager_not_contains: optimism_Bytes
  mirrorConnector: optimism_Bytes
  mirrorConnector_not: optimism_Bytes
  mirrorConnector_gt: optimism_Bytes
  mirrorConnector_lt: optimism_Bytes
  mirrorConnector_gte: optimism_Bytes
  mirrorConnector_lte: optimism_Bytes
  mirrorConnector_in: [optimism_Bytes!]
  mirrorConnector_not_in: [optimism_Bytes!]
  mirrorConnector_contains: optimism_Bytes
  mirrorConnector_not_contains: optimism_Bytes
  """Filter for the block changed event."""
  _change_block: optimism_BlockChangedFilter
  and: [optimism_ConnectorMeta_filter]
  or: [optimism_ConnectorMeta_filter]
}

enum optimism_ConnectorMeta_orderBy {
  id
  spokeDomain
  hubDomain
  amb
  rootManager
  mirrorConnector
}

type optimism_DestinationTransfer {
  id: ID!
  chainId: BigInt
  transferId: optimism_Bytes
  nonce: BigInt
  status: optimism_TransferStatus
  routers(skip: Int = 0, first: Int = 100, orderBy: optimism_Router_orderBy, orderDirection: optimism_OrderDirection, where: optimism_Router_filter): [optimism_Router!]
  originDomain: BigInt
  destinationDomain: BigInt
  canonicalDomain: BigInt
  to: optimism_Bytes
  delegate: optimism_Bytes
  receiveLocal: Boolean
  callData: optimism_Bytes
  slippage: BigInt
  bumpSlippageCount: BigInt
  originSender: optimism_Bytes
  bridgedAmt: BigInt
  normalizedIn: BigInt
  canonicalId: optimism_Bytes
  asset: optimism_Asset
  amount: BigInt
  routersFee: BigInt
  executedCaller: optimism_Bytes
  executedTransactionHash: optimism_Bytes
  executedTimestamp: BigInt
  executedGasPrice: BigInt
  executedGasLimit: BigInt
  executedBlockNumber: BigInt
  executedTxOrigin: optimism_Bytes
  executedTxNonce: BigInt
  reconciledCaller: optimism_Bytes
  reconciledTransactionHash: optimism_Bytes
  reconciledTimestamp: BigInt
  reconciledGasPrice: BigInt
  reconciledGasLimit: BigInt
  reconciledBlockNumber: BigInt
  reconciledTxOrigin: optimism_Bytes
  reconciledTxNonce: BigInt
}

input optimism_DestinationTransfer_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  chainId: BigInt
  chainId_not: BigInt
  chainId_gt: BigInt
  chainId_lt: BigInt
  chainId_gte: BigInt
  chainId_lte: BigInt
  chainId_in: [BigInt!]
  chainId_not_in: [BigInt!]
  transferId: optimism_Bytes
  transferId_not: optimism_Bytes
  transferId_gt: optimism_Bytes
  transferId_lt: optimism_Bytes
  transferId_gte: optimism_Bytes
  transferId_lte: optimism_Bytes
  transferId_in: [optimism_Bytes!]
  transferId_not_in: [optimism_Bytes!]
  transferId_contains: optimism_Bytes
  transferId_not_contains: optimism_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  status: optimism_TransferStatus
  status_not: optimism_TransferStatus
  status_in: [optimism_TransferStatus!]
  status_not_in: [optimism_TransferStatus!]
  routers: [String!]
  routers_not: [String!]
  routers_contains: [String!]
  routers_contains_nocase: [String!]
  routers_not_contains: [String!]
  routers_not_contains_nocase: [String!]
  routers_: optimism_Router_filter
  originDomain: BigInt
  originDomain_not: BigInt
  originDomain_gt: BigInt
  originDomain_lt: BigInt
  originDomain_gte: BigInt
  originDomain_lte: BigInt
  originDomain_in: [BigInt!]
  originDomain_not_in: [BigInt!]
  destinationDomain: BigInt
  destinationDomain_not: BigInt
  destinationDomain_gt: BigInt
  destinationDomain_lt: BigInt
  destinationDomain_gte: BigInt
  destinationDomain_lte: BigInt
  destinationDomain_in: [BigInt!]
  destinationDomain_not_in: [BigInt!]
  canonicalDomain: BigInt
  canonicalDomain_not: BigInt
  canonicalDomain_gt: BigInt
  canonicalDomain_lt: BigInt
  canonicalDomain_gte: BigInt
  canonicalDomain_lte: BigInt
  canonicalDomain_in: [BigInt!]
  canonicalDomain_not_in: [BigInt!]
  to: optimism_Bytes
  to_not: optimism_Bytes
  to_gt: optimism_Bytes
  to_lt: optimism_Bytes
  to_gte: optimism_Bytes
  to_lte: optimism_Bytes
  to_in: [optimism_Bytes!]
  to_not_in: [optimism_Bytes!]
  to_contains: optimism_Bytes
  to_not_contains: optimism_Bytes
  delegate: optimism_Bytes
  delegate_not: optimism_Bytes
  delegate_gt: optimism_Bytes
  delegate_lt: optimism_Bytes
  delegate_gte: optimism_Bytes
  delegate_lte: optimism_Bytes
  delegate_in: [optimism_Bytes!]
  delegate_not_in: [optimism_Bytes!]
  delegate_contains: optimism_Bytes
  delegate_not_contains: optimism_Bytes
  receiveLocal: Boolean
  receiveLocal_not: Boolean
  receiveLocal_in: [Boolean!]
  receiveLocal_not_in: [Boolean!]
  callData: optimism_Bytes
  callData_not: optimism_Bytes
  callData_gt: optimism_Bytes
  callData_lt: optimism_Bytes
  callData_gte: optimism_Bytes
  callData_lte: optimism_Bytes
  callData_in: [optimism_Bytes!]
  callData_not_in: [optimism_Bytes!]
  callData_contains: optimism_Bytes
  callData_not_contains: optimism_Bytes
  slippage: BigInt
  slippage_not: BigInt
  slippage_gt: BigInt
  slippage_lt: BigInt
  slippage_gte: BigInt
  slippage_lte: BigInt
  slippage_in: [BigInt!]
  slippage_not_in: [BigInt!]
  bumpSlippageCount: BigInt
  bumpSlippageCount_not: BigInt
  bumpSlippageCount_gt: BigInt
  bumpSlippageCount_lt: BigInt
  bumpSlippageCount_gte: BigInt
  bumpSlippageCount_lte: BigInt
  bumpSlippageCount_in: [BigInt!]
  bumpSlippageCount_not_in: [BigInt!]
  originSender: optimism_Bytes
  originSender_not: optimism_Bytes
  originSender_gt: optimism_Bytes
  originSender_lt: optimism_Bytes
  originSender_gte: optimism_Bytes
  originSender_lte: optimism_Bytes
  originSender_in: [optimism_Bytes!]
  originSender_not_in: [optimism_Bytes!]
  originSender_contains: optimism_Bytes
  originSender_not_contains: optimism_Bytes
  bridgedAmt: BigInt
  bridgedAmt_not: BigInt
  bridgedAmt_gt: BigInt
  bridgedAmt_lt: BigInt
  bridgedAmt_gte: BigInt
  bridgedAmt_lte: BigInt
  bridgedAmt_in: [BigInt!]
  bridgedAmt_not_in: [BigInt!]
  normalizedIn: BigInt
  normalizedIn_not: BigInt
  normalizedIn_gt: BigInt
  normalizedIn_lt: BigInt
  normalizedIn_gte: BigInt
  normalizedIn_lte: BigInt
  normalizedIn_in: [BigInt!]
  normalizedIn_not_in: [BigInt!]
  canonicalId: optimism_Bytes
  canonicalId_not: optimism_Bytes
  canonicalId_gt: optimism_Bytes
  canonicalId_lt: optimism_Bytes
  canonicalId_gte: optimism_Bytes
  canonicalId_lte: optimism_Bytes
  canonicalId_in: [optimism_Bytes!]
  canonicalId_not_in: [optimism_Bytes!]
  canonicalId_contains: optimism_Bytes
  canonicalId_not_contains: optimism_Bytes
  asset: String
  asset_not: String
  asset_gt: String
  asset_lt: String
  asset_gte: String
  asset_lte: String
  asset_in: [String!]
  asset_not_in: [String!]
  asset_contains: String
  asset_contains_nocase: String
  asset_not_contains: String
  asset_not_contains_nocase: String
  asset_starts_with: String
  asset_starts_with_nocase: String
  asset_not_starts_with: String
  asset_not_starts_with_nocase: String
  asset_ends_with: String
  asset_ends_with_nocase: String
  asset_not_ends_with: String
  asset_not_ends_with_nocase: String
  asset_: optimism_Asset_filter
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  routersFee: BigInt
  routersFee_not: BigInt
  routersFee_gt: BigInt
  routersFee_lt: BigInt
  routersFee_gte: BigInt
  routersFee_lte: BigInt
  routersFee_in: [BigInt!]
  routersFee_not_in: [BigInt!]
  executedCaller: optimism_Bytes
  executedCaller_not: optimism_Bytes
  executedCaller_gt: optimism_Bytes
  executedCaller_lt: optimism_Bytes
  executedCaller_gte: optimism_Bytes
  executedCaller_lte: optimism_Bytes
  executedCaller_in: [optimism_Bytes!]
  executedCaller_not_in: [optimism_Bytes!]
  executedCaller_contains: optimism_Bytes
  executedCaller_not_contains: optimism_Bytes
  executedTransactionHash: optimism_Bytes
  executedTransactionHash_not: optimism_Bytes
  executedTransactionHash_gt: optimism_Bytes
  executedTransactionHash_lt: optimism_Bytes
  executedTransactionHash_gte: optimism_Bytes
  executedTransactionHash_lte: optimism_Bytes
  executedTransactionHash_in: [optimism_Bytes!]
  executedTransactionHash_not_in: [optimism_Bytes!]
  executedTransactionHash_contains: optimism_Bytes
  executedTransactionHash_not_contains: optimism_Bytes
  executedTimestamp: BigInt
  executedTimestamp_not: BigInt
  executedTimestamp_gt: BigInt
  executedTimestamp_lt: BigInt
  executedTimestamp_gte: BigInt
  executedTimestamp_lte: BigInt
  executedTimestamp_in: [BigInt!]
  executedTimestamp_not_in: [BigInt!]
  executedGasPrice: BigInt
  executedGasPrice_not: BigInt
  executedGasPrice_gt: BigInt
  executedGasPrice_lt: BigInt
  executedGasPrice_gte: BigInt
  executedGasPrice_lte: BigInt
  executedGasPrice_in: [BigInt!]
  executedGasPrice_not_in: [BigInt!]
  executedGasLimit: BigInt
  executedGasLimit_not: BigInt
  executedGasLimit_gt: BigInt
  executedGasLimit_lt: BigInt
  executedGasLimit_gte: BigInt
  executedGasLimit_lte: BigInt
  executedGasLimit_in: [BigInt!]
  executedGasLimit_not_in: [BigInt!]
  executedBlockNumber: BigInt
  executedBlockNumber_not: BigInt
  executedBlockNumber_gt: BigInt
  executedBlockNumber_lt: BigInt
  executedBlockNumber_gte: BigInt
  executedBlockNumber_lte: BigInt
  executedBlockNumber_in: [BigInt!]
  executedBlockNumber_not_in: [BigInt!]
  executedTxOrigin: optimism_Bytes
  executedTxOrigin_not: optimism_Bytes
  executedTxOrigin_gt: optimism_Bytes
  executedTxOrigin_lt: optimism_Bytes
  executedTxOrigin_gte: optimism_Bytes
  executedTxOrigin_lte: optimism_Bytes
  executedTxOrigin_in: [optimism_Bytes!]
  executedTxOrigin_not_in: [optimism_Bytes!]
  executedTxOrigin_contains: optimism_Bytes
  executedTxOrigin_not_contains: optimism_Bytes
  executedTxNonce: BigInt
  executedTxNonce_not: BigInt
  executedTxNonce_gt: BigInt
  executedTxNonce_lt: BigInt
  executedTxNonce_gte: BigInt
  executedTxNonce_lte: BigInt
  executedTxNonce_in: [BigInt!]
  executedTxNonce_not_in: [BigInt!]
  reconciledCaller: optimism_Bytes
  reconciledCaller_not: optimism_Bytes
  reconciledCaller_gt: optimism_Bytes
  reconciledCaller_lt: optimism_Bytes
  reconciledCaller_gte: optimism_Bytes
  reconciledCaller_lte: optimism_Bytes
  reconciledCaller_in: [optimism_Bytes!]
  reconciledCaller_not_in: [optimism_Bytes!]
  reconciledCaller_contains: optimism_Bytes
  reconciledCaller_not_contains: optimism_Bytes
  reconciledTransactionHash: optimism_Bytes
  reconciledTransactionHash_not: optimism_Bytes
  reconciledTransactionHash_gt: optimism_Bytes
  reconciledTransactionHash_lt: optimism_Bytes
  reconciledTransactionHash_gte: optimism_Bytes
  reconciledTransactionHash_lte: optimism_Bytes
  reconciledTransactionHash_in: [optimism_Bytes!]
  reconciledTransactionHash_not_in: [optimism_Bytes!]
  reconciledTransactionHash_contains: optimism_Bytes
  reconciledTransactionHash_not_contains: optimism_Bytes
  reconciledTimestamp: BigInt
  reconciledTimestamp_not: BigInt
  reconciledTimestamp_gt: BigInt
  reconciledTimestamp_lt: BigInt
  reconciledTimestamp_gte: BigInt
  reconciledTimestamp_lte: BigInt
  reconciledTimestamp_in: [BigInt!]
  reconciledTimestamp_not_in: [BigInt!]
  reconciledGasPrice: BigInt
  reconciledGasPrice_not: BigInt
  reconciledGasPrice_gt: BigInt
  reconciledGasPrice_lt: BigInt
  reconciledGasPrice_gte: BigInt
  reconciledGasPrice_lte: BigInt
  reconciledGasPrice_in: [BigInt!]
  reconciledGasPrice_not_in: [BigInt!]
  reconciledGasLimit: BigInt
  reconciledGasLimit_not: BigInt
  reconciledGasLimit_gt: BigInt
  reconciledGasLimit_lt: BigInt
  reconciledGasLimit_gte: BigInt
  reconciledGasLimit_lte: BigInt
  reconciledGasLimit_in: [BigInt!]
  reconciledGasLimit_not_in: [BigInt!]
  reconciledBlockNumber: BigInt
  reconciledBlockNumber_not: BigInt
  reconciledBlockNumber_gt: BigInt
  reconciledBlockNumber_lt: BigInt
  reconciledBlockNumber_gte: BigInt
  reconciledBlockNumber_lte: BigInt
  reconciledBlockNumber_in: [BigInt!]
  reconciledBlockNumber_not_in: [BigInt!]
  reconciledTxOrigin: optimism_Bytes
  reconciledTxOrigin_not: optimism_Bytes
  reconciledTxOrigin_gt: optimism_Bytes
  reconciledTxOrigin_lt: optimism_Bytes
  reconciledTxOrigin_gte: optimism_Bytes
  reconciledTxOrigin_lte: optimism_Bytes
  reconciledTxOrigin_in: [optimism_Bytes!]
  reconciledTxOrigin_not_in: [optimism_Bytes!]
  reconciledTxOrigin_contains: optimism_Bytes
  reconciledTxOrigin_not_contains: optimism_Bytes
  reconciledTxNonce: BigInt
  reconciledTxNonce_not: BigInt
  reconciledTxNonce_gt: BigInt
  reconciledTxNonce_lt: BigInt
  reconciledTxNonce_gte: BigInt
  reconciledTxNonce_lte: BigInt
  reconciledTxNonce_in: [BigInt!]
  reconciledTxNonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: optimism_BlockChangedFilter
  and: [optimism_DestinationTransfer_filter]
  or: [optimism_DestinationTransfer_filter]
}

enum optimism_DestinationTransfer_orderBy {
  id
  chainId
  transferId
  nonce
  status
  routers
  originDomain
  destinationDomain
  canonicalDomain
  to
  delegate
  receiveLocal
  callData
  slippage
  bumpSlippageCount
  originSender
  bridgedAmt
  normalizedIn
  canonicalId
  asset
  asset__id
  asset__key
  asset__decimal
  asset__adoptedDecimal
  asset__canonicalId
  asset__canonicalDomain
  asset__adoptedAsset
  asset__localAsset
  asset__blockNumber
  amount
  routersFee
  executedCaller
  executedTransactionHash
  executedTimestamp
  executedGasPrice
  executedGasLimit
  executedBlockNumber
  executedTxOrigin
  executedTxNonce
  reconciledCaller
  reconciledTransactionHash
  reconciledTimestamp
  reconciledGasPrice
  reconciledGasLimit
  reconciledBlockNumber
  reconciledTxOrigin
  reconciledTxNonce
}

"""
8 bytes signed integer

"""
scalar optimism_Int8

type optimism_OptimisticRootFinalized {
  id: ID!
  aggregateRoot: optimism_Bytes!
  timestamp: BigInt!
  blockNumber: BigInt
}

input optimism_OptimisticRootFinalized_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  aggregateRoot: optimism_Bytes
  aggregateRoot_not: optimism_Bytes
  aggregateRoot_gt: optimism_Bytes
  aggregateRoot_lt: optimism_Bytes
  aggregateRoot_gte: optimism_Bytes
  aggregateRoot_lte: optimism_Bytes
  aggregateRoot_in: [optimism_Bytes!]
  aggregateRoot_not_in: [optimism_Bytes!]
  aggregateRoot_contains: optimism_Bytes
  aggregateRoot_not_contains: optimism_Bytes
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: optimism_BlockChangedFilter
  and: [optimism_OptimisticRootFinalized_filter]
  or: [optimism_OptimisticRootFinalized_filter]
}

enum optimism_OptimisticRootFinalized_orderBy {
  id
  aggregateRoot
  timestamp
  blockNumber
}

"""Defines the order direction, either ascending or descending"""
enum optimism_OrderDirection {
  asc
  desc
}

type optimism_OriginMessage {
  id: ID!
  transferId: optimism_Bytes
  destinationDomain: BigInt
  leaf: optimism_Bytes
  index: BigInt
  message: optimism_Bytes
  root: optimism_Bytes
  transactionHash: optimism_Bytes
  blockNumber: BigInt
  rootCount: optimism_RootCount
}

input optimism_OriginMessage_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transferId: optimism_Bytes
  transferId_not: optimism_Bytes
  transferId_gt: optimism_Bytes
  transferId_lt: optimism_Bytes
  transferId_gte: optimism_Bytes
  transferId_lte: optimism_Bytes
  transferId_in: [optimism_Bytes!]
  transferId_not_in: [optimism_Bytes!]
  transferId_contains: optimism_Bytes
  transferId_not_contains: optimism_Bytes
  destinationDomain: BigInt
  destinationDomain_not: BigInt
  destinationDomain_gt: BigInt
  destinationDomain_lt: BigInt
  destinationDomain_gte: BigInt
  destinationDomain_lte: BigInt
  destinationDomain_in: [BigInt!]
  destinationDomain_not_in: [BigInt!]
  leaf: optimism_Bytes
  leaf_not: optimism_Bytes
  leaf_gt: optimism_Bytes
  leaf_lt: optimism_Bytes
  leaf_gte: optimism_Bytes
  leaf_lte: optimism_Bytes
  leaf_in: [optimism_Bytes!]
  leaf_not_in: [optimism_Bytes!]
  leaf_contains: optimism_Bytes
  leaf_not_contains: optimism_Bytes
  index: BigInt
  index_not: BigInt
  index_gt: BigInt
  index_lt: BigInt
  index_gte: BigInt
  index_lte: BigInt
  index_in: [BigInt!]
  index_not_in: [BigInt!]
  message: optimism_Bytes
  message_not: optimism_Bytes
  message_gt: optimism_Bytes
  message_lt: optimism_Bytes
  message_gte: optimism_Bytes
  message_lte: optimism_Bytes
  message_in: [optimism_Bytes!]
  message_not_in: [optimism_Bytes!]
  message_contains: optimism_Bytes
  message_not_contains: optimism_Bytes
  root: optimism_Bytes
  root_not: optimism_Bytes
  root_gt: optimism_Bytes
  root_lt: optimism_Bytes
  root_gte: optimism_Bytes
  root_lte: optimism_Bytes
  root_in: [optimism_Bytes!]
  root_not_in: [optimism_Bytes!]
  root_contains: optimism_Bytes
  root_not_contains: optimism_Bytes
  transactionHash: optimism_Bytes
  transactionHash_not: optimism_Bytes
  transactionHash_gt: optimism_Bytes
  transactionHash_lt: optimism_Bytes
  transactionHash_gte: optimism_Bytes
  transactionHash_lte: optimism_Bytes
  transactionHash_in: [optimism_Bytes!]
  transactionHash_not_in: [optimism_Bytes!]
  transactionHash_contains: optimism_Bytes
  transactionHash_not_contains: optimism_Bytes
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  rootCount: String
  rootCount_not: String
  rootCount_gt: String
  rootCount_lt: String
  rootCount_gte: String
  rootCount_lte: String
  rootCount_in: [String!]
  rootCount_not_in: [String!]
  rootCount_contains: String
  rootCount_contains_nocase: String
  rootCount_not_contains: String
  rootCount_not_contains_nocase: String
  rootCount_starts_with: String
  rootCount_starts_with_nocase: String
  rootCount_not_starts_with: String
  rootCount_not_starts_with_nocase: String
  rootCount_ends_with: String
  rootCount_ends_with_nocase: String
  rootCount_not_ends_with: String
  rootCount_not_ends_with_nocase: String
  rootCount_: optimism_RootCount_filter
  """Filter for the block changed event."""
  _change_block: optimism_BlockChangedFilter
  and: [optimism_OriginMessage_filter]
  or: [optimism_OriginMessage_filter]
}

enum optimism_OriginMessage_orderBy {
  id
  transferId
  destinationDomain
  leaf
  index
  message
  root
  transactionHash
  blockNumber
  rootCount
  rootCount__id
  rootCount__count
}

type optimism_OriginTransfer {
  id: ID!
  chainId: BigInt
  transferId: optimism_Bytes
  nonce: BigInt
  status: optimism_TransferStatus
  messageHash: optimism_Bytes
  originDomain: BigInt
  destinationDomain: BigInt
  canonicalDomain: BigInt
  to: optimism_Bytes
  delegate: optimism_Bytes
  receiveLocal: Boolean
  callData: optimism_Bytes
  slippage: BigInt
  originSender: optimism_Bytes
  bridgedAmt: BigInt
  normalizedIn: BigInt
  canonicalId: optimism_Bytes
  asset: optimism_Asset
  transactingAsset: optimism_Bytes
  message: optimism_OriginMessage
  bumpRelayerFeeCount: BigInt
  relayerFees(skip: Int = 0, first: Int = 100, orderBy: optimism_RelayerFee_orderBy, orderDirection: optimism_OrderDirection, where: optimism_RelayerFee_filter): [optimism_RelayerFee!]
  initialRelayerFeeAsset: optimism_Bytes
  caller: optimism_Bytes
  transactionHash: optimism_Bytes
  timestamp: BigInt
  gasPrice: BigInt
  gasLimit: BigInt
  blockNumber: BigInt
  txOrigin: optimism_Bytes
  txNonce: BigInt
}

input optimism_OriginTransfer_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  chainId: BigInt
  chainId_not: BigInt
  chainId_gt: BigInt
  chainId_lt: BigInt
  chainId_gte: BigInt
  chainId_lte: BigInt
  chainId_in: [BigInt!]
  chainId_not_in: [BigInt!]
  transferId: optimism_Bytes
  transferId_not: optimism_Bytes
  transferId_gt: optimism_Bytes
  transferId_lt: optimism_Bytes
  transferId_gte: optimism_Bytes
  transferId_lte: optimism_Bytes
  transferId_in: [optimism_Bytes!]
  transferId_not_in: [optimism_Bytes!]
  transferId_contains: optimism_Bytes
  transferId_not_contains: optimism_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  status: optimism_TransferStatus
  status_not: optimism_TransferStatus
  status_in: [optimism_TransferStatus!]
  status_not_in: [optimism_TransferStatus!]
  messageHash: optimism_Bytes
  messageHash_not: optimism_Bytes
  messageHash_gt: optimism_Bytes
  messageHash_lt: optimism_Bytes
  messageHash_gte: optimism_Bytes
  messageHash_lte: optimism_Bytes
  messageHash_in: [optimism_Bytes!]
  messageHash_not_in: [optimism_Bytes!]
  messageHash_contains: optimism_Bytes
  messageHash_not_contains: optimism_Bytes
  originDomain: BigInt
  originDomain_not: BigInt
  originDomain_gt: BigInt
  originDomain_lt: BigInt
  originDomain_gte: BigInt
  originDomain_lte: BigInt
  originDomain_in: [BigInt!]
  originDomain_not_in: [BigInt!]
  destinationDomain: BigInt
  destinationDomain_not: BigInt
  destinationDomain_gt: BigInt
  destinationDomain_lt: BigInt
  destinationDomain_gte: BigInt
  destinationDomain_lte: BigInt
  destinationDomain_in: [BigInt!]
  destinationDomain_not_in: [BigInt!]
  canonicalDomain: BigInt
  canonicalDomain_not: BigInt
  canonicalDomain_gt: BigInt
  canonicalDomain_lt: BigInt
  canonicalDomain_gte: BigInt
  canonicalDomain_lte: BigInt
  canonicalDomain_in: [BigInt!]
  canonicalDomain_not_in: [BigInt!]
  to: optimism_Bytes
  to_not: optimism_Bytes
  to_gt: optimism_Bytes
  to_lt: optimism_Bytes
  to_gte: optimism_Bytes
  to_lte: optimism_Bytes
  to_in: [optimism_Bytes!]
  to_not_in: [optimism_Bytes!]
  to_contains: optimism_Bytes
  to_not_contains: optimism_Bytes
  delegate: optimism_Bytes
  delegate_not: optimism_Bytes
  delegate_gt: optimism_Bytes
  delegate_lt: optimism_Bytes
  delegate_gte: optimism_Bytes
  delegate_lte: optimism_Bytes
  delegate_in: [optimism_Bytes!]
  delegate_not_in: [optimism_Bytes!]
  delegate_contains: optimism_Bytes
  delegate_not_contains: optimism_Bytes
  receiveLocal: Boolean
  receiveLocal_not: Boolean
  receiveLocal_in: [Boolean!]
  receiveLocal_not_in: [Boolean!]
  callData: optimism_Bytes
  callData_not: optimism_Bytes
  callData_gt: optimism_Bytes
  callData_lt: optimism_Bytes
  callData_gte: optimism_Bytes
  callData_lte: optimism_Bytes
  callData_in: [optimism_Bytes!]
  callData_not_in: [optimism_Bytes!]
  callData_contains: optimism_Bytes
  callData_not_contains: optimism_Bytes
  slippage: BigInt
  slippage_not: BigInt
  slippage_gt: BigInt
  slippage_lt: BigInt
  slippage_gte: BigInt
  slippage_lte: BigInt
  slippage_in: [BigInt!]
  slippage_not_in: [BigInt!]
  originSender: optimism_Bytes
  originSender_not: optimism_Bytes
  originSender_gt: optimism_Bytes
  originSender_lt: optimism_Bytes
  originSender_gte: optimism_Bytes
  originSender_lte: optimism_Bytes
  originSender_in: [optimism_Bytes!]
  originSender_not_in: [optimism_Bytes!]
  originSender_contains: optimism_Bytes
  originSender_not_contains: optimism_Bytes
  bridgedAmt: BigInt
  bridgedAmt_not: BigInt
  bridgedAmt_gt: BigInt
  bridgedAmt_lt: BigInt
  bridgedAmt_gte: BigInt
  bridgedAmt_lte: BigInt
  bridgedAmt_in: [BigInt!]
  bridgedAmt_not_in: [BigInt!]
  normalizedIn: BigInt
  normalizedIn_not: BigInt
  normalizedIn_gt: BigInt
  normalizedIn_lt: BigInt
  normalizedIn_gte: BigInt
  normalizedIn_lte: BigInt
  normalizedIn_in: [BigInt!]
  normalizedIn_not_in: [BigInt!]
  canonicalId: optimism_Bytes
  canonicalId_not: optimism_Bytes
  canonicalId_gt: optimism_Bytes
  canonicalId_lt: optimism_Bytes
  canonicalId_gte: optimism_Bytes
  canonicalId_lte: optimism_Bytes
  canonicalId_in: [optimism_Bytes!]
  canonicalId_not_in: [optimism_Bytes!]
  canonicalId_contains: optimism_Bytes
  canonicalId_not_contains: optimism_Bytes
  asset: String
  asset_not: String
  asset_gt: String
  asset_lt: String
  asset_gte: String
  asset_lte: String
  asset_in: [String!]
  asset_not_in: [String!]
  asset_contains: String
  asset_contains_nocase: String
  asset_not_contains: String
  asset_not_contains_nocase: String
  asset_starts_with: String
  asset_starts_with_nocase: String
  asset_not_starts_with: String
  asset_not_starts_with_nocase: String
  asset_ends_with: String
  asset_ends_with_nocase: String
  asset_not_ends_with: String
  asset_not_ends_with_nocase: String
  asset_: optimism_Asset_filter
  transactingAsset: optimism_Bytes
  transactingAsset_not: optimism_Bytes
  transactingAsset_gt: optimism_Bytes
  transactingAsset_lt: optimism_Bytes
  transactingAsset_gte: optimism_Bytes
  transactingAsset_lte: optimism_Bytes
  transactingAsset_in: [optimism_Bytes!]
  transactingAsset_not_in: [optimism_Bytes!]
  transactingAsset_contains: optimism_Bytes
  transactingAsset_not_contains: optimism_Bytes
  message: String
  message_not: String
  message_gt: String
  message_lt: String
  message_gte: String
  message_lte: String
  message_in: [String!]
  message_not_in: [String!]
  message_contains: String
  message_contains_nocase: String
  message_not_contains: String
  message_not_contains_nocase: String
  message_starts_with: String
  message_starts_with_nocase: String
  message_not_starts_with: String
  message_not_starts_with_nocase: String
  message_ends_with: String
  message_ends_with_nocase: String
  message_not_ends_with: String
  message_not_ends_with_nocase: String
  message_: optimism_OriginMessage_filter
  bumpRelayerFeeCount: BigInt
  bumpRelayerFeeCount_not: BigInt
  bumpRelayerFeeCount_gt: BigInt
  bumpRelayerFeeCount_lt: BigInt
  bumpRelayerFeeCount_gte: BigInt
  bumpRelayerFeeCount_lte: BigInt
  bumpRelayerFeeCount_in: [BigInt!]
  bumpRelayerFeeCount_not_in: [BigInt!]
  relayerFees: [String!]
  relayerFees_not: [String!]
  relayerFees_contains: [String!]
  relayerFees_contains_nocase: [String!]
  relayerFees_not_contains: [String!]
  relayerFees_not_contains_nocase: [String!]
  relayerFees_: optimism_RelayerFee_filter
  initialRelayerFeeAsset: optimism_Bytes
  initialRelayerFeeAsset_not: optimism_Bytes
  initialRelayerFeeAsset_gt: optimism_Bytes
  initialRelayerFeeAsset_lt: optimism_Bytes
  initialRelayerFeeAsset_gte: optimism_Bytes
  initialRelayerFeeAsset_lte: optimism_Bytes
  initialRelayerFeeAsset_in: [optimism_Bytes!]
  initialRelayerFeeAsset_not_in: [optimism_Bytes!]
  initialRelayerFeeAsset_contains: optimism_Bytes
  initialRelayerFeeAsset_not_contains: optimism_Bytes
  caller: optimism_Bytes
  caller_not: optimism_Bytes
  caller_gt: optimism_Bytes
  caller_lt: optimism_Bytes
  caller_gte: optimism_Bytes
  caller_lte: optimism_Bytes
  caller_in: [optimism_Bytes!]
  caller_not_in: [optimism_Bytes!]
  caller_contains: optimism_Bytes
  caller_not_contains: optimism_Bytes
  transactionHash: optimism_Bytes
  transactionHash_not: optimism_Bytes
  transactionHash_gt: optimism_Bytes
  transactionHash_lt: optimism_Bytes
  transactionHash_gte: optimism_Bytes
  transactionHash_lte: optimism_Bytes
  transactionHash_in: [optimism_Bytes!]
  transactionHash_not_in: [optimism_Bytes!]
  transactionHash_contains: optimism_Bytes
  transactionHash_not_contains: optimism_Bytes
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  gasLimit: BigInt
  gasLimit_not: BigInt
  gasLimit_gt: BigInt
  gasLimit_lt: BigInt
  gasLimit_gte: BigInt
  gasLimit_lte: BigInt
  gasLimit_in: [BigInt!]
  gasLimit_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  txOrigin: optimism_Bytes
  txOrigin_not: optimism_Bytes
  txOrigin_gt: optimism_Bytes
  txOrigin_lt: optimism_Bytes
  txOrigin_gte: optimism_Bytes
  txOrigin_lte: optimism_Bytes
  txOrigin_in: [optimism_Bytes!]
  txOrigin_not_in: [optimism_Bytes!]
  txOrigin_contains: optimism_Bytes
  txOrigin_not_contains: optimism_Bytes
  txNonce: BigInt
  txNonce_not: BigInt
  txNonce_gt: BigInt
  txNonce_lt: BigInt
  txNonce_gte: BigInt
  txNonce_lte: BigInt
  txNonce_in: [BigInt!]
  txNonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: optimism_BlockChangedFilter
  and: [optimism_OriginTransfer_filter]
  or: [optimism_OriginTransfer_filter]
}

enum optimism_OriginTransfer_orderBy {
  id
  chainId
  transferId
  nonce
  status
  messageHash
  originDomain
  destinationDomain
  canonicalDomain
  to
  delegate
  receiveLocal
  callData
  slippage
  originSender
  bridgedAmt
  normalizedIn
  canonicalId
  asset
  asset__id
  asset__key
  asset__decimal
  asset__adoptedDecimal
  asset__canonicalId
  asset__canonicalDomain
  asset__adoptedAsset
  asset__localAsset
  asset__blockNumber
  transactingAsset
  message
  message__id
  message__transferId
  message__destinationDomain
  message__leaf
  message__index
  message__message
  message__root
  message__transactionHash
  message__blockNumber
  bumpRelayerFeeCount
  relayerFees
  initialRelayerFeeAsset
  caller
  transactionHash
  timestamp
  gasPrice
  gasLimit
  blockNumber
  txOrigin
  txNonce
}

type optimism_Relayer {
  id: ID!
  isActive: Boolean!
  relayer: optimism_Bytes
}

type optimism_RelayerFee {
  id: ID!
  transfer: optimism_OriginTransfer!
  fee: BigInt!
  asset: optimism_Bytes!
}

input optimism_RelayerFee_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transfer: String
  transfer_not: String
  transfer_gt: String
  transfer_lt: String
  transfer_gte: String
  transfer_lte: String
  transfer_in: [String!]
  transfer_not_in: [String!]
  transfer_contains: String
  transfer_contains_nocase: String
  transfer_not_contains: String
  transfer_not_contains_nocase: String
  transfer_starts_with: String
  transfer_starts_with_nocase: String
  transfer_not_starts_with: String
  transfer_not_starts_with_nocase: String
  transfer_ends_with: String
  transfer_ends_with_nocase: String
  transfer_not_ends_with: String
  transfer_not_ends_with_nocase: String
  transfer_: optimism_OriginTransfer_filter
  fee: BigInt
  fee_not: BigInt
  fee_gt: BigInt
  fee_lt: BigInt
  fee_gte: BigInt
  fee_lte: BigInt
  fee_in: [BigInt!]
  fee_not_in: [BigInt!]
  asset: optimism_Bytes
  asset_not: optimism_Bytes
  asset_gt: optimism_Bytes
  asset_lt: optimism_Bytes
  asset_gte: optimism_Bytes
  asset_lte: optimism_Bytes
  asset_in: [optimism_Bytes!]
  asset_not_in: [optimism_Bytes!]
  asset_contains: optimism_Bytes
  asset_not_contains: optimism_Bytes
  """Filter for the block changed event."""
  _change_block: optimism_BlockChangedFilter
  and: [optimism_RelayerFee_filter]
  or: [optimism_RelayerFee_filter]
}

enum optimism_RelayerFee_orderBy {
  id
  transfer
  transfer__id
  transfer__chainId
  transfer__transferId
  transfer__nonce
  transfer__status
  transfer__messageHash
  transfer__originDomain
  transfer__destinationDomain
  transfer__canonicalDomain
  transfer__to
  transfer__delegate
  transfer__receiveLocal
  transfer__callData
  transfer__slippage
  transfer__originSender
  transfer__bridgedAmt
  transfer__normalizedIn
  transfer__canonicalId
  transfer__transactingAsset
  transfer__bumpRelayerFeeCount
  transfer__initialRelayerFeeAsset
  transfer__caller
  transfer__transactionHash
  transfer__timestamp
  transfer__gasPrice
  transfer__gasLimit
  transfer__blockNumber
  transfer__txOrigin
  transfer__txNonce
  fee
  asset
}

type optimism_RelayerFeesIncrease {
  id: ID!
  transfer: optimism_OriginTransfer!
  increase: BigInt
  asset: optimism_Bytes
  caller: optimism_Bytes!
  transactionHash: optimism_Bytes!
  timestamp: BigInt!
  gasPrice: BigInt!
  gasLimit: BigInt!
  blockNumber: BigInt!
}

input optimism_RelayerFeesIncrease_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transfer: String
  transfer_not: String
  transfer_gt: String
  transfer_lt: String
  transfer_gte: String
  transfer_lte: String
  transfer_in: [String!]
  transfer_not_in: [String!]
  transfer_contains: String
  transfer_contains_nocase: String
  transfer_not_contains: String
  transfer_not_contains_nocase: String
  transfer_starts_with: String
  transfer_starts_with_nocase: String
  transfer_not_starts_with: String
  transfer_not_starts_with_nocase: String
  transfer_ends_with: String
  transfer_ends_with_nocase: String
  transfer_not_ends_with: String
  transfer_not_ends_with_nocase: String
  transfer_: optimism_OriginTransfer_filter
  increase: BigInt
  increase_not: BigInt
  increase_gt: BigInt
  increase_lt: BigInt
  increase_gte: BigInt
  increase_lte: BigInt
  increase_in: [BigInt!]
  increase_not_in: [BigInt!]
  asset: optimism_Bytes
  asset_not: optimism_Bytes
  asset_gt: optimism_Bytes
  asset_lt: optimism_Bytes
  asset_gte: optimism_Bytes
  asset_lte: optimism_Bytes
  asset_in: [optimism_Bytes!]
  asset_not_in: [optimism_Bytes!]
  asset_contains: optimism_Bytes
  asset_not_contains: optimism_Bytes
  caller: optimism_Bytes
  caller_not: optimism_Bytes
  caller_gt: optimism_Bytes
  caller_lt: optimism_Bytes
  caller_gte: optimism_Bytes
  caller_lte: optimism_Bytes
  caller_in: [optimism_Bytes!]
  caller_not_in: [optimism_Bytes!]
  caller_contains: optimism_Bytes
  caller_not_contains: optimism_Bytes
  transactionHash: optimism_Bytes
  transactionHash_not: optimism_Bytes
  transactionHash_gt: optimism_Bytes
  transactionHash_lt: optimism_Bytes
  transactionHash_gte: optimism_Bytes
  transactionHash_lte: optimism_Bytes
  transactionHash_in: [optimism_Bytes!]
  transactionHash_not_in: [optimism_Bytes!]
  transactionHash_contains: optimism_Bytes
  transactionHash_not_contains: optimism_Bytes
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  gasLimit: BigInt
  gasLimit_not: BigInt
  gasLimit_gt: BigInt
  gasLimit_lt: BigInt
  gasLimit_gte: BigInt
  gasLimit_lte: BigInt
  gasLimit_in: [BigInt!]
  gasLimit_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: optimism_BlockChangedFilter
  and: [optimism_RelayerFeesIncrease_filter]
  or: [optimism_RelayerFeesIncrease_filter]
}

enum optimism_RelayerFeesIncrease_orderBy {
  id
  transfer
  transfer__id
  transfer__chainId
  transfer__transferId
  transfer__nonce
  transfer__status
  transfer__messageHash
  transfer__originDomain
  transfer__destinationDomain
  transfer__canonicalDomain
  transfer__to
  transfer__delegate
  transfer__receiveLocal
  transfer__callData
  transfer__slippage
  transfer__originSender
  transfer__bridgedAmt
  transfer__normalizedIn
  transfer__canonicalId
  transfer__transactingAsset
  transfer__bumpRelayerFeeCount
  transfer__initialRelayerFeeAsset
  transfer__caller
  transfer__transactionHash
  transfer__timestamp
  transfer__gasPrice
  transfer__gasLimit
  transfer__blockNumber
  transfer__txOrigin
  transfer__txNonce
  increase
  asset
  caller
  transactionHash
  timestamp
  gasPrice
  gasLimit
  blockNumber
}

input optimism_Relayer_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  isActive: Boolean
  isActive_not: Boolean
  isActive_in: [Boolean!]
  isActive_not_in: [Boolean!]
  relayer: optimism_Bytes
  relayer_not: optimism_Bytes
  relayer_gt: optimism_Bytes
  relayer_lt: optimism_Bytes
  relayer_gte: optimism_Bytes
  relayer_lte: optimism_Bytes
  relayer_in: [optimism_Bytes!]
  relayer_not_in: [optimism_Bytes!]
  relayer_contains: optimism_Bytes
  relayer_not_contains: optimism_Bytes
  """Filter for the block changed event."""
  _change_block: optimism_BlockChangedFilter
  and: [optimism_Relayer_filter]
  or: [optimism_Relayer_filter]
}

enum optimism_Relayer_orderBy {
  id
  isActive
  relayer
}

type optimism_RootCount {
  id: ID!
  count: BigInt
}

input optimism_RootCount_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  count: BigInt
  count_not: BigInt
  count_gt: BigInt
  count_lt: BigInt
  count_gte: BigInt
  count_lte: BigInt
  count_in: [BigInt!]
  count_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: optimism_BlockChangedFilter
  and: [optimism_RootCount_filter]
  or: [optimism_RootCount_filter]
}

enum optimism_RootCount_orderBy {
  id
  count
}

type optimism_RootMessageSent {
  id: ID!
  spokeDomain: BigInt
  hubDomain: BigInt
  root: optimism_Bytes
  count: BigInt
  caller: optimism_Bytes
  transactionHash: optimism_Bytes
  timestamp: BigInt
  gasPrice: BigInt
  gasLimit: BigInt
  blockNumber: BigInt
}

input optimism_RootMessageSent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  spokeDomain: BigInt
  spokeDomain_not: BigInt
  spokeDomain_gt: BigInt
  spokeDomain_lt: BigInt
  spokeDomain_gte: BigInt
  spokeDomain_lte: BigInt
  spokeDomain_in: [BigInt!]
  spokeDomain_not_in: [BigInt!]
  hubDomain: BigInt
  hubDomain_not: BigInt
  hubDomain_gt: BigInt
  hubDomain_lt: BigInt
  hubDomain_gte: BigInt
  hubDomain_lte: BigInt
  hubDomain_in: [BigInt!]
  hubDomain_not_in: [BigInt!]
  root: optimism_Bytes
  root_not: optimism_Bytes
  root_gt: optimism_Bytes
  root_lt: optimism_Bytes
  root_gte: optimism_Bytes
  root_lte: optimism_Bytes
  root_in: [optimism_Bytes!]
  root_not_in: [optimism_Bytes!]
  root_contains: optimism_Bytes
  root_not_contains: optimism_Bytes
  count: BigInt
  count_not: BigInt
  count_gt: BigInt
  count_lt: BigInt
  count_gte: BigInt
  count_lte: BigInt
  count_in: [BigInt!]
  count_not_in: [BigInt!]
  caller: optimism_Bytes
  caller_not: optimism_Bytes
  caller_gt: optimism_Bytes
  caller_lt: optimism_Bytes
  caller_gte: optimism_Bytes
  caller_lte: optimism_Bytes
  caller_in: [optimism_Bytes!]
  caller_not_in: [optimism_Bytes!]
  caller_contains: optimism_Bytes
  caller_not_contains: optimism_Bytes
  transactionHash: optimism_Bytes
  transactionHash_not: optimism_Bytes
  transactionHash_gt: optimism_Bytes
  transactionHash_lt: optimism_Bytes
  transactionHash_gte: optimism_Bytes
  transactionHash_lte: optimism_Bytes
  transactionHash_in: [optimism_Bytes!]
  transactionHash_not_in: [optimism_Bytes!]
  transactionHash_contains: optimism_Bytes
  transactionHash_not_contains: optimism_Bytes
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  gasLimit: BigInt
  gasLimit_not: BigInt
  gasLimit_gt: BigInt
  gasLimit_lt: BigInt
  gasLimit_gte: BigInt
  gasLimit_lte: BigInt
  gasLimit_in: [BigInt!]
  gasLimit_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: optimism_BlockChangedFilter
  and: [optimism_RootMessageSent_filter]
  or: [optimism_RootMessageSent_filter]
}

enum optimism_RootMessageSent_orderBy {
  id
  spokeDomain
  hubDomain
  root
  count
  caller
  transactionHash
  timestamp
  gasPrice
  gasLimit
  blockNumber
}

type optimism_Router {
  id: ID!
  isActive: Boolean!
  owner: optimism_Bytes
  recipient: optimism_Bytes
  proposedOwner: optimism_Bytes
  proposedTimestamp: BigInt
  assetBalances(skip: Int = 0, first: Int = 100, orderBy: optimism_AssetBalance_orderBy, orderDirection: optimism_OrderDirection, where: optimism_AssetBalance_filter): [optimism_AssetBalance!]!
}

type optimism_RouterDailyTVL {
  id: ID!
  router: optimism_Router!
  asset: optimism_Asset!
  timestamp: BigInt!
  balance: BigInt!
}

input optimism_RouterDailyTVL_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  router: String
  router_not: String
  router_gt: String
  router_lt: String
  router_gte: String
  router_lte: String
  router_in: [String!]
  router_not_in: [String!]
  router_contains: String
  router_contains_nocase: String
  router_not_contains: String
  router_not_contains_nocase: String
  router_starts_with: String
  router_starts_with_nocase: String
  router_not_starts_with: String
  router_not_starts_with_nocase: String
  router_ends_with: String
  router_ends_with_nocase: String
  router_not_ends_with: String
  router_not_ends_with_nocase: String
  router_: optimism_Router_filter
  asset: String
  asset_not: String
  asset_gt: String
  asset_lt: String
  asset_gte: String
  asset_lte: String
  asset_in: [String!]
  asset_not_in: [String!]
  asset_contains: String
  asset_contains_nocase: String
  asset_not_contains: String
  asset_not_contains_nocase: String
  asset_starts_with: String
  asset_starts_with_nocase: String
  asset_not_starts_with: String
  asset_not_starts_with_nocase: String
  asset_ends_with: String
  asset_ends_with_nocase: String
  asset_not_ends_with: String
  asset_not_ends_with_nocase: String
  asset_: optimism_Asset_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  balance: BigInt
  balance_not: BigInt
  balance_gt: BigInt
  balance_lt: BigInt
  balance_gte: BigInt
  balance_lte: BigInt
  balance_in: [BigInt!]
  balance_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: optimism_BlockChangedFilter
  and: [optimism_RouterDailyTVL_filter]
  or: [optimism_RouterDailyTVL_filter]
}

enum optimism_RouterDailyTVL_orderBy {
  id
  router
  router__id
  router__isActive
  router__owner
  router__recipient
  router__proposedOwner
  router__proposedTimestamp
  asset
  asset__id
  asset__key
  asset__decimal
  asset__adoptedDecimal
  asset__canonicalId
  asset__canonicalDomain
  asset__adoptedAsset
  asset__localAsset
  asset__blockNumber
  timestamp
  balance
}

type optimism_RouterLiquidityEvent {
  id: ID!
  type: optimism_RouterLiquidityEventType
  router: optimism_Router!
  asset: optimism_Asset!
  amount: BigInt!
  balance: BigInt!
  caller: optimism_Bytes
  blockNumber: BigInt!
  timestamp: BigInt!
  transactionHash: optimism_Bytes!
  nonce: BigInt!
}

enum optimism_RouterLiquidityEventType {
  Add
  Remove
}

input optimism_RouterLiquidityEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  type: optimism_RouterLiquidityEventType
  type_not: optimism_RouterLiquidityEventType
  type_in: [optimism_RouterLiquidityEventType!]
  type_not_in: [optimism_RouterLiquidityEventType!]
  router: String
  router_not: String
  router_gt: String
  router_lt: String
  router_gte: String
  router_lte: String
  router_in: [String!]
  router_not_in: [String!]
  router_contains: String
  router_contains_nocase: String
  router_not_contains: String
  router_not_contains_nocase: String
  router_starts_with: String
  router_starts_with_nocase: String
  router_not_starts_with: String
  router_not_starts_with_nocase: String
  router_ends_with: String
  router_ends_with_nocase: String
  router_not_ends_with: String
  router_not_ends_with_nocase: String
  router_: optimism_Router_filter
  asset: String
  asset_not: String
  asset_gt: String
  asset_lt: String
  asset_gte: String
  asset_lte: String
  asset_in: [String!]
  asset_not_in: [String!]
  asset_contains: String
  asset_contains_nocase: String
  asset_not_contains: String
  asset_not_contains_nocase: String
  asset_starts_with: String
  asset_starts_with_nocase: String
  asset_not_starts_with: String
  asset_not_starts_with_nocase: String
  asset_ends_with: String
  asset_ends_with_nocase: String
  asset_not_ends_with: String
  asset_not_ends_with_nocase: String
  asset_: optimism_Asset_filter
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  balance: BigInt
  balance_not: BigInt
  balance_gt: BigInt
  balance_lt: BigInt
  balance_gte: BigInt
  balance_lte: BigInt
  balance_in: [BigInt!]
  balance_not_in: [BigInt!]
  caller: optimism_Bytes
  caller_not: optimism_Bytes
  caller_gt: optimism_Bytes
  caller_lt: optimism_Bytes
  caller_gte: optimism_Bytes
  caller_lte: optimism_Bytes
  caller_in: [optimism_Bytes!]
  caller_not_in: [optimism_Bytes!]
  caller_contains: optimism_Bytes
  caller_not_contains: optimism_Bytes
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transactionHash: optimism_Bytes
  transactionHash_not: optimism_Bytes
  transactionHash_gt: optimism_Bytes
  transactionHash_lt: optimism_Bytes
  transactionHash_gte: optimism_Bytes
  transactionHash_lte: optimism_Bytes
  transactionHash_in: [optimism_Bytes!]
  transactionHash_not_in: [optimism_Bytes!]
  transactionHash_contains: optimism_Bytes
  transactionHash_not_contains: optimism_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: optimism_BlockChangedFilter
  and: [optimism_RouterLiquidityEvent_filter]
  or: [optimism_RouterLiquidityEvent_filter]
}

enum optimism_RouterLiquidityEvent_orderBy {
  id
  type
  router
  router__id
  router__isActive
  router__owner
  router__recipient
  router__proposedOwner
  router__proposedTimestamp
  asset
  asset__id
  asset__key
  asset__decimal
  asset__adoptedDecimal
  asset__canonicalId
  asset__canonicalDomain
  asset__adoptedAsset
  asset__localAsset
  asset__blockNumber
  amount
  balance
  caller
  blockNumber
  timestamp
  transactionHash
  nonce
}

input optimism_Router_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  isActive: Boolean
  isActive_not: Boolean
  isActive_in: [Boolean!]
  isActive_not_in: [Boolean!]
  owner: optimism_Bytes
  owner_not: optimism_Bytes
  owner_gt: optimism_Bytes
  owner_lt: optimism_Bytes
  owner_gte: optimism_Bytes
  owner_lte: optimism_Bytes
  owner_in: [optimism_Bytes!]
  owner_not_in: [optimism_Bytes!]
  owner_contains: optimism_Bytes
  owner_not_contains: optimism_Bytes
  recipient: optimism_Bytes
  recipient_not: optimism_Bytes
  recipient_gt: optimism_Bytes
  recipient_lt: optimism_Bytes
  recipient_gte: optimism_Bytes
  recipient_lte: optimism_Bytes
  recipient_in: [optimism_Bytes!]
  recipient_not_in: [optimism_Bytes!]
  recipient_contains: optimism_Bytes
  recipient_not_contains: optimism_Bytes
  proposedOwner: optimism_Bytes
  proposedOwner_not: optimism_Bytes
  proposedOwner_gt: optimism_Bytes
  proposedOwner_lt: optimism_Bytes
  proposedOwner_gte: optimism_Bytes
  proposedOwner_lte: optimism_Bytes
  proposedOwner_in: [optimism_Bytes!]
  proposedOwner_not_in: [optimism_Bytes!]
  proposedOwner_contains: optimism_Bytes
  proposedOwner_not_contains: optimism_Bytes
  proposedTimestamp: BigInt
  proposedTimestamp_not: BigInt
  proposedTimestamp_gt: BigInt
  proposedTimestamp_lt: BigInt
  proposedTimestamp_gte: BigInt
  proposedTimestamp_lte: BigInt
  proposedTimestamp_in: [BigInt!]
  proposedTimestamp_not_in: [BigInt!]
  assetBalances_: optimism_AssetBalance_filter
  """Filter for the block changed event."""
  _change_block: optimism_BlockChangedFilter
  and: [optimism_Router_filter]
  or: [optimism_Router_filter]
}

enum optimism_Router_orderBy {
  id
  isActive
  owner
  recipient
  proposedOwner
  proposedTimestamp
  assetBalances
}

type optimism_Sequencer {
  id: ID!
  isActive: Boolean!
  sequencer: optimism_Bytes
}

input optimism_Sequencer_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  isActive: Boolean
  isActive_not: Boolean
  isActive_in: [Boolean!]
  isActive_not_in: [Boolean!]
  sequencer: optimism_Bytes
  sequencer_not: optimism_Bytes
  sequencer_gt: optimism_Bytes
  sequencer_lt: optimism_Bytes
  sequencer_gte: optimism_Bytes
  sequencer_lte: optimism_Bytes
  sequencer_in: [optimism_Bytes!]
  sequencer_not_in: [optimism_Bytes!]
  sequencer_contains: optimism_Bytes
  sequencer_not_contains: optimism_Bytes
  """Filter for the block changed event."""
  _change_block: optimism_BlockChangedFilter
  and: [optimism_Sequencer_filter]
  or: [optimism_Sequencer_filter]
}

enum optimism_Sequencer_orderBy {
  id
  isActive
  sequencer
}

type optimism_Setting {
  id: ID!
  maxRoutersPerTransfer: BigInt!
  caller: optimism_Bytes!
}

input optimism_Setting_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  maxRoutersPerTransfer: BigInt
  maxRoutersPerTransfer_not: BigInt
  maxRoutersPerTransfer_gt: BigInt
  maxRoutersPerTransfer_lt: BigInt
  maxRoutersPerTransfer_gte: BigInt
  maxRoutersPerTransfer_lte: BigInt
  maxRoutersPerTransfer_in: [BigInt!]
  maxRoutersPerTransfer_not_in: [BigInt!]
  caller: optimism_Bytes
  caller_not: optimism_Bytes
  caller_gt: optimism_Bytes
  caller_lt: optimism_Bytes
  caller_gte: optimism_Bytes
  caller_lte: optimism_Bytes
  caller_in: [optimism_Bytes!]
  caller_not_in: [optimism_Bytes!]
  caller_contains: optimism_Bytes
  caller_not_contains: optimism_Bytes
  """Filter for the block changed event."""
  _change_block: optimism_BlockChangedFilter
  and: [optimism_Setting_filter]
  or: [optimism_Setting_filter]
}

enum optimism_Setting_orderBy {
  id
  maxRoutersPerTransfer
  caller
}

type optimism_SlippageUpdate {
  id: ID!
  transfer: optimism_DestinationTransfer!
  slippage: BigInt!
  caller: optimism_Bytes!
  transactionHash: optimism_Bytes!
  timestamp: BigInt!
  gasPrice: BigInt!
  gasLimit: BigInt!
  blockNumber: BigInt!
}

input optimism_SlippageUpdate_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transfer: String
  transfer_not: String
  transfer_gt: String
  transfer_lt: String
  transfer_gte: String
  transfer_lte: String
  transfer_in: [String!]
  transfer_not_in: [String!]
  transfer_contains: String
  transfer_contains_nocase: String
  transfer_not_contains: String
  transfer_not_contains_nocase: String
  transfer_starts_with: String
  transfer_starts_with_nocase: String
  transfer_not_starts_with: String
  transfer_not_starts_with_nocase: String
  transfer_ends_with: String
  transfer_ends_with_nocase: String
  transfer_not_ends_with: String
  transfer_not_ends_with_nocase: String
  transfer_: optimism_DestinationTransfer_filter
  slippage: BigInt
  slippage_not: BigInt
  slippage_gt: BigInt
  slippage_lt: BigInt
  slippage_gte: BigInt
  slippage_lte: BigInt
  slippage_in: [BigInt!]
  slippage_not_in: [BigInt!]
  caller: optimism_Bytes
  caller_not: optimism_Bytes
  caller_gt: optimism_Bytes
  caller_lt: optimism_Bytes
  caller_gte: optimism_Bytes
  caller_lte: optimism_Bytes
  caller_in: [optimism_Bytes!]
  caller_not_in: [optimism_Bytes!]
  caller_contains: optimism_Bytes
  caller_not_contains: optimism_Bytes
  transactionHash: optimism_Bytes
  transactionHash_not: optimism_Bytes
  transactionHash_gt: optimism_Bytes
  transactionHash_lt: optimism_Bytes
  transactionHash_gte: optimism_Bytes
  transactionHash_lte: optimism_Bytes
  transactionHash_in: [optimism_Bytes!]
  transactionHash_not_in: [optimism_Bytes!]
  transactionHash_contains: optimism_Bytes
  transactionHash_not_contains: optimism_Bytes
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  gasLimit: BigInt
  gasLimit_not: BigInt
  gasLimit_gt: BigInt
  gasLimit_lt: BigInt
  gasLimit_gte: BigInt
  gasLimit_lte: BigInt
  gasLimit_in: [BigInt!]
  gasLimit_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: optimism_BlockChangedFilter
  and: [optimism_SlippageUpdate_filter]
  or: [optimism_SlippageUpdate_filter]
}

enum optimism_SlippageUpdate_orderBy {
  id
  transfer
  transfer__id
  transfer__chainId
  transfer__transferId
  transfer__nonce
  transfer__status
  transfer__originDomain
  transfer__destinationDomain
  transfer__canonicalDomain
  transfer__to
  transfer__delegate
  transfer__receiveLocal
  transfer__callData
  transfer__slippage
  transfer__bumpSlippageCount
  transfer__originSender
  transfer__bridgedAmt
  transfer__normalizedIn
  transfer__canonicalId
  transfer__amount
  transfer__routersFee
  transfer__executedCaller
  transfer__executedTransactionHash
  transfer__executedTimestamp
  transfer__executedGasPrice
  transfer__executedGasLimit
  transfer__executedBlockNumber
  transfer__executedTxOrigin
  transfer__executedTxNonce
  transfer__reconciledCaller
  transfer__reconciledTransactionHash
  transfer__reconciledTimestamp
  transfer__reconciledGasPrice
  transfer__reconciledGasLimit
  transfer__reconciledBlockNumber
  transfer__reconciledTxOrigin
  transfer__reconciledTxNonce
  slippage
  caller
  transactionHash
  timestamp
  gasPrice
  gasLimit
  blockNumber
}

type optimism_SnapshotRoot {
  id: ID!
  spokeDomain: BigInt
  root: optimism_Bytes!
  count: BigInt!
  timestamp: BigInt!
  blockNumber: BigInt!
}

input optimism_SnapshotRoot_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  spokeDomain: BigInt
  spokeDomain_not: BigInt
  spokeDomain_gt: BigInt
  spokeDomain_lt: BigInt
  spokeDomain_gte: BigInt
  spokeDomain_lte: BigInt
  spokeDomain_in: [BigInt!]
  spokeDomain_not_in: [BigInt!]
  root: optimism_Bytes
  root_not: optimism_Bytes
  root_gt: optimism_Bytes
  root_lt: optimism_Bytes
  root_gte: optimism_Bytes
  root_lte: optimism_Bytes
  root_in: [optimism_Bytes!]
  root_not_in: [optimism_Bytes!]
  root_contains: optimism_Bytes
  root_not_contains: optimism_Bytes
  count: BigInt
  count_not: BigInt
  count_gt: BigInt
  count_lt: BigInt
  count_gte: BigInt
  count_lte: BigInt
  count_in: [BigInt!]
  count_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: optimism_BlockChangedFilter
  and: [optimism_SnapshotRoot_filter]
  or: [optimism_SnapshotRoot_filter]
}

enum optimism_SnapshotRoot_orderBy {
  id
  spokeDomain
  root
  count
  timestamp
  blockNumber
}

type optimism_SpokeConnectorMode {
  id: ID!
  mode: String!
}

input optimism_SpokeConnectorMode_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  mode: String
  mode_not: String
  mode_gt: String
  mode_lt: String
  mode_gte: String
  mode_lte: String
  mode_in: [String!]
  mode_not_in: [String!]
  mode_contains: String
  mode_contains_nocase: String
  mode_not_contains: String
  mode_not_contains_nocase: String
  mode_starts_with: String
  mode_starts_with_nocase: String
  mode_not_starts_with: String
  mode_not_starts_with_nocase: String
  mode_ends_with: String
  mode_ends_with_nocase: String
  mode_not_ends_with: String
  mode_not_ends_with_nocase: String
  """Filter for the block changed event."""
  _change_block: optimism_BlockChangedFilter
  and: [optimism_SpokeConnectorMode_filter]
  or: [optimism_SpokeConnectorMode_filter]
}

enum optimism_SpokeConnectorMode_orderBy {
  id
  mode
}

enum optimism_TransferStatus {
  XCalled
  Executed
  Reconciled
  CompletedSlow
  CompletedFast
}

type optimism__Block_ {
  """The hash of the block"""
  hash: optimism_Bytes
  """The block number"""
  number: Int!
  """Integer representation of the timestamp stored in blocks for the chain"""
  timestamp: Int
  """The hash of the parent block"""
  parentHash: optimism_Bytes
}

"""The type for the top-level _meta field"""
type optimism__Meta_ {
  """
  Information about a specific subgraph block. The hash of the block
  will be null if the _meta field has a block constraint that asks for
  a block number. It will be filled if the _meta field has no block constraint
  and therefore asks for the latest  block
  
  """
  block: optimism__Block_!
  """The deployment ID"""
  deployment: String!
  """If `true`, the subgraph encountered indexing errors at some past block"""
  hasIndexingErrors: Boolean!
}

type avalanche_AggregateRoot {
  id: ID!
  root: avalanche_Bytes!
  blockNumber: BigInt!
}

type avalanche_AggregateRootProposed {
  id: ID!
  aggregateRoot: avalanche_Bytes!
  rootTimestamp: BigInt!
  endOfDispute: BigInt!
  domain: BigInt!
  timestamp: BigInt!
  blockNumber: BigInt
}

input avalanche_AggregateRootProposed_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  aggregateRoot: avalanche_Bytes
  aggregateRoot_not: avalanche_Bytes
  aggregateRoot_gt: avalanche_Bytes
  aggregateRoot_lt: avalanche_Bytes
  aggregateRoot_gte: avalanche_Bytes
  aggregateRoot_lte: avalanche_Bytes
  aggregateRoot_in: [avalanche_Bytes!]
  aggregateRoot_not_in: [avalanche_Bytes!]
  aggregateRoot_contains: avalanche_Bytes
  aggregateRoot_not_contains: avalanche_Bytes
  rootTimestamp: BigInt
  rootTimestamp_not: BigInt
  rootTimestamp_gt: BigInt
  rootTimestamp_lt: BigInt
  rootTimestamp_gte: BigInt
  rootTimestamp_lte: BigInt
  rootTimestamp_in: [BigInt!]
  rootTimestamp_not_in: [BigInt!]
  endOfDispute: BigInt
  endOfDispute_not: BigInt
  endOfDispute_gt: BigInt
  endOfDispute_lt: BigInt
  endOfDispute_gte: BigInt
  endOfDispute_lte: BigInt
  endOfDispute_in: [BigInt!]
  endOfDispute_not_in: [BigInt!]
  domain: BigInt
  domain_not: BigInt
  domain_gt: BigInt
  domain_lt: BigInt
  domain_gte: BigInt
  domain_lte: BigInt
  domain_in: [BigInt!]
  domain_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: avalanche_BlockChangedFilter
  and: [avalanche_AggregateRootProposed_filter]
  or: [avalanche_AggregateRootProposed_filter]
}

enum avalanche_AggregateRootProposed_orderBy {
  id
  aggregateRoot
  rootTimestamp
  endOfDispute
  domain
  timestamp
  blockNumber
}

input avalanche_AggregateRoot_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  root: avalanche_Bytes
  root_not: avalanche_Bytes
  root_gt: avalanche_Bytes
  root_lt: avalanche_Bytes
  root_gte: avalanche_Bytes
  root_lte: avalanche_Bytes
  root_in: [avalanche_Bytes!]
  root_not_in: [avalanche_Bytes!]
  root_contains: avalanche_Bytes
  root_not_contains: avalanche_Bytes
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: avalanche_BlockChangedFilter
  and: [avalanche_AggregateRoot_filter]
  or: [avalanche_AggregateRoot_filter]
}

enum avalanche_AggregateRoot_orderBy {
  id
  root
  blockNumber
}

enum avalanche_Aggregation_interval {
  hour
  day
}

type avalanche_Asset {
  id: ID!
  key: avalanche_Bytes
  decimal: BigInt
  adoptedDecimal: BigInt
  canonicalId: avalanche_Bytes
  canonicalDomain: BigInt
  adoptedAsset: avalanche_Bytes
  localAsset: avalanche_Bytes
  blockNumber: BigInt
  status: avalanche_AssetStatus
}

type avalanche_AssetBalance {
  id: ID!
  amount: BigInt!
  locked: BigInt!
  supplied: BigInt!
  removed: BigInt!
  router: avalanche_Router!
  asset: avalanche_Asset!
  feesEarned: BigInt!
}

input avalanche_AssetBalance_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  locked: BigInt
  locked_not: BigInt
  locked_gt: BigInt
  locked_lt: BigInt
  locked_gte: BigInt
  locked_lte: BigInt
  locked_in: [BigInt!]
  locked_not_in: [BigInt!]
  supplied: BigInt
  supplied_not: BigInt
  supplied_gt: BigInt
  supplied_lt: BigInt
  supplied_gte: BigInt
  supplied_lte: BigInt
  supplied_in: [BigInt!]
  supplied_not_in: [BigInt!]
  removed: BigInt
  removed_not: BigInt
  removed_gt: BigInt
  removed_lt: BigInt
  removed_gte: BigInt
  removed_lte: BigInt
  removed_in: [BigInt!]
  removed_not_in: [BigInt!]
  router: String
  router_not: String
  router_gt: String
  router_lt: String
  router_gte: String
  router_lte: String
  router_in: [String!]
  router_not_in: [String!]
  router_contains: String
  router_contains_nocase: String
  router_not_contains: String
  router_not_contains_nocase: String
  router_starts_with: String
  router_starts_with_nocase: String
  router_not_starts_with: String
  router_not_starts_with_nocase: String
  router_ends_with: String
  router_ends_with_nocase: String
  router_not_ends_with: String
  router_not_ends_with_nocase: String
  router_: avalanche_Router_filter
  asset: String
  asset_not: String
  asset_gt: String
  asset_lt: String
  asset_gte: String
  asset_lte: String
  asset_in: [String!]
  asset_not_in: [String!]
  asset_contains: String
  asset_contains_nocase: String
  asset_not_contains: String
  asset_not_contains_nocase: String
  asset_starts_with: String
  asset_starts_with_nocase: String
  asset_not_starts_with: String
  asset_not_starts_with_nocase: String
  asset_ends_with: String
  asset_ends_with_nocase: String
  asset_not_ends_with: String
  asset_not_ends_with_nocase: String
  asset_: avalanche_Asset_filter
  feesEarned: BigInt
  feesEarned_not: BigInt
  feesEarned_gt: BigInt
  feesEarned_lt: BigInt
  feesEarned_gte: BigInt
  feesEarned_lte: BigInt
  feesEarned_in: [BigInt!]
  feesEarned_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: avalanche_BlockChangedFilter
  and: [avalanche_AssetBalance_filter]
  or: [avalanche_AssetBalance_filter]
}

enum avalanche_AssetBalance_orderBy {
  id
  amount
  locked
  supplied
  removed
  router
  router__id
  router__isActive
  router__owner
  router__recipient
  router__proposedOwner
  router__proposedTimestamp
  asset
  asset__id
  asset__key
  asset__decimal
  asset__adoptedDecimal
  asset__canonicalId
  asset__canonicalDomain
  asset__adoptedAsset
  asset__localAsset
  asset__blockNumber
  feesEarned
}

type avalanche_AssetStatus {
  id: ID!
  status: Boolean
}

input avalanche_AssetStatus_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  status: Boolean
  status_not: Boolean
  status_in: [Boolean!]
  status_not_in: [Boolean!]
  """Filter for the block changed event."""
  _change_block: avalanche_BlockChangedFilter
  and: [avalanche_AssetStatus_filter]
  or: [avalanche_AssetStatus_filter]
}

enum avalanche_AssetStatus_orderBy {
  id
  status
}

input avalanche_Asset_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  key: avalanche_Bytes
  key_not: avalanche_Bytes
  key_gt: avalanche_Bytes
  key_lt: avalanche_Bytes
  key_gte: avalanche_Bytes
  key_lte: avalanche_Bytes
  key_in: [avalanche_Bytes!]
  key_not_in: [avalanche_Bytes!]
  key_contains: avalanche_Bytes
  key_not_contains: avalanche_Bytes
  decimal: BigInt
  decimal_not: BigInt
  decimal_gt: BigInt
  decimal_lt: BigInt
  decimal_gte: BigInt
  decimal_lte: BigInt
  decimal_in: [BigInt!]
  decimal_not_in: [BigInt!]
  adoptedDecimal: BigInt
  adoptedDecimal_not: BigInt
  adoptedDecimal_gt: BigInt
  adoptedDecimal_lt: BigInt
  adoptedDecimal_gte: BigInt
  adoptedDecimal_lte: BigInt
  adoptedDecimal_in: [BigInt!]
  adoptedDecimal_not_in: [BigInt!]
  canonicalId: avalanche_Bytes
  canonicalId_not: avalanche_Bytes
  canonicalId_gt: avalanche_Bytes
  canonicalId_lt: avalanche_Bytes
  canonicalId_gte: avalanche_Bytes
  canonicalId_lte: avalanche_Bytes
  canonicalId_in: [avalanche_Bytes!]
  canonicalId_not_in: [avalanche_Bytes!]
  canonicalId_contains: avalanche_Bytes
  canonicalId_not_contains: avalanche_Bytes
  canonicalDomain: BigInt
  canonicalDomain_not: BigInt
  canonicalDomain_gt: BigInt
  canonicalDomain_lt: BigInt
  canonicalDomain_gte: BigInt
  canonicalDomain_lte: BigInt
  canonicalDomain_in: [BigInt!]
  canonicalDomain_not_in: [BigInt!]
  adoptedAsset: avalanche_Bytes
  adoptedAsset_not: avalanche_Bytes
  adoptedAsset_gt: avalanche_Bytes
  adoptedAsset_lt: avalanche_Bytes
  adoptedAsset_gte: avalanche_Bytes
  adoptedAsset_lte: avalanche_Bytes
  adoptedAsset_in: [avalanche_Bytes!]
  adoptedAsset_not_in: [avalanche_Bytes!]
  adoptedAsset_contains: avalanche_Bytes
  adoptedAsset_not_contains: avalanche_Bytes
  localAsset: avalanche_Bytes
  localAsset_not: avalanche_Bytes
  localAsset_gt: avalanche_Bytes
  localAsset_lt: avalanche_Bytes
  localAsset_gte: avalanche_Bytes
  localAsset_lte: avalanche_Bytes
  localAsset_in: [avalanche_Bytes!]
  localAsset_not_in: [avalanche_Bytes!]
  localAsset_contains: avalanche_Bytes
  localAsset_not_contains: avalanche_Bytes
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  status: String
  status_not: String
  status_gt: String
  status_lt: String
  status_gte: String
  status_lte: String
  status_in: [String!]
  status_not_in: [String!]
  status_contains: String
  status_contains_nocase: String
  status_not_contains: String
  status_not_contains_nocase: String
  status_starts_with: String
  status_starts_with_nocase: String
  status_not_starts_with: String
  status_not_starts_with_nocase: String
  status_ends_with: String
  status_ends_with_nocase: String
  status_not_ends_with: String
  status_not_ends_with_nocase: String
  status_: avalanche_AssetStatus_filter
  """Filter for the block changed event."""
  _change_block: avalanche_BlockChangedFilter
  and: [avalanche_Asset_filter]
  or: [avalanche_Asset_filter]
}

enum avalanche_Asset_orderBy {
  id
  key
  decimal
  adoptedDecimal
  canonicalId
  canonicalDomain
  adoptedAsset
  localAsset
  blockNumber
  status
  status__id
  status__status
}

scalar avalanche_BigDecimal

input avalanche_BlockChangedFilter {
  number_gte: Int!
}

input avalanche_Block_height {
  hash: avalanche_Bytes
  number: Int
  number_gte: Int
}

scalar avalanche_Bytes

type avalanche_ConnectorMeta {
  id: ID!
  spokeDomain: BigInt
  hubDomain: BigInt
  amb: avalanche_Bytes
  rootManager: avalanche_Bytes
  mirrorConnector: avalanche_Bytes
}

input avalanche_ConnectorMeta_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  spokeDomain: BigInt
  spokeDomain_not: BigInt
  spokeDomain_gt: BigInt
  spokeDomain_lt: BigInt
  spokeDomain_gte: BigInt
  spokeDomain_lte: BigInt
  spokeDomain_in: [BigInt!]
  spokeDomain_not_in: [BigInt!]
  hubDomain: BigInt
  hubDomain_not: BigInt
  hubDomain_gt: BigInt
  hubDomain_lt: BigInt
  hubDomain_gte: BigInt
  hubDomain_lte: BigInt
  hubDomain_in: [BigInt!]
  hubDomain_not_in: [BigInt!]
  amb: avalanche_Bytes
  amb_not: avalanche_Bytes
  amb_gt: avalanche_Bytes
  amb_lt: avalanche_Bytes
  amb_gte: avalanche_Bytes
  amb_lte: avalanche_Bytes
  amb_in: [avalanche_Bytes!]
  amb_not_in: [avalanche_Bytes!]
  amb_contains: avalanche_Bytes
  amb_not_contains: avalanche_Bytes
  rootManager: avalanche_Bytes
  rootManager_not: avalanche_Bytes
  rootManager_gt: avalanche_Bytes
  rootManager_lt: avalanche_Bytes
  rootManager_gte: avalanche_Bytes
  rootManager_lte: avalanche_Bytes
  rootManager_in: [avalanche_Bytes!]
  rootManager_not_in: [avalanche_Bytes!]
  rootManager_contains: avalanche_Bytes
  rootManager_not_contains: avalanche_Bytes
  mirrorConnector: avalanche_Bytes
  mirrorConnector_not: avalanche_Bytes
  mirrorConnector_gt: avalanche_Bytes
  mirrorConnector_lt: avalanche_Bytes
  mirrorConnector_gte: avalanche_Bytes
  mirrorConnector_lte: avalanche_Bytes
  mirrorConnector_in: [avalanche_Bytes!]
  mirrorConnector_not_in: [avalanche_Bytes!]
  mirrorConnector_contains: avalanche_Bytes
  mirrorConnector_not_contains: avalanche_Bytes
  """Filter for the block changed event."""
  _change_block: avalanche_BlockChangedFilter
  and: [avalanche_ConnectorMeta_filter]
  or: [avalanche_ConnectorMeta_filter]
}

enum avalanche_ConnectorMeta_orderBy {
  id
  spokeDomain
  hubDomain
  amb
  rootManager
  mirrorConnector
}

type avalanche_DestinationTransfer {
  id: ID!
  chainId: BigInt
  transferId: avalanche_Bytes
  nonce: BigInt
  status: avalanche_TransferStatus
  routers(skip: Int = 0, first: Int = 100, orderBy: avalanche_Router_orderBy, orderDirection: avalanche_OrderDirection, where: avalanche_Router_filter): [avalanche_Router!]
  originDomain: BigInt
  destinationDomain: BigInt
  canonicalDomain: BigInt
  to: avalanche_Bytes
  delegate: avalanche_Bytes
  receiveLocal: Boolean
  callData: avalanche_Bytes
  slippage: BigInt
  bumpSlippageCount: BigInt
  originSender: avalanche_Bytes
  bridgedAmt: BigInt
  normalizedIn: BigInt
  canonicalId: avalanche_Bytes
  asset: avalanche_Asset
  amount: BigInt
  routersFee: BigInt
  executedCaller: avalanche_Bytes
  executedTransactionHash: avalanche_Bytes
  executedTimestamp: BigInt
  executedGasPrice: BigInt
  executedGasLimit: BigInt
  executedBlockNumber: BigInt
  executedTxOrigin: avalanche_Bytes
  executedTxNonce: BigInt
  reconciledCaller: avalanche_Bytes
  reconciledTransactionHash: avalanche_Bytes
  reconciledTimestamp: BigInt
  reconciledGasPrice: BigInt
  reconciledGasLimit: BigInt
  reconciledBlockNumber: BigInt
  reconciledTxOrigin: avalanche_Bytes
  reconciledTxNonce: BigInt
}

input avalanche_DestinationTransfer_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  chainId: BigInt
  chainId_not: BigInt
  chainId_gt: BigInt
  chainId_lt: BigInt
  chainId_gte: BigInt
  chainId_lte: BigInt
  chainId_in: [BigInt!]
  chainId_not_in: [BigInt!]
  transferId: avalanche_Bytes
  transferId_not: avalanche_Bytes
  transferId_gt: avalanche_Bytes
  transferId_lt: avalanche_Bytes
  transferId_gte: avalanche_Bytes
  transferId_lte: avalanche_Bytes
  transferId_in: [avalanche_Bytes!]
  transferId_not_in: [avalanche_Bytes!]
  transferId_contains: avalanche_Bytes
  transferId_not_contains: avalanche_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  status: avalanche_TransferStatus
  status_not: avalanche_TransferStatus
  status_in: [avalanche_TransferStatus!]
  status_not_in: [avalanche_TransferStatus!]
  routers: [String!]
  routers_not: [String!]
  routers_contains: [String!]
  routers_contains_nocase: [String!]
  routers_not_contains: [String!]
  routers_not_contains_nocase: [String!]
  routers_: avalanche_Router_filter
  originDomain: BigInt
  originDomain_not: BigInt
  originDomain_gt: BigInt
  originDomain_lt: BigInt
  originDomain_gte: BigInt
  originDomain_lte: BigInt
  originDomain_in: [BigInt!]
  originDomain_not_in: [BigInt!]
  destinationDomain: BigInt
  destinationDomain_not: BigInt
  destinationDomain_gt: BigInt
  destinationDomain_lt: BigInt
  destinationDomain_gte: BigInt
  destinationDomain_lte: BigInt
  destinationDomain_in: [BigInt!]
  destinationDomain_not_in: [BigInt!]
  canonicalDomain: BigInt
  canonicalDomain_not: BigInt
  canonicalDomain_gt: BigInt
  canonicalDomain_lt: BigInt
  canonicalDomain_gte: BigInt
  canonicalDomain_lte: BigInt
  canonicalDomain_in: [BigInt!]
  canonicalDomain_not_in: [BigInt!]
  to: avalanche_Bytes
  to_not: avalanche_Bytes
  to_gt: avalanche_Bytes
  to_lt: avalanche_Bytes
  to_gte: avalanche_Bytes
  to_lte: avalanche_Bytes
  to_in: [avalanche_Bytes!]
  to_not_in: [avalanche_Bytes!]
  to_contains: avalanche_Bytes
  to_not_contains: avalanche_Bytes
  delegate: avalanche_Bytes
  delegate_not: avalanche_Bytes
  delegate_gt: avalanche_Bytes
  delegate_lt: avalanche_Bytes
  delegate_gte: avalanche_Bytes
  delegate_lte: avalanche_Bytes
  delegate_in: [avalanche_Bytes!]
  delegate_not_in: [avalanche_Bytes!]
  delegate_contains: avalanche_Bytes
  delegate_not_contains: avalanche_Bytes
  receiveLocal: Boolean
  receiveLocal_not: Boolean
  receiveLocal_in: [Boolean!]
  receiveLocal_not_in: [Boolean!]
  callData: avalanche_Bytes
  callData_not: avalanche_Bytes
  callData_gt: avalanche_Bytes
  callData_lt: avalanche_Bytes
  callData_gte: avalanche_Bytes
  callData_lte: avalanche_Bytes
  callData_in: [avalanche_Bytes!]
  callData_not_in: [avalanche_Bytes!]
  callData_contains: avalanche_Bytes
  callData_not_contains: avalanche_Bytes
  slippage: BigInt
  slippage_not: BigInt
  slippage_gt: BigInt
  slippage_lt: BigInt
  slippage_gte: BigInt
  slippage_lte: BigInt
  slippage_in: [BigInt!]
  slippage_not_in: [BigInt!]
  bumpSlippageCount: BigInt
  bumpSlippageCount_not: BigInt
  bumpSlippageCount_gt: BigInt
  bumpSlippageCount_lt: BigInt
  bumpSlippageCount_gte: BigInt
  bumpSlippageCount_lte: BigInt
  bumpSlippageCount_in: [BigInt!]
  bumpSlippageCount_not_in: [BigInt!]
  originSender: avalanche_Bytes
  originSender_not: avalanche_Bytes
  originSender_gt: avalanche_Bytes
  originSender_lt: avalanche_Bytes
  originSender_gte: avalanche_Bytes
  originSender_lte: avalanche_Bytes
  originSender_in: [avalanche_Bytes!]
  originSender_not_in: [avalanche_Bytes!]
  originSender_contains: avalanche_Bytes
  originSender_not_contains: avalanche_Bytes
  bridgedAmt: BigInt
  bridgedAmt_not: BigInt
  bridgedAmt_gt: BigInt
  bridgedAmt_lt: BigInt
  bridgedAmt_gte: BigInt
  bridgedAmt_lte: BigInt
  bridgedAmt_in: [BigInt!]
  bridgedAmt_not_in: [BigInt!]
  normalizedIn: BigInt
  normalizedIn_not: BigInt
  normalizedIn_gt: BigInt
  normalizedIn_lt: BigInt
  normalizedIn_gte: BigInt
  normalizedIn_lte: BigInt
  normalizedIn_in: [BigInt!]
  normalizedIn_not_in: [BigInt!]
  canonicalId: avalanche_Bytes
  canonicalId_not: avalanche_Bytes
  canonicalId_gt: avalanche_Bytes
  canonicalId_lt: avalanche_Bytes
  canonicalId_gte: avalanche_Bytes
  canonicalId_lte: avalanche_Bytes
  canonicalId_in: [avalanche_Bytes!]
  canonicalId_not_in: [avalanche_Bytes!]
  canonicalId_contains: avalanche_Bytes
  canonicalId_not_contains: avalanche_Bytes
  asset: String
  asset_not: String
  asset_gt: String
  asset_lt: String
  asset_gte: String
  asset_lte: String
  asset_in: [String!]
  asset_not_in: [String!]
  asset_contains: String
  asset_contains_nocase: String
  asset_not_contains: String
  asset_not_contains_nocase: String
  asset_starts_with: String
  asset_starts_with_nocase: String
  asset_not_starts_with: String
  asset_not_starts_with_nocase: String
  asset_ends_with: String
  asset_ends_with_nocase: String
  asset_not_ends_with: String
  asset_not_ends_with_nocase: String
  asset_: avalanche_Asset_filter
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  routersFee: BigInt
  routersFee_not: BigInt
  routersFee_gt: BigInt
  routersFee_lt: BigInt
  routersFee_gte: BigInt
  routersFee_lte: BigInt
  routersFee_in: [BigInt!]
  routersFee_not_in: [BigInt!]
  executedCaller: avalanche_Bytes
  executedCaller_not: avalanche_Bytes
  executedCaller_gt: avalanche_Bytes
  executedCaller_lt: avalanche_Bytes
  executedCaller_gte: avalanche_Bytes
  executedCaller_lte: avalanche_Bytes
  executedCaller_in: [avalanche_Bytes!]
  executedCaller_not_in: [avalanche_Bytes!]
  executedCaller_contains: avalanche_Bytes
  executedCaller_not_contains: avalanche_Bytes
  executedTransactionHash: avalanche_Bytes
  executedTransactionHash_not: avalanche_Bytes
  executedTransactionHash_gt: avalanche_Bytes
  executedTransactionHash_lt: avalanche_Bytes
  executedTransactionHash_gte: avalanche_Bytes
  executedTransactionHash_lte: avalanche_Bytes
  executedTransactionHash_in: [avalanche_Bytes!]
  executedTransactionHash_not_in: [avalanche_Bytes!]
  executedTransactionHash_contains: avalanche_Bytes
  executedTransactionHash_not_contains: avalanche_Bytes
  executedTimestamp: BigInt
  executedTimestamp_not: BigInt
  executedTimestamp_gt: BigInt
  executedTimestamp_lt: BigInt
  executedTimestamp_gte: BigInt
  executedTimestamp_lte: BigInt
  executedTimestamp_in: [BigInt!]
  executedTimestamp_not_in: [BigInt!]
  executedGasPrice: BigInt
  executedGasPrice_not: BigInt
  executedGasPrice_gt: BigInt
  executedGasPrice_lt: BigInt
  executedGasPrice_gte: BigInt
  executedGasPrice_lte: BigInt
  executedGasPrice_in: [BigInt!]
  executedGasPrice_not_in: [BigInt!]
  executedGasLimit: BigInt
  executedGasLimit_not: BigInt
  executedGasLimit_gt: BigInt
  executedGasLimit_lt: BigInt
  executedGasLimit_gte: BigInt
  executedGasLimit_lte: BigInt
  executedGasLimit_in: [BigInt!]
  executedGasLimit_not_in: [BigInt!]
  executedBlockNumber: BigInt
  executedBlockNumber_not: BigInt
  executedBlockNumber_gt: BigInt
  executedBlockNumber_lt: BigInt
  executedBlockNumber_gte: BigInt
  executedBlockNumber_lte: BigInt
  executedBlockNumber_in: [BigInt!]
  executedBlockNumber_not_in: [BigInt!]
  executedTxOrigin: avalanche_Bytes
  executedTxOrigin_not: avalanche_Bytes
  executedTxOrigin_gt: avalanche_Bytes
  executedTxOrigin_lt: avalanche_Bytes
  executedTxOrigin_gte: avalanche_Bytes
  executedTxOrigin_lte: avalanche_Bytes
  executedTxOrigin_in: [avalanche_Bytes!]
  executedTxOrigin_not_in: [avalanche_Bytes!]
  executedTxOrigin_contains: avalanche_Bytes
  executedTxOrigin_not_contains: avalanche_Bytes
  executedTxNonce: BigInt
  executedTxNonce_not: BigInt
  executedTxNonce_gt: BigInt
  executedTxNonce_lt: BigInt
  executedTxNonce_gte: BigInt
  executedTxNonce_lte: BigInt
  executedTxNonce_in: [BigInt!]
  executedTxNonce_not_in: [BigInt!]
  reconciledCaller: avalanche_Bytes
  reconciledCaller_not: avalanche_Bytes
  reconciledCaller_gt: avalanche_Bytes
  reconciledCaller_lt: avalanche_Bytes
  reconciledCaller_gte: avalanche_Bytes
  reconciledCaller_lte: avalanche_Bytes
  reconciledCaller_in: [avalanche_Bytes!]
  reconciledCaller_not_in: [avalanche_Bytes!]
  reconciledCaller_contains: avalanche_Bytes
  reconciledCaller_not_contains: avalanche_Bytes
  reconciledTransactionHash: avalanche_Bytes
  reconciledTransactionHash_not: avalanche_Bytes
  reconciledTransactionHash_gt: avalanche_Bytes
  reconciledTransactionHash_lt: avalanche_Bytes
  reconciledTransactionHash_gte: avalanche_Bytes
  reconciledTransactionHash_lte: avalanche_Bytes
  reconciledTransactionHash_in: [avalanche_Bytes!]
  reconciledTransactionHash_not_in: [avalanche_Bytes!]
  reconciledTransactionHash_contains: avalanche_Bytes
  reconciledTransactionHash_not_contains: avalanche_Bytes
  reconciledTimestamp: BigInt
  reconciledTimestamp_not: BigInt
  reconciledTimestamp_gt: BigInt
  reconciledTimestamp_lt: BigInt
  reconciledTimestamp_gte: BigInt
  reconciledTimestamp_lte: BigInt
  reconciledTimestamp_in: [BigInt!]
  reconciledTimestamp_not_in: [BigInt!]
  reconciledGasPrice: BigInt
  reconciledGasPrice_not: BigInt
  reconciledGasPrice_gt: BigInt
  reconciledGasPrice_lt: BigInt
  reconciledGasPrice_gte: BigInt
  reconciledGasPrice_lte: BigInt
  reconciledGasPrice_in: [BigInt!]
  reconciledGasPrice_not_in: [BigInt!]
  reconciledGasLimit: BigInt
  reconciledGasLimit_not: BigInt
  reconciledGasLimit_gt: BigInt
  reconciledGasLimit_lt: BigInt
  reconciledGasLimit_gte: BigInt
  reconciledGasLimit_lte: BigInt
  reconciledGasLimit_in: [BigInt!]
  reconciledGasLimit_not_in: [BigInt!]
  reconciledBlockNumber: BigInt
  reconciledBlockNumber_not: BigInt
  reconciledBlockNumber_gt: BigInt
  reconciledBlockNumber_lt: BigInt
  reconciledBlockNumber_gte: BigInt
  reconciledBlockNumber_lte: BigInt
  reconciledBlockNumber_in: [BigInt!]
  reconciledBlockNumber_not_in: [BigInt!]
  reconciledTxOrigin: avalanche_Bytes
  reconciledTxOrigin_not: avalanche_Bytes
  reconciledTxOrigin_gt: avalanche_Bytes
  reconciledTxOrigin_lt: avalanche_Bytes
  reconciledTxOrigin_gte: avalanche_Bytes
  reconciledTxOrigin_lte: avalanche_Bytes
  reconciledTxOrigin_in: [avalanche_Bytes!]
  reconciledTxOrigin_not_in: [avalanche_Bytes!]
  reconciledTxOrigin_contains: avalanche_Bytes
  reconciledTxOrigin_not_contains: avalanche_Bytes
  reconciledTxNonce: BigInt
  reconciledTxNonce_not: BigInt
  reconciledTxNonce_gt: BigInt
  reconciledTxNonce_lt: BigInt
  reconciledTxNonce_gte: BigInt
  reconciledTxNonce_lte: BigInt
  reconciledTxNonce_in: [BigInt!]
  reconciledTxNonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: avalanche_BlockChangedFilter
  and: [avalanche_DestinationTransfer_filter]
  or: [avalanche_DestinationTransfer_filter]
}

enum avalanche_DestinationTransfer_orderBy {
  id
  chainId
  transferId
  nonce
  status
  routers
  originDomain
  destinationDomain
  canonicalDomain
  to
  delegate
  receiveLocal
  callData
  slippage
  bumpSlippageCount
  originSender
  bridgedAmt
  normalizedIn
  canonicalId
  asset
  asset__id
  asset__key
  asset__decimal
  asset__adoptedDecimal
  asset__canonicalId
  asset__canonicalDomain
  asset__adoptedAsset
  asset__localAsset
  asset__blockNumber
  amount
  routersFee
  executedCaller
  executedTransactionHash
  executedTimestamp
  executedGasPrice
  executedGasLimit
  executedBlockNumber
  executedTxOrigin
  executedTxNonce
  reconciledCaller
  reconciledTransactionHash
  reconciledTimestamp
  reconciledGasPrice
  reconciledGasLimit
  reconciledBlockNumber
  reconciledTxOrigin
  reconciledTxNonce
}

"""
8 bytes signed integer

"""
scalar avalanche_Int8

type avalanche_OptimisticRootFinalized {
  id: ID!
  aggregateRoot: avalanche_Bytes!
  timestamp: BigInt!
  blockNumber: BigInt
}

input avalanche_OptimisticRootFinalized_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  aggregateRoot: avalanche_Bytes
  aggregateRoot_not: avalanche_Bytes
  aggregateRoot_gt: avalanche_Bytes
  aggregateRoot_lt: avalanche_Bytes
  aggregateRoot_gte: avalanche_Bytes
  aggregateRoot_lte: avalanche_Bytes
  aggregateRoot_in: [avalanche_Bytes!]
  aggregateRoot_not_in: [avalanche_Bytes!]
  aggregateRoot_contains: avalanche_Bytes
  aggregateRoot_not_contains: avalanche_Bytes
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: avalanche_BlockChangedFilter
  and: [avalanche_OptimisticRootFinalized_filter]
  or: [avalanche_OptimisticRootFinalized_filter]
}

enum avalanche_OptimisticRootFinalized_orderBy {
  id
  aggregateRoot
  timestamp
  blockNumber
}

"""Defines the order direction, either ascending or descending"""
enum avalanche_OrderDirection {
  asc
  desc
}

type avalanche_OriginMessage {
  id: ID!
  transferId: avalanche_Bytes
  destinationDomain: BigInt
  leaf: avalanche_Bytes
  index: BigInt
  message: avalanche_Bytes
  root: avalanche_Bytes
  transactionHash: avalanche_Bytes
  blockNumber: BigInt
  rootCount: avalanche_RootCount
}

input avalanche_OriginMessage_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transferId: avalanche_Bytes
  transferId_not: avalanche_Bytes
  transferId_gt: avalanche_Bytes
  transferId_lt: avalanche_Bytes
  transferId_gte: avalanche_Bytes
  transferId_lte: avalanche_Bytes
  transferId_in: [avalanche_Bytes!]
  transferId_not_in: [avalanche_Bytes!]
  transferId_contains: avalanche_Bytes
  transferId_not_contains: avalanche_Bytes
  destinationDomain: BigInt
  destinationDomain_not: BigInt
  destinationDomain_gt: BigInt
  destinationDomain_lt: BigInt
  destinationDomain_gte: BigInt
  destinationDomain_lte: BigInt
  destinationDomain_in: [BigInt!]
  destinationDomain_not_in: [BigInt!]
  leaf: avalanche_Bytes
  leaf_not: avalanche_Bytes
  leaf_gt: avalanche_Bytes
  leaf_lt: avalanche_Bytes
  leaf_gte: avalanche_Bytes
  leaf_lte: avalanche_Bytes
  leaf_in: [avalanche_Bytes!]
  leaf_not_in: [avalanche_Bytes!]
  leaf_contains: avalanche_Bytes
  leaf_not_contains: avalanche_Bytes
  index: BigInt
  index_not: BigInt
  index_gt: BigInt
  index_lt: BigInt
  index_gte: BigInt
  index_lte: BigInt
  index_in: [BigInt!]
  index_not_in: [BigInt!]
  message: avalanche_Bytes
  message_not: avalanche_Bytes
  message_gt: avalanche_Bytes
  message_lt: avalanche_Bytes
  message_gte: avalanche_Bytes
  message_lte: avalanche_Bytes
  message_in: [avalanche_Bytes!]
  message_not_in: [avalanche_Bytes!]
  message_contains: avalanche_Bytes
  message_not_contains: avalanche_Bytes
  root: avalanche_Bytes
  root_not: avalanche_Bytes
  root_gt: avalanche_Bytes
  root_lt: avalanche_Bytes
  root_gte: avalanche_Bytes
  root_lte: avalanche_Bytes
  root_in: [avalanche_Bytes!]
  root_not_in: [avalanche_Bytes!]
  root_contains: avalanche_Bytes
  root_not_contains: avalanche_Bytes
  transactionHash: avalanche_Bytes
  transactionHash_not: avalanche_Bytes
  transactionHash_gt: avalanche_Bytes
  transactionHash_lt: avalanche_Bytes
  transactionHash_gte: avalanche_Bytes
  transactionHash_lte: avalanche_Bytes
  transactionHash_in: [avalanche_Bytes!]
  transactionHash_not_in: [avalanche_Bytes!]
  transactionHash_contains: avalanche_Bytes
  transactionHash_not_contains: avalanche_Bytes
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  rootCount: String
  rootCount_not: String
  rootCount_gt: String
  rootCount_lt: String
  rootCount_gte: String
  rootCount_lte: String
  rootCount_in: [String!]
  rootCount_not_in: [String!]
  rootCount_contains: String
  rootCount_contains_nocase: String
  rootCount_not_contains: String
  rootCount_not_contains_nocase: String
  rootCount_starts_with: String
  rootCount_starts_with_nocase: String
  rootCount_not_starts_with: String
  rootCount_not_starts_with_nocase: String
  rootCount_ends_with: String
  rootCount_ends_with_nocase: String
  rootCount_not_ends_with: String
  rootCount_not_ends_with_nocase: String
  rootCount_: avalanche_RootCount_filter
  """Filter for the block changed event."""
  _change_block: avalanche_BlockChangedFilter
  and: [avalanche_OriginMessage_filter]
  or: [avalanche_OriginMessage_filter]
}

enum avalanche_OriginMessage_orderBy {
  id
  transferId
  destinationDomain
  leaf
  index
  message
  root
  transactionHash
  blockNumber
  rootCount
  rootCount__id
  rootCount__count
}

type avalanche_OriginTransfer {
  id: ID!
  chainId: BigInt
  transferId: avalanche_Bytes
  nonce: BigInt
  status: avalanche_TransferStatus
  messageHash: avalanche_Bytes
  originDomain: BigInt
  destinationDomain: BigInt
  canonicalDomain: BigInt
  to: avalanche_Bytes
  delegate: avalanche_Bytes
  receiveLocal: Boolean
  callData: avalanche_Bytes
  slippage: BigInt
  originSender: avalanche_Bytes
  bridgedAmt: BigInt
  normalizedIn: BigInt
  canonicalId: avalanche_Bytes
  asset: avalanche_Asset
  transactingAsset: avalanche_Bytes
  message: avalanche_OriginMessage
  bumpRelayerFeeCount: BigInt
  relayerFees(skip: Int = 0, first: Int = 100, orderBy: avalanche_RelayerFee_orderBy, orderDirection: avalanche_OrderDirection, where: avalanche_RelayerFee_filter): [avalanche_RelayerFee!]
  initialRelayerFeeAsset: avalanche_Bytes
  caller: avalanche_Bytes
  transactionHash: avalanche_Bytes
  timestamp: BigInt
  gasPrice: BigInt
  gasLimit: BigInt
  blockNumber: BigInt
  txOrigin: avalanche_Bytes
  txNonce: BigInt
}

input avalanche_OriginTransfer_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  chainId: BigInt
  chainId_not: BigInt
  chainId_gt: BigInt
  chainId_lt: BigInt
  chainId_gte: BigInt
  chainId_lte: BigInt
  chainId_in: [BigInt!]
  chainId_not_in: [BigInt!]
  transferId: avalanche_Bytes
  transferId_not: avalanche_Bytes
  transferId_gt: avalanche_Bytes
  transferId_lt: avalanche_Bytes
  transferId_gte: avalanche_Bytes
  transferId_lte: avalanche_Bytes
  transferId_in: [avalanche_Bytes!]
  transferId_not_in: [avalanche_Bytes!]
  transferId_contains: avalanche_Bytes
  transferId_not_contains: avalanche_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  status: avalanche_TransferStatus
  status_not: avalanche_TransferStatus
  status_in: [avalanche_TransferStatus!]
  status_not_in: [avalanche_TransferStatus!]
  messageHash: avalanche_Bytes
  messageHash_not: avalanche_Bytes
  messageHash_gt: avalanche_Bytes
  messageHash_lt: avalanche_Bytes
  messageHash_gte: avalanche_Bytes
  messageHash_lte: avalanche_Bytes
  messageHash_in: [avalanche_Bytes!]
  messageHash_not_in: [avalanche_Bytes!]
  messageHash_contains: avalanche_Bytes
  messageHash_not_contains: avalanche_Bytes
  originDomain: BigInt
  originDomain_not: BigInt
  originDomain_gt: BigInt
  originDomain_lt: BigInt
  originDomain_gte: BigInt
  originDomain_lte: BigInt
  originDomain_in: [BigInt!]
  originDomain_not_in: [BigInt!]
  destinationDomain: BigInt
  destinationDomain_not: BigInt
  destinationDomain_gt: BigInt
  destinationDomain_lt: BigInt
  destinationDomain_gte: BigInt
  destinationDomain_lte: BigInt
  destinationDomain_in: [BigInt!]
  destinationDomain_not_in: [BigInt!]
  canonicalDomain: BigInt
  canonicalDomain_not: BigInt
  canonicalDomain_gt: BigInt
  canonicalDomain_lt: BigInt
  canonicalDomain_gte: BigInt
  canonicalDomain_lte: BigInt
  canonicalDomain_in: [BigInt!]
  canonicalDomain_not_in: [BigInt!]
  to: avalanche_Bytes
  to_not: avalanche_Bytes
  to_gt: avalanche_Bytes
  to_lt: avalanche_Bytes
  to_gte: avalanche_Bytes
  to_lte: avalanche_Bytes
  to_in: [avalanche_Bytes!]
  to_not_in: [avalanche_Bytes!]
  to_contains: avalanche_Bytes
  to_not_contains: avalanche_Bytes
  delegate: avalanche_Bytes
  delegate_not: avalanche_Bytes
  delegate_gt: avalanche_Bytes
  delegate_lt: avalanche_Bytes
  delegate_gte: avalanche_Bytes
  delegate_lte: avalanche_Bytes
  delegate_in: [avalanche_Bytes!]
  delegate_not_in: [avalanche_Bytes!]
  delegate_contains: avalanche_Bytes
  delegate_not_contains: avalanche_Bytes
  receiveLocal: Boolean
  receiveLocal_not: Boolean
  receiveLocal_in: [Boolean!]
  receiveLocal_not_in: [Boolean!]
  callData: avalanche_Bytes
  callData_not: avalanche_Bytes
  callData_gt: avalanche_Bytes
  callData_lt: avalanche_Bytes
  callData_gte: avalanche_Bytes
  callData_lte: avalanche_Bytes
  callData_in: [avalanche_Bytes!]
  callData_not_in: [avalanche_Bytes!]
  callData_contains: avalanche_Bytes
  callData_not_contains: avalanche_Bytes
  slippage: BigInt
  slippage_not: BigInt
  slippage_gt: BigInt
  slippage_lt: BigInt
  slippage_gte: BigInt
  slippage_lte: BigInt
  slippage_in: [BigInt!]
  slippage_not_in: [BigInt!]
  originSender: avalanche_Bytes
  originSender_not: avalanche_Bytes
  originSender_gt: avalanche_Bytes
  originSender_lt: avalanche_Bytes
  originSender_gte: avalanche_Bytes
  originSender_lte: avalanche_Bytes
  originSender_in: [avalanche_Bytes!]
  originSender_not_in: [avalanche_Bytes!]
  originSender_contains: avalanche_Bytes
  originSender_not_contains: avalanche_Bytes
  bridgedAmt: BigInt
  bridgedAmt_not: BigInt
  bridgedAmt_gt: BigInt
  bridgedAmt_lt: BigInt
  bridgedAmt_gte: BigInt
  bridgedAmt_lte: BigInt
  bridgedAmt_in: [BigInt!]
  bridgedAmt_not_in: [BigInt!]
  normalizedIn: BigInt
  normalizedIn_not: BigInt
  normalizedIn_gt: BigInt
  normalizedIn_lt: BigInt
  normalizedIn_gte: BigInt
  normalizedIn_lte: BigInt
  normalizedIn_in: [BigInt!]
  normalizedIn_not_in: [BigInt!]
  canonicalId: avalanche_Bytes
  canonicalId_not: avalanche_Bytes
  canonicalId_gt: avalanche_Bytes
  canonicalId_lt: avalanche_Bytes
  canonicalId_gte: avalanche_Bytes
  canonicalId_lte: avalanche_Bytes
  canonicalId_in: [avalanche_Bytes!]
  canonicalId_not_in: [avalanche_Bytes!]
  canonicalId_contains: avalanche_Bytes
  canonicalId_not_contains: avalanche_Bytes
  asset: String
  asset_not: String
  asset_gt: String
  asset_lt: String
  asset_gte: String
  asset_lte: String
  asset_in: [String!]
  asset_not_in: [String!]
  asset_contains: String
  asset_contains_nocase: String
  asset_not_contains: String
  asset_not_contains_nocase: String
  asset_starts_with: String
  asset_starts_with_nocase: String
  asset_not_starts_with: String
  asset_not_starts_with_nocase: String
  asset_ends_with: String
  asset_ends_with_nocase: String
  asset_not_ends_with: String
  asset_not_ends_with_nocase: String
  asset_: avalanche_Asset_filter
  transactingAsset: avalanche_Bytes
  transactingAsset_not: avalanche_Bytes
  transactingAsset_gt: avalanche_Bytes
  transactingAsset_lt: avalanche_Bytes
  transactingAsset_gte: avalanche_Bytes
  transactingAsset_lte: avalanche_Bytes
  transactingAsset_in: [avalanche_Bytes!]
  transactingAsset_not_in: [avalanche_Bytes!]
  transactingAsset_contains: avalanche_Bytes
  transactingAsset_not_contains: avalanche_Bytes
  message: String
  message_not: String
  message_gt: String
  message_lt: String
  message_gte: String
  message_lte: String
  message_in: [String!]
  message_not_in: [String!]
  message_contains: String
  message_contains_nocase: String
  message_not_contains: String
  message_not_contains_nocase: String
  message_starts_with: String
  message_starts_with_nocase: String
  message_not_starts_with: String
  message_not_starts_with_nocase: String
  message_ends_with: String
  message_ends_with_nocase: String
  message_not_ends_with: String
  message_not_ends_with_nocase: String
  message_: avalanche_OriginMessage_filter
  bumpRelayerFeeCount: BigInt
  bumpRelayerFeeCount_not: BigInt
  bumpRelayerFeeCount_gt: BigInt
  bumpRelayerFeeCount_lt: BigInt
  bumpRelayerFeeCount_gte: BigInt
  bumpRelayerFeeCount_lte: BigInt
  bumpRelayerFeeCount_in: [BigInt!]
  bumpRelayerFeeCount_not_in: [BigInt!]
  relayerFees: [String!]
  relayerFees_not: [String!]
  relayerFees_contains: [String!]
  relayerFees_contains_nocase: [String!]
  relayerFees_not_contains: [String!]
  relayerFees_not_contains_nocase: [String!]
  relayerFees_: avalanche_RelayerFee_filter
  initialRelayerFeeAsset: avalanche_Bytes
  initialRelayerFeeAsset_not: avalanche_Bytes
  initialRelayerFeeAsset_gt: avalanche_Bytes
  initialRelayerFeeAsset_lt: avalanche_Bytes
  initialRelayerFeeAsset_gte: avalanche_Bytes
  initialRelayerFeeAsset_lte: avalanche_Bytes
  initialRelayerFeeAsset_in: [avalanche_Bytes!]
  initialRelayerFeeAsset_not_in: [avalanche_Bytes!]
  initialRelayerFeeAsset_contains: avalanche_Bytes
  initialRelayerFeeAsset_not_contains: avalanche_Bytes
  caller: avalanche_Bytes
  caller_not: avalanche_Bytes
  caller_gt: avalanche_Bytes
  caller_lt: avalanche_Bytes
  caller_gte: avalanche_Bytes
  caller_lte: avalanche_Bytes
  caller_in: [avalanche_Bytes!]
  caller_not_in: [avalanche_Bytes!]
  caller_contains: avalanche_Bytes
  caller_not_contains: avalanche_Bytes
  transactionHash: avalanche_Bytes
  transactionHash_not: avalanche_Bytes
  transactionHash_gt: avalanche_Bytes
  transactionHash_lt: avalanche_Bytes
  transactionHash_gte: avalanche_Bytes
  transactionHash_lte: avalanche_Bytes
  transactionHash_in: [avalanche_Bytes!]
  transactionHash_not_in: [avalanche_Bytes!]
  transactionHash_contains: avalanche_Bytes
  transactionHash_not_contains: avalanche_Bytes
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  gasLimit: BigInt
  gasLimit_not: BigInt
  gasLimit_gt: BigInt
  gasLimit_lt: BigInt
  gasLimit_gte: BigInt
  gasLimit_lte: BigInt
  gasLimit_in: [BigInt!]
  gasLimit_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  txOrigin: avalanche_Bytes
  txOrigin_not: avalanche_Bytes
  txOrigin_gt: avalanche_Bytes
  txOrigin_lt: avalanche_Bytes
  txOrigin_gte: avalanche_Bytes
  txOrigin_lte: avalanche_Bytes
  txOrigin_in: [avalanche_Bytes!]
  txOrigin_not_in: [avalanche_Bytes!]
  txOrigin_contains: avalanche_Bytes
  txOrigin_not_contains: avalanche_Bytes
  txNonce: BigInt
  txNonce_not: BigInt
  txNonce_gt: BigInt
  txNonce_lt: BigInt
  txNonce_gte: BigInt
  txNonce_lte: BigInt
  txNonce_in: [BigInt!]
  txNonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: avalanche_BlockChangedFilter
  and: [avalanche_OriginTransfer_filter]
  or: [avalanche_OriginTransfer_filter]
}

enum avalanche_OriginTransfer_orderBy {
  id
  chainId
  transferId
  nonce
  status
  messageHash
  originDomain
  destinationDomain
  canonicalDomain
  to
  delegate
  receiveLocal
  callData
  slippage
  originSender
  bridgedAmt
  normalizedIn
  canonicalId
  asset
  asset__id
  asset__key
  asset__decimal
  asset__adoptedDecimal
  asset__canonicalId
  asset__canonicalDomain
  asset__adoptedAsset
  asset__localAsset
  asset__blockNumber
  transactingAsset
  message
  message__id
  message__transferId
  message__destinationDomain
  message__leaf
  message__index
  message__message
  message__root
  message__transactionHash
  message__blockNumber
  bumpRelayerFeeCount
  relayerFees
  initialRelayerFeeAsset
  caller
  transactionHash
  timestamp
  gasPrice
  gasLimit
  blockNumber
  txOrigin
  txNonce
}

type avalanche_Relayer {
  id: ID!
  isActive: Boolean!
  relayer: avalanche_Bytes
}

type avalanche_RelayerFee {
  id: ID!
  transfer: avalanche_OriginTransfer!
  fee: BigInt!
  asset: avalanche_Bytes!
}

input avalanche_RelayerFee_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transfer: String
  transfer_not: String
  transfer_gt: String
  transfer_lt: String
  transfer_gte: String
  transfer_lte: String
  transfer_in: [String!]
  transfer_not_in: [String!]
  transfer_contains: String
  transfer_contains_nocase: String
  transfer_not_contains: String
  transfer_not_contains_nocase: String
  transfer_starts_with: String
  transfer_starts_with_nocase: String
  transfer_not_starts_with: String
  transfer_not_starts_with_nocase: String
  transfer_ends_with: String
  transfer_ends_with_nocase: String
  transfer_not_ends_with: String
  transfer_not_ends_with_nocase: String
  transfer_: avalanche_OriginTransfer_filter
  fee: BigInt
  fee_not: BigInt
  fee_gt: BigInt
  fee_lt: BigInt
  fee_gte: BigInt
  fee_lte: BigInt
  fee_in: [BigInt!]
  fee_not_in: [BigInt!]
  asset: avalanche_Bytes
  asset_not: avalanche_Bytes
  asset_gt: avalanche_Bytes
  asset_lt: avalanche_Bytes
  asset_gte: avalanche_Bytes
  asset_lte: avalanche_Bytes
  asset_in: [avalanche_Bytes!]
  asset_not_in: [avalanche_Bytes!]
  asset_contains: avalanche_Bytes
  asset_not_contains: avalanche_Bytes
  """Filter for the block changed event."""
  _change_block: avalanche_BlockChangedFilter
  and: [avalanche_RelayerFee_filter]
  or: [avalanche_RelayerFee_filter]
}

enum avalanche_RelayerFee_orderBy {
  id
  transfer
  transfer__id
  transfer__chainId
  transfer__transferId
  transfer__nonce
  transfer__status
  transfer__messageHash
  transfer__originDomain
  transfer__destinationDomain
  transfer__canonicalDomain
  transfer__to
  transfer__delegate
  transfer__receiveLocal
  transfer__callData
  transfer__slippage
  transfer__originSender
  transfer__bridgedAmt
  transfer__normalizedIn
  transfer__canonicalId
  transfer__transactingAsset
  transfer__bumpRelayerFeeCount
  transfer__initialRelayerFeeAsset
  transfer__caller
  transfer__transactionHash
  transfer__timestamp
  transfer__gasPrice
  transfer__gasLimit
  transfer__blockNumber
  transfer__txOrigin
  transfer__txNonce
  fee
  asset
}

type avalanche_RelayerFeesIncrease {
  id: ID!
  transfer: avalanche_OriginTransfer!
  increase: BigInt
  asset: avalanche_Bytes
  caller: avalanche_Bytes!
  transactionHash: avalanche_Bytes!
  timestamp: BigInt!
  gasPrice: BigInt!
  gasLimit: BigInt!
  blockNumber: BigInt!
}

input avalanche_RelayerFeesIncrease_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transfer: String
  transfer_not: String
  transfer_gt: String
  transfer_lt: String
  transfer_gte: String
  transfer_lte: String
  transfer_in: [String!]
  transfer_not_in: [String!]
  transfer_contains: String
  transfer_contains_nocase: String
  transfer_not_contains: String
  transfer_not_contains_nocase: String
  transfer_starts_with: String
  transfer_starts_with_nocase: String
  transfer_not_starts_with: String
  transfer_not_starts_with_nocase: String
  transfer_ends_with: String
  transfer_ends_with_nocase: String
  transfer_not_ends_with: String
  transfer_not_ends_with_nocase: String
  transfer_: avalanche_OriginTransfer_filter
  increase: BigInt
  increase_not: BigInt
  increase_gt: BigInt
  increase_lt: BigInt
  increase_gte: BigInt
  increase_lte: BigInt
  increase_in: [BigInt!]
  increase_not_in: [BigInt!]
  asset: avalanche_Bytes
  asset_not: avalanche_Bytes
  asset_gt: avalanche_Bytes
  asset_lt: avalanche_Bytes
  asset_gte: avalanche_Bytes
  asset_lte: avalanche_Bytes
  asset_in: [avalanche_Bytes!]
  asset_not_in: [avalanche_Bytes!]
  asset_contains: avalanche_Bytes
  asset_not_contains: avalanche_Bytes
  caller: avalanche_Bytes
  caller_not: avalanche_Bytes
  caller_gt: avalanche_Bytes
  caller_lt: avalanche_Bytes
  caller_gte: avalanche_Bytes
  caller_lte: avalanche_Bytes
  caller_in: [avalanche_Bytes!]
  caller_not_in: [avalanche_Bytes!]
  caller_contains: avalanche_Bytes
  caller_not_contains: avalanche_Bytes
  transactionHash: avalanche_Bytes
  transactionHash_not: avalanche_Bytes
  transactionHash_gt: avalanche_Bytes
  transactionHash_lt: avalanche_Bytes
  transactionHash_gte: avalanche_Bytes
  transactionHash_lte: avalanche_Bytes
  transactionHash_in: [avalanche_Bytes!]
  transactionHash_not_in: [avalanche_Bytes!]
  transactionHash_contains: avalanche_Bytes
  transactionHash_not_contains: avalanche_Bytes
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  gasLimit: BigInt
  gasLimit_not: BigInt
  gasLimit_gt: BigInt
  gasLimit_lt: BigInt
  gasLimit_gte: BigInt
  gasLimit_lte: BigInt
  gasLimit_in: [BigInt!]
  gasLimit_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: avalanche_BlockChangedFilter
  and: [avalanche_RelayerFeesIncrease_filter]
  or: [avalanche_RelayerFeesIncrease_filter]
}

enum avalanche_RelayerFeesIncrease_orderBy {
  id
  transfer
  transfer__id
  transfer__chainId
  transfer__transferId
  transfer__nonce
  transfer__status
  transfer__messageHash
  transfer__originDomain
  transfer__destinationDomain
  transfer__canonicalDomain
  transfer__to
  transfer__delegate
  transfer__receiveLocal
  transfer__callData
  transfer__slippage
  transfer__originSender
  transfer__bridgedAmt
  transfer__normalizedIn
  transfer__canonicalId
  transfer__transactingAsset
  transfer__bumpRelayerFeeCount
  transfer__initialRelayerFeeAsset
  transfer__caller
  transfer__transactionHash
  transfer__timestamp
  transfer__gasPrice
  transfer__gasLimit
  transfer__blockNumber
  transfer__txOrigin
  transfer__txNonce
  increase
  asset
  caller
  transactionHash
  timestamp
  gasPrice
  gasLimit
  blockNumber
}

input avalanche_Relayer_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  isActive: Boolean
  isActive_not: Boolean
  isActive_in: [Boolean!]
  isActive_not_in: [Boolean!]
  relayer: avalanche_Bytes
  relayer_not: avalanche_Bytes
  relayer_gt: avalanche_Bytes
  relayer_lt: avalanche_Bytes
  relayer_gte: avalanche_Bytes
  relayer_lte: avalanche_Bytes
  relayer_in: [avalanche_Bytes!]
  relayer_not_in: [avalanche_Bytes!]
  relayer_contains: avalanche_Bytes
  relayer_not_contains: avalanche_Bytes
  """Filter for the block changed event."""
  _change_block: avalanche_BlockChangedFilter
  and: [avalanche_Relayer_filter]
  or: [avalanche_Relayer_filter]
}

enum avalanche_Relayer_orderBy {
  id
  isActive
  relayer
}

type avalanche_RootCount {
  id: ID!
  count: BigInt
}

input avalanche_RootCount_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  count: BigInt
  count_not: BigInt
  count_gt: BigInt
  count_lt: BigInt
  count_gte: BigInt
  count_lte: BigInt
  count_in: [BigInt!]
  count_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: avalanche_BlockChangedFilter
  and: [avalanche_RootCount_filter]
  or: [avalanche_RootCount_filter]
}

enum avalanche_RootCount_orderBy {
  id
  count
}

type avalanche_RootMessageSent {
  id: ID!
  spokeDomain: BigInt
  hubDomain: BigInt
  root: avalanche_Bytes
  count: BigInt
  caller: avalanche_Bytes
  transactionHash: avalanche_Bytes
  timestamp: BigInt
  gasPrice: BigInt
  gasLimit: BigInt
  blockNumber: BigInt
}

input avalanche_RootMessageSent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  spokeDomain: BigInt
  spokeDomain_not: BigInt
  spokeDomain_gt: BigInt
  spokeDomain_lt: BigInt
  spokeDomain_gte: BigInt
  spokeDomain_lte: BigInt
  spokeDomain_in: [BigInt!]
  spokeDomain_not_in: [BigInt!]
  hubDomain: BigInt
  hubDomain_not: BigInt
  hubDomain_gt: BigInt
  hubDomain_lt: BigInt
  hubDomain_gte: BigInt
  hubDomain_lte: BigInt
  hubDomain_in: [BigInt!]
  hubDomain_not_in: [BigInt!]
  root: avalanche_Bytes
  root_not: avalanche_Bytes
  root_gt: avalanche_Bytes
  root_lt: avalanche_Bytes
  root_gte: avalanche_Bytes
  root_lte: avalanche_Bytes
  root_in: [avalanche_Bytes!]
  root_not_in: [avalanche_Bytes!]
  root_contains: avalanche_Bytes
  root_not_contains: avalanche_Bytes
  count: BigInt
  count_not: BigInt
  count_gt: BigInt
  count_lt: BigInt
  count_gte: BigInt
  count_lte: BigInt
  count_in: [BigInt!]
  count_not_in: [BigInt!]
  caller: avalanche_Bytes
  caller_not: avalanche_Bytes
  caller_gt: avalanche_Bytes
  caller_lt: avalanche_Bytes
  caller_gte: avalanche_Bytes
  caller_lte: avalanche_Bytes
  caller_in: [avalanche_Bytes!]
  caller_not_in: [avalanche_Bytes!]
  caller_contains: avalanche_Bytes
  caller_not_contains: avalanche_Bytes
  transactionHash: avalanche_Bytes
  transactionHash_not: avalanche_Bytes
  transactionHash_gt: avalanche_Bytes
  transactionHash_lt: avalanche_Bytes
  transactionHash_gte: avalanche_Bytes
  transactionHash_lte: avalanche_Bytes
  transactionHash_in: [avalanche_Bytes!]
  transactionHash_not_in: [avalanche_Bytes!]
  transactionHash_contains: avalanche_Bytes
  transactionHash_not_contains: avalanche_Bytes
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  gasLimit: BigInt
  gasLimit_not: BigInt
  gasLimit_gt: BigInt
  gasLimit_lt: BigInt
  gasLimit_gte: BigInt
  gasLimit_lte: BigInt
  gasLimit_in: [BigInt!]
  gasLimit_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: avalanche_BlockChangedFilter
  and: [avalanche_RootMessageSent_filter]
  or: [avalanche_RootMessageSent_filter]
}

enum avalanche_RootMessageSent_orderBy {
  id
  spokeDomain
  hubDomain
  root
  count
  caller
  transactionHash
  timestamp
  gasPrice
  gasLimit
  blockNumber
}

type avalanche_Router {
  id: ID!
  isActive: Boolean!
  owner: avalanche_Bytes
  recipient: avalanche_Bytes
  proposedOwner: avalanche_Bytes
  proposedTimestamp: BigInt
  assetBalances(skip: Int = 0, first: Int = 100, orderBy: avalanche_AssetBalance_orderBy, orderDirection: avalanche_OrderDirection, where: avalanche_AssetBalance_filter): [avalanche_AssetBalance!]!
}

type avalanche_RouterDailyTVL {
  id: ID!
  router: avalanche_Router!
  asset: avalanche_Asset!
  timestamp: BigInt!
  balance: BigInt!
}

input avalanche_RouterDailyTVL_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  router: String
  router_not: String
  router_gt: String
  router_lt: String
  router_gte: String
  router_lte: String
  router_in: [String!]
  router_not_in: [String!]
  router_contains: String
  router_contains_nocase: String
  router_not_contains: String
  router_not_contains_nocase: String
  router_starts_with: String
  router_starts_with_nocase: String
  router_not_starts_with: String
  router_not_starts_with_nocase: String
  router_ends_with: String
  router_ends_with_nocase: String
  router_not_ends_with: String
  router_not_ends_with_nocase: String
  router_: avalanche_Router_filter
  asset: String
  asset_not: String
  asset_gt: String
  asset_lt: String
  asset_gte: String
  asset_lte: String
  asset_in: [String!]
  asset_not_in: [String!]
  asset_contains: String
  asset_contains_nocase: String
  asset_not_contains: String
  asset_not_contains_nocase: String
  asset_starts_with: String
  asset_starts_with_nocase: String
  asset_not_starts_with: String
  asset_not_starts_with_nocase: String
  asset_ends_with: String
  asset_ends_with_nocase: String
  asset_not_ends_with: String
  asset_not_ends_with_nocase: String
  asset_: avalanche_Asset_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  balance: BigInt
  balance_not: BigInt
  balance_gt: BigInt
  balance_lt: BigInt
  balance_gte: BigInt
  balance_lte: BigInt
  balance_in: [BigInt!]
  balance_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: avalanche_BlockChangedFilter
  and: [avalanche_RouterDailyTVL_filter]
  or: [avalanche_RouterDailyTVL_filter]
}

enum avalanche_RouterDailyTVL_orderBy {
  id
  router
  router__id
  router__isActive
  router__owner
  router__recipient
  router__proposedOwner
  router__proposedTimestamp
  asset
  asset__id
  asset__key
  asset__decimal
  asset__adoptedDecimal
  asset__canonicalId
  asset__canonicalDomain
  asset__adoptedAsset
  asset__localAsset
  asset__blockNumber
  timestamp
  balance
}

type avalanche_RouterLiquidityEvent {
  id: ID!
  type: avalanche_RouterLiquidityEventType
  router: avalanche_Router!
  asset: avalanche_Asset!
  amount: BigInt!
  balance: BigInt!
  caller: avalanche_Bytes
  blockNumber: BigInt!
  timestamp: BigInt!
  transactionHash: avalanche_Bytes!
  nonce: BigInt!
}

enum avalanche_RouterLiquidityEventType {
  Add
  Remove
}

input avalanche_RouterLiquidityEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  type: avalanche_RouterLiquidityEventType
  type_not: avalanche_RouterLiquidityEventType
  type_in: [avalanche_RouterLiquidityEventType!]
  type_not_in: [avalanche_RouterLiquidityEventType!]
  router: String
  router_not: String
  router_gt: String
  router_lt: String
  router_gte: String
  router_lte: String
  router_in: [String!]
  router_not_in: [String!]
  router_contains: String
  router_contains_nocase: String
  router_not_contains: String
  router_not_contains_nocase: String
  router_starts_with: String
  router_starts_with_nocase: String
  router_not_starts_with: String
  router_not_starts_with_nocase: String
  router_ends_with: String
  router_ends_with_nocase: String
  router_not_ends_with: String
  router_not_ends_with_nocase: String
  router_: avalanche_Router_filter
  asset: String
  asset_not: String
  asset_gt: String
  asset_lt: String
  asset_gte: String
  asset_lte: String
  asset_in: [String!]
  asset_not_in: [String!]
  asset_contains: String
  asset_contains_nocase: String
  asset_not_contains: String
  asset_not_contains_nocase: String
  asset_starts_with: String
  asset_starts_with_nocase: String
  asset_not_starts_with: String
  asset_not_starts_with_nocase: String
  asset_ends_with: String
  asset_ends_with_nocase: String
  asset_not_ends_with: String
  asset_not_ends_with_nocase: String
  asset_: avalanche_Asset_filter
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  balance: BigInt
  balance_not: BigInt
  balance_gt: BigInt
  balance_lt: BigInt
  balance_gte: BigInt
  balance_lte: BigInt
  balance_in: [BigInt!]
  balance_not_in: [BigInt!]
  caller: avalanche_Bytes
  caller_not: avalanche_Bytes
  caller_gt: avalanche_Bytes
  caller_lt: avalanche_Bytes
  caller_gte: avalanche_Bytes
  caller_lte: avalanche_Bytes
  caller_in: [avalanche_Bytes!]
  caller_not_in: [avalanche_Bytes!]
  caller_contains: avalanche_Bytes
  caller_not_contains: avalanche_Bytes
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transactionHash: avalanche_Bytes
  transactionHash_not: avalanche_Bytes
  transactionHash_gt: avalanche_Bytes
  transactionHash_lt: avalanche_Bytes
  transactionHash_gte: avalanche_Bytes
  transactionHash_lte: avalanche_Bytes
  transactionHash_in: [avalanche_Bytes!]
  transactionHash_not_in: [avalanche_Bytes!]
  transactionHash_contains: avalanche_Bytes
  transactionHash_not_contains: avalanche_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: avalanche_BlockChangedFilter
  and: [avalanche_RouterLiquidityEvent_filter]
  or: [avalanche_RouterLiquidityEvent_filter]
}

enum avalanche_RouterLiquidityEvent_orderBy {
  id
  type
  router
  router__id
  router__isActive
  router__owner
  router__recipient
  router__proposedOwner
  router__proposedTimestamp
  asset
  asset__id
  asset__key
  asset__decimal
  asset__adoptedDecimal
  asset__canonicalId
  asset__canonicalDomain
  asset__adoptedAsset
  asset__localAsset
  asset__blockNumber
  amount
  balance
  caller
  blockNumber
  timestamp
  transactionHash
  nonce
}

input avalanche_Router_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  isActive: Boolean
  isActive_not: Boolean
  isActive_in: [Boolean!]
  isActive_not_in: [Boolean!]
  owner: avalanche_Bytes
  owner_not: avalanche_Bytes
  owner_gt: avalanche_Bytes
  owner_lt: avalanche_Bytes
  owner_gte: avalanche_Bytes
  owner_lte: avalanche_Bytes
  owner_in: [avalanche_Bytes!]
  owner_not_in: [avalanche_Bytes!]
  owner_contains: avalanche_Bytes
  owner_not_contains: avalanche_Bytes
  recipient: avalanche_Bytes
  recipient_not: avalanche_Bytes
  recipient_gt: avalanche_Bytes
  recipient_lt: avalanche_Bytes
  recipient_gte: avalanche_Bytes
  recipient_lte: avalanche_Bytes
  recipient_in: [avalanche_Bytes!]
  recipient_not_in: [avalanche_Bytes!]
  recipient_contains: avalanche_Bytes
  recipient_not_contains: avalanche_Bytes
  proposedOwner: avalanche_Bytes
  proposedOwner_not: avalanche_Bytes
  proposedOwner_gt: avalanche_Bytes
  proposedOwner_lt: avalanche_Bytes
  proposedOwner_gte: avalanche_Bytes
  proposedOwner_lte: avalanche_Bytes
  proposedOwner_in: [avalanche_Bytes!]
  proposedOwner_not_in: [avalanche_Bytes!]
  proposedOwner_contains: avalanche_Bytes
  proposedOwner_not_contains: avalanche_Bytes
  proposedTimestamp: BigInt
  proposedTimestamp_not: BigInt
  proposedTimestamp_gt: BigInt
  proposedTimestamp_lt: BigInt
  proposedTimestamp_gte: BigInt
  proposedTimestamp_lte: BigInt
  proposedTimestamp_in: [BigInt!]
  proposedTimestamp_not_in: [BigInt!]
  assetBalances_: avalanche_AssetBalance_filter
  """Filter for the block changed event."""
  _change_block: avalanche_BlockChangedFilter
  and: [avalanche_Router_filter]
  or: [avalanche_Router_filter]
}

enum avalanche_Router_orderBy {
  id
  isActive
  owner
  recipient
  proposedOwner
  proposedTimestamp
  assetBalances
}

type avalanche_Sequencer {
  id: ID!
  isActive: Boolean!
  sequencer: avalanche_Bytes
}

input avalanche_Sequencer_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  isActive: Boolean
  isActive_not: Boolean
  isActive_in: [Boolean!]
  isActive_not_in: [Boolean!]
  sequencer: avalanche_Bytes
  sequencer_not: avalanche_Bytes
  sequencer_gt: avalanche_Bytes
  sequencer_lt: avalanche_Bytes
  sequencer_gte: avalanche_Bytes
  sequencer_lte: avalanche_Bytes
  sequencer_in: [avalanche_Bytes!]
  sequencer_not_in: [avalanche_Bytes!]
  sequencer_contains: avalanche_Bytes
  sequencer_not_contains: avalanche_Bytes
  """Filter for the block changed event."""
  _change_block: avalanche_BlockChangedFilter
  and: [avalanche_Sequencer_filter]
  or: [avalanche_Sequencer_filter]
}

enum avalanche_Sequencer_orderBy {
  id
  isActive
  sequencer
}

type avalanche_Setting {
  id: ID!
  maxRoutersPerTransfer: BigInt!
  caller: avalanche_Bytes!
}

input avalanche_Setting_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  maxRoutersPerTransfer: BigInt
  maxRoutersPerTransfer_not: BigInt
  maxRoutersPerTransfer_gt: BigInt
  maxRoutersPerTransfer_lt: BigInt
  maxRoutersPerTransfer_gte: BigInt
  maxRoutersPerTransfer_lte: BigInt
  maxRoutersPerTransfer_in: [BigInt!]
  maxRoutersPerTransfer_not_in: [BigInt!]
  caller: avalanche_Bytes
  caller_not: avalanche_Bytes
  caller_gt: avalanche_Bytes
  caller_lt: avalanche_Bytes
  caller_gte: avalanche_Bytes
  caller_lte: avalanche_Bytes
  caller_in: [avalanche_Bytes!]
  caller_not_in: [avalanche_Bytes!]
  caller_contains: avalanche_Bytes
  caller_not_contains: avalanche_Bytes
  """Filter for the block changed event."""
  _change_block: avalanche_BlockChangedFilter
  and: [avalanche_Setting_filter]
  or: [avalanche_Setting_filter]
}

enum avalanche_Setting_orderBy {
  id
  maxRoutersPerTransfer
  caller
}

type avalanche_SlippageUpdate {
  id: ID!
  transfer: avalanche_DestinationTransfer!
  slippage: BigInt!
  caller: avalanche_Bytes!
  transactionHash: avalanche_Bytes!
  timestamp: BigInt!
  gasPrice: BigInt!
  gasLimit: BigInt!
  blockNumber: BigInt!
}

input avalanche_SlippageUpdate_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transfer: String
  transfer_not: String
  transfer_gt: String
  transfer_lt: String
  transfer_gte: String
  transfer_lte: String
  transfer_in: [String!]
  transfer_not_in: [String!]
  transfer_contains: String
  transfer_contains_nocase: String
  transfer_not_contains: String
  transfer_not_contains_nocase: String
  transfer_starts_with: String
  transfer_starts_with_nocase: String
  transfer_not_starts_with: String
  transfer_not_starts_with_nocase: String
  transfer_ends_with: String
  transfer_ends_with_nocase: String
  transfer_not_ends_with: String
  transfer_not_ends_with_nocase: String
  transfer_: avalanche_DestinationTransfer_filter
  slippage: BigInt
  slippage_not: BigInt
  slippage_gt: BigInt
  slippage_lt: BigInt
  slippage_gte: BigInt
  slippage_lte: BigInt
  slippage_in: [BigInt!]
  slippage_not_in: [BigInt!]
  caller: avalanche_Bytes
  caller_not: avalanche_Bytes
  caller_gt: avalanche_Bytes
  caller_lt: avalanche_Bytes
  caller_gte: avalanche_Bytes
  caller_lte: avalanche_Bytes
  caller_in: [avalanche_Bytes!]
  caller_not_in: [avalanche_Bytes!]
  caller_contains: avalanche_Bytes
  caller_not_contains: avalanche_Bytes
  transactionHash: avalanche_Bytes
  transactionHash_not: avalanche_Bytes
  transactionHash_gt: avalanche_Bytes
  transactionHash_lt: avalanche_Bytes
  transactionHash_gte: avalanche_Bytes
  transactionHash_lte: avalanche_Bytes
  transactionHash_in: [avalanche_Bytes!]
  transactionHash_not_in: [avalanche_Bytes!]
  transactionHash_contains: avalanche_Bytes
  transactionHash_not_contains: avalanche_Bytes
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  gasLimit: BigInt
  gasLimit_not: BigInt
  gasLimit_gt: BigInt
  gasLimit_lt: BigInt
  gasLimit_gte: BigInt
  gasLimit_lte: BigInt
  gasLimit_in: [BigInt!]
  gasLimit_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: avalanche_BlockChangedFilter
  and: [avalanche_SlippageUpdate_filter]
  or: [avalanche_SlippageUpdate_filter]
}

enum avalanche_SlippageUpdate_orderBy {
  id
  transfer
  transfer__id
  transfer__chainId
  transfer__transferId
  transfer__nonce
  transfer__status
  transfer__originDomain
  transfer__destinationDomain
  transfer__canonicalDomain
  transfer__to
  transfer__delegate
  transfer__receiveLocal
  transfer__callData
  transfer__slippage
  transfer__bumpSlippageCount
  transfer__originSender
  transfer__bridgedAmt
  transfer__normalizedIn
  transfer__canonicalId
  transfer__amount
  transfer__routersFee
  transfer__executedCaller
  transfer__executedTransactionHash
  transfer__executedTimestamp
  transfer__executedGasPrice
  transfer__executedGasLimit
  transfer__executedBlockNumber
  transfer__executedTxOrigin
  transfer__executedTxNonce
  transfer__reconciledCaller
  transfer__reconciledTransactionHash
  transfer__reconciledTimestamp
  transfer__reconciledGasPrice
  transfer__reconciledGasLimit
  transfer__reconciledBlockNumber
  transfer__reconciledTxOrigin
  transfer__reconciledTxNonce
  slippage
  caller
  transactionHash
  timestamp
  gasPrice
  gasLimit
  blockNumber
}

type avalanche_SnapshotRoot {
  id: ID!
  spokeDomain: BigInt
  root: avalanche_Bytes!
  count: BigInt!
  timestamp: BigInt!
  blockNumber: BigInt!
}

input avalanche_SnapshotRoot_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  spokeDomain: BigInt
  spokeDomain_not: BigInt
  spokeDomain_gt: BigInt
  spokeDomain_lt: BigInt
  spokeDomain_gte: BigInt
  spokeDomain_lte: BigInt
  spokeDomain_in: [BigInt!]
  spokeDomain_not_in: [BigInt!]
  root: avalanche_Bytes
  root_not: avalanche_Bytes
  root_gt: avalanche_Bytes
  root_lt: avalanche_Bytes
  root_gte: avalanche_Bytes
  root_lte: avalanche_Bytes
  root_in: [avalanche_Bytes!]
  root_not_in: [avalanche_Bytes!]
  root_contains: avalanche_Bytes
  root_not_contains: avalanche_Bytes
  count: BigInt
  count_not: BigInt
  count_gt: BigInt
  count_lt: BigInt
  count_gte: BigInt
  count_lte: BigInt
  count_in: [BigInt!]
  count_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: avalanche_BlockChangedFilter
  and: [avalanche_SnapshotRoot_filter]
  or: [avalanche_SnapshotRoot_filter]
}

enum avalanche_SnapshotRoot_orderBy {
  id
  spokeDomain
  root
  count
  timestamp
  blockNumber
}

type avalanche_SpokeConnectorMode {
  id: ID!
  mode: String!
}

input avalanche_SpokeConnectorMode_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  mode: String
  mode_not: String
  mode_gt: String
  mode_lt: String
  mode_gte: String
  mode_lte: String
  mode_in: [String!]
  mode_not_in: [String!]
  mode_contains: String
  mode_contains_nocase: String
  mode_not_contains: String
  mode_not_contains_nocase: String
  mode_starts_with: String
  mode_starts_with_nocase: String
  mode_not_starts_with: String
  mode_not_starts_with_nocase: String
  mode_ends_with: String
  mode_ends_with_nocase: String
  mode_not_ends_with: String
  mode_not_ends_with_nocase: String
  """Filter for the block changed event."""
  _change_block: avalanche_BlockChangedFilter
  and: [avalanche_SpokeConnectorMode_filter]
  or: [avalanche_SpokeConnectorMode_filter]
}

enum avalanche_SpokeConnectorMode_orderBy {
  id
  mode
}

enum avalanche_TransferStatus {
  XCalled
  Executed
  Reconciled
  CompletedSlow
  CompletedFast
}

type avalanche__Block_ {
  """The hash of the block"""
  hash: avalanche_Bytes
  """The block number"""
  number: Int!
  """Integer representation of the timestamp stored in blocks for the chain"""
  timestamp: Int
  """The hash of the parent block"""
  parentHash: avalanche_Bytes
}

"""The type for the top-level _meta field"""
type avalanche__Meta_ {
  """
  Information about a specific subgraph block. The hash of the block
  will be null if the _meta field has a block constraint that asks for
  a block number. It will be filled if the _meta field has no block constraint
  and therefore asks for the latest  block
  
  """
  block: avalanche__Block_!
  """The deployment ID"""
  deployment: String!
  """If `true`, the subgraph encountered indexing errors at some past block"""
  hasIndexingErrors: Boolean!
}

type mantle_AggregateRoot {
  id: ID!
  root: mantle_Bytes!
  blockNumber: BigInt!
}

type mantle_AggregateRootProposed {
  id: ID!
  aggregateRoot: mantle_Bytes!
  rootTimestamp: BigInt!
  endOfDispute: BigInt!
  domain: BigInt!
  timestamp: BigInt!
  blockNumber: BigInt
}

input mantle_AggregateRootProposed_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  aggregateRoot: mantle_Bytes
  aggregateRoot_not: mantle_Bytes
  aggregateRoot_gt: mantle_Bytes
  aggregateRoot_lt: mantle_Bytes
  aggregateRoot_gte: mantle_Bytes
  aggregateRoot_lte: mantle_Bytes
  aggregateRoot_in: [mantle_Bytes!]
  aggregateRoot_not_in: [mantle_Bytes!]
  aggregateRoot_contains: mantle_Bytes
  aggregateRoot_not_contains: mantle_Bytes
  rootTimestamp: BigInt
  rootTimestamp_not: BigInt
  rootTimestamp_gt: BigInt
  rootTimestamp_lt: BigInt
  rootTimestamp_gte: BigInt
  rootTimestamp_lte: BigInt
  rootTimestamp_in: [BigInt!]
  rootTimestamp_not_in: [BigInt!]
  endOfDispute: BigInt
  endOfDispute_not: BigInt
  endOfDispute_gt: BigInt
  endOfDispute_lt: BigInt
  endOfDispute_gte: BigInt
  endOfDispute_lte: BigInt
  endOfDispute_in: [BigInt!]
  endOfDispute_not_in: [BigInt!]
  domain: BigInt
  domain_not: BigInt
  domain_gt: BigInt
  domain_lt: BigInt
  domain_gte: BigInt
  domain_lte: BigInt
  domain_in: [BigInt!]
  domain_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: mantle_BlockChangedFilter
  and: [mantle_AggregateRootProposed_filter]
  or: [mantle_AggregateRootProposed_filter]
}

enum mantle_AggregateRootProposed_orderBy {
  id
  aggregateRoot
  rootTimestamp
  endOfDispute
  domain
  timestamp
  blockNumber
}

input mantle_AggregateRoot_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  root: mantle_Bytes
  root_not: mantle_Bytes
  root_gt: mantle_Bytes
  root_lt: mantle_Bytes
  root_gte: mantle_Bytes
  root_lte: mantle_Bytes
  root_in: [mantle_Bytes!]
  root_not_in: [mantle_Bytes!]
  root_contains: mantle_Bytes
  root_not_contains: mantle_Bytes
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: mantle_BlockChangedFilter
  and: [mantle_AggregateRoot_filter]
  or: [mantle_AggregateRoot_filter]
}

enum mantle_AggregateRoot_orderBy {
  id
  root
  blockNumber
}

enum mantle_Aggregation_interval {
  hour
  day
}

type mantle_Asset {
  id: ID!
  key: mantle_Bytes
  decimal: BigInt
  adoptedDecimal: BigInt
  canonicalId: mantle_Bytes
  canonicalDomain: BigInt
  adoptedAsset: mantle_Bytes
  localAsset: mantle_Bytes
  blockNumber: BigInt
  status: mantle_AssetStatus
}

type mantle_AssetBalance {
  id: ID!
  amount: BigInt!
  locked: BigInt!
  supplied: BigInt!
  removed: BigInt!
  router: mantle_Router!
  asset: mantle_Asset!
  feesEarned: BigInt!
}

input mantle_AssetBalance_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  locked: BigInt
  locked_not: BigInt
  locked_gt: BigInt
  locked_lt: BigInt
  locked_gte: BigInt
  locked_lte: BigInt
  locked_in: [BigInt!]
  locked_not_in: [BigInt!]
  supplied: BigInt
  supplied_not: BigInt
  supplied_gt: BigInt
  supplied_lt: BigInt
  supplied_gte: BigInt
  supplied_lte: BigInt
  supplied_in: [BigInt!]
  supplied_not_in: [BigInt!]
  removed: BigInt
  removed_not: BigInt
  removed_gt: BigInt
  removed_lt: BigInt
  removed_gte: BigInt
  removed_lte: BigInt
  removed_in: [BigInt!]
  removed_not_in: [BigInt!]
  router: String
  router_not: String
  router_gt: String
  router_lt: String
  router_gte: String
  router_lte: String
  router_in: [String!]
  router_not_in: [String!]
  router_contains: String
  router_contains_nocase: String
  router_not_contains: String
  router_not_contains_nocase: String
  router_starts_with: String
  router_starts_with_nocase: String
  router_not_starts_with: String
  router_not_starts_with_nocase: String
  router_ends_with: String
  router_ends_with_nocase: String
  router_not_ends_with: String
  router_not_ends_with_nocase: String
  router_: mantle_Router_filter
  asset: String
  asset_not: String
  asset_gt: String
  asset_lt: String
  asset_gte: String
  asset_lte: String
  asset_in: [String!]
  asset_not_in: [String!]
  asset_contains: String
  asset_contains_nocase: String
  asset_not_contains: String
  asset_not_contains_nocase: String
  asset_starts_with: String
  asset_starts_with_nocase: String
  asset_not_starts_with: String
  asset_not_starts_with_nocase: String
  asset_ends_with: String
  asset_ends_with_nocase: String
  asset_not_ends_with: String
  asset_not_ends_with_nocase: String
  asset_: mantle_Asset_filter
  feesEarned: BigInt
  feesEarned_not: BigInt
  feesEarned_gt: BigInt
  feesEarned_lt: BigInt
  feesEarned_gte: BigInt
  feesEarned_lte: BigInt
  feesEarned_in: [BigInt!]
  feesEarned_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: mantle_BlockChangedFilter
  and: [mantle_AssetBalance_filter]
  or: [mantle_AssetBalance_filter]
}

enum mantle_AssetBalance_orderBy {
  id
  amount
  locked
  supplied
  removed
  router
  router__id
  router__isActive
  router__owner
  router__recipient
  router__proposedOwner
  router__proposedTimestamp
  asset
  asset__id
  asset__key
  asset__decimal
  asset__adoptedDecimal
  asset__canonicalId
  asset__canonicalDomain
  asset__adoptedAsset
  asset__localAsset
  asset__blockNumber
  feesEarned
}

type mantle_AssetStatus {
  id: ID!
  status: Boolean
}

input mantle_AssetStatus_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  status: Boolean
  status_not: Boolean
  status_in: [Boolean!]
  status_not_in: [Boolean!]
  """Filter for the block changed event."""
  _change_block: mantle_BlockChangedFilter
  and: [mantle_AssetStatus_filter]
  or: [mantle_AssetStatus_filter]
}

enum mantle_AssetStatus_orderBy {
  id
  status
}

input mantle_Asset_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  key: mantle_Bytes
  key_not: mantle_Bytes
  key_gt: mantle_Bytes
  key_lt: mantle_Bytes
  key_gte: mantle_Bytes
  key_lte: mantle_Bytes
  key_in: [mantle_Bytes!]
  key_not_in: [mantle_Bytes!]
  key_contains: mantle_Bytes
  key_not_contains: mantle_Bytes
  decimal: BigInt
  decimal_not: BigInt
  decimal_gt: BigInt
  decimal_lt: BigInt
  decimal_gte: BigInt
  decimal_lte: BigInt
  decimal_in: [BigInt!]
  decimal_not_in: [BigInt!]
  adoptedDecimal: BigInt
  adoptedDecimal_not: BigInt
  adoptedDecimal_gt: BigInt
  adoptedDecimal_lt: BigInt
  adoptedDecimal_gte: BigInt
  adoptedDecimal_lte: BigInt
  adoptedDecimal_in: [BigInt!]
  adoptedDecimal_not_in: [BigInt!]
  canonicalId: mantle_Bytes
  canonicalId_not: mantle_Bytes
  canonicalId_gt: mantle_Bytes
  canonicalId_lt: mantle_Bytes
  canonicalId_gte: mantle_Bytes
  canonicalId_lte: mantle_Bytes
  canonicalId_in: [mantle_Bytes!]
  canonicalId_not_in: [mantle_Bytes!]
  canonicalId_contains: mantle_Bytes
  canonicalId_not_contains: mantle_Bytes
  canonicalDomain: BigInt
  canonicalDomain_not: BigInt
  canonicalDomain_gt: BigInt
  canonicalDomain_lt: BigInt
  canonicalDomain_gte: BigInt
  canonicalDomain_lte: BigInt
  canonicalDomain_in: [BigInt!]
  canonicalDomain_not_in: [BigInt!]
  adoptedAsset: mantle_Bytes
  adoptedAsset_not: mantle_Bytes
  adoptedAsset_gt: mantle_Bytes
  adoptedAsset_lt: mantle_Bytes
  adoptedAsset_gte: mantle_Bytes
  adoptedAsset_lte: mantle_Bytes
  adoptedAsset_in: [mantle_Bytes!]
  adoptedAsset_not_in: [mantle_Bytes!]
  adoptedAsset_contains: mantle_Bytes
  adoptedAsset_not_contains: mantle_Bytes
  localAsset: mantle_Bytes
  localAsset_not: mantle_Bytes
  localAsset_gt: mantle_Bytes
  localAsset_lt: mantle_Bytes
  localAsset_gte: mantle_Bytes
  localAsset_lte: mantle_Bytes
  localAsset_in: [mantle_Bytes!]
  localAsset_not_in: [mantle_Bytes!]
  localAsset_contains: mantle_Bytes
  localAsset_not_contains: mantle_Bytes
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  status: String
  status_not: String
  status_gt: String
  status_lt: String
  status_gte: String
  status_lte: String
  status_in: [String!]
  status_not_in: [String!]
  status_contains: String
  status_contains_nocase: String
  status_not_contains: String
  status_not_contains_nocase: String
  status_starts_with: String
  status_starts_with_nocase: String
  status_not_starts_with: String
  status_not_starts_with_nocase: String
  status_ends_with: String
  status_ends_with_nocase: String
  status_not_ends_with: String
  status_not_ends_with_nocase: String
  status_: mantle_AssetStatus_filter
  """Filter for the block changed event."""
  _change_block: mantle_BlockChangedFilter
  and: [mantle_Asset_filter]
  or: [mantle_Asset_filter]
}

enum mantle_Asset_orderBy {
  id
  key
  decimal
  adoptedDecimal
  canonicalId
  canonicalDomain
  adoptedAsset
  localAsset
  blockNumber
  status
  status__id
  status__status
}

scalar mantle_BigDecimal

input mantle_BlockChangedFilter {
  number_gte: Int!
}

input mantle_Block_height {
  hash: mantle_Bytes
  number: Int
  number_gte: Int
}

scalar mantle_Bytes

type mantle_ConnectorMeta {
  id: ID!
  spokeDomain: BigInt
  hubDomain: BigInt
  amb: mantle_Bytes
  rootManager: mantle_Bytes
  mirrorConnector: mantle_Bytes
}

input mantle_ConnectorMeta_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  spokeDomain: BigInt
  spokeDomain_not: BigInt
  spokeDomain_gt: BigInt
  spokeDomain_lt: BigInt
  spokeDomain_gte: BigInt
  spokeDomain_lte: BigInt
  spokeDomain_in: [BigInt!]
  spokeDomain_not_in: [BigInt!]
  hubDomain: BigInt
  hubDomain_not: BigInt
  hubDomain_gt: BigInt
  hubDomain_lt: BigInt
  hubDomain_gte: BigInt
  hubDomain_lte: BigInt
  hubDomain_in: [BigInt!]
  hubDomain_not_in: [BigInt!]
  amb: mantle_Bytes
  amb_not: mantle_Bytes
  amb_gt: mantle_Bytes
  amb_lt: mantle_Bytes
  amb_gte: mantle_Bytes
  amb_lte: mantle_Bytes
  amb_in: [mantle_Bytes!]
  amb_not_in: [mantle_Bytes!]
  amb_contains: mantle_Bytes
  amb_not_contains: mantle_Bytes
  rootManager: mantle_Bytes
  rootManager_not: mantle_Bytes
  rootManager_gt: mantle_Bytes
  rootManager_lt: mantle_Bytes
  rootManager_gte: mantle_Bytes
  rootManager_lte: mantle_Bytes
  rootManager_in: [mantle_Bytes!]
  rootManager_not_in: [mantle_Bytes!]
  rootManager_contains: mantle_Bytes
  rootManager_not_contains: mantle_Bytes
  mirrorConnector: mantle_Bytes
  mirrorConnector_not: mantle_Bytes
  mirrorConnector_gt: mantle_Bytes
  mirrorConnector_lt: mantle_Bytes
  mirrorConnector_gte: mantle_Bytes
  mirrorConnector_lte: mantle_Bytes
  mirrorConnector_in: [mantle_Bytes!]
  mirrorConnector_not_in: [mantle_Bytes!]
  mirrorConnector_contains: mantle_Bytes
  mirrorConnector_not_contains: mantle_Bytes
  """Filter for the block changed event."""
  _change_block: mantle_BlockChangedFilter
  and: [mantle_ConnectorMeta_filter]
  or: [mantle_ConnectorMeta_filter]
}

enum mantle_ConnectorMeta_orderBy {
  id
  spokeDomain
  hubDomain
  amb
  rootManager
  mirrorConnector
}

type mantle_DestinationTransfer {
  id: ID!
  chainId: BigInt
  transferId: mantle_Bytes
  nonce: BigInt
  status: mantle_TransferStatus
  routers(skip: Int = 0, first: Int = 100, orderBy: mantle_Router_orderBy, orderDirection: mantle_OrderDirection, where: mantle_Router_filter): [mantle_Router!]
  originDomain: BigInt
  destinationDomain: BigInt
  canonicalDomain: BigInt
  to: mantle_Bytes
  delegate: mantle_Bytes
  receiveLocal: Boolean
  callData: mantle_Bytes
  slippage: BigInt
  bumpSlippageCount: BigInt
  originSender: mantle_Bytes
  bridgedAmt: BigInt
  normalizedIn: BigInt
  canonicalId: mantle_Bytes
  asset: mantle_Asset
  amount: BigInt
  routersFee: BigInt
  executedCaller: mantle_Bytes
  executedTransactionHash: mantle_Bytes
  executedTimestamp: BigInt
  executedGasPrice: BigInt
  executedGasLimit: BigInt
  executedBlockNumber: BigInt
  executedTxOrigin: mantle_Bytes
  executedTxNonce: BigInt
  reconciledCaller: mantle_Bytes
  reconciledTransactionHash: mantle_Bytes
  reconciledTimestamp: BigInt
  reconciledGasPrice: BigInt
  reconciledGasLimit: BigInt
  reconciledBlockNumber: BigInt
  reconciledTxOrigin: mantle_Bytes
  reconciledTxNonce: BigInt
}

input mantle_DestinationTransfer_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  chainId: BigInt
  chainId_not: BigInt
  chainId_gt: BigInt
  chainId_lt: BigInt
  chainId_gte: BigInt
  chainId_lte: BigInt
  chainId_in: [BigInt!]
  chainId_not_in: [BigInt!]
  transferId: mantle_Bytes
  transferId_not: mantle_Bytes
  transferId_gt: mantle_Bytes
  transferId_lt: mantle_Bytes
  transferId_gte: mantle_Bytes
  transferId_lte: mantle_Bytes
  transferId_in: [mantle_Bytes!]
  transferId_not_in: [mantle_Bytes!]
  transferId_contains: mantle_Bytes
  transferId_not_contains: mantle_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  status: mantle_TransferStatus
  status_not: mantle_TransferStatus
  status_in: [mantle_TransferStatus!]
  status_not_in: [mantle_TransferStatus!]
  routers: [String!]
  routers_not: [String!]
  routers_contains: [String!]
  routers_contains_nocase: [String!]
  routers_not_contains: [String!]
  routers_not_contains_nocase: [String!]
  routers_: mantle_Router_filter
  originDomain: BigInt
  originDomain_not: BigInt
  originDomain_gt: BigInt
  originDomain_lt: BigInt
  originDomain_gte: BigInt
  originDomain_lte: BigInt
  originDomain_in: [BigInt!]
  originDomain_not_in: [BigInt!]
  destinationDomain: BigInt
  destinationDomain_not: BigInt
  destinationDomain_gt: BigInt
  destinationDomain_lt: BigInt
  destinationDomain_gte: BigInt
  destinationDomain_lte: BigInt
  destinationDomain_in: [BigInt!]
  destinationDomain_not_in: [BigInt!]
  canonicalDomain: BigInt
  canonicalDomain_not: BigInt
  canonicalDomain_gt: BigInt
  canonicalDomain_lt: BigInt
  canonicalDomain_gte: BigInt
  canonicalDomain_lte: BigInt
  canonicalDomain_in: [BigInt!]
  canonicalDomain_not_in: [BigInt!]
  to: mantle_Bytes
  to_not: mantle_Bytes
  to_gt: mantle_Bytes
  to_lt: mantle_Bytes
  to_gte: mantle_Bytes
  to_lte: mantle_Bytes
  to_in: [mantle_Bytes!]
  to_not_in: [mantle_Bytes!]
  to_contains: mantle_Bytes
  to_not_contains: mantle_Bytes
  delegate: mantle_Bytes
  delegate_not: mantle_Bytes
  delegate_gt: mantle_Bytes
  delegate_lt: mantle_Bytes
  delegate_gte: mantle_Bytes
  delegate_lte: mantle_Bytes
  delegate_in: [mantle_Bytes!]
  delegate_not_in: [mantle_Bytes!]
  delegate_contains: mantle_Bytes
  delegate_not_contains: mantle_Bytes
  receiveLocal: Boolean
  receiveLocal_not: Boolean
  receiveLocal_in: [Boolean!]
  receiveLocal_not_in: [Boolean!]
  callData: mantle_Bytes
  callData_not: mantle_Bytes
  callData_gt: mantle_Bytes
  callData_lt: mantle_Bytes
  callData_gte: mantle_Bytes
  callData_lte: mantle_Bytes
  callData_in: [mantle_Bytes!]
  callData_not_in: [mantle_Bytes!]
  callData_contains: mantle_Bytes
  callData_not_contains: mantle_Bytes
  slippage: BigInt
  slippage_not: BigInt
  slippage_gt: BigInt
  slippage_lt: BigInt
  slippage_gte: BigInt
  slippage_lte: BigInt
  slippage_in: [BigInt!]
  slippage_not_in: [BigInt!]
  bumpSlippageCount: BigInt
  bumpSlippageCount_not: BigInt
  bumpSlippageCount_gt: BigInt
  bumpSlippageCount_lt: BigInt
  bumpSlippageCount_gte: BigInt
  bumpSlippageCount_lte: BigInt
  bumpSlippageCount_in: [BigInt!]
  bumpSlippageCount_not_in: [BigInt!]
  originSender: mantle_Bytes
  originSender_not: mantle_Bytes
  originSender_gt: mantle_Bytes
  originSender_lt: mantle_Bytes
  originSender_gte: mantle_Bytes
  originSender_lte: mantle_Bytes
  originSender_in: [mantle_Bytes!]
  originSender_not_in: [mantle_Bytes!]
  originSender_contains: mantle_Bytes
  originSender_not_contains: mantle_Bytes
  bridgedAmt: BigInt
  bridgedAmt_not: BigInt
  bridgedAmt_gt: BigInt
  bridgedAmt_lt: BigInt
  bridgedAmt_gte: BigInt
  bridgedAmt_lte: BigInt
  bridgedAmt_in: [BigInt!]
  bridgedAmt_not_in: [BigInt!]
  normalizedIn: BigInt
  normalizedIn_not: BigInt
  normalizedIn_gt: BigInt
  normalizedIn_lt: BigInt
  normalizedIn_gte: BigInt
  normalizedIn_lte: BigInt
  normalizedIn_in: [BigInt!]
  normalizedIn_not_in: [BigInt!]
  canonicalId: mantle_Bytes
  canonicalId_not: mantle_Bytes
  canonicalId_gt: mantle_Bytes
  canonicalId_lt: mantle_Bytes
  canonicalId_gte: mantle_Bytes
  canonicalId_lte: mantle_Bytes
  canonicalId_in: [mantle_Bytes!]
  canonicalId_not_in: [mantle_Bytes!]
  canonicalId_contains: mantle_Bytes
  canonicalId_not_contains: mantle_Bytes
  asset: String
  asset_not: String
  asset_gt: String
  asset_lt: String
  asset_gte: String
  asset_lte: String
  asset_in: [String!]
  asset_not_in: [String!]
  asset_contains: String
  asset_contains_nocase: String
  asset_not_contains: String
  asset_not_contains_nocase: String
  asset_starts_with: String
  asset_starts_with_nocase: String
  asset_not_starts_with: String
  asset_not_starts_with_nocase: String
  asset_ends_with: String
  asset_ends_with_nocase: String
  asset_not_ends_with: String
  asset_not_ends_with_nocase: String
  asset_: mantle_Asset_filter
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  routersFee: BigInt
  routersFee_not: BigInt
  routersFee_gt: BigInt
  routersFee_lt: BigInt
  routersFee_gte: BigInt
  routersFee_lte: BigInt
  routersFee_in: [BigInt!]
  routersFee_not_in: [BigInt!]
  executedCaller: mantle_Bytes
  executedCaller_not: mantle_Bytes
  executedCaller_gt: mantle_Bytes
  executedCaller_lt: mantle_Bytes
  executedCaller_gte: mantle_Bytes
  executedCaller_lte: mantle_Bytes
  executedCaller_in: [mantle_Bytes!]
  executedCaller_not_in: [mantle_Bytes!]
  executedCaller_contains: mantle_Bytes
  executedCaller_not_contains: mantle_Bytes
  executedTransactionHash: mantle_Bytes
  executedTransactionHash_not: mantle_Bytes
  executedTransactionHash_gt: mantle_Bytes
  executedTransactionHash_lt: mantle_Bytes
  executedTransactionHash_gte: mantle_Bytes
  executedTransactionHash_lte: mantle_Bytes
  executedTransactionHash_in: [mantle_Bytes!]
  executedTransactionHash_not_in: [mantle_Bytes!]
  executedTransactionHash_contains: mantle_Bytes
  executedTransactionHash_not_contains: mantle_Bytes
  executedTimestamp: BigInt
  executedTimestamp_not: BigInt
  executedTimestamp_gt: BigInt
  executedTimestamp_lt: BigInt
  executedTimestamp_gte: BigInt
  executedTimestamp_lte: BigInt
  executedTimestamp_in: [BigInt!]
  executedTimestamp_not_in: [BigInt!]
  executedGasPrice: BigInt
  executedGasPrice_not: BigInt
  executedGasPrice_gt: BigInt
  executedGasPrice_lt: BigInt
  executedGasPrice_gte: BigInt
  executedGasPrice_lte: BigInt
  executedGasPrice_in: [BigInt!]
  executedGasPrice_not_in: [BigInt!]
  executedGasLimit: BigInt
  executedGasLimit_not: BigInt
  executedGasLimit_gt: BigInt
  executedGasLimit_lt: BigInt
  executedGasLimit_gte: BigInt
  executedGasLimit_lte: BigInt
  executedGasLimit_in: [BigInt!]
  executedGasLimit_not_in: [BigInt!]
  executedBlockNumber: BigInt
  executedBlockNumber_not: BigInt
  executedBlockNumber_gt: BigInt
  executedBlockNumber_lt: BigInt
  executedBlockNumber_gte: BigInt
  executedBlockNumber_lte: BigInt
  executedBlockNumber_in: [BigInt!]
  executedBlockNumber_not_in: [BigInt!]
  executedTxOrigin: mantle_Bytes
  executedTxOrigin_not: mantle_Bytes
  executedTxOrigin_gt: mantle_Bytes
  executedTxOrigin_lt: mantle_Bytes
  executedTxOrigin_gte: mantle_Bytes
  executedTxOrigin_lte: mantle_Bytes
  executedTxOrigin_in: [mantle_Bytes!]
  executedTxOrigin_not_in: [mantle_Bytes!]
  executedTxOrigin_contains: mantle_Bytes
  executedTxOrigin_not_contains: mantle_Bytes
  executedTxNonce: BigInt
  executedTxNonce_not: BigInt
  executedTxNonce_gt: BigInt
  executedTxNonce_lt: BigInt
  executedTxNonce_gte: BigInt
  executedTxNonce_lte: BigInt
  executedTxNonce_in: [BigInt!]
  executedTxNonce_not_in: [BigInt!]
  reconciledCaller: mantle_Bytes
  reconciledCaller_not: mantle_Bytes
  reconciledCaller_gt: mantle_Bytes
  reconciledCaller_lt: mantle_Bytes
  reconciledCaller_gte: mantle_Bytes
  reconciledCaller_lte: mantle_Bytes
  reconciledCaller_in: [mantle_Bytes!]
  reconciledCaller_not_in: [mantle_Bytes!]
  reconciledCaller_contains: mantle_Bytes
  reconciledCaller_not_contains: mantle_Bytes
  reconciledTransactionHash: mantle_Bytes
  reconciledTransactionHash_not: mantle_Bytes
  reconciledTransactionHash_gt: mantle_Bytes
  reconciledTransactionHash_lt: mantle_Bytes
  reconciledTransactionHash_gte: mantle_Bytes
  reconciledTransactionHash_lte: mantle_Bytes
  reconciledTransactionHash_in: [mantle_Bytes!]
  reconciledTransactionHash_not_in: [mantle_Bytes!]
  reconciledTransactionHash_contains: mantle_Bytes
  reconciledTransactionHash_not_contains: mantle_Bytes
  reconciledTimestamp: BigInt
  reconciledTimestamp_not: BigInt
  reconciledTimestamp_gt: BigInt
  reconciledTimestamp_lt: BigInt
  reconciledTimestamp_gte: BigInt
  reconciledTimestamp_lte: BigInt
  reconciledTimestamp_in: [BigInt!]
  reconciledTimestamp_not_in: [BigInt!]
  reconciledGasPrice: BigInt
  reconciledGasPrice_not: BigInt
  reconciledGasPrice_gt: BigInt
  reconciledGasPrice_lt: BigInt
  reconciledGasPrice_gte: BigInt
  reconciledGasPrice_lte: BigInt
  reconciledGasPrice_in: [BigInt!]
  reconciledGasPrice_not_in: [BigInt!]
  reconciledGasLimit: BigInt
  reconciledGasLimit_not: BigInt
  reconciledGasLimit_gt: BigInt
  reconciledGasLimit_lt: BigInt
  reconciledGasLimit_gte: BigInt
  reconciledGasLimit_lte: BigInt
  reconciledGasLimit_in: [BigInt!]
  reconciledGasLimit_not_in: [BigInt!]
  reconciledBlockNumber: BigInt
  reconciledBlockNumber_not: BigInt
  reconciledBlockNumber_gt: BigInt
  reconciledBlockNumber_lt: BigInt
  reconciledBlockNumber_gte: BigInt
  reconciledBlockNumber_lte: BigInt
  reconciledBlockNumber_in: [BigInt!]
  reconciledBlockNumber_not_in: [BigInt!]
  reconciledTxOrigin: mantle_Bytes
  reconciledTxOrigin_not: mantle_Bytes
  reconciledTxOrigin_gt: mantle_Bytes
  reconciledTxOrigin_lt: mantle_Bytes
  reconciledTxOrigin_gte: mantle_Bytes
  reconciledTxOrigin_lte: mantle_Bytes
  reconciledTxOrigin_in: [mantle_Bytes!]
  reconciledTxOrigin_not_in: [mantle_Bytes!]
  reconciledTxOrigin_contains: mantle_Bytes
  reconciledTxOrigin_not_contains: mantle_Bytes
  reconciledTxNonce: BigInt
  reconciledTxNonce_not: BigInt
  reconciledTxNonce_gt: BigInt
  reconciledTxNonce_lt: BigInt
  reconciledTxNonce_gte: BigInt
  reconciledTxNonce_lte: BigInt
  reconciledTxNonce_in: [BigInt!]
  reconciledTxNonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: mantle_BlockChangedFilter
  and: [mantle_DestinationTransfer_filter]
  or: [mantle_DestinationTransfer_filter]
}

enum mantle_DestinationTransfer_orderBy {
  id
  chainId
  transferId
  nonce
  status
  routers
  originDomain
  destinationDomain
  canonicalDomain
  to
  delegate
  receiveLocal
  callData
  slippage
  bumpSlippageCount
  originSender
  bridgedAmt
  normalizedIn
  canonicalId
  asset
  asset__id
  asset__key
  asset__decimal
  asset__adoptedDecimal
  asset__canonicalId
  asset__canonicalDomain
  asset__adoptedAsset
  asset__localAsset
  asset__blockNumber
  amount
  routersFee
  executedCaller
  executedTransactionHash
  executedTimestamp
  executedGasPrice
  executedGasLimit
  executedBlockNumber
  executedTxOrigin
  executedTxNonce
  reconciledCaller
  reconciledTransactionHash
  reconciledTimestamp
  reconciledGasPrice
  reconciledGasLimit
  reconciledBlockNumber
  reconciledTxOrigin
  reconciledTxNonce
}

"""
8 bytes signed integer

"""
scalar mantle_Int8

type mantle_OptimisticRootFinalized {
  id: ID!
  aggregateRoot: mantle_Bytes!
  timestamp: BigInt!
  blockNumber: BigInt
}

input mantle_OptimisticRootFinalized_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  aggregateRoot: mantle_Bytes
  aggregateRoot_not: mantle_Bytes
  aggregateRoot_gt: mantle_Bytes
  aggregateRoot_lt: mantle_Bytes
  aggregateRoot_gte: mantle_Bytes
  aggregateRoot_lte: mantle_Bytes
  aggregateRoot_in: [mantle_Bytes!]
  aggregateRoot_not_in: [mantle_Bytes!]
  aggregateRoot_contains: mantle_Bytes
  aggregateRoot_not_contains: mantle_Bytes
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: mantle_BlockChangedFilter
  and: [mantle_OptimisticRootFinalized_filter]
  or: [mantle_OptimisticRootFinalized_filter]
}

enum mantle_OptimisticRootFinalized_orderBy {
  id
  aggregateRoot
  timestamp
  blockNumber
}

"""Defines the order direction, either ascending or descending"""
enum mantle_OrderDirection {
  asc
  desc
}

type mantle_OriginMessage {
  id: ID!
  transferId: mantle_Bytes
  destinationDomain: BigInt
  leaf: mantle_Bytes
  index: BigInt
  message: mantle_Bytes
  root: mantle_Bytes
  transactionHash: mantle_Bytes
  blockNumber: BigInt
  rootCount: mantle_RootCount
}

input mantle_OriginMessage_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transferId: mantle_Bytes
  transferId_not: mantle_Bytes
  transferId_gt: mantle_Bytes
  transferId_lt: mantle_Bytes
  transferId_gte: mantle_Bytes
  transferId_lte: mantle_Bytes
  transferId_in: [mantle_Bytes!]
  transferId_not_in: [mantle_Bytes!]
  transferId_contains: mantle_Bytes
  transferId_not_contains: mantle_Bytes
  destinationDomain: BigInt
  destinationDomain_not: BigInt
  destinationDomain_gt: BigInt
  destinationDomain_lt: BigInt
  destinationDomain_gte: BigInt
  destinationDomain_lte: BigInt
  destinationDomain_in: [BigInt!]
  destinationDomain_not_in: [BigInt!]
  leaf: mantle_Bytes
  leaf_not: mantle_Bytes
  leaf_gt: mantle_Bytes
  leaf_lt: mantle_Bytes
  leaf_gte: mantle_Bytes
  leaf_lte: mantle_Bytes
  leaf_in: [mantle_Bytes!]
  leaf_not_in: [mantle_Bytes!]
  leaf_contains: mantle_Bytes
  leaf_not_contains: mantle_Bytes
  index: BigInt
  index_not: BigInt
  index_gt: BigInt
  index_lt: BigInt
  index_gte: BigInt
  index_lte: BigInt
  index_in: [BigInt!]
  index_not_in: [BigInt!]
  message: mantle_Bytes
  message_not: mantle_Bytes
  message_gt: mantle_Bytes
  message_lt: mantle_Bytes
  message_gte: mantle_Bytes
  message_lte: mantle_Bytes
  message_in: [mantle_Bytes!]
  message_not_in: [mantle_Bytes!]
  message_contains: mantle_Bytes
  message_not_contains: mantle_Bytes
  root: mantle_Bytes
  root_not: mantle_Bytes
  root_gt: mantle_Bytes
  root_lt: mantle_Bytes
  root_gte: mantle_Bytes
  root_lte: mantle_Bytes
  root_in: [mantle_Bytes!]
  root_not_in: [mantle_Bytes!]
  root_contains: mantle_Bytes
  root_not_contains: mantle_Bytes
  transactionHash: mantle_Bytes
  transactionHash_not: mantle_Bytes
  transactionHash_gt: mantle_Bytes
  transactionHash_lt: mantle_Bytes
  transactionHash_gte: mantle_Bytes
  transactionHash_lte: mantle_Bytes
  transactionHash_in: [mantle_Bytes!]
  transactionHash_not_in: [mantle_Bytes!]
  transactionHash_contains: mantle_Bytes
  transactionHash_not_contains: mantle_Bytes
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  rootCount: String
  rootCount_not: String
  rootCount_gt: String
  rootCount_lt: String
  rootCount_gte: String
  rootCount_lte: String
  rootCount_in: [String!]
  rootCount_not_in: [String!]
  rootCount_contains: String
  rootCount_contains_nocase: String
  rootCount_not_contains: String
  rootCount_not_contains_nocase: String
  rootCount_starts_with: String
  rootCount_starts_with_nocase: String
  rootCount_not_starts_with: String
  rootCount_not_starts_with_nocase: String
  rootCount_ends_with: String
  rootCount_ends_with_nocase: String
  rootCount_not_ends_with: String
  rootCount_not_ends_with_nocase: String
  rootCount_: mantle_RootCount_filter
  """Filter for the block changed event."""
  _change_block: mantle_BlockChangedFilter
  and: [mantle_OriginMessage_filter]
  or: [mantle_OriginMessage_filter]
}

enum mantle_OriginMessage_orderBy {
  id
  transferId
  destinationDomain
  leaf
  index
  message
  root
  transactionHash
  blockNumber
  rootCount
  rootCount__id
  rootCount__count
}

type mantle_OriginTransfer {
  id: ID!
  chainId: BigInt
  transferId: mantle_Bytes
  nonce: BigInt
  status: mantle_TransferStatus
  messageHash: mantle_Bytes
  originDomain: BigInt
  destinationDomain: BigInt
  canonicalDomain: BigInt
  to: mantle_Bytes
  delegate: mantle_Bytes
  receiveLocal: Boolean
  callData: mantle_Bytes
  slippage: BigInt
  originSender: mantle_Bytes
  bridgedAmt: BigInt
  normalizedIn: BigInt
  canonicalId: mantle_Bytes
  asset: mantle_Asset
  transactingAsset: mantle_Bytes
  message: mantle_OriginMessage
  bumpRelayerFeeCount: BigInt
  relayerFees(skip: Int = 0, first: Int = 100, orderBy: mantle_RelayerFee_orderBy, orderDirection: mantle_OrderDirection, where: mantle_RelayerFee_filter): [mantle_RelayerFee!]
  initialRelayerFeeAsset: mantle_Bytes
  caller: mantle_Bytes
  transactionHash: mantle_Bytes
  timestamp: BigInt
  gasPrice: BigInt
  gasLimit: BigInt
  blockNumber: BigInt
  txOrigin: mantle_Bytes
  txNonce: BigInt
}

input mantle_OriginTransfer_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  chainId: BigInt
  chainId_not: BigInt
  chainId_gt: BigInt
  chainId_lt: BigInt
  chainId_gte: BigInt
  chainId_lte: BigInt
  chainId_in: [BigInt!]
  chainId_not_in: [BigInt!]
  transferId: mantle_Bytes
  transferId_not: mantle_Bytes
  transferId_gt: mantle_Bytes
  transferId_lt: mantle_Bytes
  transferId_gte: mantle_Bytes
  transferId_lte: mantle_Bytes
  transferId_in: [mantle_Bytes!]
  transferId_not_in: [mantle_Bytes!]
  transferId_contains: mantle_Bytes
  transferId_not_contains: mantle_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  status: mantle_TransferStatus
  status_not: mantle_TransferStatus
  status_in: [mantle_TransferStatus!]
  status_not_in: [mantle_TransferStatus!]
  messageHash: mantle_Bytes
  messageHash_not: mantle_Bytes
  messageHash_gt: mantle_Bytes
  messageHash_lt: mantle_Bytes
  messageHash_gte: mantle_Bytes
  messageHash_lte: mantle_Bytes
  messageHash_in: [mantle_Bytes!]
  messageHash_not_in: [mantle_Bytes!]
  messageHash_contains: mantle_Bytes
  messageHash_not_contains: mantle_Bytes
  originDomain: BigInt
  originDomain_not: BigInt
  originDomain_gt: BigInt
  originDomain_lt: BigInt
  originDomain_gte: BigInt
  originDomain_lte: BigInt
  originDomain_in: [BigInt!]
  originDomain_not_in: [BigInt!]
  destinationDomain: BigInt
  destinationDomain_not: BigInt
  destinationDomain_gt: BigInt
  destinationDomain_lt: BigInt
  destinationDomain_gte: BigInt
  destinationDomain_lte: BigInt
  destinationDomain_in: [BigInt!]
  destinationDomain_not_in: [BigInt!]
  canonicalDomain: BigInt
  canonicalDomain_not: BigInt
  canonicalDomain_gt: BigInt
  canonicalDomain_lt: BigInt
  canonicalDomain_gte: BigInt
  canonicalDomain_lte: BigInt
  canonicalDomain_in: [BigInt!]
  canonicalDomain_not_in: [BigInt!]
  to: mantle_Bytes
  to_not: mantle_Bytes
  to_gt: mantle_Bytes
  to_lt: mantle_Bytes
  to_gte: mantle_Bytes
  to_lte: mantle_Bytes
  to_in: [mantle_Bytes!]
  to_not_in: [mantle_Bytes!]
  to_contains: mantle_Bytes
  to_not_contains: mantle_Bytes
  delegate: mantle_Bytes
  delegate_not: mantle_Bytes
  delegate_gt: mantle_Bytes
  delegate_lt: mantle_Bytes
  delegate_gte: mantle_Bytes
  delegate_lte: mantle_Bytes
  delegate_in: [mantle_Bytes!]
  delegate_not_in: [mantle_Bytes!]
  delegate_contains: mantle_Bytes
  delegate_not_contains: mantle_Bytes
  receiveLocal: Boolean
  receiveLocal_not: Boolean
  receiveLocal_in: [Boolean!]
  receiveLocal_not_in: [Boolean!]
  callData: mantle_Bytes
  callData_not: mantle_Bytes
  callData_gt: mantle_Bytes
  callData_lt: mantle_Bytes
  callData_gte: mantle_Bytes
  callData_lte: mantle_Bytes
  callData_in: [mantle_Bytes!]
  callData_not_in: [mantle_Bytes!]
  callData_contains: mantle_Bytes
  callData_not_contains: mantle_Bytes
  slippage: BigInt
  slippage_not: BigInt
  slippage_gt: BigInt
  slippage_lt: BigInt
  slippage_gte: BigInt
  slippage_lte: BigInt
  slippage_in: [BigInt!]
  slippage_not_in: [BigInt!]
  originSender: mantle_Bytes
  originSender_not: mantle_Bytes
  originSender_gt: mantle_Bytes
  originSender_lt: mantle_Bytes
  originSender_gte: mantle_Bytes
  originSender_lte: mantle_Bytes
  originSender_in: [mantle_Bytes!]
  originSender_not_in: [mantle_Bytes!]
  originSender_contains: mantle_Bytes
  originSender_not_contains: mantle_Bytes
  bridgedAmt: BigInt
  bridgedAmt_not: BigInt
  bridgedAmt_gt: BigInt
  bridgedAmt_lt: BigInt
  bridgedAmt_gte: BigInt
  bridgedAmt_lte: BigInt
  bridgedAmt_in: [BigInt!]
  bridgedAmt_not_in: [BigInt!]
  normalizedIn: BigInt
  normalizedIn_not: BigInt
  normalizedIn_gt: BigInt
  normalizedIn_lt: BigInt
  normalizedIn_gte: BigInt
  normalizedIn_lte: BigInt
  normalizedIn_in: [BigInt!]
  normalizedIn_not_in: [BigInt!]
  canonicalId: mantle_Bytes
  canonicalId_not: mantle_Bytes
  canonicalId_gt: mantle_Bytes
  canonicalId_lt: mantle_Bytes
  canonicalId_gte: mantle_Bytes
  canonicalId_lte: mantle_Bytes
  canonicalId_in: [mantle_Bytes!]
  canonicalId_not_in: [mantle_Bytes!]
  canonicalId_contains: mantle_Bytes
  canonicalId_not_contains: mantle_Bytes
  asset: String
  asset_not: String
  asset_gt: String
  asset_lt: String
  asset_gte: String
  asset_lte: String
  asset_in: [String!]
  asset_not_in: [String!]
  asset_contains: String
  asset_contains_nocase: String
  asset_not_contains: String
  asset_not_contains_nocase: String
  asset_starts_with: String
  asset_starts_with_nocase: String
  asset_not_starts_with: String
  asset_not_starts_with_nocase: String
  asset_ends_with: String
  asset_ends_with_nocase: String
  asset_not_ends_with: String
  asset_not_ends_with_nocase: String
  asset_: mantle_Asset_filter
  transactingAsset: mantle_Bytes
  transactingAsset_not: mantle_Bytes
  transactingAsset_gt: mantle_Bytes
  transactingAsset_lt: mantle_Bytes
  transactingAsset_gte: mantle_Bytes
  transactingAsset_lte: mantle_Bytes
  transactingAsset_in: [mantle_Bytes!]
  transactingAsset_not_in: [mantle_Bytes!]
  transactingAsset_contains: mantle_Bytes
  transactingAsset_not_contains: mantle_Bytes
  message: String
  message_not: String
  message_gt: String
  message_lt: String
  message_gte: String
  message_lte: String
  message_in: [String!]
  message_not_in: [String!]
  message_contains: String
  message_contains_nocase: String
  message_not_contains: String
  message_not_contains_nocase: String
  message_starts_with: String
  message_starts_with_nocase: String
  message_not_starts_with: String
  message_not_starts_with_nocase: String
  message_ends_with: String
  message_ends_with_nocase: String
  message_not_ends_with: String
  message_not_ends_with_nocase: String
  message_: mantle_OriginMessage_filter
  bumpRelayerFeeCount: BigInt
  bumpRelayerFeeCount_not: BigInt
  bumpRelayerFeeCount_gt: BigInt
  bumpRelayerFeeCount_lt: BigInt
  bumpRelayerFeeCount_gte: BigInt
  bumpRelayerFeeCount_lte: BigInt
  bumpRelayerFeeCount_in: [BigInt!]
  bumpRelayerFeeCount_not_in: [BigInt!]
  relayerFees: [String!]
  relayerFees_not: [String!]
  relayerFees_contains: [String!]
  relayerFees_contains_nocase: [String!]
  relayerFees_not_contains: [String!]
  relayerFees_not_contains_nocase: [String!]
  relayerFees_: mantle_RelayerFee_filter
  initialRelayerFeeAsset: mantle_Bytes
  initialRelayerFeeAsset_not: mantle_Bytes
  initialRelayerFeeAsset_gt: mantle_Bytes
  initialRelayerFeeAsset_lt: mantle_Bytes
  initialRelayerFeeAsset_gte: mantle_Bytes
  initialRelayerFeeAsset_lte: mantle_Bytes
  initialRelayerFeeAsset_in: [mantle_Bytes!]
  initialRelayerFeeAsset_not_in: [mantle_Bytes!]
  initialRelayerFeeAsset_contains: mantle_Bytes
  initialRelayerFeeAsset_not_contains: mantle_Bytes
  caller: mantle_Bytes
  caller_not: mantle_Bytes
  caller_gt: mantle_Bytes
  caller_lt: mantle_Bytes
  caller_gte: mantle_Bytes
  caller_lte: mantle_Bytes
  caller_in: [mantle_Bytes!]
  caller_not_in: [mantle_Bytes!]
  caller_contains: mantle_Bytes
  caller_not_contains: mantle_Bytes
  transactionHash: mantle_Bytes
  transactionHash_not: mantle_Bytes
  transactionHash_gt: mantle_Bytes
  transactionHash_lt: mantle_Bytes
  transactionHash_gte: mantle_Bytes
  transactionHash_lte: mantle_Bytes
  transactionHash_in: [mantle_Bytes!]
  transactionHash_not_in: [mantle_Bytes!]
  transactionHash_contains: mantle_Bytes
  transactionHash_not_contains: mantle_Bytes
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  gasLimit: BigInt
  gasLimit_not: BigInt
  gasLimit_gt: BigInt
  gasLimit_lt: BigInt
  gasLimit_gte: BigInt
  gasLimit_lte: BigInt
  gasLimit_in: [BigInt!]
  gasLimit_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  txOrigin: mantle_Bytes
  txOrigin_not: mantle_Bytes
  txOrigin_gt: mantle_Bytes
  txOrigin_lt: mantle_Bytes
  txOrigin_gte: mantle_Bytes
  txOrigin_lte: mantle_Bytes
  txOrigin_in: [mantle_Bytes!]
  txOrigin_not_in: [mantle_Bytes!]
  txOrigin_contains: mantle_Bytes
  txOrigin_not_contains: mantle_Bytes
  txNonce: BigInt
  txNonce_not: BigInt
  txNonce_gt: BigInt
  txNonce_lt: BigInt
  txNonce_gte: BigInt
  txNonce_lte: BigInt
  txNonce_in: [BigInt!]
  txNonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: mantle_BlockChangedFilter
  and: [mantle_OriginTransfer_filter]
  or: [mantle_OriginTransfer_filter]
}

enum mantle_OriginTransfer_orderBy {
  id
  chainId
  transferId
  nonce
  status
  messageHash
  originDomain
  destinationDomain
  canonicalDomain
  to
  delegate
  receiveLocal
  callData
  slippage
  originSender
  bridgedAmt
  normalizedIn
  canonicalId
  asset
  asset__id
  asset__key
  asset__decimal
  asset__adoptedDecimal
  asset__canonicalId
  asset__canonicalDomain
  asset__adoptedAsset
  asset__localAsset
  asset__blockNumber
  transactingAsset
  message
  message__id
  message__transferId
  message__destinationDomain
  message__leaf
  message__index
  message__message
  message__root
  message__transactionHash
  message__blockNumber
  bumpRelayerFeeCount
  relayerFees
  initialRelayerFeeAsset
  caller
  transactionHash
  timestamp
  gasPrice
  gasLimit
  blockNumber
  txOrigin
  txNonce
}

type mantle_Relayer {
  id: ID!
  isActive: Boolean!
  relayer: mantle_Bytes
}

type mantle_RelayerFee {
  id: ID!
  transfer: mantle_OriginTransfer!
  fee: BigInt!
  asset: mantle_Bytes!
}

input mantle_RelayerFee_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transfer: String
  transfer_not: String
  transfer_gt: String
  transfer_lt: String
  transfer_gte: String
  transfer_lte: String
  transfer_in: [String!]
  transfer_not_in: [String!]
  transfer_contains: String
  transfer_contains_nocase: String
  transfer_not_contains: String
  transfer_not_contains_nocase: String
  transfer_starts_with: String
  transfer_starts_with_nocase: String
  transfer_not_starts_with: String
  transfer_not_starts_with_nocase: String
  transfer_ends_with: String
  transfer_ends_with_nocase: String
  transfer_not_ends_with: String
  transfer_not_ends_with_nocase: String
  transfer_: mantle_OriginTransfer_filter
  fee: BigInt
  fee_not: BigInt
  fee_gt: BigInt
  fee_lt: BigInt
  fee_gte: BigInt
  fee_lte: BigInt
  fee_in: [BigInt!]
  fee_not_in: [BigInt!]
  asset: mantle_Bytes
  asset_not: mantle_Bytes
  asset_gt: mantle_Bytes
  asset_lt: mantle_Bytes
  asset_gte: mantle_Bytes
  asset_lte: mantle_Bytes
  asset_in: [mantle_Bytes!]
  asset_not_in: [mantle_Bytes!]
  asset_contains: mantle_Bytes
  asset_not_contains: mantle_Bytes
  """Filter for the block changed event."""
  _change_block: mantle_BlockChangedFilter
  and: [mantle_RelayerFee_filter]
  or: [mantle_RelayerFee_filter]
}

enum mantle_RelayerFee_orderBy {
  id
  transfer
  transfer__id
  transfer__chainId
  transfer__transferId
  transfer__nonce
  transfer__status
  transfer__messageHash
  transfer__originDomain
  transfer__destinationDomain
  transfer__canonicalDomain
  transfer__to
  transfer__delegate
  transfer__receiveLocal
  transfer__callData
  transfer__slippage
  transfer__originSender
  transfer__bridgedAmt
  transfer__normalizedIn
  transfer__canonicalId
  transfer__transactingAsset
  transfer__bumpRelayerFeeCount
  transfer__initialRelayerFeeAsset
  transfer__caller
  transfer__transactionHash
  transfer__timestamp
  transfer__gasPrice
  transfer__gasLimit
  transfer__blockNumber
  transfer__txOrigin
  transfer__txNonce
  fee
  asset
}

type mantle_RelayerFeesIncrease {
  id: ID!
  transfer: mantle_OriginTransfer!
  increase: BigInt
  asset: mantle_Bytes
  caller: mantle_Bytes!
  transactionHash: mantle_Bytes!
  timestamp: BigInt!
  gasPrice: BigInt!
  gasLimit: BigInt!
  blockNumber: BigInt!
}

input mantle_RelayerFeesIncrease_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transfer: String
  transfer_not: String
  transfer_gt: String
  transfer_lt: String
  transfer_gte: String
  transfer_lte: String
  transfer_in: [String!]
  transfer_not_in: [String!]
  transfer_contains: String
  transfer_contains_nocase: String
  transfer_not_contains: String
  transfer_not_contains_nocase: String
  transfer_starts_with: String
  transfer_starts_with_nocase: String
  transfer_not_starts_with: String
  transfer_not_starts_with_nocase: String
  transfer_ends_with: String
  transfer_ends_with_nocase: String
  transfer_not_ends_with: String
  transfer_not_ends_with_nocase: String
  transfer_: mantle_OriginTransfer_filter
  increase: BigInt
  increase_not: BigInt
  increase_gt: BigInt
  increase_lt: BigInt
  increase_gte: BigInt
  increase_lte: BigInt
  increase_in: [BigInt!]
  increase_not_in: [BigInt!]
  asset: mantle_Bytes
  asset_not: mantle_Bytes
  asset_gt: mantle_Bytes
  asset_lt: mantle_Bytes
  asset_gte: mantle_Bytes
  asset_lte: mantle_Bytes
  asset_in: [mantle_Bytes!]
  asset_not_in: [mantle_Bytes!]
  asset_contains: mantle_Bytes
  asset_not_contains: mantle_Bytes
  caller: mantle_Bytes
  caller_not: mantle_Bytes
  caller_gt: mantle_Bytes
  caller_lt: mantle_Bytes
  caller_gte: mantle_Bytes
  caller_lte: mantle_Bytes
  caller_in: [mantle_Bytes!]
  caller_not_in: [mantle_Bytes!]
  caller_contains: mantle_Bytes
  caller_not_contains: mantle_Bytes
  transactionHash: mantle_Bytes
  transactionHash_not: mantle_Bytes
  transactionHash_gt: mantle_Bytes
  transactionHash_lt: mantle_Bytes
  transactionHash_gte: mantle_Bytes
  transactionHash_lte: mantle_Bytes
  transactionHash_in: [mantle_Bytes!]
  transactionHash_not_in: [mantle_Bytes!]
  transactionHash_contains: mantle_Bytes
  transactionHash_not_contains: mantle_Bytes
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  gasLimit: BigInt
  gasLimit_not: BigInt
  gasLimit_gt: BigInt
  gasLimit_lt: BigInt
  gasLimit_gte: BigInt
  gasLimit_lte: BigInt
  gasLimit_in: [BigInt!]
  gasLimit_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: mantle_BlockChangedFilter
  and: [mantle_RelayerFeesIncrease_filter]
  or: [mantle_RelayerFeesIncrease_filter]
}

enum mantle_RelayerFeesIncrease_orderBy {
  id
  transfer
  transfer__id
  transfer__chainId
  transfer__transferId
  transfer__nonce
  transfer__status
  transfer__messageHash
  transfer__originDomain
  transfer__destinationDomain
  transfer__canonicalDomain
  transfer__to
  transfer__delegate
  transfer__receiveLocal
  transfer__callData
  transfer__slippage
  transfer__originSender
  transfer__bridgedAmt
  transfer__normalizedIn
  transfer__canonicalId
  transfer__transactingAsset
  transfer__bumpRelayerFeeCount
  transfer__initialRelayerFeeAsset
  transfer__caller
  transfer__transactionHash
  transfer__timestamp
  transfer__gasPrice
  transfer__gasLimit
  transfer__blockNumber
  transfer__txOrigin
  transfer__txNonce
  increase
  asset
  caller
  transactionHash
  timestamp
  gasPrice
  gasLimit
  blockNumber
}

input mantle_Relayer_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  isActive: Boolean
  isActive_not: Boolean
  isActive_in: [Boolean!]
  isActive_not_in: [Boolean!]
  relayer: mantle_Bytes
  relayer_not: mantle_Bytes
  relayer_gt: mantle_Bytes
  relayer_lt: mantle_Bytes
  relayer_gte: mantle_Bytes
  relayer_lte: mantle_Bytes
  relayer_in: [mantle_Bytes!]
  relayer_not_in: [mantle_Bytes!]
  relayer_contains: mantle_Bytes
  relayer_not_contains: mantle_Bytes
  """Filter for the block changed event."""
  _change_block: mantle_BlockChangedFilter
  and: [mantle_Relayer_filter]
  or: [mantle_Relayer_filter]
}

enum mantle_Relayer_orderBy {
  id
  isActive
  relayer
}

type mantle_RootCount {
  id: ID!
  count: BigInt
}

input mantle_RootCount_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  count: BigInt
  count_not: BigInt
  count_gt: BigInt
  count_lt: BigInt
  count_gte: BigInt
  count_lte: BigInt
  count_in: [BigInt!]
  count_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: mantle_BlockChangedFilter
  and: [mantle_RootCount_filter]
  or: [mantle_RootCount_filter]
}

enum mantle_RootCount_orderBy {
  id
  count
}

type mantle_RootMessageSent {
  id: ID!
  spokeDomain: BigInt
  hubDomain: BigInt
  root: mantle_Bytes
  count: BigInt
  caller: mantle_Bytes
  transactionHash: mantle_Bytes
  timestamp: BigInt
  gasPrice: BigInt
  gasLimit: BigInt
  blockNumber: BigInt
}

input mantle_RootMessageSent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  spokeDomain: BigInt
  spokeDomain_not: BigInt
  spokeDomain_gt: BigInt
  spokeDomain_lt: BigInt
  spokeDomain_gte: BigInt
  spokeDomain_lte: BigInt
  spokeDomain_in: [BigInt!]
  spokeDomain_not_in: [BigInt!]
  hubDomain: BigInt
  hubDomain_not: BigInt
  hubDomain_gt: BigInt
  hubDomain_lt: BigInt
  hubDomain_gte: BigInt
  hubDomain_lte: BigInt
  hubDomain_in: [BigInt!]
  hubDomain_not_in: [BigInt!]
  root: mantle_Bytes
  root_not: mantle_Bytes
  root_gt: mantle_Bytes
  root_lt: mantle_Bytes
  root_gte: mantle_Bytes
  root_lte: mantle_Bytes
  root_in: [mantle_Bytes!]
  root_not_in: [mantle_Bytes!]
  root_contains: mantle_Bytes
  root_not_contains: mantle_Bytes
  count: BigInt
  count_not: BigInt
  count_gt: BigInt
  count_lt: BigInt
  count_gte: BigInt
  count_lte: BigInt
  count_in: [BigInt!]
  count_not_in: [BigInt!]
  caller: mantle_Bytes
  caller_not: mantle_Bytes
  caller_gt: mantle_Bytes
  caller_lt: mantle_Bytes
  caller_gte: mantle_Bytes
  caller_lte: mantle_Bytes
  caller_in: [mantle_Bytes!]
  caller_not_in: [mantle_Bytes!]
  caller_contains: mantle_Bytes
  caller_not_contains: mantle_Bytes
  transactionHash: mantle_Bytes
  transactionHash_not: mantle_Bytes
  transactionHash_gt: mantle_Bytes
  transactionHash_lt: mantle_Bytes
  transactionHash_gte: mantle_Bytes
  transactionHash_lte: mantle_Bytes
  transactionHash_in: [mantle_Bytes!]
  transactionHash_not_in: [mantle_Bytes!]
  transactionHash_contains: mantle_Bytes
  transactionHash_not_contains: mantle_Bytes
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  gasLimit: BigInt
  gasLimit_not: BigInt
  gasLimit_gt: BigInt
  gasLimit_lt: BigInt
  gasLimit_gte: BigInt
  gasLimit_lte: BigInt
  gasLimit_in: [BigInt!]
  gasLimit_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: mantle_BlockChangedFilter
  and: [mantle_RootMessageSent_filter]
  or: [mantle_RootMessageSent_filter]
}

enum mantle_RootMessageSent_orderBy {
  id
  spokeDomain
  hubDomain
  root
  count
  caller
  transactionHash
  timestamp
  gasPrice
  gasLimit
  blockNumber
}

type mantle_Router {
  id: ID!
  isActive: Boolean!
  owner: mantle_Bytes
  recipient: mantle_Bytes
  proposedOwner: mantle_Bytes
  proposedTimestamp: BigInt
  assetBalances(skip: Int = 0, first: Int = 100, orderBy: mantle_AssetBalance_orderBy, orderDirection: mantle_OrderDirection, where: mantle_AssetBalance_filter): [mantle_AssetBalance!]!
}

type mantle_RouterDailyTVL {
  id: ID!
  router: mantle_Router!
  asset: mantle_Asset!
  timestamp: BigInt!
  balance: BigInt!
}

input mantle_RouterDailyTVL_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  router: String
  router_not: String
  router_gt: String
  router_lt: String
  router_gte: String
  router_lte: String
  router_in: [String!]
  router_not_in: [String!]
  router_contains: String
  router_contains_nocase: String
  router_not_contains: String
  router_not_contains_nocase: String
  router_starts_with: String
  router_starts_with_nocase: String
  router_not_starts_with: String
  router_not_starts_with_nocase: String
  router_ends_with: String
  router_ends_with_nocase: String
  router_not_ends_with: String
  router_not_ends_with_nocase: String
  router_: mantle_Router_filter
  asset: String
  asset_not: String
  asset_gt: String
  asset_lt: String
  asset_gte: String
  asset_lte: String
  asset_in: [String!]
  asset_not_in: [String!]
  asset_contains: String
  asset_contains_nocase: String
  asset_not_contains: String
  asset_not_contains_nocase: String
  asset_starts_with: String
  asset_starts_with_nocase: String
  asset_not_starts_with: String
  asset_not_starts_with_nocase: String
  asset_ends_with: String
  asset_ends_with_nocase: String
  asset_not_ends_with: String
  asset_not_ends_with_nocase: String
  asset_: mantle_Asset_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  balance: BigInt
  balance_not: BigInt
  balance_gt: BigInt
  balance_lt: BigInt
  balance_gte: BigInt
  balance_lte: BigInt
  balance_in: [BigInt!]
  balance_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: mantle_BlockChangedFilter
  and: [mantle_RouterDailyTVL_filter]
  or: [mantle_RouterDailyTVL_filter]
}

enum mantle_RouterDailyTVL_orderBy {
  id
  router
  router__id
  router__isActive
  router__owner
  router__recipient
  router__proposedOwner
  router__proposedTimestamp
  asset
  asset__id
  asset__key
  asset__decimal
  asset__adoptedDecimal
  asset__canonicalId
  asset__canonicalDomain
  asset__adoptedAsset
  asset__localAsset
  asset__blockNumber
  timestamp
  balance
}

type mantle_RouterLiquidityEvent {
  id: ID!
  type: mantle_RouterLiquidityEventType
  router: mantle_Router!
  asset: mantle_Asset!
  amount: BigInt!
  balance: BigInt!
  caller: mantle_Bytes
  blockNumber: BigInt!
  timestamp: BigInt!
  transactionHash: mantle_Bytes!
  nonce: BigInt!
}

enum mantle_RouterLiquidityEventType {
  Add
  Remove
}

input mantle_RouterLiquidityEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  type: mantle_RouterLiquidityEventType
  type_not: mantle_RouterLiquidityEventType
  type_in: [mantle_RouterLiquidityEventType!]
  type_not_in: [mantle_RouterLiquidityEventType!]
  router: String
  router_not: String
  router_gt: String
  router_lt: String
  router_gte: String
  router_lte: String
  router_in: [String!]
  router_not_in: [String!]
  router_contains: String
  router_contains_nocase: String
  router_not_contains: String
  router_not_contains_nocase: String
  router_starts_with: String
  router_starts_with_nocase: String
  router_not_starts_with: String
  router_not_starts_with_nocase: String
  router_ends_with: String
  router_ends_with_nocase: String
  router_not_ends_with: String
  router_not_ends_with_nocase: String
  router_: mantle_Router_filter
  asset: String
  asset_not: String
  asset_gt: String
  asset_lt: String
  asset_gte: String
  asset_lte: String
  asset_in: [String!]
  asset_not_in: [String!]
  asset_contains: String
  asset_contains_nocase: String
  asset_not_contains: String
  asset_not_contains_nocase: String
  asset_starts_with: String
  asset_starts_with_nocase: String
  asset_not_starts_with: String
  asset_not_starts_with_nocase: String
  asset_ends_with: String
  asset_ends_with_nocase: String
  asset_not_ends_with: String
  asset_not_ends_with_nocase: String
  asset_: mantle_Asset_filter
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  balance: BigInt
  balance_not: BigInt
  balance_gt: BigInt
  balance_lt: BigInt
  balance_gte: BigInt
  balance_lte: BigInt
  balance_in: [BigInt!]
  balance_not_in: [BigInt!]
  caller: mantle_Bytes
  caller_not: mantle_Bytes
  caller_gt: mantle_Bytes
  caller_lt: mantle_Bytes
  caller_gte: mantle_Bytes
  caller_lte: mantle_Bytes
  caller_in: [mantle_Bytes!]
  caller_not_in: [mantle_Bytes!]
  caller_contains: mantle_Bytes
  caller_not_contains: mantle_Bytes
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transactionHash: mantle_Bytes
  transactionHash_not: mantle_Bytes
  transactionHash_gt: mantle_Bytes
  transactionHash_lt: mantle_Bytes
  transactionHash_gte: mantle_Bytes
  transactionHash_lte: mantle_Bytes
  transactionHash_in: [mantle_Bytes!]
  transactionHash_not_in: [mantle_Bytes!]
  transactionHash_contains: mantle_Bytes
  transactionHash_not_contains: mantle_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: mantle_BlockChangedFilter
  and: [mantle_RouterLiquidityEvent_filter]
  or: [mantle_RouterLiquidityEvent_filter]
}

enum mantle_RouterLiquidityEvent_orderBy {
  id
  type
  router
  router__id
  router__isActive
  router__owner
  router__recipient
  router__proposedOwner
  router__proposedTimestamp
  asset
  asset__id
  asset__key
  asset__decimal
  asset__adoptedDecimal
  asset__canonicalId
  asset__canonicalDomain
  asset__adoptedAsset
  asset__localAsset
  asset__blockNumber
  amount
  balance
  caller
  blockNumber
  timestamp
  transactionHash
  nonce
}

input mantle_Router_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  isActive: Boolean
  isActive_not: Boolean
  isActive_in: [Boolean!]
  isActive_not_in: [Boolean!]
  owner: mantle_Bytes
  owner_not: mantle_Bytes
  owner_gt: mantle_Bytes
  owner_lt: mantle_Bytes
  owner_gte: mantle_Bytes
  owner_lte: mantle_Bytes
  owner_in: [mantle_Bytes!]
  owner_not_in: [mantle_Bytes!]
  owner_contains: mantle_Bytes
  owner_not_contains: mantle_Bytes
  recipient: mantle_Bytes
  recipient_not: mantle_Bytes
  recipient_gt: mantle_Bytes
  recipient_lt: mantle_Bytes
  recipient_gte: mantle_Bytes
  recipient_lte: mantle_Bytes
  recipient_in: [mantle_Bytes!]
  recipient_not_in: [mantle_Bytes!]
  recipient_contains: mantle_Bytes
  recipient_not_contains: mantle_Bytes
  proposedOwner: mantle_Bytes
  proposedOwner_not: mantle_Bytes
  proposedOwner_gt: mantle_Bytes
  proposedOwner_lt: mantle_Bytes
  proposedOwner_gte: mantle_Bytes
  proposedOwner_lte: mantle_Bytes
  proposedOwner_in: [mantle_Bytes!]
  proposedOwner_not_in: [mantle_Bytes!]
  proposedOwner_contains: mantle_Bytes
  proposedOwner_not_contains: mantle_Bytes
  proposedTimestamp: BigInt
  proposedTimestamp_not: BigInt
  proposedTimestamp_gt: BigInt
  proposedTimestamp_lt: BigInt
  proposedTimestamp_gte: BigInt
  proposedTimestamp_lte: BigInt
  proposedTimestamp_in: [BigInt!]
  proposedTimestamp_not_in: [BigInt!]
  assetBalances_: mantle_AssetBalance_filter
  """Filter for the block changed event."""
  _change_block: mantle_BlockChangedFilter
  and: [mantle_Router_filter]
  or: [mantle_Router_filter]
}

enum mantle_Router_orderBy {
  id
  isActive
  owner
  recipient
  proposedOwner
  proposedTimestamp
  assetBalances
}

type mantle_Sequencer {
  id: ID!
  isActive: Boolean!
  sequencer: mantle_Bytes
}

input mantle_Sequencer_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  isActive: Boolean
  isActive_not: Boolean
  isActive_in: [Boolean!]
  isActive_not_in: [Boolean!]
  sequencer: mantle_Bytes
  sequencer_not: mantle_Bytes
  sequencer_gt: mantle_Bytes
  sequencer_lt: mantle_Bytes
  sequencer_gte: mantle_Bytes
  sequencer_lte: mantle_Bytes
  sequencer_in: [mantle_Bytes!]
  sequencer_not_in: [mantle_Bytes!]
  sequencer_contains: mantle_Bytes
  sequencer_not_contains: mantle_Bytes
  """Filter for the block changed event."""
  _change_block: mantle_BlockChangedFilter
  and: [mantle_Sequencer_filter]
  or: [mantle_Sequencer_filter]
}

enum mantle_Sequencer_orderBy {
  id
  isActive
  sequencer
}

type mantle_Setting {
  id: ID!
  maxRoutersPerTransfer: BigInt!
  caller: mantle_Bytes!
}

input mantle_Setting_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  maxRoutersPerTransfer: BigInt
  maxRoutersPerTransfer_not: BigInt
  maxRoutersPerTransfer_gt: BigInt
  maxRoutersPerTransfer_lt: BigInt
  maxRoutersPerTransfer_gte: BigInt
  maxRoutersPerTransfer_lte: BigInt
  maxRoutersPerTransfer_in: [BigInt!]
  maxRoutersPerTransfer_not_in: [BigInt!]
  caller: mantle_Bytes
  caller_not: mantle_Bytes
  caller_gt: mantle_Bytes
  caller_lt: mantle_Bytes
  caller_gte: mantle_Bytes
  caller_lte: mantle_Bytes
  caller_in: [mantle_Bytes!]
  caller_not_in: [mantle_Bytes!]
  caller_contains: mantle_Bytes
  caller_not_contains: mantle_Bytes
  """Filter for the block changed event."""
  _change_block: mantle_BlockChangedFilter
  and: [mantle_Setting_filter]
  or: [mantle_Setting_filter]
}

enum mantle_Setting_orderBy {
  id
  maxRoutersPerTransfer
  caller
}

type mantle_SlippageUpdate {
  id: ID!
  transfer: mantle_DestinationTransfer!
  slippage: BigInt!
  caller: mantle_Bytes!
  transactionHash: mantle_Bytes!
  timestamp: BigInt!
  gasPrice: BigInt!
  gasLimit: BigInt!
  blockNumber: BigInt!
}

input mantle_SlippageUpdate_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transfer: String
  transfer_not: String
  transfer_gt: String
  transfer_lt: String
  transfer_gte: String
  transfer_lte: String
  transfer_in: [String!]
  transfer_not_in: [String!]
  transfer_contains: String
  transfer_contains_nocase: String
  transfer_not_contains: String
  transfer_not_contains_nocase: String
  transfer_starts_with: String
  transfer_starts_with_nocase: String
  transfer_not_starts_with: String
  transfer_not_starts_with_nocase: String
  transfer_ends_with: String
  transfer_ends_with_nocase: String
  transfer_not_ends_with: String
  transfer_not_ends_with_nocase: String
  transfer_: mantle_DestinationTransfer_filter
  slippage: BigInt
  slippage_not: BigInt
  slippage_gt: BigInt
  slippage_lt: BigInt
  slippage_gte: BigInt
  slippage_lte: BigInt
  slippage_in: [BigInt!]
  slippage_not_in: [BigInt!]
  caller: mantle_Bytes
  caller_not: mantle_Bytes
  caller_gt: mantle_Bytes
  caller_lt: mantle_Bytes
  caller_gte: mantle_Bytes
  caller_lte: mantle_Bytes
  caller_in: [mantle_Bytes!]
  caller_not_in: [mantle_Bytes!]
  caller_contains: mantle_Bytes
  caller_not_contains: mantle_Bytes
  transactionHash: mantle_Bytes
  transactionHash_not: mantle_Bytes
  transactionHash_gt: mantle_Bytes
  transactionHash_lt: mantle_Bytes
  transactionHash_gte: mantle_Bytes
  transactionHash_lte: mantle_Bytes
  transactionHash_in: [mantle_Bytes!]
  transactionHash_not_in: [mantle_Bytes!]
  transactionHash_contains: mantle_Bytes
  transactionHash_not_contains: mantle_Bytes
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  gasLimit: BigInt
  gasLimit_not: BigInt
  gasLimit_gt: BigInt
  gasLimit_lt: BigInt
  gasLimit_gte: BigInt
  gasLimit_lte: BigInt
  gasLimit_in: [BigInt!]
  gasLimit_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: mantle_BlockChangedFilter
  and: [mantle_SlippageUpdate_filter]
  or: [mantle_SlippageUpdate_filter]
}

enum mantle_SlippageUpdate_orderBy {
  id
  transfer
  transfer__id
  transfer__chainId
  transfer__transferId
  transfer__nonce
  transfer__status
  transfer__originDomain
  transfer__destinationDomain
  transfer__canonicalDomain
  transfer__to
  transfer__delegate
  transfer__receiveLocal
  transfer__callData
  transfer__slippage
  transfer__bumpSlippageCount
  transfer__originSender
  transfer__bridgedAmt
  transfer__normalizedIn
  transfer__canonicalId
  transfer__amount
  transfer__routersFee
  transfer__executedCaller
  transfer__executedTransactionHash
  transfer__executedTimestamp
  transfer__executedGasPrice
  transfer__executedGasLimit
  transfer__executedBlockNumber
  transfer__executedTxOrigin
  transfer__executedTxNonce
  transfer__reconciledCaller
  transfer__reconciledTransactionHash
  transfer__reconciledTimestamp
  transfer__reconciledGasPrice
  transfer__reconciledGasLimit
  transfer__reconciledBlockNumber
  transfer__reconciledTxOrigin
  transfer__reconciledTxNonce
  slippage
  caller
  transactionHash
  timestamp
  gasPrice
  gasLimit
  blockNumber
}

type mantle_SnapshotRoot {
  id: ID!
  spokeDomain: BigInt
  root: mantle_Bytes!
  count: BigInt!
  timestamp: BigInt!
  blockNumber: BigInt!
}

input mantle_SnapshotRoot_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  spokeDomain: BigInt
  spokeDomain_not: BigInt
  spokeDomain_gt: BigInt
  spokeDomain_lt: BigInt
  spokeDomain_gte: BigInt
  spokeDomain_lte: BigInt
  spokeDomain_in: [BigInt!]
  spokeDomain_not_in: [BigInt!]
  root: mantle_Bytes
  root_not: mantle_Bytes
  root_gt: mantle_Bytes
  root_lt: mantle_Bytes
  root_gte: mantle_Bytes
  root_lte: mantle_Bytes
  root_in: [mantle_Bytes!]
  root_not_in: [mantle_Bytes!]
  root_contains: mantle_Bytes
  root_not_contains: mantle_Bytes
  count: BigInt
  count_not: BigInt
  count_gt: BigInt
  count_lt: BigInt
  count_gte: BigInt
  count_lte: BigInt
  count_in: [BigInt!]
  count_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: mantle_BlockChangedFilter
  and: [mantle_SnapshotRoot_filter]
  or: [mantle_SnapshotRoot_filter]
}

enum mantle_SnapshotRoot_orderBy {
  id
  spokeDomain
  root
  count
  timestamp
  blockNumber
}

type mantle_SpokeConnectorMode {
  id: ID!
  mode: String!
}

input mantle_SpokeConnectorMode_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  mode: String
  mode_not: String
  mode_gt: String
  mode_lt: String
  mode_gte: String
  mode_lte: String
  mode_in: [String!]
  mode_not_in: [String!]
  mode_contains: String
  mode_contains_nocase: String
  mode_not_contains: String
  mode_not_contains_nocase: String
  mode_starts_with: String
  mode_starts_with_nocase: String
  mode_not_starts_with: String
  mode_not_starts_with_nocase: String
  mode_ends_with: String
  mode_ends_with_nocase: String
  mode_not_ends_with: String
  mode_not_ends_with_nocase: String
  """Filter for the block changed event."""
  _change_block: mantle_BlockChangedFilter
  and: [mantle_SpokeConnectorMode_filter]
  or: [mantle_SpokeConnectorMode_filter]
}

enum mantle_SpokeConnectorMode_orderBy {
  id
  mode
}

enum mantle_TransferStatus {
  XCalled
  Executed
  Reconciled
  CompletedSlow
  CompletedFast
}

type mantle__Block_ {
  """The hash of the block"""
  hash: mantle_Bytes
  """The block number"""
  number: Int!
  """Integer representation of the timestamp stored in blocks for the chain"""
  timestamp: Int
  """The hash of the parent block"""
  parentHash: mantle_Bytes
}

"""The type for the top-level _meta field"""
type mantle__Meta_ {
  """
  Information about a specific subgraph block. The hash of the block
  will be null if the _meta field has a block constraint that asks for
  a block number. It will be filled if the _meta field has no block constraint
  and therefore asks for the latest  block
  
  """
  block: mantle__Block_!
  """The deployment ID"""
  deployment: String!
  """If `true`, the subgraph encountered indexing errors at some past block"""
  hasIndexingErrors: Boolean!
}

type xlayer_AggregateRoot {
  id: ID!
  root: xlayer_Bytes!
  blockNumber: BigInt!
}

type xlayer_AggregateRootProposed {
  id: ID!
  aggregateRoot: xlayer_Bytes!
  rootTimestamp: BigInt!
  endOfDispute: BigInt!
  domain: BigInt!
  timestamp: BigInt!
  blockNumber: BigInt
}

input xlayer_AggregateRootProposed_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  aggregateRoot: xlayer_Bytes
  aggregateRoot_not: xlayer_Bytes
  aggregateRoot_gt: xlayer_Bytes
  aggregateRoot_lt: xlayer_Bytes
  aggregateRoot_gte: xlayer_Bytes
  aggregateRoot_lte: xlayer_Bytes
  aggregateRoot_in: [xlayer_Bytes!]
  aggregateRoot_not_in: [xlayer_Bytes!]
  aggregateRoot_contains: xlayer_Bytes
  aggregateRoot_not_contains: xlayer_Bytes
  rootTimestamp: BigInt
  rootTimestamp_not: BigInt
  rootTimestamp_gt: BigInt
  rootTimestamp_lt: BigInt
  rootTimestamp_gte: BigInt
  rootTimestamp_lte: BigInt
  rootTimestamp_in: [BigInt!]
  rootTimestamp_not_in: [BigInt!]
  endOfDispute: BigInt
  endOfDispute_not: BigInt
  endOfDispute_gt: BigInt
  endOfDispute_lt: BigInt
  endOfDispute_gte: BigInt
  endOfDispute_lte: BigInt
  endOfDispute_in: [BigInt!]
  endOfDispute_not_in: [BigInt!]
  domain: BigInt
  domain_not: BigInt
  domain_gt: BigInt
  domain_lt: BigInt
  domain_gte: BigInt
  domain_lte: BigInt
  domain_in: [BigInt!]
  domain_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: xlayer_BlockChangedFilter
  and: [xlayer_AggregateRootProposed_filter]
  or: [xlayer_AggregateRootProposed_filter]
}

enum xlayer_AggregateRootProposed_orderBy {
  id
  aggregateRoot
  rootTimestamp
  endOfDispute
  domain
  timestamp
  blockNumber
}

input xlayer_AggregateRoot_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  root: xlayer_Bytes
  root_not: xlayer_Bytes
  root_gt: xlayer_Bytes
  root_lt: xlayer_Bytes
  root_gte: xlayer_Bytes
  root_lte: xlayer_Bytes
  root_in: [xlayer_Bytes!]
  root_not_in: [xlayer_Bytes!]
  root_contains: xlayer_Bytes
  root_not_contains: xlayer_Bytes
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: xlayer_BlockChangedFilter
  and: [xlayer_AggregateRoot_filter]
  or: [xlayer_AggregateRoot_filter]
}

enum xlayer_AggregateRoot_orderBy {
  id
  root
  blockNumber
}

enum xlayer_Aggregation_interval {
  hour
  day
}

type xlayer_Asset {
  id: ID!
  key: xlayer_Bytes
  decimal: BigInt
  adoptedDecimal: BigInt
  canonicalId: xlayer_Bytes
  canonicalDomain: BigInt
  adoptedAsset: xlayer_Bytes
  localAsset: xlayer_Bytes
  blockNumber: BigInt
  status: xlayer_AssetStatus
}

type xlayer_AssetBalance {
  id: ID!
  amount: BigInt!
  locked: BigInt!
  supplied: BigInt!
  removed: BigInt!
  router: xlayer_Router!
  asset: xlayer_Asset!
  feesEarned: BigInt!
}

input xlayer_AssetBalance_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  locked: BigInt
  locked_not: BigInt
  locked_gt: BigInt
  locked_lt: BigInt
  locked_gte: BigInt
  locked_lte: BigInt
  locked_in: [BigInt!]
  locked_not_in: [BigInt!]
  supplied: BigInt
  supplied_not: BigInt
  supplied_gt: BigInt
  supplied_lt: BigInt
  supplied_gte: BigInt
  supplied_lte: BigInt
  supplied_in: [BigInt!]
  supplied_not_in: [BigInt!]
  removed: BigInt
  removed_not: BigInt
  removed_gt: BigInt
  removed_lt: BigInt
  removed_gte: BigInt
  removed_lte: BigInt
  removed_in: [BigInt!]
  removed_not_in: [BigInt!]
  router: String
  router_not: String
  router_gt: String
  router_lt: String
  router_gte: String
  router_lte: String
  router_in: [String!]
  router_not_in: [String!]
  router_contains: String
  router_contains_nocase: String
  router_not_contains: String
  router_not_contains_nocase: String
  router_starts_with: String
  router_starts_with_nocase: String
  router_not_starts_with: String
  router_not_starts_with_nocase: String
  router_ends_with: String
  router_ends_with_nocase: String
  router_not_ends_with: String
  router_not_ends_with_nocase: String
  router_: xlayer_Router_filter
  asset: String
  asset_not: String
  asset_gt: String
  asset_lt: String
  asset_gte: String
  asset_lte: String
  asset_in: [String!]
  asset_not_in: [String!]
  asset_contains: String
  asset_contains_nocase: String
  asset_not_contains: String
  asset_not_contains_nocase: String
  asset_starts_with: String
  asset_starts_with_nocase: String
  asset_not_starts_with: String
  asset_not_starts_with_nocase: String
  asset_ends_with: String
  asset_ends_with_nocase: String
  asset_not_ends_with: String
  asset_not_ends_with_nocase: String
  asset_: xlayer_Asset_filter
  feesEarned: BigInt
  feesEarned_not: BigInt
  feesEarned_gt: BigInt
  feesEarned_lt: BigInt
  feesEarned_gte: BigInt
  feesEarned_lte: BigInt
  feesEarned_in: [BigInt!]
  feesEarned_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: xlayer_BlockChangedFilter
  and: [xlayer_AssetBalance_filter]
  or: [xlayer_AssetBalance_filter]
}

enum xlayer_AssetBalance_orderBy {
  id
  amount
  locked
  supplied
  removed
  router
  router__id
  router__isActive
  router__owner
  router__recipient
  router__proposedOwner
  router__proposedTimestamp
  asset
  asset__id
  asset__key
  asset__decimal
  asset__adoptedDecimal
  asset__canonicalId
  asset__canonicalDomain
  asset__adoptedAsset
  asset__localAsset
  asset__blockNumber
  feesEarned
}

type xlayer_AssetStatus {
  id: ID!
  status: Boolean
}

input xlayer_AssetStatus_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  status: Boolean
  status_not: Boolean
  status_in: [Boolean!]
  status_not_in: [Boolean!]
  """Filter for the block changed event."""
  _change_block: xlayer_BlockChangedFilter
  and: [xlayer_AssetStatus_filter]
  or: [xlayer_AssetStatus_filter]
}

enum xlayer_AssetStatus_orderBy {
  id
  status
}

input xlayer_Asset_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  key: xlayer_Bytes
  key_not: xlayer_Bytes
  key_gt: xlayer_Bytes
  key_lt: xlayer_Bytes
  key_gte: xlayer_Bytes
  key_lte: xlayer_Bytes
  key_in: [xlayer_Bytes!]
  key_not_in: [xlayer_Bytes!]
  key_contains: xlayer_Bytes
  key_not_contains: xlayer_Bytes
  decimal: BigInt
  decimal_not: BigInt
  decimal_gt: BigInt
  decimal_lt: BigInt
  decimal_gte: BigInt
  decimal_lte: BigInt
  decimal_in: [BigInt!]
  decimal_not_in: [BigInt!]
  adoptedDecimal: BigInt
  adoptedDecimal_not: BigInt
  adoptedDecimal_gt: BigInt
  adoptedDecimal_lt: BigInt
  adoptedDecimal_gte: BigInt
  adoptedDecimal_lte: BigInt
  adoptedDecimal_in: [BigInt!]
  adoptedDecimal_not_in: [BigInt!]
  canonicalId: xlayer_Bytes
  canonicalId_not: xlayer_Bytes
  canonicalId_gt: xlayer_Bytes
  canonicalId_lt: xlayer_Bytes
  canonicalId_gte: xlayer_Bytes
  canonicalId_lte: xlayer_Bytes
  canonicalId_in: [xlayer_Bytes!]
  canonicalId_not_in: [xlayer_Bytes!]
  canonicalId_contains: xlayer_Bytes
  canonicalId_not_contains: xlayer_Bytes
  canonicalDomain: BigInt
  canonicalDomain_not: BigInt
  canonicalDomain_gt: BigInt
  canonicalDomain_lt: BigInt
  canonicalDomain_gte: BigInt
  canonicalDomain_lte: BigInt
  canonicalDomain_in: [BigInt!]
  canonicalDomain_not_in: [BigInt!]
  adoptedAsset: xlayer_Bytes
  adoptedAsset_not: xlayer_Bytes
  adoptedAsset_gt: xlayer_Bytes
  adoptedAsset_lt: xlayer_Bytes
  adoptedAsset_gte: xlayer_Bytes
  adoptedAsset_lte: xlayer_Bytes
  adoptedAsset_in: [xlayer_Bytes!]
  adoptedAsset_not_in: [xlayer_Bytes!]
  adoptedAsset_contains: xlayer_Bytes
  adoptedAsset_not_contains: xlayer_Bytes
  localAsset: xlayer_Bytes
  localAsset_not: xlayer_Bytes
  localAsset_gt: xlayer_Bytes
  localAsset_lt: xlayer_Bytes
  localAsset_gte: xlayer_Bytes
  localAsset_lte: xlayer_Bytes
  localAsset_in: [xlayer_Bytes!]
  localAsset_not_in: [xlayer_Bytes!]
  localAsset_contains: xlayer_Bytes
  localAsset_not_contains: xlayer_Bytes
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  status: String
  status_not: String
  status_gt: String
  status_lt: String
  status_gte: String
  status_lte: String
  status_in: [String!]
  status_not_in: [String!]
  status_contains: String
  status_contains_nocase: String
  status_not_contains: String
  status_not_contains_nocase: String
  status_starts_with: String
  status_starts_with_nocase: String
  status_not_starts_with: String
  status_not_starts_with_nocase: String
  status_ends_with: String
  status_ends_with_nocase: String
  status_not_ends_with: String
  status_not_ends_with_nocase: String
  status_: xlayer_AssetStatus_filter
  """Filter for the block changed event."""
  _change_block: xlayer_BlockChangedFilter
  and: [xlayer_Asset_filter]
  or: [xlayer_Asset_filter]
}

enum xlayer_Asset_orderBy {
  id
  key
  decimal
  adoptedDecimal
  canonicalId
  canonicalDomain
  adoptedAsset
  localAsset
  blockNumber
  status
  status__id
  status__status
}

scalar xlayer_BigDecimal

input xlayer_BlockChangedFilter {
  number_gte: Int!
}

input xlayer_Block_height {
  hash: xlayer_Bytes
  number: Int
  number_gte: Int
}

scalar xlayer_Bytes

type xlayer_ConnectorMeta {
  id: ID!
  spokeDomain: BigInt
  hubDomain: BigInt
  amb: xlayer_Bytes
  rootManager: xlayer_Bytes
  mirrorConnector: xlayer_Bytes
}

input xlayer_ConnectorMeta_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  spokeDomain: BigInt
  spokeDomain_not: BigInt
  spokeDomain_gt: BigInt
  spokeDomain_lt: BigInt
  spokeDomain_gte: BigInt
  spokeDomain_lte: BigInt
  spokeDomain_in: [BigInt!]
  spokeDomain_not_in: [BigInt!]
  hubDomain: BigInt
  hubDomain_not: BigInt
  hubDomain_gt: BigInt
  hubDomain_lt: BigInt
  hubDomain_gte: BigInt
  hubDomain_lte: BigInt
  hubDomain_in: [BigInt!]
  hubDomain_not_in: [BigInt!]
  amb: xlayer_Bytes
  amb_not: xlayer_Bytes
  amb_gt: xlayer_Bytes
  amb_lt: xlayer_Bytes
  amb_gte: xlayer_Bytes
  amb_lte: xlayer_Bytes
  amb_in: [xlayer_Bytes!]
  amb_not_in: [xlayer_Bytes!]
  amb_contains: xlayer_Bytes
  amb_not_contains: xlayer_Bytes
  rootManager: xlayer_Bytes
  rootManager_not: xlayer_Bytes
  rootManager_gt: xlayer_Bytes
  rootManager_lt: xlayer_Bytes
  rootManager_gte: xlayer_Bytes
  rootManager_lte: xlayer_Bytes
  rootManager_in: [xlayer_Bytes!]
  rootManager_not_in: [xlayer_Bytes!]
  rootManager_contains: xlayer_Bytes
  rootManager_not_contains: xlayer_Bytes
  mirrorConnector: xlayer_Bytes
  mirrorConnector_not: xlayer_Bytes
  mirrorConnector_gt: xlayer_Bytes
  mirrorConnector_lt: xlayer_Bytes
  mirrorConnector_gte: xlayer_Bytes
  mirrorConnector_lte: xlayer_Bytes
  mirrorConnector_in: [xlayer_Bytes!]
  mirrorConnector_not_in: [xlayer_Bytes!]
  mirrorConnector_contains: xlayer_Bytes
  mirrorConnector_not_contains: xlayer_Bytes
  """Filter for the block changed event."""
  _change_block: xlayer_BlockChangedFilter
  and: [xlayer_ConnectorMeta_filter]
  or: [xlayer_ConnectorMeta_filter]
}

enum xlayer_ConnectorMeta_orderBy {
  id
  spokeDomain
  hubDomain
  amb
  rootManager
  mirrorConnector
}

type xlayer_DestinationTransfer {
  id: ID!
  chainId: BigInt
  transferId: xlayer_Bytes
  nonce: BigInt
  status: xlayer_TransferStatus
  routers(skip: Int = 0, first: Int = 100, orderBy: xlayer_Router_orderBy, orderDirection: xlayer_OrderDirection, where: xlayer_Router_filter): [xlayer_Router!]
  originDomain: BigInt
  destinationDomain: BigInt
  canonicalDomain: BigInt
  to: xlayer_Bytes
  delegate: xlayer_Bytes
  receiveLocal: Boolean
  callData: xlayer_Bytes
  slippage: BigInt
  bumpSlippageCount: BigInt
  originSender: xlayer_Bytes
  bridgedAmt: BigInt
  normalizedIn: BigInt
  canonicalId: xlayer_Bytes
  asset: xlayer_Asset
  amount: BigInt
  routersFee: BigInt
  executedCaller: xlayer_Bytes
  executedTransactionHash: xlayer_Bytes
  executedTimestamp: BigInt
  executedGasPrice: BigInt
  executedGasLimit: BigInt
  executedBlockNumber: BigInt
  executedTxOrigin: xlayer_Bytes
  executedTxNonce: BigInt
  reconciledCaller: xlayer_Bytes
  reconciledTransactionHash: xlayer_Bytes
  reconciledTimestamp: BigInt
  reconciledGasPrice: BigInt
  reconciledGasLimit: BigInt
  reconciledBlockNumber: BigInt
  reconciledTxOrigin: xlayer_Bytes
  reconciledTxNonce: BigInt
}

input xlayer_DestinationTransfer_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  chainId: BigInt
  chainId_not: BigInt
  chainId_gt: BigInt
  chainId_lt: BigInt
  chainId_gte: BigInt
  chainId_lte: BigInt
  chainId_in: [BigInt!]
  chainId_not_in: [BigInt!]
  transferId: xlayer_Bytes
  transferId_not: xlayer_Bytes
  transferId_gt: xlayer_Bytes
  transferId_lt: xlayer_Bytes
  transferId_gte: xlayer_Bytes
  transferId_lte: xlayer_Bytes
  transferId_in: [xlayer_Bytes!]
  transferId_not_in: [xlayer_Bytes!]
  transferId_contains: xlayer_Bytes
  transferId_not_contains: xlayer_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  status: xlayer_TransferStatus
  status_not: xlayer_TransferStatus
  status_in: [xlayer_TransferStatus!]
  status_not_in: [xlayer_TransferStatus!]
  routers: [String!]
  routers_not: [String!]
  routers_contains: [String!]
  routers_contains_nocase: [String!]
  routers_not_contains: [String!]
  routers_not_contains_nocase: [String!]
  routers_: xlayer_Router_filter
  originDomain: BigInt
  originDomain_not: BigInt
  originDomain_gt: BigInt
  originDomain_lt: BigInt
  originDomain_gte: BigInt
  originDomain_lte: BigInt
  originDomain_in: [BigInt!]
  originDomain_not_in: [BigInt!]
  destinationDomain: BigInt
  destinationDomain_not: BigInt
  destinationDomain_gt: BigInt
  destinationDomain_lt: BigInt
  destinationDomain_gte: BigInt
  destinationDomain_lte: BigInt
  destinationDomain_in: [BigInt!]
  destinationDomain_not_in: [BigInt!]
  canonicalDomain: BigInt
  canonicalDomain_not: BigInt
  canonicalDomain_gt: BigInt
  canonicalDomain_lt: BigInt
  canonicalDomain_gte: BigInt
  canonicalDomain_lte: BigInt
  canonicalDomain_in: [BigInt!]
  canonicalDomain_not_in: [BigInt!]
  to: xlayer_Bytes
  to_not: xlayer_Bytes
  to_gt: xlayer_Bytes
  to_lt: xlayer_Bytes
  to_gte: xlayer_Bytes
  to_lte: xlayer_Bytes
  to_in: [xlayer_Bytes!]
  to_not_in: [xlayer_Bytes!]
  to_contains: xlayer_Bytes
  to_not_contains: xlayer_Bytes
  delegate: xlayer_Bytes
  delegate_not: xlayer_Bytes
  delegate_gt: xlayer_Bytes
  delegate_lt: xlayer_Bytes
  delegate_gte: xlayer_Bytes
  delegate_lte: xlayer_Bytes
  delegate_in: [xlayer_Bytes!]
  delegate_not_in: [xlayer_Bytes!]
  delegate_contains: xlayer_Bytes
  delegate_not_contains: xlayer_Bytes
  receiveLocal: Boolean
  receiveLocal_not: Boolean
  receiveLocal_in: [Boolean!]
  receiveLocal_not_in: [Boolean!]
  callData: xlayer_Bytes
  callData_not: xlayer_Bytes
  callData_gt: xlayer_Bytes
  callData_lt: xlayer_Bytes
  callData_gte: xlayer_Bytes
  callData_lte: xlayer_Bytes
  callData_in: [xlayer_Bytes!]
  callData_not_in: [xlayer_Bytes!]
  callData_contains: xlayer_Bytes
  callData_not_contains: xlayer_Bytes
  slippage: BigInt
  slippage_not: BigInt
  slippage_gt: BigInt
  slippage_lt: BigInt
  slippage_gte: BigInt
  slippage_lte: BigInt
  slippage_in: [BigInt!]
  slippage_not_in: [BigInt!]
  bumpSlippageCount: BigInt
  bumpSlippageCount_not: BigInt
  bumpSlippageCount_gt: BigInt
  bumpSlippageCount_lt: BigInt
  bumpSlippageCount_gte: BigInt
  bumpSlippageCount_lte: BigInt
  bumpSlippageCount_in: [BigInt!]
  bumpSlippageCount_not_in: [BigInt!]
  originSender: xlayer_Bytes
  originSender_not: xlayer_Bytes
  originSender_gt: xlayer_Bytes
  originSender_lt: xlayer_Bytes
  originSender_gte: xlayer_Bytes
  originSender_lte: xlayer_Bytes
  originSender_in: [xlayer_Bytes!]
  originSender_not_in: [xlayer_Bytes!]
  originSender_contains: xlayer_Bytes
  originSender_not_contains: xlayer_Bytes
  bridgedAmt: BigInt
  bridgedAmt_not: BigInt
  bridgedAmt_gt: BigInt
  bridgedAmt_lt: BigInt
  bridgedAmt_gte: BigInt
  bridgedAmt_lte: BigInt
  bridgedAmt_in: [BigInt!]
  bridgedAmt_not_in: [BigInt!]
  normalizedIn: BigInt
  normalizedIn_not: BigInt
  normalizedIn_gt: BigInt
  normalizedIn_lt: BigInt
  normalizedIn_gte: BigInt
  normalizedIn_lte: BigInt
  normalizedIn_in: [BigInt!]
  normalizedIn_not_in: [BigInt!]
  canonicalId: xlayer_Bytes
  canonicalId_not: xlayer_Bytes
  canonicalId_gt: xlayer_Bytes
  canonicalId_lt: xlayer_Bytes
  canonicalId_gte: xlayer_Bytes
  canonicalId_lte: xlayer_Bytes
  canonicalId_in: [xlayer_Bytes!]
  canonicalId_not_in: [xlayer_Bytes!]
  canonicalId_contains: xlayer_Bytes
  canonicalId_not_contains: xlayer_Bytes
  asset: String
  asset_not: String
  asset_gt: String
  asset_lt: String
  asset_gte: String
  asset_lte: String
  asset_in: [String!]
  asset_not_in: [String!]
  asset_contains: String
  asset_contains_nocase: String
  asset_not_contains: String
  asset_not_contains_nocase: String
  asset_starts_with: String
  asset_starts_with_nocase: String
  asset_not_starts_with: String
  asset_not_starts_with_nocase: String
  asset_ends_with: String
  asset_ends_with_nocase: String
  asset_not_ends_with: String
  asset_not_ends_with_nocase: String
  asset_: xlayer_Asset_filter
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  routersFee: BigInt
  routersFee_not: BigInt
  routersFee_gt: BigInt
  routersFee_lt: BigInt
  routersFee_gte: BigInt
  routersFee_lte: BigInt
  routersFee_in: [BigInt!]
  routersFee_not_in: [BigInt!]
  executedCaller: xlayer_Bytes
  executedCaller_not: xlayer_Bytes
  executedCaller_gt: xlayer_Bytes
  executedCaller_lt: xlayer_Bytes
  executedCaller_gte: xlayer_Bytes
  executedCaller_lte: xlayer_Bytes
  executedCaller_in: [xlayer_Bytes!]
  executedCaller_not_in: [xlayer_Bytes!]
  executedCaller_contains: xlayer_Bytes
  executedCaller_not_contains: xlayer_Bytes
  executedTransactionHash: xlayer_Bytes
  executedTransactionHash_not: xlayer_Bytes
  executedTransactionHash_gt: xlayer_Bytes
  executedTransactionHash_lt: xlayer_Bytes
  executedTransactionHash_gte: xlayer_Bytes
  executedTransactionHash_lte: xlayer_Bytes
  executedTransactionHash_in: [xlayer_Bytes!]
  executedTransactionHash_not_in: [xlayer_Bytes!]
  executedTransactionHash_contains: xlayer_Bytes
  executedTransactionHash_not_contains: xlayer_Bytes
  executedTimestamp: BigInt
  executedTimestamp_not: BigInt
  executedTimestamp_gt: BigInt
  executedTimestamp_lt: BigInt
  executedTimestamp_gte: BigInt
  executedTimestamp_lte: BigInt
  executedTimestamp_in: [BigInt!]
  executedTimestamp_not_in: [BigInt!]
  executedGasPrice: BigInt
  executedGasPrice_not: BigInt
  executedGasPrice_gt: BigInt
  executedGasPrice_lt: BigInt
  executedGasPrice_gte: BigInt
  executedGasPrice_lte: BigInt
  executedGasPrice_in: [BigInt!]
  executedGasPrice_not_in: [BigInt!]
  executedGasLimit: BigInt
  executedGasLimit_not: BigInt
  executedGasLimit_gt: BigInt
  executedGasLimit_lt: BigInt
  executedGasLimit_gte: BigInt
  executedGasLimit_lte: BigInt
  executedGasLimit_in: [BigInt!]
  executedGasLimit_not_in: [BigInt!]
  executedBlockNumber: BigInt
  executedBlockNumber_not: BigInt
  executedBlockNumber_gt: BigInt
  executedBlockNumber_lt: BigInt
  executedBlockNumber_gte: BigInt
  executedBlockNumber_lte: BigInt
  executedBlockNumber_in: [BigInt!]
  executedBlockNumber_not_in: [BigInt!]
  executedTxOrigin: xlayer_Bytes
  executedTxOrigin_not: xlayer_Bytes
  executedTxOrigin_gt: xlayer_Bytes
  executedTxOrigin_lt: xlayer_Bytes
  executedTxOrigin_gte: xlayer_Bytes
  executedTxOrigin_lte: xlayer_Bytes
  executedTxOrigin_in: [xlayer_Bytes!]
  executedTxOrigin_not_in: [xlayer_Bytes!]
  executedTxOrigin_contains: xlayer_Bytes
  executedTxOrigin_not_contains: xlayer_Bytes
  executedTxNonce: BigInt
  executedTxNonce_not: BigInt
  executedTxNonce_gt: BigInt
  executedTxNonce_lt: BigInt
  executedTxNonce_gte: BigInt
  executedTxNonce_lte: BigInt
  executedTxNonce_in: [BigInt!]
  executedTxNonce_not_in: [BigInt!]
  reconciledCaller: xlayer_Bytes
  reconciledCaller_not: xlayer_Bytes
  reconciledCaller_gt: xlayer_Bytes
  reconciledCaller_lt: xlayer_Bytes
  reconciledCaller_gte: xlayer_Bytes
  reconciledCaller_lte: xlayer_Bytes
  reconciledCaller_in: [xlayer_Bytes!]
  reconciledCaller_not_in: [xlayer_Bytes!]
  reconciledCaller_contains: xlayer_Bytes
  reconciledCaller_not_contains: xlayer_Bytes
  reconciledTransactionHash: xlayer_Bytes
  reconciledTransactionHash_not: xlayer_Bytes
  reconciledTransactionHash_gt: xlayer_Bytes
  reconciledTransactionHash_lt: xlayer_Bytes
  reconciledTransactionHash_gte: xlayer_Bytes
  reconciledTransactionHash_lte: xlayer_Bytes
  reconciledTransactionHash_in: [xlayer_Bytes!]
  reconciledTransactionHash_not_in: [xlayer_Bytes!]
  reconciledTransactionHash_contains: xlayer_Bytes
  reconciledTransactionHash_not_contains: xlayer_Bytes
  reconciledTimestamp: BigInt
  reconciledTimestamp_not: BigInt
  reconciledTimestamp_gt: BigInt
  reconciledTimestamp_lt: BigInt
  reconciledTimestamp_gte: BigInt
  reconciledTimestamp_lte: BigInt
  reconciledTimestamp_in: [BigInt!]
  reconciledTimestamp_not_in: [BigInt!]
  reconciledGasPrice: BigInt
  reconciledGasPrice_not: BigInt
  reconciledGasPrice_gt: BigInt
  reconciledGasPrice_lt: BigInt
  reconciledGasPrice_gte: BigInt
  reconciledGasPrice_lte: BigInt
  reconciledGasPrice_in: [BigInt!]
  reconciledGasPrice_not_in: [BigInt!]
  reconciledGasLimit: BigInt
  reconciledGasLimit_not: BigInt
  reconciledGasLimit_gt: BigInt
  reconciledGasLimit_lt: BigInt
  reconciledGasLimit_gte: BigInt
  reconciledGasLimit_lte: BigInt
  reconciledGasLimit_in: [BigInt!]
  reconciledGasLimit_not_in: [BigInt!]
  reconciledBlockNumber: BigInt
  reconciledBlockNumber_not: BigInt
  reconciledBlockNumber_gt: BigInt
  reconciledBlockNumber_lt: BigInt
  reconciledBlockNumber_gte: BigInt
  reconciledBlockNumber_lte: BigInt
  reconciledBlockNumber_in: [BigInt!]
  reconciledBlockNumber_not_in: [BigInt!]
  reconciledTxOrigin: xlayer_Bytes
  reconciledTxOrigin_not: xlayer_Bytes
  reconciledTxOrigin_gt: xlayer_Bytes
  reconciledTxOrigin_lt: xlayer_Bytes
  reconciledTxOrigin_gte: xlayer_Bytes
  reconciledTxOrigin_lte: xlayer_Bytes
  reconciledTxOrigin_in: [xlayer_Bytes!]
  reconciledTxOrigin_not_in: [xlayer_Bytes!]
  reconciledTxOrigin_contains: xlayer_Bytes
  reconciledTxOrigin_not_contains: xlayer_Bytes
  reconciledTxNonce: BigInt
  reconciledTxNonce_not: BigInt
  reconciledTxNonce_gt: BigInt
  reconciledTxNonce_lt: BigInt
  reconciledTxNonce_gte: BigInt
  reconciledTxNonce_lte: BigInt
  reconciledTxNonce_in: [BigInt!]
  reconciledTxNonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: xlayer_BlockChangedFilter
  and: [xlayer_DestinationTransfer_filter]
  or: [xlayer_DestinationTransfer_filter]
}

enum xlayer_DestinationTransfer_orderBy {
  id
  chainId
  transferId
  nonce
  status
  routers
  originDomain
  destinationDomain
  canonicalDomain
  to
  delegate
  receiveLocal
  callData
  slippage
  bumpSlippageCount
  originSender
  bridgedAmt
  normalizedIn
  canonicalId
  asset
  asset__id
  asset__key
  asset__decimal
  asset__adoptedDecimal
  asset__canonicalId
  asset__canonicalDomain
  asset__adoptedAsset
  asset__localAsset
  asset__blockNumber
  amount
  routersFee
  executedCaller
  executedTransactionHash
  executedTimestamp
  executedGasPrice
  executedGasLimit
  executedBlockNumber
  executedTxOrigin
  executedTxNonce
  reconciledCaller
  reconciledTransactionHash
  reconciledTimestamp
  reconciledGasPrice
  reconciledGasLimit
  reconciledBlockNumber
  reconciledTxOrigin
  reconciledTxNonce
}

"""
8 bytes signed integer

"""
scalar xlayer_Int8

type xlayer_OptimisticRootFinalized {
  id: ID!
  aggregateRoot: xlayer_Bytes!
  timestamp: BigInt!
  blockNumber: BigInt
}

input xlayer_OptimisticRootFinalized_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  aggregateRoot: xlayer_Bytes
  aggregateRoot_not: xlayer_Bytes
  aggregateRoot_gt: xlayer_Bytes
  aggregateRoot_lt: xlayer_Bytes
  aggregateRoot_gte: xlayer_Bytes
  aggregateRoot_lte: xlayer_Bytes
  aggregateRoot_in: [xlayer_Bytes!]
  aggregateRoot_not_in: [xlayer_Bytes!]
  aggregateRoot_contains: xlayer_Bytes
  aggregateRoot_not_contains: xlayer_Bytes
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: xlayer_BlockChangedFilter
  and: [xlayer_OptimisticRootFinalized_filter]
  or: [xlayer_OptimisticRootFinalized_filter]
}

enum xlayer_OptimisticRootFinalized_orderBy {
  id
  aggregateRoot
  timestamp
  blockNumber
}

"""Defines the order direction, either ascending or descending"""
enum xlayer_OrderDirection {
  asc
  desc
}

type xlayer_OriginMessage {
  id: ID!
  transferId: xlayer_Bytes
  destinationDomain: BigInt
  leaf: xlayer_Bytes
  index: BigInt
  message: xlayer_Bytes
  root: xlayer_Bytes
  transactionHash: xlayer_Bytes
  blockNumber: BigInt
  rootCount: xlayer_RootCount
}

input xlayer_OriginMessage_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transferId: xlayer_Bytes
  transferId_not: xlayer_Bytes
  transferId_gt: xlayer_Bytes
  transferId_lt: xlayer_Bytes
  transferId_gte: xlayer_Bytes
  transferId_lte: xlayer_Bytes
  transferId_in: [xlayer_Bytes!]
  transferId_not_in: [xlayer_Bytes!]
  transferId_contains: xlayer_Bytes
  transferId_not_contains: xlayer_Bytes
  destinationDomain: BigInt
  destinationDomain_not: BigInt
  destinationDomain_gt: BigInt
  destinationDomain_lt: BigInt
  destinationDomain_gte: BigInt
  destinationDomain_lte: BigInt
  destinationDomain_in: [BigInt!]
  destinationDomain_not_in: [BigInt!]
  leaf: xlayer_Bytes
  leaf_not: xlayer_Bytes
  leaf_gt: xlayer_Bytes
  leaf_lt: xlayer_Bytes
  leaf_gte: xlayer_Bytes
  leaf_lte: xlayer_Bytes
  leaf_in: [xlayer_Bytes!]
  leaf_not_in: [xlayer_Bytes!]
  leaf_contains: xlayer_Bytes
  leaf_not_contains: xlayer_Bytes
  index: BigInt
  index_not: BigInt
  index_gt: BigInt
  index_lt: BigInt
  index_gte: BigInt
  index_lte: BigInt
  index_in: [BigInt!]
  index_not_in: [BigInt!]
  message: xlayer_Bytes
  message_not: xlayer_Bytes
  message_gt: xlayer_Bytes
  message_lt: xlayer_Bytes
  message_gte: xlayer_Bytes
  message_lte: xlayer_Bytes
  message_in: [xlayer_Bytes!]
  message_not_in: [xlayer_Bytes!]
  message_contains: xlayer_Bytes
  message_not_contains: xlayer_Bytes
  root: xlayer_Bytes
  root_not: xlayer_Bytes
  root_gt: xlayer_Bytes
  root_lt: xlayer_Bytes
  root_gte: xlayer_Bytes
  root_lte: xlayer_Bytes
  root_in: [xlayer_Bytes!]
  root_not_in: [xlayer_Bytes!]
  root_contains: xlayer_Bytes
  root_not_contains: xlayer_Bytes
  transactionHash: xlayer_Bytes
  transactionHash_not: xlayer_Bytes
  transactionHash_gt: xlayer_Bytes
  transactionHash_lt: xlayer_Bytes
  transactionHash_gte: xlayer_Bytes
  transactionHash_lte: xlayer_Bytes
  transactionHash_in: [xlayer_Bytes!]
  transactionHash_not_in: [xlayer_Bytes!]
  transactionHash_contains: xlayer_Bytes
  transactionHash_not_contains: xlayer_Bytes
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  rootCount: String
  rootCount_not: String
  rootCount_gt: String
  rootCount_lt: String
  rootCount_gte: String
  rootCount_lte: String
  rootCount_in: [String!]
  rootCount_not_in: [String!]
  rootCount_contains: String
  rootCount_contains_nocase: String
  rootCount_not_contains: String
  rootCount_not_contains_nocase: String
  rootCount_starts_with: String
  rootCount_starts_with_nocase: String
  rootCount_not_starts_with: String
  rootCount_not_starts_with_nocase: String
  rootCount_ends_with: String
  rootCount_ends_with_nocase: String
  rootCount_not_ends_with: String
  rootCount_not_ends_with_nocase: String
  rootCount_: xlayer_RootCount_filter
  """Filter for the block changed event."""
  _change_block: xlayer_BlockChangedFilter
  and: [xlayer_OriginMessage_filter]
  or: [xlayer_OriginMessage_filter]
}

enum xlayer_OriginMessage_orderBy {
  id
  transferId
  destinationDomain
  leaf
  index
  message
  root
  transactionHash
  blockNumber
  rootCount
  rootCount__id
  rootCount__count
}

type xlayer_OriginTransfer {
  id: ID!
  chainId: BigInt
  transferId: xlayer_Bytes
  nonce: BigInt
  status: xlayer_TransferStatus
  messageHash: xlayer_Bytes
  originDomain: BigInt
  destinationDomain: BigInt
  canonicalDomain: BigInt
  to: xlayer_Bytes
  delegate: xlayer_Bytes
  receiveLocal: Boolean
  callData: xlayer_Bytes
  slippage: BigInt
  originSender: xlayer_Bytes
  bridgedAmt: BigInt
  normalizedIn: BigInt
  canonicalId: xlayer_Bytes
  asset: xlayer_Asset
  transactingAsset: xlayer_Bytes
  message: xlayer_OriginMessage
  bumpRelayerFeeCount: BigInt
  relayerFees(skip: Int = 0, first: Int = 100, orderBy: xlayer_RelayerFee_orderBy, orderDirection: xlayer_OrderDirection, where: xlayer_RelayerFee_filter): [xlayer_RelayerFee!]
  initialRelayerFeeAsset: xlayer_Bytes
  caller: xlayer_Bytes
  transactionHash: xlayer_Bytes
  timestamp: BigInt
  gasPrice: BigInt
  gasLimit: BigInt
  blockNumber: BigInt
  txOrigin: xlayer_Bytes
  txNonce: BigInt
}

input xlayer_OriginTransfer_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  chainId: BigInt
  chainId_not: BigInt
  chainId_gt: BigInt
  chainId_lt: BigInt
  chainId_gte: BigInt
  chainId_lte: BigInt
  chainId_in: [BigInt!]
  chainId_not_in: [BigInt!]
  transferId: xlayer_Bytes
  transferId_not: xlayer_Bytes
  transferId_gt: xlayer_Bytes
  transferId_lt: xlayer_Bytes
  transferId_gte: xlayer_Bytes
  transferId_lte: xlayer_Bytes
  transferId_in: [xlayer_Bytes!]
  transferId_not_in: [xlayer_Bytes!]
  transferId_contains: xlayer_Bytes
  transferId_not_contains: xlayer_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  status: xlayer_TransferStatus
  status_not: xlayer_TransferStatus
  status_in: [xlayer_TransferStatus!]
  status_not_in: [xlayer_TransferStatus!]
  messageHash: xlayer_Bytes
  messageHash_not: xlayer_Bytes
  messageHash_gt: xlayer_Bytes
  messageHash_lt: xlayer_Bytes
  messageHash_gte: xlayer_Bytes
  messageHash_lte: xlayer_Bytes
  messageHash_in: [xlayer_Bytes!]
  messageHash_not_in: [xlayer_Bytes!]
  messageHash_contains: xlayer_Bytes
  messageHash_not_contains: xlayer_Bytes
  originDomain: BigInt
  originDomain_not: BigInt
  originDomain_gt: BigInt
  originDomain_lt: BigInt
  originDomain_gte: BigInt
  originDomain_lte: BigInt
  originDomain_in: [BigInt!]
  originDomain_not_in: [BigInt!]
  destinationDomain: BigInt
  destinationDomain_not: BigInt
  destinationDomain_gt: BigInt
  destinationDomain_lt: BigInt
  destinationDomain_gte: BigInt
  destinationDomain_lte: BigInt
  destinationDomain_in: [BigInt!]
  destinationDomain_not_in: [BigInt!]
  canonicalDomain: BigInt
  canonicalDomain_not: BigInt
  canonicalDomain_gt: BigInt
  canonicalDomain_lt: BigInt
  canonicalDomain_gte: BigInt
  canonicalDomain_lte: BigInt
  canonicalDomain_in: [BigInt!]
  canonicalDomain_not_in: [BigInt!]
  to: xlayer_Bytes
  to_not: xlayer_Bytes
  to_gt: xlayer_Bytes
  to_lt: xlayer_Bytes
  to_gte: xlayer_Bytes
  to_lte: xlayer_Bytes
  to_in: [xlayer_Bytes!]
  to_not_in: [xlayer_Bytes!]
  to_contains: xlayer_Bytes
  to_not_contains: xlayer_Bytes
  delegate: xlayer_Bytes
  delegate_not: xlayer_Bytes
  delegate_gt: xlayer_Bytes
  delegate_lt: xlayer_Bytes
  delegate_gte: xlayer_Bytes
  delegate_lte: xlayer_Bytes
  delegate_in: [xlayer_Bytes!]
  delegate_not_in: [xlayer_Bytes!]
  delegate_contains: xlayer_Bytes
  delegate_not_contains: xlayer_Bytes
  receiveLocal: Boolean
  receiveLocal_not: Boolean
  receiveLocal_in: [Boolean!]
  receiveLocal_not_in: [Boolean!]
  callData: xlayer_Bytes
  callData_not: xlayer_Bytes
  callData_gt: xlayer_Bytes
  callData_lt: xlayer_Bytes
  callData_gte: xlayer_Bytes
  callData_lte: xlayer_Bytes
  callData_in: [xlayer_Bytes!]
  callData_not_in: [xlayer_Bytes!]
  callData_contains: xlayer_Bytes
  callData_not_contains: xlayer_Bytes
  slippage: BigInt
  slippage_not: BigInt
  slippage_gt: BigInt
  slippage_lt: BigInt
  slippage_gte: BigInt
  slippage_lte: BigInt
  slippage_in: [BigInt!]
  slippage_not_in: [BigInt!]
  originSender: xlayer_Bytes
  originSender_not: xlayer_Bytes
  originSender_gt: xlayer_Bytes
  originSender_lt: xlayer_Bytes
  originSender_gte: xlayer_Bytes
  originSender_lte: xlayer_Bytes
  originSender_in: [xlayer_Bytes!]
  originSender_not_in: [xlayer_Bytes!]
  originSender_contains: xlayer_Bytes
  originSender_not_contains: xlayer_Bytes
  bridgedAmt: BigInt
  bridgedAmt_not: BigInt
  bridgedAmt_gt: BigInt
  bridgedAmt_lt: BigInt
  bridgedAmt_gte: BigInt
  bridgedAmt_lte: BigInt
  bridgedAmt_in: [BigInt!]
  bridgedAmt_not_in: [BigInt!]
  normalizedIn: BigInt
  normalizedIn_not: BigInt
  normalizedIn_gt: BigInt
  normalizedIn_lt: BigInt
  normalizedIn_gte: BigInt
  normalizedIn_lte: BigInt
  normalizedIn_in: [BigInt!]
  normalizedIn_not_in: [BigInt!]
  canonicalId: xlayer_Bytes
  canonicalId_not: xlayer_Bytes
  canonicalId_gt: xlayer_Bytes
  canonicalId_lt: xlayer_Bytes
  canonicalId_gte: xlayer_Bytes
  canonicalId_lte: xlayer_Bytes
  canonicalId_in: [xlayer_Bytes!]
  canonicalId_not_in: [xlayer_Bytes!]
  canonicalId_contains: xlayer_Bytes
  canonicalId_not_contains: xlayer_Bytes
  asset: String
  asset_not: String
  asset_gt: String
  asset_lt: String
  asset_gte: String
  asset_lte: String
  asset_in: [String!]
  asset_not_in: [String!]
  asset_contains: String
  asset_contains_nocase: String
  asset_not_contains: String
  asset_not_contains_nocase: String
  asset_starts_with: String
  asset_starts_with_nocase: String
  asset_not_starts_with: String
  asset_not_starts_with_nocase: String
  asset_ends_with: String
  asset_ends_with_nocase: String
  asset_not_ends_with: String
  asset_not_ends_with_nocase: String
  asset_: xlayer_Asset_filter
  transactingAsset: xlayer_Bytes
  transactingAsset_not: xlayer_Bytes
  transactingAsset_gt: xlayer_Bytes
  transactingAsset_lt: xlayer_Bytes
  transactingAsset_gte: xlayer_Bytes
  transactingAsset_lte: xlayer_Bytes
  transactingAsset_in: [xlayer_Bytes!]
  transactingAsset_not_in: [xlayer_Bytes!]
  transactingAsset_contains: xlayer_Bytes
  transactingAsset_not_contains: xlayer_Bytes
  message: String
  message_not: String
  message_gt: String
  message_lt: String
  message_gte: String
  message_lte: String
  message_in: [String!]
  message_not_in: [String!]
  message_contains: String
  message_contains_nocase: String
  message_not_contains: String
  message_not_contains_nocase: String
  message_starts_with: String
  message_starts_with_nocase: String
  message_not_starts_with: String
  message_not_starts_with_nocase: String
  message_ends_with: String
  message_ends_with_nocase: String
  message_not_ends_with: String
  message_not_ends_with_nocase: String
  message_: xlayer_OriginMessage_filter
  bumpRelayerFeeCount: BigInt
  bumpRelayerFeeCount_not: BigInt
  bumpRelayerFeeCount_gt: BigInt
  bumpRelayerFeeCount_lt: BigInt
  bumpRelayerFeeCount_gte: BigInt
  bumpRelayerFeeCount_lte: BigInt
  bumpRelayerFeeCount_in: [BigInt!]
  bumpRelayerFeeCount_not_in: [BigInt!]
  relayerFees: [String!]
  relayerFees_not: [String!]
  relayerFees_contains: [String!]
  relayerFees_contains_nocase: [String!]
  relayerFees_not_contains: [String!]
  relayerFees_not_contains_nocase: [String!]
  relayerFees_: xlayer_RelayerFee_filter
  initialRelayerFeeAsset: xlayer_Bytes
  initialRelayerFeeAsset_not: xlayer_Bytes
  initialRelayerFeeAsset_gt: xlayer_Bytes
  initialRelayerFeeAsset_lt: xlayer_Bytes
  initialRelayerFeeAsset_gte: xlayer_Bytes
  initialRelayerFeeAsset_lte: xlayer_Bytes
  initialRelayerFeeAsset_in: [xlayer_Bytes!]
  initialRelayerFeeAsset_not_in: [xlayer_Bytes!]
  initialRelayerFeeAsset_contains: xlayer_Bytes
  initialRelayerFeeAsset_not_contains: xlayer_Bytes
  caller: xlayer_Bytes
  caller_not: xlayer_Bytes
  caller_gt: xlayer_Bytes
  caller_lt: xlayer_Bytes
  caller_gte: xlayer_Bytes
  caller_lte: xlayer_Bytes
  caller_in: [xlayer_Bytes!]
  caller_not_in: [xlayer_Bytes!]
  caller_contains: xlayer_Bytes
  caller_not_contains: xlayer_Bytes
  transactionHash: xlayer_Bytes
  transactionHash_not: xlayer_Bytes
  transactionHash_gt: xlayer_Bytes
  transactionHash_lt: xlayer_Bytes
  transactionHash_gte: xlayer_Bytes
  transactionHash_lte: xlayer_Bytes
  transactionHash_in: [xlayer_Bytes!]
  transactionHash_not_in: [xlayer_Bytes!]
  transactionHash_contains: xlayer_Bytes
  transactionHash_not_contains: xlayer_Bytes
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  gasLimit: BigInt
  gasLimit_not: BigInt
  gasLimit_gt: BigInt
  gasLimit_lt: BigInt
  gasLimit_gte: BigInt
  gasLimit_lte: BigInt
  gasLimit_in: [BigInt!]
  gasLimit_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  txOrigin: xlayer_Bytes
  txOrigin_not: xlayer_Bytes
  txOrigin_gt: xlayer_Bytes
  txOrigin_lt: xlayer_Bytes
  txOrigin_gte: xlayer_Bytes
  txOrigin_lte: xlayer_Bytes
  txOrigin_in: [xlayer_Bytes!]
  txOrigin_not_in: [xlayer_Bytes!]
  txOrigin_contains: xlayer_Bytes
  txOrigin_not_contains: xlayer_Bytes
  txNonce: BigInt
  txNonce_not: BigInt
  txNonce_gt: BigInt
  txNonce_lt: BigInt
  txNonce_gte: BigInt
  txNonce_lte: BigInt
  txNonce_in: [BigInt!]
  txNonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: xlayer_BlockChangedFilter
  and: [xlayer_OriginTransfer_filter]
  or: [xlayer_OriginTransfer_filter]
}

enum xlayer_OriginTransfer_orderBy {
  id
  chainId
  transferId
  nonce
  status
  messageHash
  originDomain
  destinationDomain
  canonicalDomain
  to
  delegate
  receiveLocal
  callData
  slippage
  originSender
  bridgedAmt
  normalizedIn
  canonicalId
  asset
  asset__id
  asset__key
  asset__decimal
  asset__adoptedDecimal
  asset__canonicalId
  asset__canonicalDomain
  asset__adoptedAsset
  asset__localAsset
  asset__blockNumber
  transactingAsset
  message
  message__id
  message__transferId
  message__destinationDomain
  message__leaf
  message__index
  message__message
  message__root
  message__transactionHash
  message__blockNumber
  bumpRelayerFeeCount
  relayerFees
  initialRelayerFeeAsset
  caller
  transactionHash
  timestamp
  gasPrice
  gasLimit
  blockNumber
  txOrigin
  txNonce
}

type xlayer_Relayer {
  id: ID!
  isActive: Boolean!
  relayer: xlayer_Bytes
}

type xlayer_RelayerFee {
  id: ID!
  transfer: xlayer_OriginTransfer!
  fee: BigInt!
  asset: xlayer_Bytes!
}

input xlayer_RelayerFee_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transfer: String
  transfer_not: String
  transfer_gt: String
  transfer_lt: String
  transfer_gte: String
  transfer_lte: String
  transfer_in: [String!]
  transfer_not_in: [String!]
  transfer_contains: String
  transfer_contains_nocase: String
  transfer_not_contains: String
  transfer_not_contains_nocase: String
  transfer_starts_with: String
  transfer_starts_with_nocase: String
  transfer_not_starts_with: String
  transfer_not_starts_with_nocase: String
  transfer_ends_with: String
  transfer_ends_with_nocase: String
  transfer_not_ends_with: String
  transfer_not_ends_with_nocase: String
  transfer_: xlayer_OriginTransfer_filter
  fee: BigInt
  fee_not: BigInt
  fee_gt: BigInt
  fee_lt: BigInt
  fee_gte: BigInt
  fee_lte: BigInt
  fee_in: [BigInt!]
  fee_not_in: [BigInt!]
  asset: xlayer_Bytes
  asset_not: xlayer_Bytes
  asset_gt: xlayer_Bytes
  asset_lt: xlayer_Bytes
  asset_gte: xlayer_Bytes
  asset_lte: xlayer_Bytes
  asset_in: [xlayer_Bytes!]
  asset_not_in: [xlayer_Bytes!]
  asset_contains: xlayer_Bytes
  asset_not_contains: xlayer_Bytes
  """Filter for the block changed event."""
  _change_block: xlayer_BlockChangedFilter
  and: [xlayer_RelayerFee_filter]
  or: [xlayer_RelayerFee_filter]
}

enum xlayer_RelayerFee_orderBy {
  id
  transfer
  transfer__id
  transfer__chainId
  transfer__transferId
  transfer__nonce
  transfer__status
  transfer__messageHash
  transfer__originDomain
  transfer__destinationDomain
  transfer__canonicalDomain
  transfer__to
  transfer__delegate
  transfer__receiveLocal
  transfer__callData
  transfer__slippage
  transfer__originSender
  transfer__bridgedAmt
  transfer__normalizedIn
  transfer__canonicalId
  transfer__transactingAsset
  transfer__bumpRelayerFeeCount
  transfer__initialRelayerFeeAsset
  transfer__caller
  transfer__transactionHash
  transfer__timestamp
  transfer__gasPrice
  transfer__gasLimit
  transfer__blockNumber
  transfer__txOrigin
  transfer__txNonce
  fee
  asset
}

type xlayer_RelayerFeesIncrease {
  id: ID!
  transfer: xlayer_OriginTransfer!
  increase: BigInt
  asset: xlayer_Bytes
  caller: xlayer_Bytes!
  transactionHash: xlayer_Bytes!
  timestamp: BigInt!
  gasPrice: BigInt!
  gasLimit: BigInt!
  blockNumber: BigInt!
}

input xlayer_RelayerFeesIncrease_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transfer: String
  transfer_not: String
  transfer_gt: String
  transfer_lt: String
  transfer_gte: String
  transfer_lte: String
  transfer_in: [String!]
  transfer_not_in: [String!]
  transfer_contains: String
  transfer_contains_nocase: String
  transfer_not_contains: String
  transfer_not_contains_nocase: String
  transfer_starts_with: String
  transfer_starts_with_nocase: String
  transfer_not_starts_with: String
  transfer_not_starts_with_nocase: String
  transfer_ends_with: String
  transfer_ends_with_nocase: String
  transfer_not_ends_with: String
  transfer_not_ends_with_nocase: String
  transfer_: xlayer_OriginTransfer_filter
  increase: BigInt
  increase_not: BigInt
  increase_gt: BigInt
  increase_lt: BigInt
  increase_gte: BigInt
  increase_lte: BigInt
  increase_in: [BigInt!]
  increase_not_in: [BigInt!]
  asset: xlayer_Bytes
  asset_not: xlayer_Bytes
  asset_gt: xlayer_Bytes
  asset_lt: xlayer_Bytes
  asset_gte: xlayer_Bytes
  asset_lte: xlayer_Bytes
  asset_in: [xlayer_Bytes!]
  asset_not_in: [xlayer_Bytes!]
  asset_contains: xlayer_Bytes
  asset_not_contains: xlayer_Bytes
  caller: xlayer_Bytes
  caller_not: xlayer_Bytes
  caller_gt: xlayer_Bytes
  caller_lt: xlayer_Bytes
  caller_gte: xlayer_Bytes
  caller_lte: xlayer_Bytes
  caller_in: [xlayer_Bytes!]
  caller_not_in: [xlayer_Bytes!]
  caller_contains: xlayer_Bytes
  caller_not_contains: xlayer_Bytes
  transactionHash: xlayer_Bytes
  transactionHash_not: xlayer_Bytes
  transactionHash_gt: xlayer_Bytes
  transactionHash_lt: xlayer_Bytes
  transactionHash_gte: xlayer_Bytes
  transactionHash_lte: xlayer_Bytes
  transactionHash_in: [xlayer_Bytes!]
  transactionHash_not_in: [xlayer_Bytes!]
  transactionHash_contains: xlayer_Bytes
  transactionHash_not_contains: xlayer_Bytes
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  gasLimit: BigInt
  gasLimit_not: BigInt
  gasLimit_gt: BigInt
  gasLimit_lt: BigInt
  gasLimit_gte: BigInt
  gasLimit_lte: BigInt
  gasLimit_in: [BigInt!]
  gasLimit_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: xlayer_BlockChangedFilter
  and: [xlayer_RelayerFeesIncrease_filter]
  or: [xlayer_RelayerFeesIncrease_filter]
}

enum xlayer_RelayerFeesIncrease_orderBy {
  id
  transfer
  transfer__id
  transfer__chainId
  transfer__transferId
  transfer__nonce
  transfer__status
  transfer__messageHash
  transfer__originDomain
  transfer__destinationDomain
  transfer__canonicalDomain
  transfer__to
  transfer__delegate
  transfer__receiveLocal
  transfer__callData
  transfer__slippage
  transfer__originSender
  transfer__bridgedAmt
  transfer__normalizedIn
  transfer__canonicalId
  transfer__transactingAsset
  transfer__bumpRelayerFeeCount
  transfer__initialRelayerFeeAsset
  transfer__caller
  transfer__transactionHash
  transfer__timestamp
  transfer__gasPrice
  transfer__gasLimit
  transfer__blockNumber
  transfer__txOrigin
  transfer__txNonce
  increase
  asset
  caller
  transactionHash
  timestamp
  gasPrice
  gasLimit
  blockNumber
}

input xlayer_Relayer_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  isActive: Boolean
  isActive_not: Boolean
  isActive_in: [Boolean!]
  isActive_not_in: [Boolean!]
  relayer: xlayer_Bytes
  relayer_not: xlayer_Bytes
  relayer_gt: xlayer_Bytes
  relayer_lt: xlayer_Bytes
  relayer_gte: xlayer_Bytes
  relayer_lte: xlayer_Bytes
  relayer_in: [xlayer_Bytes!]
  relayer_not_in: [xlayer_Bytes!]
  relayer_contains: xlayer_Bytes
  relayer_not_contains: xlayer_Bytes
  """Filter for the block changed event."""
  _change_block: xlayer_BlockChangedFilter
  and: [xlayer_Relayer_filter]
  or: [xlayer_Relayer_filter]
}

enum xlayer_Relayer_orderBy {
  id
  isActive
  relayer
}

type xlayer_RootCount {
  id: ID!
  count: BigInt
}

input xlayer_RootCount_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  count: BigInt
  count_not: BigInt
  count_gt: BigInt
  count_lt: BigInt
  count_gte: BigInt
  count_lte: BigInt
  count_in: [BigInt!]
  count_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: xlayer_BlockChangedFilter
  and: [xlayer_RootCount_filter]
  or: [xlayer_RootCount_filter]
}

enum xlayer_RootCount_orderBy {
  id
  count
}

type xlayer_RootMessageSent {
  id: ID!
  spokeDomain: BigInt
  hubDomain: BigInt
  root: xlayer_Bytes
  count: BigInt
  caller: xlayer_Bytes
  transactionHash: xlayer_Bytes
  timestamp: BigInt
  gasPrice: BigInt
  gasLimit: BigInt
  blockNumber: BigInt
}

input xlayer_RootMessageSent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  spokeDomain: BigInt
  spokeDomain_not: BigInt
  spokeDomain_gt: BigInt
  spokeDomain_lt: BigInt
  spokeDomain_gte: BigInt
  spokeDomain_lte: BigInt
  spokeDomain_in: [BigInt!]
  spokeDomain_not_in: [BigInt!]
  hubDomain: BigInt
  hubDomain_not: BigInt
  hubDomain_gt: BigInt
  hubDomain_lt: BigInt
  hubDomain_gte: BigInt
  hubDomain_lte: BigInt
  hubDomain_in: [BigInt!]
  hubDomain_not_in: [BigInt!]
  root: xlayer_Bytes
  root_not: xlayer_Bytes
  root_gt: xlayer_Bytes
  root_lt: xlayer_Bytes
  root_gte: xlayer_Bytes
  root_lte: xlayer_Bytes
  root_in: [xlayer_Bytes!]
  root_not_in: [xlayer_Bytes!]
  root_contains: xlayer_Bytes
  root_not_contains: xlayer_Bytes
  count: BigInt
  count_not: BigInt
  count_gt: BigInt
  count_lt: BigInt
  count_gte: BigInt
  count_lte: BigInt
  count_in: [BigInt!]
  count_not_in: [BigInt!]
  caller: xlayer_Bytes
  caller_not: xlayer_Bytes
  caller_gt: xlayer_Bytes
  caller_lt: xlayer_Bytes
  caller_gte: xlayer_Bytes
  caller_lte: xlayer_Bytes
  caller_in: [xlayer_Bytes!]
  caller_not_in: [xlayer_Bytes!]
  caller_contains: xlayer_Bytes
  caller_not_contains: xlayer_Bytes
  transactionHash: xlayer_Bytes
  transactionHash_not: xlayer_Bytes
  transactionHash_gt: xlayer_Bytes
  transactionHash_lt: xlayer_Bytes
  transactionHash_gte: xlayer_Bytes
  transactionHash_lte: xlayer_Bytes
  transactionHash_in: [xlayer_Bytes!]
  transactionHash_not_in: [xlayer_Bytes!]
  transactionHash_contains: xlayer_Bytes
  transactionHash_not_contains: xlayer_Bytes
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  gasLimit: BigInt
  gasLimit_not: BigInt
  gasLimit_gt: BigInt
  gasLimit_lt: BigInt
  gasLimit_gte: BigInt
  gasLimit_lte: BigInt
  gasLimit_in: [BigInt!]
  gasLimit_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: xlayer_BlockChangedFilter
  and: [xlayer_RootMessageSent_filter]
  or: [xlayer_RootMessageSent_filter]
}

enum xlayer_RootMessageSent_orderBy {
  id
  spokeDomain
  hubDomain
  root
  count
  caller
  transactionHash
  timestamp
  gasPrice
  gasLimit
  blockNumber
}

type xlayer_Router {
  id: ID!
  isActive: Boolean!
  owner: xlayer_Bytes
  recipient: xlayer_Bytes
  proposedOwner: xlayer_Bytes
  proposedTimestamp: BigInt
  assetBalances(skip: Int = 0, first: Int = 100, orderBy: xlayer_AssetBalance_orderBy, orderDirection: xlayer_OrderDirection, where: xlayer_AssetBalance_filter): [xlayer_AssetBalance!]!
}

type xlayer_RouterDailyTVL {
  id: ID!
  router: xlayer_Router!
  asset: xlayer_Asset!
  timestamp: BigInt!
  balance: BigInt!
}

input xlayer_RouterDailyTVL_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  router: String
  router_not: String
  router_gt: String
  router_lt: String
  router_gte: String
  router_lte: String
  router_in: [String!]
  router_not_in: [String!]
  router_contains: String
  router_contains_nocase: String
  router_not_contains: String
  router_not_contains_nocase: String
  router_starts_with: String
  router_starts_with_nocase: String
  router_not_starts_with: String
  router_not_starts_with_nocase: String
  router_ends_with: String
  router_ends_with_nocase: String
  router_not_ends_with: String
  router_not_ends_with_nocase: String
  router_: xlayer_Router_filter
  asset: String
  asset_not: String
  asset_gt: String
  asset_lt: String
  asset_gte: String
  asset_lte: String
  asset_in: [String!]
  asset_not_in: [String!]
  asset_contains: String
  asset_contains_nocase: String
  asset_not_contains: String
  asset_not_contains_nocase: String
  asset_starts_with: String
  asset_starts_with_nocase: String
  asset_not_starts_with: String
  asset_not_starts_with_nocase: String
  asset_ends_with: String
  asset_ends_with_nocase: String
  asset_not_ends_with: String
  asset_not_ends_with_nocase: String
  asset_: xlayer_Asset_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  balance: BigInt
  balance_not: BigInt
  balance_gt: BigInt
  balance_lt: BigInt
  balance_gte: BigInt
  balance_lte: BigInt
  balance_in: [BigInt!]
  balance_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: xlayer_BlockChangedFilter
  and: [xlayer_RouterDailyTVL_filter]
  or: [xlayer_RouterDailyTVL_filter]
}

enum xlayer_RouterDailyTVL_orderBy {
  id
  router
  router__id
  router__isActive
  router__owner
  router__recipient
  router__proposedOwner
  router__proposedTimestamp
  asset
  asset__id
  asset__key
  asset__decimal
  asset__adoptedDecimal
  asset__canonicalId
  asset__canonicalDomain
  asset__adoptedAsset
  asset__localAsset
  asset__blockNumber
  timestamp
  balance
}

type xlayer_RouterLiquidityEvent {
  id: ID!
  type: xlayer_RouterLiquidityEventType
  router: xlayer_Router!
  asset: xlayer_Asset!
  amount: BigInt!
  balance: BigInt!
  caller: xlayer_Bytes
  blockNumber: BigInt!
  timestamp: BigInt!
  transactionHash: xlayer_Bytes!
  nonce: BigInt!
}

enum xlayer_RouterLiquidityEventType {
  Add
  Remove
}

input xlayer_RouterLiquidityEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  type: xlayer_RouterLiquidityEventType
  type_not: xlayer_RouterLiquidityEventType
  type_in: [xlayer_RouterLiquidityEventType!]
  type_not_in: [xlayer_RouterLiquidityEventType!]
  router: String
  router_not: String
  router_gt: String
  router_lt: String
  router_gte: String
  router_lte: String
  router_in: [String!]
  router_not_in: [String!]
  router_contains: String
  router_contains_nocase: String
  router_not_contains: String
  router_not_contains_nocase: String
  router_starts_with: String
  router_starts_with_nocase: String
  router_not_starts_with: String
  router_not_starts_with_nocase: String
  router_ends_with: String
  router_ends_with_nocase: String
  router_not_ends_with: String
  router_not_ends_with_nocase: String
  router_: xlayer_Router_filter
  asset: String
  asset_not: String
  asset_gt: String
  asset_lt: String
  asset_gte: String
  asset_lte: String
  asset_in: [String!]
  asset_not_in: [String!]
  asset_contains: String
  asset_contains_nocase: String
  asset_not_contains: String
  asset_not_contains_nocase: String
  asset_starts_with: String
  asset_starts_with_nocase: String
  asset_not_starts_with: String
  asset_not_starts_with_nocase: String
  asset_ends_with: String
  asset_ends_with_nocase: String
  asset_not_ends_with: String
  asset_not_ends_with_nocase: String
  asset_: xlayer_Asset_filter
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  balance: BigInt
  balance_not: BigInt
  balance_gt: BigInt
  balance_lt: BigInt
  balance_gte: BigInt
  balance_lte: BigInt
  balance_in: [BigInt!]
  balance_not_in: [BigInt!]
  caller: xlayer_Bytes
  caller_not: xlayer_Bytes
  caller_gt: xlayer_Bytes
  caller_lt: xlayer_Bytes
  caller_gte: xlayer_Bytes
  caller_lte: xlayer_Bytes
  caller_in: [xlayer_Bytes!]
  caller_not_in: [xlayer_Bytes!]
  caller_contains: xlayer_Bytes
  caller_not_contains: xlayer_Bytes
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transactionHash: xlayer_Bytes
  transactionHash_not: xlayer_Bytes
  transactionHash_gt: xlayer_Bytes
  transactionHash_lt: xlayer_Bytes
  transactionHash_gte: xlayer_Bytes
  transactionHash_lte: xlayer_Bytes
  transactionHash_in: [xlayer_Bytes!]
  transactionHash_not_in: [xlayer_Bytes!]
  transactionHash_contains: xlayer_Bytes
  transactionHash_not_contains: xlayer_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: xlayer_BlockChangedFilter
  and: [xlayer_RouterLiquidityEvent_filter]
  or: [xlayer_RouterLiquidityEvent_filter]
}

enum xlayer_RouterLiquidityEvent_orderBy {
  id
  type
  router
  router__id
  router__isActive
  router__owner
  router__recipient
  router__proposedOwner
  router__proposedTimestamp
  asset
  asset__id
  asset__key
  asset__decimal
  asset__adoptedDecimal
  asset__canonicalId
  asset__canonicalDomain
  asset__adoptedAsset
  asset__localAsset
  asset__blockNumber
  amount
  balance
  caller
  blockNumber
  timestamp
  transactionHash
  nonce
}

input xlayer_Router_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  isActive: Boolean
  isActive_not: Boolean
  isActive_in: [Boolean!]
  isActive_not_in: [Boolean!]
  owner: xlayer_Bytes
  owner_not: xlayer_Bytes
  owner_gt: xlayer_Bytes
  owner_lt: xlayer_Bytes
  owner_gte: xlayer_Bytes
  owner_lte: xlayer_Bytes
  owner_in: [xlayer_Bytes!]
  owner_not_in: [xlayer_Bytes!]
  owner_contains: xlayer_Bytes
  owner_not_contains: xlayer_Bytes
  recipient: xlayer_Bytes
  recipient_not: xlayer_Bytes
  recipient_gt: xlayer_Bytes
  recipient_lt: xlayer_Bytes
  recipient_gte: xlayer_Bytes
  recipient_lte: xlayer_Bytes
  recipient_in: [xlayer_Bytes!]
  recipient_not_in: [xlayer_Bytes!]
  recipient_contains: xlayer_Bytes
  recipient_not_contains: xlayer_Bytes
  proposedOwner: xlayer_Bytes
  proposedOwner_not: xlayer_Bytes
  proposedOwner_gt: xlayer_Bytes
  proposedOwner_lt: xlayer_Bytes
  proposedOwner_gte: xlayer_Bytes
  proposedOwner_lte: xlayer_Bytes
  proposedOwner_in: [xlayer_Bytes!]
  proposedOwner_not_in: [xlayer_Bytes!]
  proposedOwner_contains: xlayer_Bytes
  proposedOwner_not_contains: xlayer_Bytes
  proposedTimestamp: BigInt
  proposedTimestamp_not: BigInt
  proposedTimestamp_gt: BigInt
  proposedTimestamp_lt: BigInt
  proposedTimestamp_gte: BigInt
  proposedTimestamp_lte: BigInt
  proposedTimestamp_in: [BigInt!]
  proposedTimestamp_not_in: [BigInt!]
  assetBalances_: xlayer_AssetBalance_filter
  """Filter for the block changed event."""
  _change_block: xlayer_BlockChangedFilter
  and: [xlayer_Router_filter]
  or: [xlayer_Router_filter]
}

enum xlayer_Router_orderBy {
  id
  isActive
  owner
  recipient
  proposedOwner
  proposedTimestamp
  assetBalances
}

type xlayer_Sequencer {
  id: ID!
  isActive: Boolean!
  sequencer: xlayer_Bytes
}

input xlayer_Sequencer_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  isActive: Boolean
  isActive_not: Boolean
  isActive_in: [Boolean!]
  isActive_not_in: [Boolean!]
  sequencer: xlayer_Bytes
  sequencer_not: xlayer_Bytes
  sequencer_gt: xlayer_Bytes
  sequencer_lt: xlayer_Bytes
  sequencer_gte: xlayer_Bytes
  sequencer_lte: xlayer_Bytes
  sequencer_in: [xlayer_Bytes!]
  sequencer_not_in: [xlayer_Bytes!]
  sequencer_contains: xlayer_Bytes
  sequencer_not_contains: xlayer_Bytes
  """Filter for the block changed event."""
  _change_block: xlayer_BlockChangedFilter
  and: [xlayer_Sequencer_filter]
  or: [xlayer_Sequencer_filter]
}

enum xlayer_Sequencer_orderBy {
  id
  isActive
  sequencer
}

type xlayer_Setting {
  id: ID!
  maxRoutersPerTransfer: BigInt!
  caller: xlayer_Bytes!
}

input xlayer_Setting_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  maxRoutersPerTransfer: BigInt
  maxRoutersPerTransfer_not: BigInt
  maxRoutersPerTransfer_gt: BigInt
  maxRoutersPerTransfer_lt: BigInt
  maxRoutersPerTransfer_gte: BigInt
  maxRoutersPerTransfer_lte: BigInt
  maxRoutersPerTransfer_in: [BigInt!]
  maxRoutersPerTransfer_not_in: [BigInt!]
  caller: xlayer_Bytes
  caller_not: xlayer_Bytes
  caller_gt: xlayer_Bytes
  caller_lt: xlayer_Bytes
  caller_gte: xlayer_Bytes
  caller_lte: xlayer_Bytes
  caller_in: [xlayer_Bytes!]
  caller_not_in: [xlayer_Bytes!]
  caller_contains: xlayer_Bytes
  caller_not_contains: xlayer_Bytes
  """Filter for the block changed event."""
  _change_block: xlayer_BlockChangedFilter
  and: [xlayer_Setting_filter]
  or: [xlayer_Setting_filter]
}

enum xlayer_Setting_orderBy {
  id
  maxRoutersPerTransfer
  caller
}

type xlayer_SlippageUpdate {
  id: ID!
  transfer: xlayer_DestinationTransfer!
  slippage: BigInt!
  caller: xlayer_Bytes!
  transactionHash: xlayer_Bytes!
  timestamp: BigInt!
  gasPrice: BigInt!
  gasLimit: BigInt!
  blockNumber: BigInt!
}

input xlayer_SlippageUpdate_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transfer: String
  transfer_not: String
  transfer_gt: String
  transfer_lt: String
  transfer_gte: String
  transfer_lte: String
  transfer_in: [String!]
  transfer_not_in: [String!]
  transfer_contains: String
  transfer_contains_nocase: String
  transfer_not_contains: String
  transfer_not_contains_nocase: String
  transfer_starts_with: String
  transfer_starts_with_nocase: String
  transfer_not_starts_with: String
  transfer_not_starts_with_nocase: String
  transfer_ends_with: String
  transfer_ends_with_nocase: String
  transfer_not_ends_with: String
  transfer_not_ends_with_nocase: String
  transfer_: xlayer_DestinationTransfer_filter
  slippage: BigInt
  slippage_not: BigInt
  slippage_gt: BigInt
  slippage_lt: BigInt
  slippage_gte: BigInt
  slippage_lte: BigInt
  slippage_in: [BigInt!]
  slippage_not_in: [BigInt!]
  caller: xlayer_Bytes
  caller_not: xlayer_Bytes
  caller_gt: xlayer_Bytes
  caller_lt: xlayer_Bytes
  caller_gte: xlayer_Bytes
  caller_lte: xlayer_Bytes
  caller_in: [xlayer_Bytes!]
  caller_not_in: [xlayer_Bytes!]
  caller_contains: xlayer_Bytes
  caller_not_contains: xlayer_Bytes
  transactionHash: xlayer_Bytes
  transactionHash_not: xlayer_Bytes
  transactionHash_gt: xlayer_Bytes
  transactionHash_lt: xlayer_Bytes
  transactionHash_gte: xlayer_Bytes
  transactionHash_lte: xlayer_Bytes
  transactionHash_in: [xlayer_Bytes!]
  transactionHash_not_in: [xlayer_Bytes!]
  transactionHash_contains: xlayer_Bytes
  transactionHash_not_contains: xlayer_Bytes
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  gasLimit: BigInt
  gasLimit_not: BigInt
  gasLimit_gt: BigInt
  gasLimit_lt: BigInt
  gasLimit_gte: BigInt
  gasLimit_lte: BigInt
  gasLimit_in: [BigInt!]
  gasLimit_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: xlayer_BlockChangedFilter
  and: [xlayer_SlippageUpdate_filter]
  or: [xlayer_SlippageUpdate_filter]
}

enum xlayer_SlippageUpdate_orderBy {
  id
  transfer
  transfer__id
  transfer__chainId
  transfer__transferId
  transfer__nonce
  transfer__status
  transfer__originDomain
  transfer__destinationDomain
  transfer__canonicalDomain
  transfer__to
  transfer__delegate
  transfer__receiveLocal
  transfer__callData
  transfer__slippage
  transfer__bumpSlippageCount
  transfer__originSender
  transfer__bridgedAmt
  transfer__normalizedIn
  transfer__canonicalId
  transfer__amount
  transfer__routersFee
  transfer__executedCaller
  transfer__executedTransactionHash
  transfer__executedTimestamp
  transfer__executedGasPrice
  transfer__executedGasLimit
  transfer__executedBlockNumber
  transfer__executedTxOrigin
  transfer__executedTxNonce
  transfer__reconciledCaller
  transfer__reconciledTransactionHash
  transfer__reconciledTimestamp
  transfer__reconciledGasPrice
  transfer__reconciledGasLimit
  transfer__reconciledBlockNumber
  transfer__reconciledTxOrigin
  transfer__reconciledTxNonce
  slippage
  caller
  transactionHash
  timestamp
  gasPrice
  gasLimit
  blockNumber
}

type xlayer_SnapshotRoot {
  id: ID!
  spokeDomain: BigInt
  root: xlayer_Bytes!
  count: BigInt!
  timestamp: BigInt!
  blockNumber: BigInt!
}

input xlayer_SnapshotRoot_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  spokeDomain: BigInt
  spokeDomain_not: BigInt
  spokeDomain_gt: BigInt
  spokeDomain_lt: BigInt
  spokeDomain_gte: BigInt
  spokeDomain_lte: BigInt
  spokeDomain_in: [BigInt!]
  spokeDomain_not_in: [BigInt!]
  root: xlayer_Bytes
  root_not: xlayer_Bytes
  root_gt: xlayer_Bytes
  root_lt: xlayer_Bytes
  root_gte: xlayer_Bytes
  root_lte: xlayer_Bytes
  root_in: [xlayer_Bytes!]
  root_not_in: [xlayer_Bytes!]
  root_contains: xlayer_Bytes
  root_not_contains: xlayer_Bytes
  count: BigInt
  count_not: BigInt
  count_gt: BigInt
  count_lt: BigInt
  count_gte: BigInt
  count_lte: BigInt
  count_in: [BigInt!]
  count_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: xlayer_BlockChangedFilter
  and: [xlayer_SnapshotRoot_filter]
  or: [xlayer_SnapshotRoot_filter]
}

enum xlayer_SnapshotRoot_orderBy {
  id
  spokeDomain
  root
  count
  timestamp
  blockNumber
}

type xlayer_SpokeConnectorMode {
  id: ID!
  mode: String!
}

input xlayer_SpokeConnectorMode_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  mode: String
  mode_not: String
  mode_gt: String
  mode_lt: String
  mode_gte: String
  mode_lte: String
  mode_in: [String!]
  mode_not_in: [String!]
  mode_contains: String
  mode_contains_nocase: String
  mode_not_contains: String
  mode_not_contains_nocase: String
  mode_starts_with: String
  mode_starts_with_nocase: String
  mode_not_starts_with: String
  mode_not_starts_with_nocase: String
  mode_ends_with: String
  mode_ends_with_nocase: String
  mode_not_ends_with: String
  mode_not_ends_with_nocase: String
  """Filter for the block changed event."""
  _change_block: xlayer_BlockChangedFilter
  and: [xlayer_SpokeConnectorMode_filter]
  or: [xlayer_SpokeConnectorMode_filter]
}

enum xlayer_SpokeConnectorMode_orderBy {
  id
  mode
}

enum xlayer_TransferStatus {
  XCalled
  Executed
  Reconciled
  CompletedSlow
  CompletedFast
}

type xlayer__Block_ {
  """The hash of the block"""
  hash: xlayer_Bytes
  """The block number"""
  number: Int!
  """Integer representation of the timestamp stored in blocks for the chain"""
  timestamp: Int
  """The hash of the parent block"""
  parentHash: xlayer_Bytes
}

"""The type for the top-level _meta field"""
type xlayer__Meta_ {
  """
  Information about a specific subgraph block. The hash of the block
  will be null if the _meta field has a block constraint that asks for
  a block number. It will be filled if the _meta field has no block constraint
  and therefore asks for the latest  block
  
  """
  block: xlayer__Block_!
  """The deployment ID"""
  deployment: String!
  """If `true`, the subgraph encountered indexing errors at some past block"""
  hasIndexingErrors: Boolean!
}

type mode_AggregateRoot {
  id: ID!
  root: mode_Bytes!
  blockNumber: BigInt!
}

type mode_AggregateRootProposed {
  id: ID!
  aggregateRoot: mode_Bytes!
  rootTimestamp: BigInt!
  endOfDispute: BigInt!
  domain: BigInt!
  timestamp: BigInt!
  blockNumber: BigInt
}

input mode_AggregateRootProposed_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  aggregateRoot: mode_Bytes
  aggregateRoot_not: mode_Bytes
  aggregateRoot_gt: mode_Bytes
  aggregateRoot_lt: mode_Bytes
  aggregateRoot_gte: mode_Bytes
  aggregateRoot_lte: mode_Bytes
  aggregateRoot_in: [mode_Bytes!]
  aggregateRoot_not_in: [mode_Bytes!]
  aggregateRoot_contains: mode_Bytes
  aggregateRoot_not_contains: mode_Bytes
  rootTimestamp: BigInt
  rootTimestamp_not: BigInt
  rootTimestamp_gt: BigInt
  rootTimestamp_lt: BigInt
  rootTimestamp_gte: BigInt
  rootTimestamp_lte: BigInt
  rootTimestamp_in: [BigInt!]
  rootTimestamp_not_in: [BigInt!]
  endOfDispute: BigInt
  endOfDispute_not: BigInt
  endOfDispute_gt: BigInt
  endOfDispute_lt: BigInt
  endOfDispute_gte: BigInt
  endOfDispute_lte: BigInt
  endOfDispute_in: [BigInt!]
  endOfDispute_not_in: [BigInt!]
  domain: BigInt
  domain_not: BigInt
  domain_gt: BigInt
  domain_lt: BigInt
  domain_gte: BigInt
  domain_lte: BigInt
  domain_in: [BigInt!]
  domain_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: mode_BlockChangedFilter
  and: [mode_AggregateRootProposed_filter]
  or: [mode_AggregateRootProposed_filter]
}

enum mode_AggregateRootProposed_orderBy {
  id
  aggregateRoot
  rootTimestamp
  endOfDispute
  domain
  timestamp
  blockNumber
}

input mode_AggregateRoot_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  root: mode_Bytes
  root_not: mode_Bytes
  root_gt: mode_Bytes
  root_lt: mode_Bytes
  root_gte: mode_Bytes
  root_lte: mode_Bytes
  root_in: [mode_Bytes!]
  root_not_in: [mode_Bytes!]
  root_contains: mode_Bytes
  root_not_contains: mode_Bytes
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: mode_BlockChangedFilter
  and: [mode_AggregateRoot_filter]
  or: [mode_AggregateRoot_filter]
}

enum mode_AggregateRoot_orderBy {
  id
  root
  blockNumber
}

enum mode_Aggregation_interval {
  hour
  day
}

type mode_Asset {
  id: ID!
  key: mode_Bytes
  decimal: BigInt
  adoptedDecimal: BigInt
  canonicalId: mode_Bytes
  canonicalDomain: BigInt
  adoptedAsset: mode_Bytes
  localAsset: mode_Bytes
  blockNumber: BigInt
  status: mode_AssetStatus
}

type mode_AssetBalance {
  id: ID!
  amount: BigInt!
  locked: BigInt!
  supplied: BigInt!
  removed: BigInt!
  router: mode_Router!
  asset: mode_Asset!
  feesEarned: BigInt!
}

input mode_AssetBalance_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  locked: BigInt
  locked_not: BigInt
  locked_gt: BigInt
  locked_lt: BigInt
  locked_gte: BigInt
  locked_lte: BigInt
  locked_in: [BigInt!]
  locked_not_in: [BigInt!]
  supplied: BigInt
  supplied_not: BigInt
  supplied_gt: BigInt
  supplied_lt: BigInt
  supplied_gte: BigInt
  supplied_lte: BigInt
  supplied_in: [BigInt!]
  supplied_not_in: [BigInt!]
  removed: BigInt
  removed_not: BigInt
  removed_gt: BigInt
  removed_lt: BigInt
  removed_gte: BigInt
  removed_lte: BigInt
  removed_in: [BigInt!]
  removed_not_in: [BigInt!]
  router: String
  router_not: String
  router_gt: String
  router_lt: String
  router_gte: String
  router_lte: String
  router_in: [String!]
  router_not_in: [String!]
  router_contains: String
  router_contains_nocase: String
  router_not_contains: String
  router_not_contains_nocase: String
  router_starts_with: String
  router_starts_with_nocase: String
  router_not_starts_with: String
  router_not_starts_with_nocase: String
  router_ends_with: String
  router_ends_with_nocase: String
  router_not_ends_with: String
  router_not_ends_with_nocase: String
  router_: mode_Router_filter
  asset: String
  asset_not: String
  asset_gt: String
  asset_lt: String
  asset_gte: String
  asset_lte: String
  asset_in: [String!]
  asset_not_in: [String!]
  asset_contains: String
  asset_contains_nocase: String
  asset_not_contains: String
  asset_not_contains_nocase: String
  asset_starts_with: String
  asset_starts_with_nocase: String
  asset_not_starts_with: String
  asset_not_starts_with_nocase: String
  asset_ends_with: String
  asset_ends_with_nocase: String
  asset_not_ends_with: String
  asset_not_ends_with_nocase: String
  asset_: mode_Asset_filter
  feesEarned: BigInt
  feesEarned_not: BigInt
  feesEarned_gt: BigInt
  feesEarned_lt: BigInt
  feesEarned_gte: BigInt
  feesEarned_lte: BigInt
  feesEarned_in: [BigInt!]
  feesEarned_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: mode_BlockChangedFilter
  and: [mode_AssetBalance_filter]
  or: [mode_AssetBalance_filter]
}

enum mode_AssetBalance_orderBy {
  id
  amount
  locked
  supplied
  removed
  router
  router__id
  router__isActive
  router__owner
  router__recipient
  router__proposedOwner
  router__proposedTimestamp
  asset
  asset__id
  asset__key
  asset__decimal
  asset__adoptedDecimal
  asset__canonicalId
  asset__canonicalDomain
  asset__adoptedAsset
  asset__localAsset
  asset__blockNumber
  feesEarned
}

type mode_AssetStatus {
  id: ID!
  status: Boolean
}

input mode_AssetStatus_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  status: Boolean
  status_not: Boolean
  status_in: [Boolean!]
  status_not_in: [Boolean!]
  """Filter for the block changed event."""
  _change_block: mode_BlockChangedFilter
  and: [mode_AssetStatus_filter]
  or: [mode_AssetStatus_filter]
}

enum mode_AssetStatus_orderBy {
  id
  status
}

input mode_Asset_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  key: mode_Bytes
  key_not: mode_Bytes
  key_gt: mode_Bytes
  key_lt: mode_Bytes
  key_gte: mode_Bytes
  key_lte: mode_Bytes
  key_in: [mode_Bytes!]
  key_not_in: [mode_Bytes!]
  key_contains: mode_Bytes
  key_not_contains: mode_Bytes
  decimal: BigInt
  decimal_not: BigInt
  decimal_gt: BigInt
  decimal_lt: BigInt
  decimal_gte: BigInt
  decimal_lte: BigInt
  decimal_in: [BigInt!]
  decimal_not_in: [BigInt!]
  adoptedDecimal: BigInt
  adoptedDecimal_not: BigInt
  adoptedDecimal_gt: BigInt
  adoptedDecimal_lt: BigInt
  adoptedDecimal_gte: BigInt
  adoptedDecimal_lte: BigInt
  adoptedDecimal_in: [BigInt!]
  adoptedDecimal_not_in: [BigInt!]
  canonicalId: mode_Bytes
  canonicalId_not: mode_Bytes
  canonicalId_gt: mode_Bytes
  canonicalId_lt: mode_Bytes
  canonicalId_gte: mode_Bytes
  canonicalId_lte: mode_Bytes
  canonicalId_in: [mode_Bytes!]
  canonicalId_not_in: [mode_Bytes!]
  canonicalId_contains: mode_Bytes
  canonicalId_not_contains: mode_Bytes
  canonicalDomain: BigInt
  canonicalDomain_not: BigInt
  canonicalDomain_gt: BigInt
  canonicalDomain_lt: BigInt
  canonicalDomain_gte: BigInt
  canonicalDomain_lte: BigInt
  canonicalDomain_in: [BigInt!]
  canonicalDomain_not_in: [BigInt!]
  adoptedAsset: mode_Bytes
  adoptedAsset_not: mode_Bytes
  adoptedAsset_gt: mode_Bytes
  adoptedAsset_lt: mode_Bytes
  adoptedAsset_gte: mode_Bytes
  adoptedAsset_lte: mode_Bytes
  adoptedAsset_in: [mode_Bytes!]
  adoptedAsset_not_in: [mode_Bytes!]
  adoptedAsset_contains: mode_Bytes
  adoptedAsset_not_contains: mode_Bytes
  localAsset: mode_Bytes
  localAsset_not: mode_Bytes
  localAsset_gt: mode_Bytes
  localAsset_lt: mode_Bytes
  localAsset_gte: mode_Bytes
  localAsset_lte: mode_Bytes
  localAsset_in: [mode_Bytes!]
  localAsset_not_in: [mode_Bytes!]
  localAsset_contains: mode_Bytes
  localAsset_not_contains: mode_Bytes
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  status: String
  status_not: String
  status_gt: String
  status_lt: String
  status_gte: String
  status_lte: String
  status_in: [String!]
  status_not_in: [String!]
  status_contains: String
  status_contains_nocase: String
  status_not_contains: String
  status_not_contains_nocase: String
  status_starts_with: String
  status_starts_with_nocase: String
  status_not_starts_with: String
  status_not_starts_with_nocase: String
  status_ends_with: String
  status_ends_with_nocase: String
  status_not_ends_with: String
  status_not_ends_with_nocase: String
  status_: mode_AssetStatus_filter
  """Filter for the block changed event."""
  _change_block: mode_BlockChangedFilter
  and: [mode_Asset_filter]
  or: [mode_Asset_filter]
}

enum mode_Asset_orderBy {
  id
  key
  decimal
  adoptedDecimal
  canonicalId
  canonicalDomain
  adoptedAsset
  localAsset
  blockNumber
  status
  status__id
  status__status
}

scalar mode_BigDecimal

input mode_BlockChangedFilter {
  number_gte: Int!
}

input mode_Block_height {
  hash: mode_Bytes
  number: Int
  number_gte: Int
}

scalar mode_Bytes

type mode_ConnectorMeta {
  id: ID!
  spokeDomain: BigInt
  hubDomain: BigInt
  amb: mode_Bytes
  rootManager: mode_Bytes
  mirrorConnector: mode_Bytes
}

input mode_ConnectorMeta_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  spokeDomain: BigInt
  spokeDomain_not: BigInt
  spokeDomain_gt: BigInt
  spokeDomain_lt: BigInt
  spokeDomain_gte: BigInt
  spokeDomain_lte: BigInt
  spokeDomain_in: [BigInt!]
  spokeDomain_not_in: [BigInt!]
  hubDomain: BigInt
  hubDomain_not: BigInt
  hubDomain_gt: BigInt
  hubDomain_lt: BigInt
  hubDomain_gte: BigInt
  hubDomain_lte: BigInt
  hubDomain_in: [BigInt!]
  hubDomain_not_in: [BigInt!]
  amb: mode_Bytes
  amb_not: mode_Bytes
  amb_gt: mode_Bytes
  amb_lt: mode_Bytes
  amb_gte: mode_Bytes
  amb_lte: mode_Bytes
  amb_in: [mode_Bytes!]
  amb_not_in: [mode_Bytes!]
  amb_contains: mode_Bytes
  amb_not_contains: mode_Bytes
  rootManager: mode_Bytes
  rootManager_not: mode_Bytes
  rootManager_gt: mode_Bytes
  rootManager_lt: mode_Bytes
  rootManager_gte: mode_Bytes
  rootManager_lte: mode_Bytes
  rootManager_in: [mode_Bytes!]
  rootManager_not_in: [mode_Bytes!]
  rootManager_contains: mode_Bytes
  rootManager_not_contains: mode_Bytes
  mirrorConnector: mode_Bytes
  mirrorConnector_not: mode_Bytes
  mirrorConnector_gt: mode_Bytes
  mirrorConnector_lt: mode_Bytes
  mirrorConnector_gte: mode_Bytes
  mirrorConnector_lte: mode_Bytes
  mirrorConnector_in: [mode_Bytes!]
  mirrorConnector_not_in: [mode_Bytes!]
  mirrorConnector_contains: mode_Bytes
  mirrorConnector_not_contains: mode_Bytes
  """Filter for the block changed event."""
  _change_block: mode_BlockChangedFilter
  and: [mode_ConnectorMeta_filter]
  or: [mode_ConnectorMeta_filter]
}

enum mode_ConnectorMeta_orderBy {
  id
  spokeDomain
  hubDomain
  amb
  rootManager
  mirrorConnector
}

type mode_DestinationTransfer {
  id: ID!
  chainId: BigInt
  transferId: mode_Bytes
  nonce: BigInt
  status: mode_TransferStatus
  routers(skip: Int = 0, first: Int = 100, orderBy: mode_Router_orderBy, orderDirection: mode_OrderDirection, where: mode_Router_filter): [mode_Router!]
  originDomain: BigInt
  destinationDomain: BigInt
  canonicalDomain: BigInt
  to: mode_Bytes
  delegate: mode_Bytes
  receiveLocal: Boolean
  callData: mode_Bytes
  slippage: BigInt
  bumpSlippageCount: BigInt
  originSender: mode_Bytes
  bridgedAmt: BigInt
  normalizedIn: BigInt
  canonicalId: mode_Bytes
  asset: mode_Asset
  amount: BigInt
  routersFee: BigInt
  executedCaller: mode_Bytes
  executedTransactionHash: mode_Bytes
  executedTimestamp: BigInt
  executedGasPrice: BigInt
  executedGasLimit: BigInt
  executedBlockNumber: BigInt
  executedTxOrigin: mode_Bytes
  executedTxNonce: BigInt
  reconciledCaller: mode_Bytes
  reconciledTransactionHash: mode_Bytes
  reconciledTimestamp: BigInt
  reconciledGasPrice: BigInt
  reconciledGasLimit: BigInt
  reconciledBlockNumber: BigInt
  reconciledTxOrigin: mode_Bytes
  reconciledTxNonce: BigInt
}

input mode_DestinationTransfer_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  chainId: BigInt
  chainId_not: BigInt
  chainId_gt: BigInt
  chainId_lt: BigInt
  chainId_gte: BigInt
  chainId_lte: BigInt
  chainId_in: [BigInt!]
  chainId_not_in: [BigInt!]
  transferId: mode_Bytes
  transferId_not: mode_Bytes
  transferId_gt: mode_Bytes
  transferId_lt: mode_Bytes
  transferId_gte: mode_Bytes
  transferId_lte: mode_Bytes
  transferId_in: [mode_Bytes!]
  transferId_not_in: [mode_Bytes!]
  transferId_contains: mode_Bytes
  transferId_not_contains: mode_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  status: mode_TransferStatus
  status_not: mode_TransferStatus
  status_in: [mode_TransferStatus!]
  status_not_in: [mode_TransferStatus!]
  routers: [String!]
  routers_not: [String!]
  routers_contains: [String!]
  routers_contains_nocase: [String!]
  routers_not_contains: [String!]
  routers_not_contains_nocase: [String!]
  routers_: mode_Router_filter
  originDomain: BigInt
  originDomain_not: BigInt
  originDomain_gt: BigInt
  originDomain_lt: BigInt
  originDomain_gte: BigInt
  originDomain_lte: BigInt
  originDomain_in: [BigInt!]
  originDomain_not_in: [BigInt!]
  destinationDomain: BigInt
  destinationDomain_not: BigInt
  destinationDomain_gt: BigInt
  destinationDomain_lt: BigInt
  destinationDomain_gte: BigInt
  destinationDomain_lte: BigInt
  destinationDomain_in: [BigInt!]
  destinationDomain_not_in: [BigInt!]
  canonicalDomain: BigInt
  canonicalDomain_not: BigInt
  canonicalDomain_gt: BigInt
  canonicalDomain_lt: BigInt
  canonicalDomain_gte: BigInt
  canonicalDomain_lte: BigInt
  canonicalDomain_in: [BigInt!]
  canonicalDomain_not_in: [BigInt!]
  to: mode_Bytes
  to_not: mode_Bytes
  to_gt: mode_Bytes
  to_lt: mode_Bytes
  to_gte: mode_Bytes
  to_lte: mode_Bytes
  to_in: [mode_Bytes!]
  to_not_in: [mode_Bytes!]
  to_contains: mode_Bytes
  to_not_contains: mode_Bytes
  delegate: mode_Bytes
  delegate_not: mode_Bytes
  delegate_gt: mode_Bytes
  delegate_lt: mode_Bytes
  delegate_gte: mode_Bytes
  delegate_lte: mode_Bytes
  delegate_in: [mode_Bytes!]
  delegate_not_in: [mode_Bytes!]
  delegate_contains: mode_Bytes
  delegate_not_contains: mode_Bytes
  receiveLocal: Boolean
  receiveLocal_not: Boolean
  receiveLocal_in: [Boolean!]
  receiveLocal_not_in: [Boolean!]
  callData: mode_Bytes
  callData_not: mode_Bytes
  callData_gt: mode_Bytes
  callData_lt: mode_Bytes
  callData_gte: mode_Bytes
  callData_lte: mode_Bytes
  callData_in: [mode_Bytes!]
  callData_not_in: [mode_Bytes!]
  callData_contains: mode_Bytes
  callData_not_contains: mode_Bytes
  slippage: BigInt
  slippage_not: BigInt
  slippage_gt: BigInt
  slippage_lt: BigInt
  slippage_gte: BigInt
  slippage_lte: BigInt
  slippage_in: [BigInt!]
  slippage_not_in: [BigInt!]
  bumpSlippageCount: BigInt
  bumpSlippageCount_not: BigInt
  bumpSlippageCount_gt: BigInt
  bumpSlippageCount_lt: BigInt
  bumpSlippageCount_gte: BigInt
  bumpSlippageCount_lte: BigInt
  bumpSlippageCount_in: [BigInt!]
  bumpSlippageCount_not_in: [BigInt!]
  originSender: mode_Bytes
  originSender_not: mode_Bytes
  originSender_gt: mode_Bytes
  originSender_lt: mode_Bytes
  originSender_gte: mode_Bytes
  originSender_lte: mode_Bytes
  originSender_in: [mode_Bytes!]
  originSender_not_in: [mode_Bytes!]
  originSender_contains: mode_Bytes
  originSender_not_contains: mode_Bytes
  bridgedAmt: BigInt
  bridgedAmt_not: BigInt
  bridgedAmt_gt: BigInt
  bridgedAmt_lt: BigInt
  bridgedAmt_gte: BigInt
  bridgedAmt_lte: BigInt
  bridgedAmt_in: [BigInt!]
  bridgedAmt_not_in: [BigInt!]
  normalizedIn: BigInt
  normalizedIn_not: BigInt
  normalizedIn_gt: BigInt
  normalizedIn_lt: BigInt
  normalizedIn_gte: BigInt
  normalizedIn_lte: BigInt
  normalizedIn_in: [BigInt!]
  normalizedIn_not_in: [BigInt!]
  canonicalId: mode_Bytes
  canonicalId_not: mode_Bytes
  canonicalId_gt: mode_Bytes
  canonicalId_lt: mode_Bytes
  canonicalId_gte: mode_Bytes
  canonicalId_lte: mode_Bytes
  canonicalId_in: [mode_Bytes!]
  canonicalId_not_in: [mode_Bytes!]
  canonicalId_contains: mode_Bytes
  canonicalId_not_contains: mode_Bytes
  asset: String
  asset_not: String
  asset_gt: String
  asset_lt: String
  asset_gte: String
  asset_lte: String
  asset_in: [String!]
  asset_not_in: [String!]
  asset_contains: String
  asset_contains_nocase: String
  asset_not_contains: String
  asset_not_contains_nocase: String
  asset_starts_with: String
  asset_starts_with_nocase: String
  asset_not_starts_with: String
  asset_not_starts_with_nocase: String
  asset_ends_with: String
  asset_ends_with_nocase: String
  asset_not_ends_with: String
  asset_not_ends_with_nocase: String
  asset_: mode_Asset_filter
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  routersFee: BigInt
  routersFee_not: BigInt
  routersFee_gt: BigInt
  routersFee_lt: BigInt
  routersFee_gte: BigInt
  routersFee_lte: BigInt
  routersFee_in: [BigInt!]
  routersFee_not_in: [BigInt!]
  executedCaller: mode_Bytes
  executedCaller_not: mode_Bytes
  executedCaller_gt: mode_Bytes
  executedCaller_lt: mode_Bytes
  executedCaller_gte: mode_Bytes
  executedCaller_lte: mode_Bytes
  executedCaller_in: [mode_Bytes!]
  executedCaller_not_in: [mode_Bytes!]
  executedCaller_contains: mode_Bytes
  executedCaller_not_contains: mode_Bytes
  executedTransactionHash: mode_Bytes
  executedTransactionHash_not: mode_Bytes
  executedTransactionHash_gt: mode_Bytes
  executedTransactionHash_lt: mode_Bytes
  executedTransactionHash_gte: mode_Bytes
  executedTransactionHash_lte: mode_Bytes
  executedTransactionHash_in: [mode_Bytes!]
  executedTransactionHash_not_in: [mode_Bytes!]
  executedTransactionHash_contains: mode_Bytes
  executedTransactionHash_not_contains: mode_Bytes
  executedTimestamp: BigInt
  executedTimestamp_not: BigInt
  executedTimestamp_gt: BigInt
  executedTimestamp_lt: BigInt
  executedTimestamp_gte: BigInt
  executedTimestamp_lte: BigInt
  executedTimestamp_in: [BigInt!]
  executedTimestamp_not_in: [BigInt!]
  executedGasPrice: BigInt
  executedGasPrice_not: BigInt
  executedGasPrice_gt: BigInt
  executedGasPrice_lt: BigInt
  executedGasPrice_gte: BigInt
  executedGasPrice_lte: BigInt
  executedGasPrice_in: [BigInt!]
  executedGasPrice_not_in: [BigInt!]
  executedGasLimit: BigInt
  executedGasLimit_not: BigInt
  executedGasLimit_gt: BigInt
  executedGasLimit_lt: BigInt
  executedGasLimit_gte: BigInt
  executedGasLimit_lte: BigInt
  executedGasLimit_in: [BigInt!]
  executedGasLimit_not_in: [BigInt!]
  executedBlockNumber: BigInt
  executedBlockNumber_not: BigInt
  executedBlockNumber_gt: BigInt
  executedBlockNumber_lt: BigInt
  executedBlockNumber_gte: BigInt
  executedBlockNumber_lte: BigInt
  executedBlockNumber_in: [BigInt!]
  executedBlockNumber_not_in: [BigInt!]
  executedTxOrigin: mode_Bytes
  executedTxOrigin_not: mode_Bytes
  executedTxOrigin_gt: mode_Bytes
  executedTxOrigin_lt: mode_Bytes
  executedTxOrigin_gte: mode_Bytes
  executedTxOrigin_lte: mode_Bytes
  executedTxOrigin_in: [mode_Bytes!]
  executedTxOrigin_not_in: [mode_Bytes!]
  executedTxOrigin_contains: mode_Bytes
  executedTxOrigin_not_contains: mode_Bytes
  executedTxNonce: BigInt
  executedTxNonce_not: BigInt
  executedTxNonce_gt: BigInt
  executedTxNonce_lt: BigInt
  executedTxNonce_gte: BigInt
  executedTxNonce_lte: BigInt
  executedTxNonce_in: [BigInt!]
  executedTxNonce_not_in: [BigInt!]
  reconciledCaller: mode_Bytes
  reconciledCaller_not: mode_Bytes
  reconciledCaller_gt: mode_Bytes
  reconciledCaller_lt: mode_Bytes
  reconciledCaller_gte: mode_Bytes
  reconciledCaller_lte: mode_Bytes
  reconciledCaller_in: [mode_Bytes!]
  reconciledCaller_not_in: [mode_Bytes!]
  reconciledCaller_contains: mode_Bytes
  reconciledCaller_not_contains: mode_Bytes
  reconciledTransactionHash: mode_Bytes
  reconciledTransactionHash_not: mode_Bytes
  reconciledTransactionHash_gt: mode_Bytes
  reconciledTransactionHash_lt: mode_Bytes
  reconciledTransactionHash_gte: mode_Bytes
  reconciledTransactionHash_lte: mode_Bytes
  reconciledTransactionHash_in: [mode_Bytes!]
  reconciledTransactionHash_not_in: [mode_Bytes!]
  reconciledTransactionHash_contains: mode_Bytes
  reconciledTransactionHash_not_contains: mode_Bytes
  reconciledTimestamp: BigInt
  reconciledTimestamp_not: BigInt
  reconciledTimestamp_gt: BigInt
  reconciledTimestamp_lt: BigInt
  reconciledTimestamp_gte: BigInt
  reconciledTimestamp_lte: BigInt
  reconciledTimestamp_in: [BigInt!]
  reconciledTimestamp_not_in: [BigInt!]
  reconciledGasPrice: BigInt
  reconciledGasPrice_not: BigInt
  reconciledGasPrice_gt: BigInt
  reconciledGasPrice_lt: BigInt
  reconciledGasPrice_gte: BigInt
  reconciledGasPrice_lte: BigInt
  reconciledGasPrice_in: [BigInt!]
  reconciledGasPrice_not_in: [BigInt!]
  reconciledGasLimit: BigInt
  reconciledGasLimit_not: BigInt
  reconciledGasLimit_gt: BigInt
  reconciledGasLimit_lt: BigInt
  reconciledGasLimit_gte: BigInt
  reconciledGasLimit_lte: BigInt
  reconciledGasLimit_in: [BigInt!]
  reconciledGasLimit_not_in: [BigInt!]
  reconciledBlockNumber: BigInt
  reconciledBlockNumber_not: BigInt
  reconciledBlockNumber_gt: BigInt
  reconciledBlockNumber_lt: BigInt
  reconciledBlockNumber_gte: BigInt
  reconciledBlockNumber_lte: BigInt
  reconciledBlockNumber_in: [BigInt!]
  reconciledBlockNumber_not_in: [BigInt!]
  reconciledTxOrigin: mode_Bytes
  reconciledTxOrigin_not: mode_Bytes
  reconciledTxOrigin_gt: mode_Bytes
  reconciledTxOrigin_lt: mode_Bytes
  reconciledTxOrigin_gte: mode_Bytes
  reconciledTxOrigin_lte: mode_Bytes
  reconciledTxOrigin_in: [mode_Bytes!]
  reconciledTxOrigin_not_in: [mode_Bytes!]
  reconciledTxOrigin_contains: mode_Bytes
  reconciledTxOrigin_not_contains: mode_Bytes
  reconciledTxNonce: BigInt
  reconciledTxNonce_not: BigInt
  reconciledTxNonce_gt: BigInt
  reconciledTxNonce_lt: BigInt
  reconciledTxNonce_gte: BigInt
  reconciledTxNonce_lte: BigInt
  reconciledTxNonce_in: [BigInt!]
  reconciledTxNonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: mode_BlockChangedFilter
  and: [mode_DestinationTransfer_filter]
  or: [mode_DestinationTransfer_filter]
}

enum mode_DestinationTransfer_orderBy {
  id
  chainId
  transferId
  nonce
  status
  routers
  originDomain
  destinationDomain
  canonicalDomain
  to
  delegate
  receiveLocal
  callData
  slippage
  bumpSlippageCount
  originSender
  bridgedAmt
  normalizedIn
  canonicalId
  asset
  asset__id
  asset__key
  asset__decimal
  asset__adoptedDecimal
  asset__canonicalId
  asset__canonicalDomain
  asset__adoptedAsset
  asset__localAsset
  asset__blockNumber
  amount
  routersFee
  executedCaller
  executedTransactionHash
  executedTimestamp
  executedGasPrice
  executedGasLimit
  executedBlockNumber
  executedTxOrigin
  executedTxNonce
  reconciledCaller
  reconciledTransactionHash
  reconciledTimestamp
  reconciledGasPrice
  reconciledGasLimit
  reconciledBlockNumber
  reconciledTxOrigin
  reconciledTxNonce
}

"""
8 bytes signed integer

"""
scalar mode_Int8

type mode_OptimisticRootFinalized {
  id: ID!
  aggregateRoot: mode_Bytes!
  timestamp: BigInt!
  blockNumber: BigInt
}

input mode_OptimisticRootFinalized_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  aggregateRoot: mode_Bytes
  aggregateRoot_not: mode_Bytes
  aggregateRoot_gt: mode_Bytes
  aggregateRoot_lt: mode_Bytes
  aggregateRoot_gte: mode_Bytes
  aggregateRoot_lte: mode_Bytes
  aggregateRoot_in: [mode_Bytes!]
  aggregateRoot_not_in: [mode_Bytes!]
  aggregateRoot_contains: mode_Bytes
  aggregateRoot_not_contains: mode_Bytes
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: mode_BlockChangedFilter
  and: [mode_OptimisticRootFinalized_filter]
  or: [mode_OptimisticRootFinalized_filter]
}

enum mode_OptimisticRootFinalized_orderBy {
  id
  aggregateRoot
  timestamp
  blockNumber
}

"""Defines the order direction, either ascending or descending"""
enum mode_OrderDirection {
  asc
  desc
}

type mode_OriginMessage {
  id: ID!
  transferId: mode_Bytes
  destinationDomain: BigInt
  leaf: mode_Bytes
  index: BigInt
  message: mode_Bytes
  root: mode_Bytes
  transactionHash: mode_Bytes
  blockNumber: BigInt
  rootCount: mode_RootCount
}

input mode_OriginMessage_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transferId: mode_Bytes
  transferId_not: mode_Bytes
  transferId_gt: mode_Bytes
  transferId_lt: mode_Bytes
  transferId_gte: mode_Bytes
  transferId_lte: mode_Bytes
  transferId_in: [mode_Bytes!]
  transferId_not_in: [mode_Bytes!]
  transferId_contains: mode_Bytes
  transferId_not_contains: mode_Bytes
  destinationDomain: BigInt
  destinationDomain_not: BigInt
  destinationDomain_gt: BigInt
  destinationDomain_lt: BigInt
  destinationDomain_gte: BigInt
  destinationDomain_lte: BigInt
  destinationDomain_in: [BigInt!]
  destinationDomain_not_in: [BigInt!]
  leaf: mode_Bytes
  leaf_not: mode_Bytes
  leaf_gt: mode_Bytes
  leaf_lt: mode_Bytes
  leaf_gte: mode_Bytes
  leaf_lte: mode_Bytes
  leaf_in: [mode_Bytes!]
  leaf_not_in: [mode_Bytes!]
  leaf_contains: mode_Bytes
  leaf_not_contains: mode_Bytes
  index: BigInt
  index_not: BigInt
  index_gt: BigInt
  index_lt: BigInt
  index_gte: BigInt
  index_lte: BigInt
  index_in: [BigInt!]
  index_not_in: [BigInt!]
  message: mode_Bytes
  message_not: mode_Bytes
  message_gt: mode_Bytes
  message_lt: mode_Bytes
  message_gte: mode_Bytes
  message_lte: mode_Bytes
  message_in: [mode_Bytes!]
  message_not_in: [mode_Bytes!]
  message_contains: mode_Bytes
  message_not_contains: mode_Bytes
  root: mode_Bytes
  root_not: mode_Bytes
  root_gt: mode_Bytes
  root_lt: mode_Bytes
  root_gte: mode_Bytes
  root_lte: mode_Bytes
  root_in: [mode_Bytes!]
  root_not_in: [mode_Bytes!]
  root_contains: mode_Bytes
  root_not_contains: mode_Bytes
  transactionHash: mode_Bytes
  transactionHash_not: mode_Bytes
  transactionHash_gt: mode_Bytes
  transactionHash_lt: mode_Bytes
  transactionHash_gte: mode_Bytes
  transactionHash_lte: mode_Bytes
  transactionHash_in: [mode_Bytes!]
  transactionHash_not_in: [mode_Bytes!]
  transactionHash_contains: mode_Bytes
  transactionHash_not_contains: mode_Bytes
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  rootCount: String
  rootCount_not: String
  rootCount_gt: String
  rootCount_lt: String
  rootCount_gte: String
  rootCount_lte: String
  rootCount_in: [String!]
  rootCount_not_in: [String!]
  rootCount_contains: String
  rootCount_contains_nocase: String
  rootCount_not_contains: String
  rootCount_not_contains_nocase: String
  rootCount_starts_with: String
  rootCount_starts_with_nocase: String
  rootCount_not_starts_with: String
  rootCount_not_starts_with_nocase: String
  rootCount_ends_with: String
  rootCount_ends_with_nocase: String
  rootCount_not_ends_with: String
  rootCount_not_ends_with_nocase: String
  rootCount_: mode_RootCount_filter
  """Filter for the block changed event."""
  _change_block: mode_BlockChangedFilter
  and: [mode_OriginMessage_filter]
  or: [mode_OriginMessage_filter]
}

enum mode_OriginMessage_orderBy {
  id
  transferId
  destinationDomain
  leaf
  index
  message
  root
  transactionHash
  blockNumber
  rootCount
  rootCount__id
  rootCount__count
}

type mode_OriginTransfer {
  id: ID!
  chainId: BigInt
  transferId: mode_Bytes
  nonce: BigInt
  status: mode_TransferStatus
  messageHash: mode_Bytes
  originDomain: BigInt
  destinationDomain: BigInt
  canonicalDomain: BigInt
  to: mode_Bytes
  delegate: mode_Bytes
  receiveLocal: Boolean
  callData: mode_Bytes
  slippage: BigInt
  originSender: mode_Bytes
  bridgedAmt: BigInt
  normalizedIn: BigInt
  canonicalId: mode_Bytes
  asset: mode_Asset
  transactingAsset: mode_Bytes
  message: mode_OriginMessage
  bumpRelayerFeeCount: BigInt
  relayerFees(skip: Int = 0, first: Int = 100, orderBy: mode_RelayerFee_orderBy, orderDirection: mode_OrderDirection, where: mode_RelayerFee_filter): [mode_RelayerFee!]
  initialRelayerFeeAsset: mode_Bytes
  caller: mode_Bytes
  transactionHash: mode_Bytes
  timestamp: BigInt
  gasPrice: BigInt
  gasLimit: BigInt
  blockNumber: BigInt
  txOrigin: mode_Bytes
  txNonce: BigInt
}

input mode_OriginTransfer_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  chainId: BigInt
  chainId_not: BigInt
  chainId_gt: BigInt
  chainId_lt: BigInt
  chainId_gte: BigInt
  chainId_lte: BigInt
  chainId_in: [BigInt!]
  chainId_not_in: [BigInt!]
  transferId: mode_Bytes
  transferId_not: mode_Bytes
  transferId_gt: mode_Bytes
  transferId_lt: mode_Bytes
  transferId_gte: mode_Bytes
  transferId_lte: mode_Bytes
  transferId_in: [mode_Bytes!]
  transferId_not_in: [mode_Bytes!]
  transferId_contains: mode_Bytes
  transferId_not_contains: mode_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  status: mode_TransferStatus
  status_not: mode_TransferStatus
  status_in: [mode_TransferStatus!]
  status_not_in: [mode_TransferStatus!]
  messageHash: mode_Bytes
  messageHash_not: mode_Bytes
  messageHash_gt: mode_Bytes
  messageHash_lt: mode_Bytes
  messageHash_gte: mode_Bytes
  messageHash_lte: mode_Bytes
  messageHash_in: [mode_Bytes!]
  messageHash_not_in: [mode_Bytes!]
  messageHash_contains: mode_Bytes
  messageHash_not_contains: mode_Bytes
  originDomain: BigInt
  originDomain_not: BigInt
  originDomain_gt: BigInt
  originDomain_lt: BigInt
  originDomain_gte: BigInt
  originDomain_lte: BigInt
  originDomain_in: [BigInt!]
  originDomain_not_in: [BigInt!]
  destinationDomain: BigInt
  destinationDomain_not: BigInt
  destinationDomain_gt: BigInt
  destinationDomain_lt: BigInt
  destinationDomain_gte: BigInt
  destinationDomain_lte: BigInt
  destinationDomain_in: [BigInt!]
  destinationDomain_not_in: [BigInt!]
  canonicalDomain: BigInt
  canonicalDomain_not: BigInt
  canonicalDomain_gt: BigInt
  canonicalDomain_lt: BigInt
  canonicalDomain_gte: BigInt
  canonicalDomain_lte: BigInt
  canonicalDomain_in: [BigInt!]
  canonicalDomain_not_in: [BigInt!]
  to: mode_Bytes
  to_not: mode_Bytes
  to_gt: mode_Bytes
  to_lt: mode_Bytes
  to_gte: mode_Bytes
  to_lte: mode_Bytes
  to_in: [mode_Bytes!]
  to_not_in: [mode_Bytes!]
  to_contains: mode_Bytes
  to_not_contains: mode_Bytes
  delegate: mode_Bytes
  delegate_not: mode_Bytes
  delegate_gt: mode_Bytes
  delegate_lt: mode_Bytes
  delegate_gte: mode_Bytes
  delegate_lte: mode_Bytes
  delegate_in: [mode_Bytes!]
  delegate_not_in: [mode_Bytes!]
  delegate_contains: mode_Bytes
  delegate_not_contains: mode_Bytes
  receiveLocal: Boolean
  receiveLocal_not: Boolean
  receiveLocal_in: [Boolean!]
  receiveLocal_not_in: [Boolean!]
  callData: mode_Bytes
  callData_not: mode_Bytes
  callData_gt: mode_Bytes
  callData_lt: mode_Bytes
  callData_gte: mode_Bytes
  callData_lte: mode_Bytes
  callData_in: [mode_Bytes!]
  callData_not_in: [mode_Bytes!]
  callData_contains: mode_Bytes
  callData_not_contains: mode_Bytes
  slippage: BigInt
  slippage_not: BigInt
  slippage_gt: BigInt
  slippage_lt: BigInt
  slippage_gte: BigInt
  slippage_lte: BigInt
  slippage_in: [BigInt!]
  slippage_not_in: [BigInt!]
  originSender: mode_Bytes
  originSender_not: mode_Bytes
  originSender_gt: mode_Bytes
  originSender_lt: mode_Bytes
  originSender_gte: mode_Bytes
  originSender_lte: mode_Bytes
  originSender_in: [mode_Bytes!]
  originSender_not_in: [mode_Bytes!]
  originSender_contains: mode_Bytes
  originSender_not_contains: mode_Bytes
  bridgedAmt: BigInt
  bridgedAmt_not: BigInt
  bridgedAmt_gt: BigInt
  bridgedAmt_lt: BigInt
  bridgedAmt_gte: BigInt
  bridgedAmt_lte: BigInt
  bridgedAmt_in: [BigInt!]
  bridgedAmt_not_in: [BigInt!]
  normalizedIn: BigInt
  normalizedIn_not: BigInt
  normalizedIn_gt: BigInt
  normalizedIn_lt: BigInt
  normalizedIn_gte: BigInt
  normalizedIn_lte: BigInt
  normalizedIn_in: [BigInt!]
  normalizedIn_not_in: [BigInt!]
  canonicalId: mode_Bytes
  canonicalId_not: mode_Bytes
  canonicalId_gt: mode_Bytes
  canonicalId_lt: mode_Bytes
  canonicalId_gte: mode_Bytes
  canonicalId_lte: mode_Bytes
  canonicalId_in: [mode_Bytes!]
  canonicalId_not_in: [mode_Bytes!]
  canonicalId_contains: mode_Bytes
  canonicalId_not_contains: mode_Bytes
  asset: String
  asset_not: String
  asset_gt: String
  asset_lt: String
  asset_gte: String
  asset_lte: String
  asset_in: [String!]
  asset_not_in: [String!]
  asset_contains: String
  asset_contains_nocase: String
  asset_not_contains: String
  asset_not_contains_nocase: String
  asset_starts_with: String
  asset_starts_with_nocase: String
  asset_not_starts_with: String
  asset_not_starts_with_nocase: String
  asset_ends_with: String
  asset_ends_with_nocase: String
  asset_not_ends_with: String
  asset_not_ends_with_nocase: String
  asset_: mode_Asset_filter
  transactingAsset: mode_Bytes
  transactingAsset_not: mode_Bytes
  transactingAsset_gt: mode_Bytes
  transactingAsset_lt: mode_Bytes
  transactingAsset_gte: mode_Bytes
  transactingAsset_lte: mode_Bytes
  transactingAsset_in: [mode_Bytes!]
  transactingAsset_not_in: [mode_Bytes!]
  transactingAsset_contains: mode_Bytes
  transactingAsset_not_contains: mode_Bytes
  message: String
  message_not: String
  message_gt: String
  message_lt: String
  message_gte: String
  message_lte: String
  message_in: [String!]
  message_not_in: [String!]
  message_contains: String
  message_contains_nocase: String
  message_not_contains: String
  message_not_contains_nocase: String
  message_starts_with: String
  message_starts_with_nocase: String
  message_not_starts_with: String
  message_not_starts_with_nocase: String
  message_ends_with: String
  message_ends_with_nocase: String
  message_not_ends_with: String
  message_not_ends_with_nocase: String
  message_: mode_OriginMessage_filter
  bumpRelayerFeeCount: BigInt
  bumpRelayerFeeCount_not: BigInt
  bumpRelayerFeeCount_gt: BigInt
  bumpRelayerFeeCount_lt: BigInt
  bumpRelayerFeeCount_gte: BigInt
  bumpRelayerFeeCount_lte: BigInt
  bumpRelayerFeeCount_in: [BigInt!]
  bumpRelayerFeeCount_not_in: [BigInt!]
  relayerFees: [String!]
  relayerFees_not: [String!]
  relayerFees_contains: [String!]
  relayerFees_contains_nocase: [String!]
  relayerFees_not_contains: [String!]
  relayerFees_not_contains_nocase: [String!]
  relayerFees_: mode_RelayerFee_filter
  initialRelayerFeeAsset: mode_Bytes
  initialRelayerFeeAsset_not: mode_Bytes
  initialRelayerFeeAsset_gt: mode_Bytes
  initialRelayerFeeAsset_lt: mode_Bytes
  initialRelayerFeeAsset_gte: mode_Bytes
  initialRelayerFeeAsset_lte: mode_Bytes
  initialRelayerFeeAsset_in: [mode_Bytes!]
  initialRelayerFeeAsset_not_in: [mode_Bytes!]
  initialRelayerFeeAsset_contains: mode_Bytes
  initialRelayerFeeAsset_not_contains: mode_Bytes
  caller: mode_Bytes
  caller_not: mode_Bytes
  caller_gt: mode_Bytes
  caller_lt: mode_Bytes
  caller_gte: mode_Bytes
  caller_lte: mode_Bytes
  caller_in: [mode_Bytes!]
  caller_not_in: [mode_Bytes!]
  caller_contains: mode_Bytes
  caller_not_contains: mode_Bytes
  transactionHash: mode_Bytes
  transactionHash_not: mode_Bytes
  transactionHash_gt: mode_Bytes
  transactionHash_lt: mode_Bytes
  transactionHash_gte: mode_Bytes
  transactionHash_lte: mode_Bytes
  transactionHash_in: [mode_Bytes!]
  transactionHash_not_in: [mode_Bytes!]
  transactionHash_contains: mode_Bytes
  transactionHash_not_contains: mode_Bytes
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  gasLimit: BigInt
  gasLimit_not: BigInt
  gasLimit_gt: BigInt
  gasLimit_lt: BigInt
  gasLimit_gte: BigInt
  gasLimit_lte: BigInt
  gasLimit_in: [BigInt!]
  gasLimit_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  txOrigin: mode_Bytes
  txOrigin_not: mode_Bytes
  txOrigin_gt: mode_Bytes
  txOrigin_lt: mode_Bytes
  txOrigin_gte: mode_Bytes
  txOrigin_lte: mode_Bytes
  txOrigin_in: [mode_Bytes!]
  txOrigin_not_in: [mode_Bytes!]
  txOrigin_contains: mode_Bytes
  txOrigin_not_contains: mode_Bytes
  txNonce: BigInt
  txNonce_not: BigInt
  txNonce_gt: BigInt
  txNonce_lt: BigInt
  txNonce_gte: BigInt
  txNonce_lte: BigInt
  txNonce_in: [BigInt!]
  txNonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: mode_BlockChangedFilter
  and: [mode_OriginTransfer_filter]
  or: [mode_OriginTransfer_filter]
}

enum mode_OriginTransfer_orderBy {
  id
  chainId
  transferId
  nonce
  status
  messageHash
  originDomain
  destinationDomain
  canonicalDomain
  to
  delegate
  receiveLocal
  callData
  slippage
  originSender
  bridgedAmt
  normalizedIn
  canonicalId
  asset
  asset__id
  asset__key
  asset__decimal
  asset__adoptedDecimal
  asset__canonicalId
  asset__canonicalDomain
  asset__adoptedAsset
  asset__localAsset
  asset__blockNumber
  transactingAsset
  message
  message__id
  message__transferId
  message__destinationDomain
  message__leaf
  message__index
  message__message
  message__root
  message__transactionHash
  message__blockNumber
  bumpRelayerFeeCount
  relayerFees
  initialRelayerFeeAsset
  caller
  transactionHash
  timestamp
  gasPrice
  gasLimit
  blockNumber
  txOrigin
  txNonce
}

type mode_Relayer {
  id: ID!
  isActive: Boolean!
  relayer: mode_Bytes
}

type mode_RelayerFee {
  id: ID!
  transfer: mode_OriginTransfer!
  fee: BigInt!
  asset: mode_Bytes!
}

input mode_RelayerFee_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transfer: String
  transfer_not: String
  transfer_gt: String
  transfer_lt: String
  transfer_gte: String
  transfer_lte: String
  transfer_in: [String!]
  transfer_not_in: [String!]
  transfer_contains: String
  transfer_contains_nocase: String
  transfer_not_contains: String
  transfer_not_contains_nocase: String
  transfer_starts_with: String
  transfer_starts_with_nocase: String
  transfer_not_starts_with: String
  transfer_not_starts_with_nocase: String
  transfer_ends_with: String
  transfer_ends_with_nocase: String
  transfer_not_ends_with: String
  transfer_not_ends_with_nocase: String
  transfer_: mode_OriginTransfer_filter
  fee: BigInt
  fee_not: BigInt
  fee_gt: BigInt
  fee_lt: BigInt
  fee_gte: BigInt
  fee_lte: BigInt
  fee_in: [BigInt!]
  fee_not_in: [BigInt!]
  asset: mode_Bytes
  asset_not: mode_Bytes
  asset_gt: mode_Bytes
  asset_lt: mode_Bytes
  asset_gte: mode_Bytes
  asset_lte: mode_Bytes
  asset_in: [mode_Bytes!]
  asset_not_in: [mode_Bytes!]
  asset_contains: mode_Bytes
  asset_not_contains: mode_Bytes
  """Filter for the block changed event."""
  _change_block: mode_BlockChangedFilter
  and: [mode_RelayerFee_filter]
  or: [mode_RelayerFee_filter]
}

enum mode_RelayerFee_orderBy {
  id
  transfer
  transfer__id
  transfer__chainId
  transfer__transferId
  transfer__nonce
  transfer__status
  transfer__messageHash
  transfer__originDomain
  transfer__destinationDomain
  transfer__canonicalDomain
  transfer__to
  transfer__delegate
  transfer__receiveLocal
  transfer__callData
  transfer__slippage
  transfer__originSender
  transfer__bridgedAmt
  transfer__normalizedIn
  transfer__canonicalId
  transfer__transactingAsset
  transfer__bumpRelayerFeeCount
  transfer__initialRelayerFeeAsset
  transfer__caller
  transfer__transactionHash
  transfer__timestamp
  transfer__gasPrice
  transfer__gasLimit
  transfer__blockNumber
  transfer__txOrigin
  transfer__txNonce
  fee
  asset
}

type mode_RelayerFeesIncrease {
  id: ID!
  transfer: mode_OriginTransfer!
  increase: BigInt
  asset: mode_Bytes
  caller: mode_Bytes!
  transactionHash: mode_Bytes!
  timestamp: BigInt!
  gasPrice: BigInt!
  gasLimit: BigInt!
  blockNumber: BigInt!
}

input mode_RelayerFeesIncrease_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transfer: String
  transfer_not: String
  transfer_gt: String
  transfer_lt: String
  transfer_gte: String
  transfer_lte: String
  transfer_in: [String!]
  transfer_not_in: [String!]
  transfer_contains: String
  transfer_contains_nocase: String
  transfer_not_contains: String
  transfer_not_contains_nocase: String
  transfer_starts_with: String
  transfer_starts_with_nocase: String
  transfer_not_starts_with: String
  transfer_not_starts_with_nocase: String
  transfer_ends_with: String
  transfer_ends_with_nocase: String
  transfer_not_ends_with: String
  transfer_not_ends_with_nocase: String
  transfer_: mode_OriginTransfer_filter
  increase: BigInt
  increase_not: BigInt
  increase_gt: BigInt
  increase_lt: BigInt
  increase_gte: BigInt
  increase_lte: BigInt
  increase_in: [BigInt!]
  increase_not_in: [BigInt!]
  asset: mode_Bytes
  asset_not: mode_Bytes
  asset_gt: mode_Bytes
  asset_lt: mode_Bytes
  asset_gte: mode_Bytes
  asset_lte: mode_Bytes
  asset_in: [mode_Bytes!]
  asset_not_in: [mode_Bytes!]
  asset_contains: mode_Bytes
  asset_not_contains: mode_Bytes
  caller: mode_Bytes
  caller_not: mode_Bytes
  caller_gt: mode_Bytes
  caller_lt: mode_Bytes
  caller_gte: mode_Bytes
  caller_lte: mode_Bytes
  caller_in: [mode_Bytes!]
  caller_not_in: [mode_Bytes!]
  caller_contains: mode_Bytes
  caller_not_contains: mode_Bytes
  transactionHash: mode_Bytes
  transactionHash_not: mode_Bytes
  transactionHash_gt: mode_Bytes
  transactionHash_lt: mode_Bytes
  transactionHash_gte: mode_Bytes
  transactionHash_lte: mode_Bytes
  transactionHash_in: [mode_Bytes!]
  transactionHash_not_in: [mode_Bytes!]
  transactionHash_contains: mode_Bytes
  transactionHash_not_contains: mode_Bytes
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  gasLimit: BigInt
  gasLimit_not: BigInt
  gasLimit_gt: BigInt
  gasLimit_lt: BigInt
  gasLimit_gte: BigInt
  gasLimit_lte: BigInt
  gasLimit_in: [BigInt!]
  gasLimit_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: mode_BlockChangedFilter
  and: [mode_RelayerFeesIncrease_filter]
  or: [mode_RelayerFeesIncrease_filter]
}

enum mode_RelayerFeesIncrease_orderBy {
  id
  transfer
  transfer__id
  transfer__chainId
  transfer__transferId
  transfer__nonce
  transfer__status
  transfer__messageHash
  transfer__originDomain
  transfer__destinationDomain
  transfer__canonicalDomain
  transfer__to
  transfer__delegate
  transfer__receiveLocal
  transfer__callData
  transfer__slippage
  transfer__originSender
  transfer__bridgedAmt
  transfer__normalizedIn
  transfer__canonicalId
  transfer__transactingAsset
  transfer__bumpRelayerFeeCount
  transfer__initialRelayerFeeAsset
  transfer__caller
  transfer__transactionHash
  transfer__timestamp
  transfer__gasPrice
  transfer__gasLimit
  transfer__blockNumber
  transfer__txOrigin
  transfer__txNonce
  increase
  asset
  caller
  transactionHash
  timestamp
  gasPrice
  gasLimit
  blockNumber
}

input mode_Relayer_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  isActive: Boolean
  isActive_not: Boolean
  isActive_in: [Boolean!]
  isActive_not_in: [Boolean!]
  relayer: mode_Bytes
  relayer_not: mode_Bytes
  relayer_gt: mode_Bytes
  relayer_lt: mode_Bytes
  relayer_gte: mode_Bytes
  relayer_lte: mode_Bytes
  relayer_in: [mode_Bytes!]
  relayer_not_in: [mode_Bytes!]
  relayer_contains: mode_Bytes
  relayer_not_contains: mode_Bytes
  """Filter for the block changed event."""
  _change_block: mode_BlockChangedFilter
  and: [mode_Relayer_filter]
  or: [mode_Relayer_filter]
}

enum mode_Relayer_orderBy {
  id
  isActive
  relayer
}

type mode_RootCount {
  id: ID!
  count: BigInt
}

input mode_RootCount_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  count: BigInt
  count_not: BigInt
  count_gt: BigInt
  count_lt: BigInt
  count_gte: BigInt
  count_lte: BigInt
  count_in: [BigInt!]
  count_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: mode_BlockChangedFilter
  and: [mode_RootCount_filter]
  or: [mode_RootCount_filter]
}

enum mode_RootCount_orderBy {
  id
  count
}

type mode_RootMessageSent {
  id: ID!
  spokeDomain: BigInt
  hubDomain: BigInt
  root: mode_Bytes
  count: BigInt
  caller: mode_Bytes
  transactionHash: mode_Bytes
  timestamp: BigInt
  gasPrice: BigInt
  gasLimit: BigInt
  blockNumber: BigInt
}

input mode_RootMessageSent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  spokeDomain: BigInt
  spokeDomain_not: BigInt
  spokeDomain_gt: BigInt
  spokeDomain_lt: BigInt
  spokeDomain_gte: BigInt
  spokeDomain_lte: BigInt
  spokeDomain_in: [BigInt!]
  spokeDomain_not_in: [BigInt!]
  hubDomain: BigInt
  hubDomain_not: BigInt
  hubDomain_gt: BigInt
  hubDomain_lt: BigInt
  hubDomain_gte: BigInt
  hubDomain_lte: BigInt
  hubDomain_in: [BigInt!]
  hubDomain_not_in: [BigInt!]
  root: mode_Bytes
  root_not: mode_Bytes
  root_gt: mode_Bytes
  root_lt: mode_Bytes
  root_gte: mode_Bytes
  root_lte: mode_Bytes
  root_in: [mode_Bytes!]
  root_not_in: [mode_Bytes!]
  root_contains: mode_Bytes
  root_not_contains: mode_Bytes
  count: BigInt
  count_not: BigInt
  count_gt: BigInt
  count_lt: BigInt
  count_gte: BigInt
  count_lte: BigInt
  count_in: [BigInt!]
  count_not_in: [BigInt!]
  caller: mode_Bytes
  caller_not: mode_Bytes
  caller_gt: mode_Bytes
  caller_lt: mode_Bytes
  caller_gte: mode_Bytes
  caller_lte: mode_Bytes
  caller_in: [mode_Bytes!]
  caller_not_in: [mode_Bytes!]
  caller_contains: mode_Bytes
  caller_not_contains: mode_Bytes
  transactionHash: mode_Bytes
  transactionHash_not: mode_Bytes
  transactionHash_gt: mode_Bytes
  transactionHash_lt: mode_Bytes
  transactionHash_gte: mode_Bytes
  transactionHash_lte: mode_Bytes
  transactionHash_in: [mode_Bytes!]
  transactionHash_not_in: [mode_Bytes!]
  transactionHash_contains: mode_Bytes
  transactionHash_not_contains: mode_Bytes
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  gasLimit: BigInt
  gasLimit_not: BigInt
  gasLimit_gt: BigInt
  gasLimit_lt: BigInt
  gasLimit_gte: BigInt
  gasLimit_lte: BigInt
  gasLimit_in: [BigInt!]
  gasLimit_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: mode_BlockChangedFilter
  and: [mode_RootMessageSent_filter]
  or: [mode_RootMessageSent_filter]
}

enum mode_RootMessageSent_orderBy {
  id
  spokeDomain
  hubDomain
  root
  count
  caller
  transactionHash
  timestamp
  gasPrice
  gasLimit
  blockNumber
}

type mode_Router {
  id: ID!
  isActive: Boolean!
  owner: mode_Bytes
  recipient: mode_Bytes
  proposedOwner: mode_Bytes
  proposedTimestamp: BigInt
  assetBalances(skip: Int = 0, first: Int = 100, orderBy: mode_AssetBalance_orderBy, orderDirection: mode_OrderDirection, where: mode_AssetBalance_filter): [mode_AssetBalance!]!
}

type mode_RouterDailyTVL {
  id: ID!
  router: mode_Router!
  asset: mode_Asset!
  timestamp: BigInt!
  balance: BigInt!
}

input mode_RouterDailyTVL_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  router: String
  router_not: String
  router_gt: String
  router_lt: String
  router_gte: String
  router_lte: String
  router_in: [String!]
  router_not_in: [String!]
  router_contains: String
  router_contains_nocase: String
  router_not_contains: String
  router_not_contains_nocase: String
  router_starts_with: String
  router_starts_with_nocase: String
  router_not_starts_with: String
  router_not_starts_with_nocase: String
  router_ends_with: String
  router_ends_with_nocase: String
  router_not_ends_with: String
  router_not_ends_with_nocase: String
  router_: mode_Router_filter
  asset: String
  asset_not: String
  asset_gt: String
  asset_lt: String
  asset_gte: String
  asset_lte: String
  asset_in: [String!]
  asset_not_in: [String!]
  asset_contains: String
  asset_contains_nocase: String
  asset_not_contains: String
  asset_not_contains_nocase: String
  asset_starts_with: String
  asset_starts_with_nocase: String
  asset_not_starts_with: String
  asset_not_starts_with_nocase: String
  asset_ends_with: String
  asset_ends_with_nocase: String
  asset_not_ends_with: String
  asset_not_ends_with_nocase: String
  asset_: mode_Asset_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  balance: BigInt
  balance_not: BigInt
  balance_gt: BigInt
  balance_lt: BigInt
  balance_gte: BigInt
  balance_lte: BigInt
  balance_in: [BigInt!]
  balance_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: mode_BlockChangedFilter
  and: [mode_RouterDailyTVL_filter]
  or: [mode_RouterDailyTVL_filter]
}

enum mode_RouterDailyTVL_orderBy {
  id
  router
  router__id
  router__isActive
  router__owner
  router__recipient
  router__proposedOwner
  router__proposedTimestamp
  asset
  asset__id
  asset__key
  asset__decimal
  asset__adoptedDecimal
  asset__canonicalId
  asset__canonicalDomain
  asset__adoptedAsset
  asset__localAsset
  asset__blockNumber
  timestamp
  balance
}

type mode_RouterLiquidityEvent {
  id: ID!
  type: mode_RouterLiquidityEventType
  router: mode_Router!
  asset: mode_Asset!
  amount: BigInt!
  balance: BigInt!
  caller: mode_Bytes
  blockNumber: BigInt!
  timestamp: BigInt!
  transactionHash: mode_Bytes!
  nonce: BigInt!
}

enum mode_RouterLiquidityEventType {
  Add
  Remove
}

input mode_RouterLiquidityEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  type: mode_RouterLiquidityEventType
  type_not: mode_RouterLiquidityEventType
  type_in: [mode_RouterLiquidityEventType!]
  type_not_in: [mode_RouterLiquidityEventType!]
  router: String
  router_not: String
  router_gt: String
  router_lt: String
  router_gte: String
  router_lte: String
  router_in: [String!]
  router_not_in: [String!]
  router_contains: String
  router_contains_nocase: String
  router_not_contains: String
  router_not_contains_nocase: String
  router_starts_with: String
  router_starts_with_nocase: String
  router_not_starts_with: String
  router_not_starts_with_nocase: String
  router_ends_with: String
  router_ends_with_nocase: String
  router_not_ends_with: String
  router_not_ends_with_nocase: String
  router_: mode_Router_filter
  asset: String
  asset_not: String
  asset_gt: String
  asset_lt: String
  asset_gte: String
  asset_lte: String
  asset_in: [String!]
  asset_not_in: [String!]
  asset_contains: String
  asset_contains_nocase: String
  asset_not_contains: String
  asset_not_contains_nocase: String
  asset_starts_with: String
  asset_starts_with_nocase: String
  asset_not_starts_with: String
  asset_not_starts_with_nocase: String
  asset_ends_with: String
  asset_ends_with_nocase: String
  asset_not_ends_with: String
  asset_not_ends_with_nocase: String
  asset_: mode_Asset_filter
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  balance: BigInt
  balance_not: BigInt
  balance_gt: BigInt
  balance_lt: BigInt
  balance_gte: BigInt
  balance_lte: BigInt
  balance_in: [BigInt!]
  balance_not_in: [BigInt!]
  caller: mode_Bytes
  caller_not: mode_Bytes
  caller_gt: mode_Bytes
  caller_lt: mode_Bytes
  caller_gte: mode_Bytes
  caller_lte: mode_Bytes
  caller_in: [mode_Bytes!]
  caller_not_in: [mode_Bytes!]
  caller_contains: mode_Bytes
  caller_not_contains: mode_Bytes
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transactionHash: mode_Bytes
  transactionHash_not: mode_Bytes
  transactionHash_gt: mode_Bytes
  transactionHash_lt: mode_Bytes
  transactionHash_gte: mode_Bytes
  transactionHash_lte: mode_Bytes
  transactionHash_in: [mode_Bytes!]
  transactionHash_not_in: [mode_Bytes!]
  transactionHash_contains: mode_Bytes
  transactionHash_not_contains: mode_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: mode_BlockChangedFilter
  and: [mode_RouterLiquidityEvent_filter]
  or: [mode_RouterLiquidityEvent_filter]
}

enum mode_RouterLiquidityEvent_orderBy {
  id
  type
  router
  router__id
  router__isActive
  router__owner
  router__recipient
  router__proposedOwner
  router__proposedTimestamp
  asset
  asset__id
  asset__key
  asset__decimal
  asset__adoptedDecimal
  asset__canonicalId
  asset__canonicalDomain
  asset__adoptedAsset
  asset__localAsset
  asset__blockNumber
  amount
  balance
  caller
  blockNumber
  timestamp
  transactionHash
  nonce
}

input mode_Router_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  isActive: Boolean
  isActive_not: Boolean
  isActive_in: [Boolean!]
  isActive_not_in: [Boolean!]
  owner: mode_Bytes
  owner_not: mode_Bytes
  owner_gt: mode_Bytes
  owner_lt: mode_Bytes
  owner_gte: mode_Bytes
  owner_lte: mode_Bytes
  owner_in: [mode_Bytes!]
  owner_not_in: [mode_Bytes!]
  owner_contains: mode_Bytes
  owner_not_contains: mode_Bytes
  recipient: mode_Bytes
  recipient_not: mode_Bytes
  recipient_gt: mode_Bytes
  recipient_lt: mode_Bytes
  recipient_gte: mode_Bytes
  recipient_lte: mode_Bytes
  recipient_in: [mode_Bytes!]
  recipient_not_in: [mode_Bytes!]
  recipient_contains: mode_Bytes
  recipient_not_contains: mode_Bytes
  proposedOwner: mode_Bytes
  proposedOwner_not: mode_Bytes
  proposedOwner_gt: mode_Bytes
  proposedOwner_lt: mode_Bytes
  proposedOwner_gte: mode_Bytes
  proposedOwner_lte: mode_Bytes
  proposedOwner_in: [mode_Bytes!]
  proposedOwner_not_in: [mode_Bytes!]
  proposedOwner_contains: mode_Bytes
  proposedOwner_not_contains: mode_Bytes
  proposedTimestamp: BigInt
  proposedTimestamp_not: BigInt
  proposedTimestamp_gt: BigInt
  proposedTimestamp_lt: BigInt
  proposedTimestamp_gte: BigInt
  proposedTimestamp_lte: BigInt
  proposedTimestamp_in: [BigInt!]
  proposedTimestamp_not_in: [BigInt!]
  assetBalances_: mode_AssetBalance_filter
  """Filter for the block changed event."""
  _change_block: mode_BlockChangedFilter
  and: [mode_Router_filter]
  or: [mode_Router_filter]
}

enum mode_Router_orderBy {
  id
  isActive
  owner
  recipient
  proposedOwner
  proposedTimestamp
  assetBalances
}

type mode_Sequencer {
  id: ID!
  isActive: Boolean!
  sequencer: mode_Bytes
}

input mode_Sequencer_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  isActive: Boolean
  isActive_not: Boolean
  isActive_in: [Boolean!]
  isActive_not_in: [Boolean!]
  sequencer: mode_Bytes
  sequencer_not: mode_Bytes
  sequencer_gt: mode_Bytes
  sequencer_lt: mode_Bytes
  sequencer_gte: mode_Bytes
  sequencer_lte: mode_Bytes
  sequencer_in: [mode_Bytes!]
  sequencer_not_in: [mode_Bytes!]
  sequencer_contains: mode_Bytes
  sequencer_not_contains: mode_Bytes
  """Filter for the block changed event."""
  _change_block: mode_BlockChangedFilter
  and: [mode_Sequencer_filter]
  or: [mode_Sequencer_filter]
}

enum mode_Sequencer_orderBy {
  id
  isActive
  sequencer
}

type mode_Setting {
  id: ID!
  maxRoutersPerTransfer: BigInt!
  caller: mode_Bytes!
}

input mode_Setting_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  maxRoutersPerTransfer: BigInt
  maxRoutersPerTransfer_not: BigInt
  maxRoutersPerTransfer_gt: BigInt
  maxRoutersPerTransfer_lt: BigInt
  maxRoutersPerTransfer_gte: BigInt
  maxRoutersPerTransfer_lte: BigInt
  maxRoutersPerTransfer_in: [BigInt!]
  maxRoutersPerTransfer_not_in: [BigInt!]
  caller: mode_Bytes
  caller_not: mode_Bytes
  caller_gt: mode_Bytes
  caller_lt: mode_Bytes
  caller_gte: mode_Bytes
  caller_lte: mode_Bytes
  caller_in: [mode_Bytes!]
  caller_not_in: [mode_Bytes!]
  caller_contains: mode_Bytes
  caller_not_contains: mode_Bytes
  """Filter for the block changed event."""
  _change_block: mode_BlockChangedFilter
  and: [mode_Setting_filter]
  or: [mode_Setting_filter]
}

enum mode_Setting_orderBy {
  id
  maxRoutersPerTransfer
  caller
}

type mode_SlippageUpdate {
  id: ID!
  transfer: mode_DestinationTransfer!
  slippage: BigInt!
  caller: mode_Bytes!
  transactionHash: mode_Bytes!
  timestamp: BigInt!
  gasPrice: BigInt!
  gasLimit: BigInt!
  blockNumber: BigInt!
}

input mode_SlippageUpdate_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transfer: String
  transfer_not: String
  transfer_gt: String
  transfer_lt: String
  transfer_gte: String
  transfer_lte: String
  transfer_in: [String!]
  transfer_not_in: [String!]
  transfer_contains: String
  transfer_contains_nocase: String
  transfer_not_contains: String
  transfer_not_contains_nocase: String
  transfer_starts_with: String
  transfer_starts_with_nocase: String
  transfer_not_starts_with: String
  transfer_not_starts_with_nocase: String
  transfer_ends_with: String
  transfer_ends_with_nocase: String
  transfer_not_ends_with: String
  transfer_not_ends_with_nocase: String
  transfer_: mode_DestinationTransfer_filter
  slippage: BigInt
  slippage_not: BigInt
  slippage_gt: BigInt
  slippage_lt: BigInt
  slippage_gte: BigInt
  slippage_lte: BigInt
  slippage_in: [BigInt!]
  slippage_not_in: [BigInt!]
  caller: mode_Bytes
  caller_not: mode_Bytes
  caller_gt: mode_Bytes
  caller_lt: mode_Bytes
  caller_gte: mode_Bytes
  caller_lte: mode_Bytes
  caller_in: [mode_Bytes!]
  caller_not_in: [mode_Bytes!]
  caller_contains: mode_Bytes
  caller_not_contains: mode_Bytes
  transactionHash: mode_Bytes
  transactionHash_not: mode_Bytes
  transactionHash_gt: mode_Bytes
  transactionHash_lt: mode_Bytes
  transactionHash_gte: mode_Bytes
  transactionHash_lte: mode_Bytes
  transactionHash_in: [mode_Bytes!]
  transactionHash_not_in: [mode_Bytes!]
  transactionHash_contains: mode_Bytes
  transactionHash_not_contains: mode_Bytes
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  gasLimit: BigInt
  gasLimit_not: BigInt
  gasLimit_gt: BigInt
  gasLimit_lt: BigInt
  gasLimit_gte: BigInt
  gasLimit_lte: BigInt
  gasLimit_in: [BigInt!]
  gasLimit_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: mode_BlockChangedFilter
  and: [mode_SlippageUpdate_filter]
  or: [mode_SlippageUpdate_filter]
}

enum mode_SlippageUpdate_orderBy {
  id
  transfer
  transfer__id
  transfer__chainId
  transfer__transferId
  transfer__nonce
  transfer__status
  transfer__originDomain
  transfer__destinationDomain
  transfer__canonicalDomain
  transfer__to
  transfer__delegate
  transfer__receiveLocal
  transfer__callData
  transfer__slippage
  transfer__bumpSlippageCount
  transfer__originSender
  transfer__bridgedAmt
  transfer__normalizedIn
  transfer__canonicalId
  transfer__amount
  transfer__routersFee
  transfer__executedCaller
  transfer__executedTransactionHash
  transfer__executedTimestamp
  transfer__executedGasPrice
  transfer__executedGasLimit
  transfer__executedBlockNumber
  transfer__executedTxOrigin
  transfer__executedTxNonce
  transfer__reconciledCaller
  transfer__reconciledTransactionHash
  transfer__reconciledTimestamp
  transfer__reconciledGasPrice
  transfer__reconciledGasLimit
  transfer__reconciledBlockNumber
  transfer__reconciledTxOrigin
  transfer__reconciledTxNonce
  slippage
  caller
  transactionHash
  timestamp
  gasPrice
  gasLimit
  blockNumber
}

type mode_SnapshotRoot {
  id: ID!
  spokeDomain: BigInt
  root: mode_Bytes!
  count: BigInt!
  timestamp: BigInt!
  blockNumber: BigInt!
}

input mode_SnapshotRoot_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  spokeDomain: BigInt
  spokeDomain_not: BigInt
  spokeDomain_gt: BigInt
  spokeDomain_lt: BigInt
  spokeDomain_gte: BigInt
  spokeDomain_lte: BigInt
  spokeDomain_in: [BigInt!]
  spokeDomain_not_in: [BigInt!]
  root: mode_Bytes
  root_not: mode_Bytes
  root_gt: mode_Bytes
  root_lt: mode_Bytes
  root_gte: mode_Bytes
  root_lte: mode_Bytes
  root_in: [mode_Bytes!]
  root_not_in: [mode_Bytes!]
  root_contains: mode_Bytes
  root_not_contains: mode_Bytes
  count: BigInt
  count_not: BigInt
  count_gt: BigInt
  count_lt: BigInt
  count_gte: BigInt
  count_lte: BigInt
  count_in: [BigInt!]
  count_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: mode_BlockChangedFilter
  and: [mode_SnapshotRoot_filter]
  or: [mode_SnapshotRoot_filter]
}

enum mode_SnapshotRoot_orderBy {
  id
  spokeDomain
  root
  count
  timestamp
  blockNumber
}

type mode_SpokeConnectorMode {
  id: ID!
  mode: String!
}

input mode_SpokeConnectorMode_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  mode: String
  mode_not: String
  mode_gt: String
  mode_lt: String
  mode_gte: String
  mode_lte: String
  mode_in: [String!]
  mode_not_in: [String!]
  mode_contains: String
  mode_contains_nocase: String
  mode_not_contains: String
  mode_not_contains_nocase: String
  mode_starts_with: String
  mode_starts_with_nocase: String
  mode_not_starts_with: String
  mode_not_starts_with_nocase: String
  mode_ends_with: String
  mode_ends_with_nocase: String
  mode_not_ends_with: String
  mode_not_ends_with_nocase: String
  """Filter for the block changed event."""
  _change_block: mode_BlockChangedFilter
  and: [mode_SpokeConnectorMode_filter]
  or: [mode_SpokeConnectorMode_filter]
}

enum mode_SpokeConnectorMode_orderBy {
  id
  mode
}

enum mode_TransferStatus {
  XCalled
  Executed
  Reconciled
  CompletedSlow
  CompletedFast
}

type mode__Block_ {
  """The hash of the block"""
  hash: mode_Bytes
  """The block number"""
  number: Int!
  """Integer representation of the timestamp stored in blocks for the chain"""
  timestamp: Int
  """The hash of the parent block"""
  parentHash: mode_Bytes
}

"""The type for the top-level _meta field"""
type mode__Meta_ {
  """
  Information about a specific subgraph block. The hash of the block
  will be null if the _meta field has a block constraint that asks for
  a block number. It will be filled if the _meta field has no block constraint
  and therefore asks for the latest  block
  
  """
  block: mode__Block_!
  """The deployment ID"""
  deployment: String!
  """If `true`, the subgraph encountered indexing errors at some past block"""
  hasIndexingErrors: Boolean!
}

type arbitrumone_AggregateRoot {
  id: ID!
  root: arbitrumone_Bytes!
  blockNumber: BigInt!
}

type arbitrumone_AggregateRootProposed {
  id: ID!
  aggregateRoot: arbitrumone_Bytes!
  rootTimestamp: BigInt!
  endOfDispute: BigInt!
  domain: BigInt!
  timestamp: BigInt!
  blockNumber: BigInt
}

input arbitrumone_AggregateRootProposed_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  aggregateRoot: arbitrumone_Bytes
  aggregateRoot_not: arbitrumone_Bytes
  aggregateRoot_gt: arbitrumone_Bytes
  aggregateRoot_lt: arbitrumone_Bytes
  aggregateRoot_gte: arbitrumone_Bytes
  aggregateRoot_lte: arbitrumone_Bytes
  aggregateRoot_in: [arbitrumone_Bytes!]
  aggregateRoot_not_in: [arbitrumone_Bytes!]
  aggregateRoot_contains: arbitrumone_Bytes
  aggregateRoot_not_contains: arbitrumone_Bytes
  rootTimestamp: BigInt
  rootTimestamp_not: BigInt
  rootTimestamp_gt: BigInt
  rootTimestamp_lt: BigInt
  rootTimestamp_gte: BigInt
  rootTimestamp_lte: BigInt
  rootTimestamp_in: [BigInt!]
  rootTimestamp_not_in: [BigInt!]
  endOfDispute: BigInt
  endOfDispute_not: BigInt
  endOfDispute_gt: BigInt
  endOfDispute_lt: BigInt
  endOfDispute_gte: BigInt
  endOfDispute_lte: BigInt
  endOfDispute_in: [BigInt!]
  endOfDispute_not_in: [BigInt!]
  domain: BigInt
  domain_not: BigInt
  domain_gt: BigInt
  domain_lt: BigInt
  domain_gte: BigInt
  domain_lte: BigInt
  domain_in: [BigInt!]
  domain_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: arbitrumone_BlockChangedFilter
  and: [arbitrumone_AggregateRootProposed_filter]
  or: [arbitrumone_AggregateRootProposed_filter]
}

enum arbitrumone_AggregateRootProposed_orderBy {
  id
  aggregateRoot
  rootTimestamp
  endOfDispute
  domain
  timestamp
  blockNumber
}

input arbitrumone_AggregateRoot_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  root: arbitrumone_Bytes
  root_not: arbitrumone_Bytes
  root_gt: arbitrumone_Bytes
  root_lt: arbitrumone_Bytes
  root_gte: arbitrumone_Bytes
  root_lte: arbitrumone_Bytes
  root_in: [arbitrumone_Bytes!]
  root_not_in: [arbitrumone_Bytes!]
  root_contains: arbitrumone_Bytes
  root_not_contains: arbitrumone_Bytes
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: arbitrumone_BlockChangedFilter
  and: [arbitrumone_AggregateRoot_filter]
  or: [arbitrumone_AggregateRoot_filter]
}

enum arbitrumone_AggregateRoot_orderBy {
  id
  root
  blockNumber
}

enum arbitrumone_Aggregation_interval {
  hour
  day
}

type arbitrumone_Asset {
  id: ID!
  key: arbitrumone_Bytes
  decimal: BigInt
  adoptedDecimal: BigInt
  canonicalId: arbitrumone_Bytes
  canonicalDomain: BigInt
  adoptedAsset: arbitrumone_Bytes
  localAsset: arbitrumone_Bytes
  blockNumber: BigInt
  status: arbitrumone_AssetStatus
}

type arbitrumone_AssetBalance {
  id: ID!
  amount: BigInt!
  locked: BigInt!
  supplied: BigInt!
  removed: BigInt!
  router: arbitrumone_Router!
  asset: arbitrumone_Asset!
  feesEarned: BigInt!
}

input arbitrumone_AssetBalance_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  locked: BigInt
  locked_not: BigInt
  locked_gt: BigInt
  locked_lt: BigInt
  locked_gte: BigInt
  locked_lte: BigInt
  locked_in: [BigInt!]
  locked_not_in: [BigInt!]
  supplied: BigInt
  supplied_not: BigInt
  supplied_gt: BigInt
  supplied_lt: BigInt
  supplied_gte: BigInt
  supplied_lte: BigInt
  supplied_in: [BigInt!]
  supplied_not_in: [BigInt!]
  removed: BigInt
  removed_not: BigInt
  removed_gt: BigInt
  removed_lt: BigInt
  removed_gte: BigInt
  removed_lte: BigInt
  removed_in: [BigInt!]
  removed_not_in: [BigInt!]
  router: String
  router_not: String
  router_gt: String
  router_lt: String
  router_gte: String
  router_lte: String
  router_in: [String!]
  router_not_in: [String!]
  router_contains: String
  router_contains_nocase: String
  router_not_contains: String
  router_not_contains_nocase: String
  router_starts_with: String
  router_starts_with_nocase: String
  router_not_starts_with: String
  router_not_starts_with_nocase: String
  router_ends_with: String
  router_ends_with_nocase: String
  router_not_ends_with: String
  router_not_ends_with_nocase: String
  router_: arbitrumone_Router_filter
  asset: String
  asset_not: String
  asset_gt: String
  asset_lt: String
  asset_gte: String
  asset_lte: String
  asset_in: [String!]
  asset_not_in: [String!]
  asset_contains: String
  asset_contains_nocase: String
  asset_not_contains: String
  asset_not_contains_nocase: String
  asset_starts_with: String
  asset_starts_with_nocase: String
  asset_not_starts_with: String
  asset_not_starts_with_nocase: String
  asset_ends_with: String
  asset_ends_with_nocase: String
  asset_not_ends_with: String
  asset_not_ends_with_nocase: String
  asset_: arbitrumone_Asset_filter
  feesEarned: BigInt
  feesEarned_not: BigInt
  feesEarned_gt: BigInt
  feesEarned_lt: BigInt
  feesEarned_gte: BigInt
  feesEarned_lte: BigInt
  feesEarned_in: [BigInt!]
  feesEarned_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: arbitrumone_BlockChangedFilter
  and: [arbitrumone_AssetBalance_filter]
  or: [arbitrumone_AssetBalance_filter]
}

enum arbitrumone_AssetBalance_orderBy {
  id
  amount
  locked
  supplied
  removed
  router
  router__id
  router__isActive
  router__owner
  router__recipient
  router__proposedOwner
  router__proposedTimestamp
  asset
  asset__id
  asset__key
  asset__decimal
  asset__adoptedDecimal
  asset__canonicalId
  asset__canonicalDomain
  asset__adoptedAsset
  asset__localAsset
  asset__blockNumber
  feesEarned
}

type arbitrumone_AssetStatus {
  id: ID!
  status: Boolean
}

input arbitrumone_AssetStatus_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  status: Boolean
  status_not: Boolean
  status_in: [Boolean!]
  status_not_in: [Boolean!]
  """Filter for the block changed event."""
  _change_block: arbitrumone_BlockChangedFilter
  and: [arbitrumone_AssetStatus_filter]
  or: [arbitrumone_AssetStatus_filter]
}

enum arbitrumone_AssetStatus_orderBy {
  id
  status
}

input arbitrumone_Asset_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  key: arbitrumone_Bytes
  key_not: arbitrumone_Bytes
  key_gt: arbitrumone_Bytes
  key_lt: arbitrumone_Bytes
  key_gte: arbitrumone_Bytes
  key_lte: arbitrumone_Bytes
  key_in: [arbitrumone_Bytes!]
  key_not_in: [arbitrumone_Bytes!]
  key_contains: arbitrumone_Bytes
  key_not_contains: arbitrumone_Bytes
  decimal: BigInt
  decimal_not: BigInt
  decimal_gt: BigInt
  decimal_lt: BigInt
  decimal_gte: BigInt
  decimal_lte: BigInt
  decimal_in: [BigInt!]
  decimal_not_in: [BigInt!]
  adoptedDecimal: BigInt
  adoptedDecimal_not: BigInt
  adoptedDecimal_gt: BigInt
  adoptedDecimal_lt: BigInt
  adoptedDecimal_gte: BigInt
  adoptedDecimal_lte: BigInt
  adoptedDecimal_in: [BigInt!]
  adoptedDecimal_not_in: [BigInt!]
  canonicalId: arbitrumone_Bytes
  canonicalId_not: arbitrumone_Bytes
  canonicalId_gt: arbitrumone_Bytes
  canonicalId_lt: arbitrumone_Bytes
  canonicalId_gte: arbitrumone_Bytes
  canonicalId_lte: arbitrumone_Bytes
  canonicalId_in: [arbitrumone_Bytes!]
  canonicalId_not_in: [arbitrumone_Bytes!]
  canonicalId_contains: arbitrumone_Bytes
  canonicalId_not_contains: arbitrumone_Bytes
  canonicalDomain: BigInt
  canonicalDomain_not: BigInt
  canonicalDomain_gt: BigInt
  canonicalDomain_lt: BigInt
  canonicalDomain_gte: BigInt
  canonicalDomain_lte: BigInt
  canonicalDomain_in: [BigInt!]
  canonicalDomain_not_in: [BigInt!]
  adoptedAsset: arbitrumone_Bytes
  adoptedAsset_not: arbitrumone_Bytes
  adoptedAsset_gt: arbitrumone_Bytes
  adoptedAsset_lt: arbitrumone_Bytes
  adoptedAsset_gte: arbitrumone_Bytes
  adoptedAsset_lte: arbitrumone_Bytes
  adoptedAsset_in: [arbitrumone_Bytes!]
  adoptedAsset_not_in: [arbitrumone_Bytes!]
  adoptedAsset_contains: arbitrumone_Bytes
  adoptedAsset_not_contains: arbitrumone_Bytes
  localAsset: arbitrumone_Bytes
  localAsset_not: arbitrumone_Bytes
  localAsset_gt: arbitrumone_Bytes
  localAsset_lt: arbitrumone_Bytes
  localAsset_gte: arbitrumone_Bytes
  localAsset_lte: arbitrumone_Bytes
  localAsset_in: [arbitrumone_Bytes!]
  localAsset_not_in: [arbitrumone_Bytes!]
  localAsset_contains: arbitrumone_Bytes
  localAsset_not_contains: arbitrumone_Bytes
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  status: String
  status_not: String
  status_gt: String
  status_lt: String
  status_gte: String
  status_lte: String
  status_in: [String!]
  status_not_in: [String!]
  status_contains: String
  status_contains_nocase: String
  status_not_contains: String
  status_not_contains_nocase: String
  status_starts_with: String
  status_starts_with_nocase: String
  status_not_starts_with: String
  status_not_starts_with_nocase: String
  status_ends_with: String
  status_ends_with_nocase: String
  status_not_ends_with: String
  status_not_ends_with_nocase: String
  status_: arbitrumone_AssetStatus_filter
  """Filter for the block changed event."""
  _change_block: arbitrumone_BlockChangedFilter
  and: [arbitrumone_Asset_filter]
  or: [arbitrumone_Asset_filter]
}

enum arbitrumone_Asset_orderBy {
  id
  key
  decimal
  adoptedDecimal
  canonicalId
  canonicalDomain
  adoptedAsset
  localAsset
  blockNumber
  status
  status__id
  status__status
}

scalar arbitrumone_BigDecimal

input arbitrumone_BlockChangedFilter {
  number_gte: Int!
}

input arbitrumone_Block_height {
  hash: arbitrumone_Bytes
  number: Int
  number_gte: Int
}

scalar arbitrumone_Bytes

type arbitrumone_ConnectorMeta {
  id: ID!
  spokeDomain: BigInt
  hubDomain: BigInt
  amb: arbitrumone_Bytes
  rootManager: arbitrumone_Bytes
  mirrorConnector: arbitrumone_Bytes
}

input arbitrumone_ConnectorMeta_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  spokeDomain: BigInt
  spokeDomain_not: BigInt
  spokeDomain_gt: BigInt
  spokeDomain_lt: BigInt
  spokeDomain_gte: BigInt
  spokeDomain_lte: BigInt
  spokeDomain_in: [BigInt!]
  spokeDomain_not_in: [BigInt!]
  hubDomain: BigInt
  hubDomain_not: BigInt
  hubDomain_gt: BigInt
  hubDomain_lt: BigInt
  hubDomain_gte: BigInt
  hubDomain_lte: BigInt
  hubDomain_in: [BigInt!]
  hubDomain_not_in: [BigInt!]
  amb: arbitrumone_Bytes
  amb_not: arbitrumone_Bytes
  amb_gt: arbitrumone_Bytes
  amb_lt: arbitrumone_Bytes
  amb_gte: arbitrumone_Bytes
  amb_lte: arbitrumone_Bytes
  amb_in: [arbitrumone_Bytes!]
  amb_not_in: [arbitrumone_Bytes!]
  amb_contains: arbitrumone_Bytes
  amb_not_contains: arbitrumone_Bytes
  rootManager: arbitrumone_Bytes
  rootManager_not: arbitrumone_Bytes
  rootManager_gt: arbitrumone_Bytes
  rootManager_lt: arbitrumone_Bytes
  rootManager_gte: arbitrumone_Bytes
  rootManager_lte: arbitrumone_Bytes
  rootManager_in: [arbitrumone_Bytes!]
  rootManager_not_in: [arbitrumone_Bytes!]
  rootManager_contains: arbitrumone_Bytes
  rootManager_not_contains: arbitrumone_Bytes
  mirrorConnector: arbitrumone_Bytes
  mirrorConnector_not: arbitrumone_Bytes
  mirrorConnector_gt: arbitrumone_Bytes
  mirrorConnector_lt: arbitrumone_Bytes
  mirrorConnector_gte: arbitrumone_Bytes
  mirrorConnector_lte: arbitrumone_Bytes
  mirrorConnector_in: [arbitrumone_Bytes!]
  mirrorConnector_not_in: [arbitrumone_Bytes!]
  mirrorConnector_contains: arbitrumone_Bytes
  mirrorConnector_not_contains: arbitrumone_Bytes
  """Filter for the block changed event."""
  _change_block: arbitrumone_BlockChangedFilter
  and: [arbitrumone_ConnectorMeta_filter]
  or: [arbitrumone_ConnectorMeta_filter]
}

enum arbitrumone_ConnectorMeta_orderBy {
  id
  spokeDomain
  hubDomain
  amb
  rootManager
  mirrorConnector
}

type arbitrumone_DestinationTransfer {
  id: ID!
  chainId: BigInt
  transferId: arbitrumone_Bytes
  nonce: BigInt
  status: arbitrumone_TransferStatus
  routers(skip: Int = 0, first: Int = 100, orderBy: arbitrumone_Router_orderBy, orderDirection: arbitrumone_OrderDirection, where: arbitrumone_Router_filter): [arbitrumone_Router!]
  originDomain: BigInt
  destinationDomain: BigInt
  canonicalDomain: BigInt
  to: arbitrumone_Bytes
  delegate: arbitrumone_Bytes
  receiveLocal: Boolean
  callData: arbitrumone_Bytes
  slippage: BigInt
  bumpSlippageCount: BigInt
  originSender: arbitrumone_Bytes
  bridgedAmt: BigInt
  normalizedIn: BigInt
  canonicalId: arbitrumone_Bytes
  asset: arbitrumone_Asset
  amount: BigInt
  routersFee: BigInt
  executedCaller: arbitrumone_Bytes
  executedTransactionHash: arbitrumone_Bytes
  executedTimestamp: BigInt
  executedGasPrice: BigInt
  executedGasLimit: BigInt
  executedBlockNumber: BigInt
  executedTxOrigin: arbitrumone_Bytes
  executedTxNonce: BigInt
  reconciledCaller: arbitrumone_Bytes
  reconciledTransactionHash: arbitrumone_Bytes
  reconciledTimestamp: BigInt
  reconciledGasPrice: BigInt
  reconciledGasLimit: BigInt
  reconciledBlockNumber: BigInt
  reconciledTxOrigin: arbitrumone_Bytes
  reconciledTxNonce: BigInt
}

input arbitrumone_DestinationTransfer_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  chainId: BigInt
  chainId_not: BigInt
  chainId_gt: BigInt
  chainId_lt: BigInt
  chainId_gte: BigInt
  chainId_lte: BigInt
  chainId_in: [BigInt!]
  chainId_not_in: [BigInt!]
  transferId: arbitrumone_Bytes
  transferId_not: arbitrumone_Bytes
  transferId_gt: arbitrumone_Bytes
  transferId_lt: arbitrumone_Bytes
  transferId_gte: arbitrumone_Bytes
  transferId_lte: arbitrumone_Bytes
  transferId_in: [arbitrumone_Bytes!]
  transferId_not_in: [arbitrumone_Bytes!]
  transferId_contains: arbitrumone_Bytes
  transferId_not_contains: arbitrumone_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  status: arbitrumone_TransferStatus
  status_not: arbitrumone_TransferStatus
  status_in: [arbitrumone_TransferStatus!]
  status_not_in: [arbitrumone_TransferStatus!]
  routers: [String!]
  routers_not: [String!]
  routers_contains: [String!]
  routers_contains_nocase: [String!]
  routers_not_contains: [String!]
  routers_not_contains_nocase: [String!]
  routers_: arbitrumone_Router_filter
  originDomain: BigInt
  originDomain_not: BigInt
  originDomain_gt: BigInt
  originDomain_lt: BigInt
  originDomain_gte: BigInt
  originDomain_lte: BigInt
  originDomain_in: [BigInt!]
  originDomain_not_in: [BigInt!]
  destinationDomain: BigInt
  destinationDomain_not: BigInt
  destinationDomain_gt: BigInt
  destinationDomain_lt: BigInt
  destinationDomain_gte: BigInt
  destinationDomain_lte: BigInt
  destinationDomain_in: [BigInt!]
  destinationDomain_not_in: [BigInt!]
  canonicalDomain: BigInt
  canonicalDomain_not: BigInt
  canonicalDomain_gt: BigInt
  canonicalDomain_lt: BigInt
  canonicalDomain_gte: BigInt
  canonicalDomain_lte: BigInt
  canonicalDomain_in: [BigInt!]
  canonicalDomain_not_in: [BigInt!]
  to: arbitrumone_Bytes
  to_not: arbitrumone_Bytes
  to_gt: arbitrumone_Bytes
  to_lt: arbitrumone_Bytes
  to_gte: arbitrumone_Bytes
  to_lte: arbitrumone_Bytes
  to_in: [arbitrumone_Bytes!]
  to_not_in: [arbitrumone_Bytes!]
  to_contains: arbitrumone_Bytes
  to_not_contains: arbitrumone_Bytes
  delegate: arbitrumone_Bytes
  delegate_not: arbitrumone_Bytes
  delegate_gt: arbitrumone_Bytes
  delegate_lt: arbitrumone_Bytes
  delegate_gte: arbitrumone_Bytes
  delegate_lte: arbitrumone_Bytes
  delegate_in: [arbitrumone_Bytes!]
  delegate_not_in: [arbitrumone_Bytes!]
  delegate_contains: arbitrumone_Bytes
  delegate_not_contains: arbitrumone_Bytes
  receiveLocal: Boolean
  receiveLocal_not: Boolean
  receiveLocal_in: [Boolean!]
  receiveLocal_not_in: [Boolean!]
  callData: arbitrumone_Bytes
  callData_not: arbitrumone_Bytes
  callData_gt: arbitrumone_Bytes
  callData_lt: arbitrumone_Bytes
  callData_gte: arbitrumone_Bytes
  callData_lte: arbitrumone_Bytes
  callData_in: [arbitrumone_Bytes!]
  callData_not_in: [arbitrumone_Bytes!]
  callData_contains: arbitrumone_Bytes
  callData_not_contains: arbitrumone_Bytes
  slippage: BigInt
  slippage_not: BigInt
  slippage_gt: BigInt
  slippage_lt: BigInt
  slippage_gte: BigInt
  slippage_lte: BigInt
  slippage_in: [BigInt!]
  slippage_not_in: [BigInt!]
  bumpSlippageCount: BigInt
  bumpSlippageCount_not: BigInt
  bumpSlippageCount_gt: BigInt
  bumpSlippageCount_lt: BigInt
  bumpSlippageCount_gte: BigInt
  bumpSlippageCount_lte: BigInt
  bumpSlippageCount_in: [BigInt!]
  bumpSlippageCount_not_in: [BigInt!]
  originSender: arbitrumone_Bytes
  originSender_not: arbitrumone_Bytes
  originSender_gt: arbitrumone_Bytes
  originSender_lt: arbitrumone_Bytes
  originSender_gte: arbitrumone_Bytes
  originSender_lte: arbitrumone_Bytes
  originSender_in: [arbitrumone_Bytes!]
  originSender_not_in: [arbitrumone_Bytes!]
  originSender_contains: arbitrumone_Bytes
  originSender_not_contains: arbitrumone_Bytes
  bridgedAmt: BigInt
  bridgedAmt_not: BigInt
  bridgedAmt_gt: BigInt
  bridgedAmt_lt: BigInt
  bridgedAmt_gte: BigInt
  bridgedAmt_lte: BigInt
  bridgedAmt_in: [BigInt!]
  bridgedAmt_not_in: [BigInt!]
  normalizedIn: BigInt
  normalizedIn_not: BigInt
  normalizedIn_gt: BigInt
  normalizedIn_lt: BigInt
  normalizedIn_gte: BigInt
  normalizedIn_lte: BigInt
  normalizedIn_in: [BigInt!]
  normalizedIn_not_in: [BigInt!]
  canonicalId: arbitrumone_Bytes
  canonicalId_not: arbitrumone_Bytes
  canonicalId_gt: arbitrumone_Bytes
  canonicalId_lt: arbitrumone_Bytes
  canonicalId_gte: arbitrumone_Bytes
  canonicalId_lte: arbitrumone_Bytes
  canonicalId_in: [arbitrumone_Bytes!]
  canonicalId_not_in: [arbitrumone_Bytes!]
  canonicalId_contains: arbitrumone_Bytes
  canonicalId_not_contains: arbitrumone_Bytes
  asset: String
  asset_not: String
  asset_gt: String
  asset_lt: String
  asset_gte: String
  asset_lte: String
  asset_in: [String!]
  asset_not_in: [String!]
  asset_contains: String
  asset_contains_nocase: String
  asset_not_contains: String
  asset_not_contains_nocase: String
  asset_starts_with: String
  asset_starts_with_nocase: String
  asset_not_starts_with: String
  asset_not_starts_with_nocase: String
  asset_ends_with: String
  asset_ends_with_nocase: String
  asset_not_ends_with: String
  asset_not_ends_with_nocase: String
  asset_: arbitrumone_Asset_filter
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  routersFee: BigInt
  routersFee_not: BigInt
  routersFee_gt: BigInt
  routersFee_lt: BigInt
  routersFee_gte: BigInt
  routersFee_lte: BigInt
  routersFee_in: [BigInt!]
  routersFee_not_in: [BigInt!]
  executedCaller: arbitrumone_Bytes
  executedCaller_not: arbitrumone_Bytes
  executedCaller_gt: arbitrumone_Bytes
  executedCaller_lt: arbitrumone_Bytes
  executedCaller_gte: arbitrumone_Bytes
  executedCaller_lte: arbitrumone_Bytes
  executedCaller_in: [arbitrumone_Bytes!]
  executedCaller_not_in: [arbitrumone_Bytes!]
  executedCaller_contains: arbitrumone_Bytes
  executedCaller_not_contains: arbitrumone_Bytes
  executedTransactionHash: arbitrumone_Bytes
  executedTransactionHash_not: arbitrumone_Bytes
  executedTransactionHash_gt: arbitrumone_Bytes
  executedTransactionHash_lt: arbitrumone_Bytes
  executedTransactionHash_gte: arbitrumone_Bytes
  executedTransactionHash_lte: arbitrumone_Bytes
  executedTransactionHash_in: [arbitrumone_Bytes!]
  executedTransactionHash_not_in: [arbitrumone_Bytes!]
  executedTransactionHash_contains: arbitrumone_Bytes
  executedTransactionHash_not_contains: arbitrumone_Bytes
  executedTimestamp: BigInt
  executedTimestamp_not: BigInt
  executedTimestamp_gt: BigInt
  executedTimestamp_lt: BigInt
  executedTimestamp_gte: BigInt
  executedTimestamp_lte: BigInt
  executedTimestamp_in: [BigInt!]
  executedTimestamp_not_in: [BigInt!]
  executedGasPrice: BigInt
  executedGasPrice_not: BigInt
  executedGasPrice_gt: BigInt
  executedGasPrice_lt: BigInt
  executedGasPrice_gte: BigInt
  executedGasPrice_lte: BigInt
  executedGasPrice_in: [BigInt!]
  executedGasPrice_not_in: [BigInt!]
  executedGasLimit: BigInt
  executedGasLimit_not: BigInt
  executedGasLimit_gt: BigInt
  executedGasLimit_lt: BigInt
  executedGasLimit_gte: BigInt
  executedGasLimit_lte: BigInt
  executedGasLimit_in: [BigInt!]
  executedGasLimit_not_in: [BigInt!]
  executedBlockNumber: BigInt
  executedBlockNumber_not: BigInt
  executedBlockNumber_gt: BigInt
  executedBlockNumber_lt: BigInt
  executedBlockNumber_gte: BigInt
  executedBlockNumber_lte: BigInt
  executedBlockNumber_in: [BigInt!]
  executedBlockNumber_not_in: [BigInt!]
  executedTxOrigin: arbitrumone_Bytes
  executedTxOrigin_not: arbitrumone_Bytes
  executedTxOrigin_gt: arbitrumone_Bytes
  executedTxOrigin_lt: arbitrumone_Bytes
  executedTxOrigin_gte: arbitrumone_Bytes
  executedTxOrigin_lte: arbitrumone_Bytes
  executedTxOrigin_in: [arbitrumone_Bytes!]
  executedTxOrigin_not_in: [arbitrumone_Bytes!]
  executedTxOrigin_contains: arbitrumone_Bytes
  executedTxOrigin_not_contains: arbitrumone_Bytes
  executedTxNonce: BigInt
  executedTxNonce_not: BigInt
  executedTxNonce_gt: BigInt
  executedTxNonce_lt: BigInt
  executedTxNonce_gte: BigInt
  executedTxNonce_lte: BigInt
  executedTxNonce_in: [BigInt!]
  executedTxNonce_not_in: [BigInt!]
  reconciledCaller: arbitrumone_Bytes
  reconciledCaller_not: arbitrumone_Bytes
  reconciledCaller_gt: arbitrumone_Bytes
  reconciledCaller_lt: arbitrumone_Bytes
  reconciledCaller_gte: arbitrumone_Bytes
  reconciledCaller_lte: arbitrumone_Bytes
  reconciledCaller_in: [arbitrumone_Bytes!]
  reconciledCaller_not_in: [arbitrumone_Bytes!]
  reconciledCaller_contains: arbitrumone_Bytes
  reconciledCaller_not_contains: arbitrumone_Bytes
  reconciledTransactionHash: arbitrumone_Bytes
  reconciledTransactionHash_not: arbitrumone_Bytes
  reconciledTransactionHash_gt: arbitrumone_Bytes
  reconciledTransactionHash_lt: arbitrumone_Bytes
  reconciledTransactionHash_gte: arbitrumone_Bytes
  reconciledTransactionHash_lte: arbitrumone_Bytes
  reconciledTransactionHash_in: [arbitrumone_Bytes!]
  reconciledTransactionHash_not_in: [arbitrumone_Bytes!]
  reconciledTransactionHash_contains: arbitrumone_Bytes
  reconciledTransactionHash_not_contains: arbitrumone_Bytes
  reconciledTimestamp: BigInt
  reconciledTimestamp_not: BigInt
  reconciledTimestamp_gt: BigInt
  reconciledTimestamp_lt: BigInt
  reconciledTimestamp_gte: BigInt
  reconciledTimestamp_lte: BigInt
  reconciledTimestamp_in: [BigInt!]
  reconciledTimestamp_not_in: [BigInt!]
  reconciledGasPrice: BigInt
  reconciledGasPrice_not: BigInt
  reconciledGasPrice_gt: BigInt
  reconciledGasPrice_lt: BigInt
  reconciledGasPrice_gte: BigInt
  reconciledGasPrice_lte: BigInt
  reconciledGasPrice_in: [BigInt!]
  reconciledGasPrice_not_in: [BigInt!]
  reconciledGasLimit: BigInt
  reconciledGasLimit_not: BigInt
  reconciledGasLimit_gt: BigInt
  reconciledGasLimit_lt: BigInt
  reconciledGasLimit_gte: BigInt
  reconciledGasLimit_lte: BigInt
  reconciledGasLimit_in: [BigInt!]
  reconciledGasLimit_not_in: [BigInt!]
  reconciledBlockNumber: BigInt
  reconciledBlockNumber_not: BigInt
  reconciledBlockNumber_gt: BigInt
  reconciledBlockNumber_lt: BigInt
  reconciledBlockNumber_gte: BigInt
  reconciledBlockNumber_lte: BigInt
  reconciledBlockNumber_in: [BigInt!]
  reconciledBlockNumber_not_in: [BigInt!]
  reconciledTxOrigin: arbitrumone_Bytes
  reconciledTxOrigin_not: arbitrumone_Bytes
  reconciledTxOrigin_gt: arbitrumone_Bytes
  reconciledTxOrigin_lt: arbitrumone_Bytes
  reconciledTxOrigin_gte: arbitrumone_Bytes
  reconciledTxOrigin_lte: arbitrumone_Bytes
  reconciledTxOrigin_in: [arbitrumone_Bytes!]
  reconciledTxOrigin_not_in: [arbitrumone_Bytes!]
  reconciledTxOrigin_contains: arbitrumone_Bytes
  reconciledTxOrigin_not_contains: arbitrumone_Bytes
  reconciledTxNonce: BigInt
  reconciledTxNonce_not: BigInt
  reconciledTxNonce_gt: BigInt
  reconciledTxNonce_lt: BigInt
  reconciledTxNonce_gte: BigInt
  reconciledTxNonce_lte: BigInt
  reconciledTxNonce_in: [BigInt!]
  reconciledTxNonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: arbitrumone_BlockChangedFilter
  and: [arbitrumone_DestinationTransfer_filter]
  or: [arbitrumone_DestinationTransfer_filter]
}

enum arbitrumone_DestinationTransfer_orderBy {
  id
  chainId
  transferId
  nonce
  status
  routers
  originDomain
  destinationDomain
  canonicalDomain
  to
  delegate
  receiveLocal
  callData
  slippage
  bumpSlippageCount
  originSender
  bridgedAmt
  normalizedIn
  canonicalId
  asset
  asset__id
  asset__key
  asset__decimal
  asset__adoptedDecimal
  asset__canonicalId
  asset__canonicalDomain
  asset__adoptedAsset
  asset__localAsset
  asset__blockNumber
  amount
  routersFee
  executedCaller
  executedTransactionHash
  executedTimestamp
  executedGasPrice
  executedGasLimit
  executedBlockNumber
  executedTxOrigin
  executedTxNonce
  reconciledCaller
  reconciledTransactionHash
  reconciledTimestamp
  reconciledGasPrice
  reconciledGasLimit
  reconciledBlockNumber
  reconciledTxOrigin
  reconciledTxNonce
}

"""
8 bytes signed integer

"""
scalar arbitrumone_Int8

type arbitrumone_OptimisticRootFinalized {
  id: ID!
  aggregateRoot: arbitrumone_Bytes!
  timestamp: BigInt!
  blockNumber: BigInt
}

input arbitrumone_OptimisticRootFinalized_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  aggregateRoot: arbitrumone_Bytes
  aggregateRoot_not: arbitrumone_Bytes
  aggregateRoot_gt: arbitrumone_Bytes
  aggregateRoot_lt: arbitrumone_Bytes
  aggregateRoot_gte: arbitrumone_Bytes
  aggregateRoot_lte: arbitrumone_Bytes
  aggregateRoot_in: [arbitrumone_Bytes!]
  aggregateRoot_not_in: [arbitrumone_Bytes!]
  aggregateRoot_contains: arbitrumone_Bytes
  aggregateRoot_not_contains: arbitrumone_Bytes
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: arbitrumone_BlockChangedFilter
  and: [arbitrumone_OptimisticRootFinalized_filter]
  or: [arbitrumone_OptimisticRootFinalized_filter]
}

enum arbitrumone_OptimisticRootFinalized_orderBy {
  id
  aggregateRoot
  timestamp
  blockNumber
}

"""Defines the order direction, either ascending or descending"""
enum arbitrumone_OrderDirection {
  asc
  desc
}

type arbitrumone_OriginMessage {
  id: ID!
  transferId: arbitrumone_Bytes
  destinationDomain: BigInt
  leaf: arbitrumone_Bytes
  index: BigInt
  message: arbitrumone_Bytes
  root: arbitrumone_Bytes
  transactionHash: arbitrumone_Bytes
  blockNumber: BigInt
  rootCount: arbitrumone_RootCount
}

input arbitrumone_OriginMessage_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transferId: arbitrumone_Bytes
  transferId_not: arbitrumone_Bytes
  transferId_gt: arbitrumone_Bytes
  transferId_lt: arbitrumone_Bytes
  transferId_gte: arbitrumone_Bytes
  transferId_lte: arbitrumone_Bytes
  transferId_in: [arbitrumone_Bytes!]
  transferId_not_in: [arbitrumone_Bytes!]
  transferId_contains: arbitrumone_Bytes
  transferId_not_contains: arbitrumone_Bytes
  destinationDomain: BigInt
  destinationDomain_not: BigInt
  destinationDomain_gt: BigInt
  destinationDomain_lt: BigInt
  destinationDomain_gte: BigInt
  destinationDomain_lte: BigInt
  destinationDomain_in: [BigInt!]
  destinationDomain_not_in: [BigInt!]
  leaf: arbitrumone_Bytes
  leaf_not: arbitrumone_Bytes
  leaf_gt: arbitrumone_Bytes
  leaf_lt: arbitrumone_Bytes
  leaf_gte: arbitrumone_Bytes
  leaf_lte: arbitrumone_Bytes
  leaf_in: [arbitrumone_Bytes!]
  leaf_not_in: [arbitrumone_Bytes!]
  leaf_contains: arbitrumone_Bytes
  leaf_not_contains: arbitrumone_Bytes
  index: BigInt
  index_not: BigInt
  index_gt: BigInt
  index_lt: BigInt
  index_gte: BigInt
  index_lte: BigInt
  index_in: [BigInt!]
  index_not_in: [BigInt!]
  message: arbitrumone_Bytes
  message_not: arbitrumone_Bytes
  message_gt: arbitrumone_Bytes
  message_lt: arbitrumone_Bytes
  message_gte: arbitrumone_Bytes
  message_lte: arbitrumone_Bytes
  message_in: [arbitrumone_Bytes!]
  message_not_in: [arbitrumone_Bytes!]
  message_contains: arbitrumone_Bytes
  message_not_contains: arbitrumone_Bytes
  root: arbitrumone_Bytes
  root_not: arbitrumone_Bytes
  root_gt: arbitrumone_Bytes
  root_lt: arbitrumone_Bytes
  root_gte: arbitrumone_Bytes
  root_lte: arbitrumone_Bytes
  root_in: [arbitrumone_Bytes!]
  root_not_in: [arbitrumone_Bytes!]
  root_contains: arbitrumone_Bytes
  root_not_contains: arbitrumone_Bytes
  transactionHash: arbitrumone_Bytes
  transactionHash_not: arbitrumone_Bytes
  transactionHash_gt: arbitrumone_Bytes
  transactionHash_lt: arbitrumone_Bytes
  transactionHash_gte: arbitrumone_Bytes
  transactionHash_lte: arbitrumone_Bytes
  transactionHash_in: [arbitrumone_Bytes!]
  transactionHash_not_in: [arbitrumone_Bytes!]
  transactionHash_contains: arbitrumone_Bytes
  transactionHash_not_contains: arbitrumone_Bytes
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  rootCount: String
  rootCount_not: String
  rootCount_gt: String
  rootCount_lt: String
  rootCount_gte: String
  rootCount_lte: String
  rootCount_in: [String!]
  rootCount_not_in: [String!]
  rootCount_contains: String
  rootCount_contains_nocase: String
  rootCount_not_contains: String
  rootCount_not_contains_nocase: String
  rootCount_starts_with: String
  rootCount_starts_with_nocase: String
  rootCount_not_starts_with: String
  rootCount_not_starts_with_nocase: String
  rootCount_ends_with: String
  rootCount_ends_with_nocase: String
  rootCount_not_ends_with: String
  rootCount_not_ends_with_nocase: String
  rootCount_: arbitrumone_RootCount_filter
  """Filter for the block changed event."""
  _change_block: arbitrumone_BlockChangedFilter
  and: [arbitrumone_OriginMessage_filter]
  or: [arbitrumone_OriginMessage_filter]
}

enum arbitrumone_OriginMessage_orderBy {
  id
  transferId
  destinationDomain
  leaf
  index
  message
  root
  transactionHash
  blockNumber
  rootCount
  rootCount__id
  rootCount__count
}

type arbitrumone_OriginTransfer {
  id: ID!
  chainId: BigInt
  transferId: arbitrumone_Bytes
  nonce: BigInt
  status: arbitrumone_TransferStatus
  messageHash: arbitrumone_Bytes
  originDomain: BigInt
  destinationDomain: BigInt
  canonicalDomain: BigInt
  to: arbitrumone_Bytes
  delegate: arbitrumone_Bytes
  receiveLocal: Boolean
  callData: arbitrumone_Bytes
  slippage: BigInt
  originSender: arbitrumone_Bytes
  bridgedAmt: BigInt
  normalizedIn: BigInt
  canonicalId: arbitrumone_Bytes
  asset: arbitrumone_Asset
  transactingAsset: arbitrumone_Bytes
  message: arbitrumone_OriginMessage
  bumpRelayerFeeCount: BigInt
  relayerFees(skip: Int = 0, first: Int = 100, orderBy: arbitrumone_RelayerFee_orderBy, orderDirection: arbitrumone_OrderDirection, where: arbitrumone_RelayerFee_filter): [arbitrumone_RelayerFee!]
  initialRelayerFeeAsset: arbitrumone_Bytes
  caller: arbitrumone_Bytes
  transactionHash: arbitrumone_Bytes
  timestamp: BigInt
  gasPrice: BigInt
  gasLimit: BigInt
  blockNumber: BigInt
  txOrigin: arbitrumone_Bytes
  txNonce: BigInt
}

input arbitrumone_OriginTransfer_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  chainId: BigInt
  chainId_not: BigInt
  chainId_gt: BigInt
  chainId_lt: BigInt
  chainId_gte: BigInt
  chainId_lte: BigInt
  chainId_in: [BigInt!]
  chainId_not_in: [BigInt!]
  transferId: arbitrumone_Bytes
  transferId_not: arbitrumone_Bytes
  transferId_gt: arbitrumone_Bytes
  transferId_lt: arbitrumone_Bytes
  transferId_gte: arbitrumone_Bytes
  transferId_lte: arbitrumone_Bytes
  transferId_in: [arbitrumone_Bytes!]
  transferId_not_in: [arbitrumone_Bytes!]
  transferId_contains: arbitrumone_Bytes
  transferId_not_contains: arbitrumone_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  status: arbitrumone_TransferStatus
  status_not: arbitrumone_TransferStatus
  status_in: [arbitrumone_TransferStatus!]
  status_not_in: [arbitrumone_TransferStatus!]
  messageHash: arbitrumone_Bytes
  messageHash_not: arbitrumone_Bytes
  messageHash_gt: arbitrumone_Bytes
  messageHash_lt: arbitrumone_Bytes
  messageHash_gte: arbitrumone_Bytes
  messageHash_lte: arbitrumone_Bytes
  messageHash_in: [arbitrumone_Bytes!]
  messageHash_not_in: [arbitrumone_Bytes!]
  messageHash_contains: arbitrumone_Bytes
  messageHash_not_contains: arbitrumone_Bytes
  originDomain: BigInt
  originDomain_not: BigInt
  originDomain_gt: BigInt
  originDomain_lt: BigInt
  originDomain_gte: BigInt
  originDomain_lte: BigInt
  originDomain_in: [BigInt!]
  originDomain_not_in: [BigInt!]
  destinationDomain: BigInt
  destinationDomain_not: BigInt
  destinationDomain_gt: BigInt
  destinationDomain_lt: BigInt
  destinationDomain_gte: BigInt
  destinationDomain_lte: BigInt
  destinationDomain_in: [BigInt!]
  destinationDomain_not_in: [BigInt!]
  canonicalDomain: BigInt
  canonicalDomain_not: BigInt
  canonicalDomain_gt: BigInt
  canonicalDomain_lt: BigInt
  canonicalDomain_gte: BigInt
  canonicalDomain_lte: BigInt
  canonicalDomain_in: [BigInt!]
  canonicalDomain_not_in: [BigInt!]
  to: arbitrumone_Bytes
  to_not: arbitrumone_Bytes
  to_gt: arbitrumone_Bytes
  to_lt: arbitrumone_Bytes
  to_gte: arbitrumone_Bytes
  to_lte: arbitrumone_Bytes
  to_in: [arbitrumone_Bytes!]
  to_not_in: [arbitrumone_Bytes!]
  to_contains: arbitrumone_Bytes
  to_not_contains: arbitrumone_Bytes
  delegate: arbitrumone_Bytes
  delegate_not: arbitrumone_Bytes
  delegate_gt: arbitrumone_Bytes
  delegate_lt: arbitrumone_Bytes
  delegate_gte: arbitrumone_Bytes
  delegate_lte: arbitrumone_Bytes
  delegate_in: [arbitrumone_Bytes!]
  delegate_not_in: [arbitrumone_Bytes!]
  delegate_contains: arbitrumone_Bytes
  delegate_not_contains: arbitrumone_Bytes
  receiveLocal: Boolean
  receiveLocal_not: Boolean
  receiveLocal_in: [Boolean!]
  receiveLocal_not_in: [Boolean!]
  callData: arbitrumone_Bytes
  callData_not: arbitrumone_Bytes
  callData_gt: arbitrumone_Bytes
  callData_lt: arbitrumone_Bytes
  callData_gte: arbitrumone_Bytes
  callData_lte: arbitrumone_Bytes
  callData_in: [arbitrumone_Bytes!]
  callData_not_in: [arbitrumone_Bytes!]
  callData_contains: arbitrumone_Bytes
  callData_not_contains: arbitrumone_Bytes
  slippage: BigInt
  slippage_not: BigInt
  slippage_gt: BigInt
  slippage_lt: BigInt
  slippage_gte: BigInt
  slippage_lte: BigInt
  slippage_in: [BigInt!]
  slippage_not_in: [BigInt!]
  originSender: arbitrumone_Bytes
  originSender_not: arbitrumone_Bytes
  originSender_gt: arbitrumone_Bytes
  originSender_lt: arbitrumone_Bytes
  originSender_gte: arbitrumone_Bytes
  originSender_lte: arbitrumone_Bytes
  originSender_in: [arbitrumone_Bytes!]
  originSender_not_in: [arbitrumone_Bytes!]
  originSender_contains: arbitrumone_Bytes
  originSender_not_contains: arbitrumone_Bytes
  bridgedAmt: BigInt
  bridgedAmt_not: BigInt
  bridgedAmt_gt: BigInt
  bridgedAmt_lt: BigInt
  bridgedAmt_gte: BigInt
  bridgedAmt_lte: BigInt
  bridgedAmt_in: [BigInt!]
  bridgedAmt_not_in: [BigInt!]
  normalizedIn: BigInt
  normalizedIn_not: BigInt
  normalizedIn_gt: BigInt
  normalizedIn_lt: BigInt
  normalizedIn_gte: BigInt
  normalizedIn_lte: BigInt
  normalizedIn_in: [BigInt!]
  normalizedIn_not_in: [BigInt!]
  canonicalId: arbitrumone_Bytes
  canonicalId_not: arbitrumone_Bytes
  canonicalId_gt: arbitrumone_Bytes
  canonicalId_lt: arbitrumone_Bytes
  canonicalId_gte: arbitrumone_Bytes
  canonicalId_lte: arbitrumone_Bytes
  canonicalId_in: [arbitrumone_Bytes!]
  canonicalId_not_in: [arbitrumone_Bytes!]
  canonicalId_contains: arbitrumone_Bytes
  canonicalId_not_contains: arbitrumone_Bytes
  asset: String
  asset_not: String
  asset_gt: String
  asset_lt: String
  asset_gte: String
  asset_lte: String
  asset_in: [String!]
  asset_not_in: [String!]
  asset_contains: String
  asset_contains_nocase: String
  asset_not_contains: String
  asset_not_contains_nocase: String
  asset_starts_with: String
  asset_starts_with_nocase: String
  asset_not_starts_with: String
  asset_not_starts_with_nocase: String
  asset_ends_with: String
  asset_ends_with_nocase: String
  asset_not_ends_with: String
  asset_not_ends_with_nocase: String
  asset_: arbitrumone_Asset_filter
  transactingAsset: arbitrumone_Bytes
  transactingAsset_not: arbitrumone_Bytes
  transactingAsset_gt: arbitrumone_Bytes
  transactingAsset_lt: arbitrumone_Bytes
  transactingAsset_gte: arbitrumone_Bytes
  transactingAsset_lte: arbitrumone_Bytes
  transactingAsset_in: [arbitrumone_Bytes!]
  transactingAsset_not_in: [arbitrumone_Bytes!]
  transactingAsset_contains: arbitrumone_Bytes
  transactingAsset_not_contains: arbitrumone_Bytes
  message: String
  message_not: String
  message_gt: String
  message_lt: String
  message_gte: String
  message_lte: String
  message_in: [String!]
  message_not_in: [String!]
  message_contains: String
  message_contains_nocase: String
  message_not_contains: String
  message_not_contains_nocase: String
  message_starts_with: String
  message_starts_with_nocase: String
  message_not_starts_with: String
  message_not_starts_with_nocase: String
  message_ends_with: String
  message_ends_with_nocase: String
  message_not_ends_with: String
  message_not_ends_with_nocase: String
  message_: arbitrumone_OriginMessage_filter
  bumpRelayerFeeCount: BigInt
  bumpRelayerFeeCount_not: BigInt
  bumpRelayerFeeCount_gt: BigInt
  bumpRelayerFeeCount_lt: BigInt
  bumpRelayerFeeCount_gte: BigInt
  bumpRelayerFeeCount_lte: BigInt
  bumpRelayerFeeCount_in: [BigInt!]
  bumpRelayerFeeCount_not_in: [BigInt!]
  relayerFees: [String!]
  relayerFees_not: [String!]
  relayerFees_contains: [String!]
  relayerFees_contains_nocase: [String!]
  relayerFees_not_contains: [String!]
  relayerFees_not_contains_nocase: [String!]
  relayerFees_: arbitrumone_RelayerFee_filter
  initialRelayerFeeAsset: arbitrumone_Bytes
  initialRelayerFeeAsset_not: arbitrumone_Bytes
  initialRelayerFeeAsset_gt: arbitrumone_Bytes
  initialRelayerFeeAsset_lt: arbitrumone_Bytes
  initialRelayerFeeAsset_gte: arbitrumone_Bytes
  initialRelayerFeeAsset_lte: arbitrumone_Bytes
  initialRelayerFeeAsset_in: [arbitrumone_Bytes!]
  initialRelayerFeeAsset_not_in: [arbitrumone_Bytes!]
  initialRelayerFeeAsset_contains: arbitrumone_Bytes
  initialRelayerFeeAsset_not_contains: arbitrumone_Bytes
  caller: arbitrumone_Bytes
  caller_not: arbitrumone_Bytes
  caller_gt: arbitrumone_Bytes
  caller_lt: arbitrumone_Bytes
  caller_gte: arbitrumone_Bytes
  caller_lte: arbitrumone_Bytes
  caller_in: [arbitrumone_Bytes!]
  caller_not_in: [arbitrumone_Bytes!]
  caller_contains: arbitrumone_Bytes
  caller_not_contains: arbitrumone_Bytes
  transactionHash: arbitrumone_Bytes
  transactionHash_not: arbitrumone_Bytes
  transactionHash_gt: arbitrumone_Bytes
  transactionHash_lt: arbitrumone_Bytes
  transactionHash_gte: arbitrumone_Bytes
  transactionHash_lte: arbitrumone_Bytes
  transactionHash_in: [arbitrumone_Bytes!]
  transactionHash_not_in: [arbitrumone_Bytes!]
  transactionHash_contains: arbitrumone_Bytes
  transactionHash_not_contains: arbitrumone_Bytes
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  gasLimit: BigInt
  gasLimit_not: BigInt
  gasLimit_gt: BigInt
  gasLimit_lt: BigInt
  gasLimit_gte: BigInt
  gasLimit_lte: BigInt
  gasLimit_in: [BigInt!]
  gasLimit_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  txOrigin: arbitrumone_Bytes
  txOrigin_not: arbitrumone_Bytes
  txOrigin_gt: arbitrumone_Bytes
  txOrigin_lt: arbitrumone_Bytes
  txOrigin_gte: arbitrumone_Bytes
  txOrigin_lte: arbitrumone_Bytes
  txOrigin_in: [arbitrumone_Bytes!]
  txOrigin_not_in: [arbitrumone_Bytes!]
  txOrigin_contains: arbitrumone_Bytes
  txOrigin_not_contains: arbitrumone_Bytes
  txNonce: BigInt
  txNonce_not: BigInt
  txNonce_gt: BigInt
  txNonce_lt: BigInt
  txNonce_gte: BigInt
  txNonce_lte: BigInt
  txNonce_in: [BigInt!]
  txNonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: arbitrumone_BlockChangedFilter
  and: [arbitrumone_OriginTransfer_filter]
  or: [arbitrumone_OriginTransfer_filter]
}

enum arbitrumone_OriginTransfer_orderBy {
  id
  chainId
  transferId
  nonce
  status
  messageHash
  originDomain
  destinationDomain
  canonicalDomain
  to
  delegate
  receiveLocal
  callData
  slippage
  originSender
  bridgedAmt
  normalizedIn
  canonicalId
  asset
  asset__id
  asset__key
  asset__decimal
  asset__adoptedDecimal
  asset__canonicalId
  asset__canonicalDomain
  asset__adoptedAsset
  asset__localAsset
  asset__blockNumber
  transactingAsset
  message
  message__id
  message__transferId
  message__destinationDomain
  message__leaf
  message__index
  message__message
  message__root
  message__transactionHash
  message__blockNumber
  bumpRelayerFeeCount
  relayerFees
  initialRelayerFeeAsset
  caller
  transactionHash
  timestamp
  gasPrice
  gasLimit
  blockNumber
  txOrigin
  txNonce
}

type arbitrumone_Relayer {
  id: ID!
  isActive: Boolean!
  relayer: arbitrumone_Bytes
}

type arbitrumone_RelayerFee {
  id: ID!
  transfer: arbitrumone_OriginTransfer!
  fee: BigInt!
  asset: arbitrumone_Bytes!
}

input arbitrumone_RelayerFee_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transfer: String
  transfer_not: String
  transfer_gt: String
  transfer_lt: String
  transfer_gte: String
  transfer_lte: String
  transfer_in: [String!]
  transfer_not_in: [String!]
  transfer_contains: String
  transfer_contains_nocase: String
  transfer_not_contains: String
  transfer_not_contains_nocase: String
  transfer_starts_with: String
  transfer_starts_with_nocase: String
  transfer_not_starts_with: String
  transfer_not_starts_with_nocase: String
  transfer_ends_with: String
  transfer_ends_with_nocase: String
  transfer_not_ends_with: String
  transfer_not_ends_with_nocase: String
  transfer_: arbitrumone_OriginTransfer_filter
  fee: BigInt
  fee_not: BigInt
  fee_gt: BigInt
  fee_lt: BigInt
  fee_gte: BigInt
  fee_lte: BigInt
  fee_in: [BigInt!]
  fee_not_in: [BigInt!]
  asset: arbitrumone_Bytes
  asset_not: arbitrumone_Bytes
  asset_gt: arbitrumone_Bytes
  asset_lt: arbitrumone_Bytes
  asset_gte: arbitrumone_Bytes
  asset_lte: arbitrumone_Bytes
  asset_in: [arbitrumone_Bytes!]
  asset_not_in: [arbitrumone_Bytes!]
  asset_contains: arbitrumone_Bytes
  asset_not_contains: arbitrumone_Bytes
  """Filter for the block changed event."""
  _change_block: arbitrumone_BlockChangedFilter
  and: [arbitrumone_RelayerFee_filter]
  or: [arbitrumone_RelayerFee_filter]
}

enum arbitrumone_RelayerFee_orderBy {
  id
  transfer
  transfer__id
  transfer__chainId
  transfer__transferId
  transfer__nonce
  transfer__status
  transfer__messageHash
  transfer__originDomain
  transfer__destinationDomain
  transfer__canonicalDomain
  transfer__to
  transfer__delegate
  transfer__receiveLocal
  transfer__callData
  transfer__slippage
  transfer__originSender
  transfer__bridgedAmt
  transfer__normalizedIn
  transfer__canonicalId
  transfer__transactingAsset
  transfer__bumpRelayerFeeCount
  transfer__initialRelayerFeeAsset
  transfer__caller
  transfer__transactionHash
  transfer__timestamp
  transfer__gasPrice
  transfer__gasLimit
  transfer__blockNumber
  transfer__txOrigin
  transfer__txNonce
  fee
  asset
}

type arbitrumone_RelayerFeesIncrease {
  id: ID!
  transfer: arbitrumone_OriginTransfer!
  increase: BigInt
  asset: arbitrumone_Bytes
  caller: arbitrumone_Bytes!
  transactionHash: arbitrumone_Bytes!
  timestamp: BigInt!
  gasPrice: BigInt!
  gasLimit: BigInt!
  blockNumber: BigInt!
}

input arbitrumone_RelayerFeesIncrease_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transfer: String
  transfer_not: String
  transfer_gt: String
  transfer_lt: String
  transfer_gte: String
  transfer_lte: String
  transfer_in: [String!]
  transfer_not_in: [String!]
  transfer_contains: String
  transfer_contains_nocase: String
  transfer_not_contains: String
  transfer_not_contains_nocase: String
  transfer_starts_with: String
  transfer_starts_with_nocase: String
  transfer_not_starts_with: String
  transfer_not_starts_with_nocase: String
  transfer_ends_with: String
  transfer_ends_with_nocase: String
  transfer_not_ends_with: String
  transfer_not_ends_with_nocase: String
  transfer_: arbitrumone_OriginTransfer_filter
  increase: BigInt
  increase_not: BigInt
  increase_gt: BigInt
  increase_lt: BigInt
  increase_gte: BigInt
  increase_lte: BigInt
  increase_in: [BigInt!]
  increase_not_in: [BigInt!]
  asset: arbitrumone_Bytes
  asset_not: arbitrumone_Bytes
  asset_gt: arbitrumone_Bytes
  asset_lt: arbitrumone_Bytes
  asset_gte: arbitrumone_Bytes
  asset_lte: arbitrumone_Bytes
  asset_in: [arbitrumone_Bytes!]
  asset_not_in: [arbitrumone_Bytes!]
  asset_contains: arbitrumone_Bytes
  asset_not_contains: arbitrumone_Bytes
  caller: arbitrumone_Bytes
  caller_not: arbitrumone_Bytes
  caller_gt: arbitrumone_Bytes
  caller_lt: arbitrumone_Bytes
  caller_gte: arbitrumone_Bytes
  caller_lte: arbitrumone_Bytes
  caller_in: [arbitrumone_Bytes!]
  caller_not_in: [arbitrumone_Bytes!]
  caller_contains: arbitrumone_Bytes
  caller_not_contains: arbitrumone_Bytes
  transactionHash: arbitrumone_Bytes
  transactionHash_not: arbitrumone_Bytes
  transactionHash_gt: arbitrumone_Bytes
  transactionHash_lt: arbitrumone_Bytes
  transactionHash_gte: arbitrumone_Bytes
  transactionHash_lte: arbitrumone_Bytes
  transactionHash_in: [arbitrumone_Bytes!]
  transactionHash_not_in: [arbitrumone_Bytes!]
  transactionHash_contains: arbitrumone_Bytes
  transactionHash_not_contains: arbitrumone_Bytes
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  gasLimit: BigInt
  gasLimit_not: BigInt
  gasLimit_gt: BigInt
  gasLimit_lt: BigInt
  gasLimit_gte: BigInt
  gasLimit_lte: BigInt
  gasLimit_in: [BigInt!]
  gasLimit_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: arbitrumone_BlockChangedFilter
  and: [arbitrumone_RelayerFeesIncrease_filter]
  or: [arbitrumone_RelayerFeesIncrease_filter]
}

enum arbitrumone_RelayerFeesIncrease_orderBy {
  id
  transfer
  transfer__id
  transfer__chainId
  transfer__transferId
  transfer__nonce
  transfer__status
  transfer__messageHash
  transfer__originDomain
  transfer__destinationDomain
  transfer__canonicalDomain
  transfer__to
  transfer__delegate
  transfer__receiveLocal
  transfer__callData
  transfer__slippage
  transfer__originSender
  transfer__bridgedAmt
  transfer__normalizedIn
  transfer__canonicalId
  transfer__transactingAsset
  transfer__bumpRelayerFeeCount
  transfer__initialRelayerFeeAsset
  transfer__caller
  transfer__transactionHash
  transfer__timestamp
  transfer__gasPrice
  transfer__gasLimit
  transfer__blockNumber
  transfer__txOrigin
  transfer__txNonce
  increase
  asset
  caller
  transactionHash
  timestamp
  gasPrice
  gasLimit
  blockNumber
}

input arbitrumone_Relayer_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  isActive: Boolean
  isActive_not: Boolean
  isActive_in: [Boolean!]
  isActive_not_in: [Boolean!]
  relayer: arbitrumone_Bytes
  relayer_not: arbitrumone_Bytes
  relayer_gt: arbitrumone_Bytes
  relayer_lt: arbitrumone_Bytes
  relayer_gte: arbitrumone_Bytes
  relayer_lte: arbitrumone_Bytes
  relayer_in: [arbitrumone_Bytes!]
  relayer_not_in: [arbitrumone_Bytes!]
  relayer_contains: arbitrumone_Bytes
  relayer_not_contains: arbitrumone_Bytes
  """Filter for the block changed event."""
  _change_block: arbitrumone_BlockChangedFilter
  and: [arbitrumone_Relayer_filter]
  or: [arbitrumone_Relayer_filter]
}

enum arbitrumone_Relayer_orderBy {
  id
  isActive
  relayer
}

type arbitrumone_RootCount {
  id: ID!
  count: BigInt
}

input arbitrumone_RootCount_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  count: BigInt
  count_not: BigInt
  count_gt: BigInt
  count_lt: BigInt
  count_gte: BigInt
  count_lte: BigInt
  count_in: [BigInt!]
  count_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: arbitrumone_BlockChangedFilter
  and: [arbitrumone_RootCount_filter]
  or: [arbitrumone_RootCount_filter]
}

enum arbitrumone_RootCount_orderBy {
  id
  count
}

type arbitrumone_RootMessageSent {
  id: ID!
  spokeDomain: BigInt
  hubDomain: BigInt
  root: arbitrumone_Bytes
  count: BigInt
  caller: arbitrumone_Bytes
  transactionHash: arbitrumone_Bytes
  timestamp: BigInt
  gasPrice: BigInt
  gasLimit: BigInt
  blockNumber: BigInt
}

input arbitrumone_RootMessageSent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  spokeDomain: BigInt
  spokeDomain_not: BigInt
  spokeDomain_gt: BigInt
  spokeDomain_lt: BigInt
  spokeDomain_gte: BigInt
  spokeDomain_lte: BigInt
  spokeDomain_in: [BigInt!]
  spokeDomain_not_in: [BigInt!]
  hubDomain: BigInt
  hubDomain_not: BigInt
  hubDomain_gt: BigInt
  hubDomain_lt: BigInt
  hubDomain_gte: BigInt
  hubDomain_lte: BigInt
  hubDomain_in: [BigInt!]
  hubDomain_not_in: [BigInt!]
  root: arbitrumone_Bytes
  root_not: arbitrumone_Bytes
  root_gt: arbitrumone_Bytes
  root_lt: arbitrumone_Bytes
  root_gte: arbitrumone_Bytes
  root_lte: arbitrumone_Bytes
  root_in: [arbitrumone_Bytes!]
  root_not_in: [arbitrumone_Bytes!]
  root_contains: arbitrumone_Bytes
  root_not_contains: arbitrumone_Bytes
  count: BigInt
  count_not: BigInt
  count_gt: BigInt
  count_lt: BigInt
  count_gte: BigInt
  count_lte: BigInt
  count_in: [BigInt!]
  count_not_in: [BigInt!]
  caller: arbitrumone_Bytes
  caller_not: arbitrumone_Bytes
  caller_gt: arbitrumone_Bytes
  caller_lt: arbitrumone_Bytes
  caller_gte: arbitrumone_Bytes
  caller_lte: arbitrumone_Bytes
  caller_in: [arbitrumone_Bytes!]
  caller_not_in: [arbitrumone_Bytes!]
  caller_contains: arbitrumone_Bytes
  caller_not_contains: arbitrumone_Bytes
  transactionHash: arbitrumone_Bytes
  transactionHash_not: arbitrumone_Bytes
  transactionHash_gt: arbitrumone_Bytes
  transactionHash_lt: arbitrumone_Bytes
  transactionHash_gte: arbitrumone_Bytes
  transactionHash_lte: arbitrumone_Bytes
  transactionHash_in: [arbitrumone_Bytes!]
  transactionHash_not_in: [arbitrumone_Bytes!]
  transactionHash_contains: arbitrumone_Bytes
  transactionHash_not_contains: arbitrumone_Bytes
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  gasLimit: BigInt
  gasLimit_not: BigInt
  gasLimit_gt: BigInt
  gasLimit_lt: BigInt
  gasLimit_gte: BigInt
  gasLimit_lte: BigInt
  gasLimit_in: [BigInt!]
  gasLimit_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: arbitrumone_BlockChangedFilter
  and: [arbitrumone_RootMessageSent_filter]
  or: [arbitrumone_RootMessageSent_filter]
}

enum arbitrumone_RootMessageSent_orderBy {
  id
  spokeDomain
  hubDomain
  root
  count
  caller
  transactionHash
  timestamp
  gasPrice
  gasLimit
  blockNumber
}

type arbitrumone_Router {
  id: ID!
  isActive: Boolean!
  owner: arbitrumone_Bytes
  recipient: arbitrumone_Bytes
  proposedOwner: arbitrumone_Bytes
  proposedTimestamp: BigInt
  assetBalances(skip: Int = 0, first: Int = 100, orderBy: arbitrumone_AssetBalance_orderBy, orderDirection: arbitrumone_OrderDirection, where: arbitrumone_AssetBalance_filter): [arbitrumone_AssetBalance!]!
}

type arbitrumone_RouterDailyTVL {
  id: ID!
  router: arbitrumone_Router!
  asset: arbitrumone_Asset!
  timestamp: BigInt!
  balance: BigInt!
}

input arbitrumone_RouterDailyTVL_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  router: String
  router_not: String
  router_gt: String
  router_lt: String
  router_gte: String
  router_lte: String
  router_in: [String!]
  router_not_in: [String!]
  router_contains: String
  router_contains_nocase: String
  router_not_contains: String
  router_not_contains_nocase: String
  router_starts_with: String
  router_starts_with_nocase: String
  router_not_starts_with: String
  router_not_starts_with_nocase: String
  router_ends_with: String
  router_ends_with_nocase: String
  router_not_ends_with: String
  router_not_ends_with_nocase: String
  router_: arbitrumone_Router_filter
  asset: String
  asset_not: String
  asset_gt: String
  asset_lt: String
  asset_gte: String
  asset_lte: String
  asset_in: [String!]
  asset_not_in: [String!]
  asset_contains: String
  asset_contains_nocase: String
  asset_not_contains: String
  asset_not_contains_nocase: String
  asset_starts_with: String
  asset_starts_with_nocase: String
  asset_not_starts_with: String
  asset_not_starts_with_nocase: String
  asset_ends_with: String
  asset_ends_with_nocase: String
  asset_not_ends_with: String
  asset_not_ends_with_nocase: String
  asset_: arbitrumone_Asset_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  balance: BigInt
  balance_not: BigInt
  balance_gt: BigInt
  balance_lt: BigInt
  balance_gte: BigInt
  balance_lte: BigInt
  balance_in: [BigInt!]
  balance_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: arbitrumone_BlockChangedFilter
  and: [arbitrumone_RouterDailyTVL_filter]
  or: [arbitrumone_RouterDailyTVL_filter]
}

enum arbitrumone_RouterDailyTVL_orderBy {
  id
  router
  router__id
  router__isActive
  router__owner
  router__recipient
  router__proposedOwner
  router__proposedTimestamp
  asset
  asset__id
  asset__key
  asset__decimal
  asset__adoptedDecimal
  asset__canonicalId
  asset__canonicalDomain
  asset__adoptedAsset
  asset__localAsset
  asset__blockNumber
  timestamp
  balance
}

type arbitrumone_RouterLiquidityEvent {
  id: ID!
  type: arbitrumone_RouterLiquidityEventType
  router: arbitrumone_Router!
  asset: arbitrumone_Asset!
  amount: BigInt!
  balance: BigInt!
  caller: arbitrumone_Bytes
  blockNumber: BigInt!
  timestamp: BigInt!
  transactionHash: arbitrumone_Bytes!
  nonce: BigInt!
}

enum arbitrumone_RouterLiquidityEventType {
  Add
  Remove
}

input arbitrumone_RouterLiquidityEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  type: arbitrumone_RouterLiquidityEventType
  type_not: arbitrumone_RouterLiquidityEventType
  type_in: [arbitrumone_RouterLiquidityEventType!]
  type_not_in: [arbitrumone_RouterLiquidityEventType!]
  router: String
  router_not: String
  router_gt: String
  router_lt: String
  router_gte: String
  router_lte: String
  router_in: [String!]
  router_not_in: [String!]
  router_contains: String
  router_contains_nocase: String
  router_not_contains: String
  router_not_contains_nocase: String
  router_starts_with: String
  router_starts_with_nocase: String
  router_not_starts_with: String
  router_not_starts_with_nocase: String
  router_ends_with: String
  router_ends_with_nocase: String
  router_not_ends_with: String
  router_not_ends_with_nocase: String
  router_: arbitrumone_Router_filter
  asset: String
  asset_not: String
  asset_gt: String
  asset_lt: String
  asset_gte: String
  asset_lte: String
  asset_in: [String!]
  asset_not_in: [String!]
  asset_contains: String
  asset_contains_nocase: String
  asset_not_contains: String
  asset_not_contains_nocase: String
  asset_starts_with: String
  asset_starts_with_nocase: String
  asset_not_starts_with: String
  asset_not_starts_with_nocase: String
  asset_ends_with: String
  asset_ends_with_nocase: String
  asset_not_ends_with: String
  asset_not_ends_with_nocase: String
  asset_: arbitrumone_Asset_filter
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  balance: BigInt
  balance_not: BigInt
  balance_gt: BigInt
  balance_lt: BigInt
  balance_gte: BigInt
  balance_lte: BigInt
  balance_in: [BigInt!]
  balance_not_in: [BigInt!]
  caller: arbitrumone_Bytes
  caller_not: arbitrumone_Bytes
  caller_gt: arbitrumone_Bytes
  caller_lt: arbitrumone_Bytes
  caller_gte: arbitrumone_Bytes
  caller_lte: arbitrumone_Bytes
  caller_in: [arbitrumone_Bytes!]
  caller_not_in: [arbitrumone_Bytes!]
  caller_contains: arbitrumone_Bytes
  caller_not_contains: arbitrumone_Bytes
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transactionHash: arbitrumone_Bytes
  transactionHash_not: arbitrumone_Bytes
  transactionHash_gt: arbitrumone_Bytes
  transactionHash_lt: arbitrumone_Bytes
  transactionHash_gte: arbitrumone_Bytes
  transactionHash_lte: arbitrumone_Bytes
  transactionHash_in: [arbitrumone_Bytes!]
  transactionHash_not_in: [arbitrumone_Bytes!]
  transactionHash_contains: arbitrumone_Bytes
  transactionHash_not_contains: arbitrumone_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: arbitrumone_BlockChangedFilter
  and: [arbitrumone_RouterLiquidityEvent_filter]
  or: [arbitrumone_RouterLiquidityEvent_filter]
}

enum arbitrumone_RouterLiquidityEvent_orderBy {
  id
  type
  router
  router__id
  router__isActive
  router__owner
  router__recipient
  router__proposedOwner
  router__proposedTimestamp
  asset
  asset__id
  asset__key
  asset__decimal
  asset__adoptedDecimal
  asset__canonicalId
  asset__canonicalDomain
  asset__adoptedAsset
  asset__localAsset
  asset__blockNumber
  amount
  balance
  caller
  blockNumber
  timestamp
  transactionHash
  nonce
}

input arbitrumone_Router_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  isActive: Boolean
  isActive_not: Boolean
  isActive_in: [Boolean!]
  isActive_not_in: [Boolean!]
  owner: arbitrumone_Bytes
  owner_not: arbitrumone_Bytes
  owner_gt: arbitrumone_Bytes
  owner_lt: arbitrumone_Bytes
  owner_gte: arbitrumone_Bytes
  owner_lte: arbitrumone_Bytes
  owner_in: [arbitrumone_Bytes!]
  owner_not_in: [arbitrumone_Bytes!]
  owner_contains: arbitrumone_Bytes
  owner_not_contains: arbitrumone_Bytes
  recipient: arbitrumone_Bytes
  recipient_not: arbitrumone_Bytes
  recipient_gt: arbitrumone_Bytes
  recipient_lt: arbitrumone_Bytes
  recipient_gte: arbitrumone_Bytes
  recipient_lte: arbitrumone_Bytes
  recipient_in: [arbitrumone_Bytes!]
  recipient_not_in: [arbitrumone_Bytes!]
  recipient_contains: arbitrumone_Bytes
  recipient_not_contains: arbitrumone_Bytes
  proposedOwner: arbitrumone_Bytes
  proposedOwner_not: arbitrumone_Bytes
  proposedOwner_gt: arbitrumone_Bytes
  proposedOwner_lt: arbitrumone_Bytes
  proposedOwner_gte: arbitrumone_Bytes
  proposedOwner_lte: arbitrumone_Bytes
  proposedOwner_in: [arbitrumone_Bytes!]
  proposedOwner_not_in: [arbitrumone_Bytes!]
  proposedOwner_contains: arbitrumone_Bytes
  proposedOwner_not_contains: arbitrumone_Bytes
  proposedTimestamp: BigInt
  proposedTimestamp_not: BigInt
  proposedTimestamp_gt: BigInt
  proposedTimestamp_lt: BigInt
  proposedTimestamp_gte: BigInt
  proposedTimestamp_lte: BigInt
  proposedTimestamp_in: [BigInt!]
  proposedTimestamp_not_in: [BigInt!]
  assetBalances_: arbitrumone_AssetBalance_filter
  """Filter for the block changed event."""
  _change_block: arbitrumone_BlockChangedFilter
  and: [arbitrumone_Router_filter]
  or: [arbitrumone_Router_filter]
}

enum arbitrumone_Router_orderBy {
  id
  isActive
  owner
  recipient
  proposedOwner
  proposedTimestamp
  assetBalances
}

type arbitrumone_Sequencer {
  id: ID!
  isActive: Boolean!
  sequencer: arbitrumone_Bytes
}

input arbitrumone_Sequencer_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  isActive: Boolean
  isActive_not: Boolean
  isActive_in: [Boolean!]
  isActive_not_in: [Boolean!]
  sequencer: arbitrumone_Bytes
  sequencer_not: arbitrumone_Bytes
  sequencer_gt: arbitrumone_Bytes
  sequencer_lt: arbitrumone_Bytes
  sequencer_gte: arbitrumone_Bytes
  sequencer_lte: arbitrumone_Bytes
  sequencer_in: [arbitrumone_Bytes!]
  sequencer_not_in: [arbitrumone_Bytes!]
  sequencer_contains: arbitrumone_Bytes
  sequencer_not_contains: arbitrumone_Bytes
  """Filter for the block changed event."""
  _change_block: arbitrumone_BlockChangedFilter
  and: [arbitrumone_Sequencer_filter]
  or: [arbitrumone_Sequencer_filter]
}

enum arbitrumone_Sequencer_orderBy {
  id
  isActive
  sequencer
}

type arbitrumone_Setting {
  id: ID!
  maxRoutersPerTransfer: BigInt!
  caller: arbitrumone_Bytes!
}

input arbitrumone_Setting_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  maxRoutersPerTransfer: BigInt
  maxRoutersPerTransfer_not: BigInt
  maxRoutersPerTransfer_gt: BigInt
  maxRoutersPerTransfer_lt: BigInt
  maxRoutersPerTransfer_gte: BigInt
  maxRoutersPerTransfer_lte: BigInt
  maxRoutersPerTransfer_in: [BigInt!]
  maxRoutersPerTransfer_not_in: [BigInt!]
  caller: arbitrumone_Bytes
  caller_not: arbitrumone_Bytes
  caller_gt: arbitrumone_Bytes
  caller_lt: arbitrumone_Bytes
  caller_gte: arbitrumone_Bytes
  caller_lte: arbitrumone_Bytes
  caller_in: [arbitrumone_Bytes!]
  caller_not_in: [arbitrumone_Bytes!]
  caller_contains: arbitrumone_Bytes
  caller_not_contains: arbitrumone_Bytes
  """Filter for the block changed event."""
  _change_block: arbitrumone_BlockChangedFilter
  and: [arbitrumone_Setting_filter]
  or: [arbitrumone_Setting_filter]
}

enum arbitrumone_Setting_orderBy {
  id
  maxRoutersPerTransfer
  caller
}

type arbitrumone_SlippageUpdate {
  id: ID!
  transfer: arbitrumone_DestinationTransfer!
  slippage: BigInt!
  caller: arbitrumone_Bytes!
  transactionHash: arbitrumone_Bytes!
  timestamp: BigInt!
  gasPrice: BigInt!
  gasLimit: BigInt!
  blockNumber: BigInt!
}

input arbitrumone_SlippageUpdate_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transfer: String
  transfer_not: String
  transfer_gt: String
  transfer_lt: String
  transfer_gte: String
  transfer_lte: String
  transfer_in: [String!]
  transfer_not_in: [String!]
  transfer_contains: String
  transfer_contains_nocase: String
  transfer_not_contains: String
  transfer_not_contains_nocase: String
  transfer_starts_with: String
  transfer_starts_with_nocase: String
  transfer_not_starts_with: String
  transfer_not_starts_with_nocase: String
  transfer_ends_with: String
  transfer_ends_with_nocase: String
  transfer_not_ends_with: String
  transfer_not_ends_with_nocase: String
  transfer_: arbitrumone_DestinationTransfer_filter
  slippage: BigInt
  slippage_not: BigInt
  slippage_gt: BigInt
  slippage_lt: BigInt
  slippage_gte: BigInt
  slippage_lte: BigInt
  slippage_in: [BigInt!]
  slippage_not_in: [BigInt!]
  caller: arbitrumone_Bytes
  caller_not: arbitrumone_Bytes
  caller_gt: arbitrumone_Bytes
  caller_lt: arbitrumone_Bytes
  caller_gte: arbitrumone_Bytes
  caller_lte: arbitrumone_Bytes
  caller_in: [arbitrumone_Bytes!]
  caller_not_in: [arbitrumone_Bytes!]
  caller_contains: arbitrumone_Bytes
  caller_not_contains: arbitrumone_Bytes
  transactionHash: arbitrumone_Bytes
  transactionHash_not: arbitrumone_Bytes
  transactionHash_gt: arbitrumone_Bytes
  transactionHash_lt: arbitrumone_Bytes
  transactionHash_gte: arbitrumone_Bytes
  transactionHash_lte: arbitrumone_Bytes
  transactionHash_in: [arbitrumone_Bytes!]
  transactionHash_not_in: [arbitrumone_Bytes!]
  transactionHash_contains: arbitrumone_Bytes
  transactionHash_not_contains: arbitrumone_Bytes
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  gasLimit: BigInt
  gasLimit_not: BigInt
  gasLimit_gt: BigInt
  gasLimit_lt: BigInt
  gasLimit_gte: BigInt
  gasLimit_lte: BigInt
  gasLimit_in: [BigInt!]
  gasLimit_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: arbitrumone_BlockChangedFilter
  and: [arbitrumone_SlippageUpdate_filter]
  or: [arbitrumone_SlippageUpdate_filter]
}

enum arbitrumone_SlippageUpdate_orderBy {
  id
  transfer
  transfer__id
  transfer__chainId
  transfer__transferId
  transfer__nonce
  transfer__status
  transfer__originDomain
  transfer__destinationDomain
  transfer__canonicalDomain
  transfer__to
  transfer__delegate
  transfer__receiveLocal
  transfer__callData
  transfer__slippage
  transfer__bumpSlippageCount
  transfer__originSender
  transfer__bridgedAmt
  transfer__normalizedIn
  transfer__canonicalId
  transfer__amount
  transfer__routersFee
  transfer__executedCaller
  transfer__executedTransactionHash
  transfer__executedTimestamp
  transfer__executedGasPrice
  transfer__executedGasLimit
  transfer__executedBlockNumber
  transfer__executedTxOrigin
  transfer__executedTxNonce
  transfer__reconciledCaller
  transfer__reconciledTransactionHash
  transfer__reconciledTimestamp
  transfer__reconciledGasPrice
  transfer__reconciledGasLimit
  transfer__reconciledBlockNumber
  transfer__reconciledTxOrigin
  transfer__reconciledTxNonce
  slippage
  caller
  transactionHash
  timestamp
  gasPrice
  gasLimit
  blockNumber
}

type arbitrumone_SnapshotRoot {
  id: ID!
  spokeDomain: BigInt
  root: arbitrumone_Bytes!
  count: BigInt!
  timestamp: BigInt!
  blockNumber: BigInt!
}

input arbitrumone_SnapshotRoot_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  spokeDomain: BigInt
  spokeDomain_not: BigInt
  spokeDomain_gt: BigInt
  spokeDomain_lt: BigInt
  spokeDomain_gte: BigInt
  spokeDomain_lte: BigInt
  spokeDomain_in: [BigInt!]
  spokeDomain_not_in: [BigInt!]
  root: arbitrumone_Bytes
  root_not: arbitrumone_Bytes
  root_gt: arbitrumone_Bytes
  root_lt: arbitrumone_Bytes
  root_gte: arbitrumone_Bytes
  root_lte: arbitrumone_Bytes
  root_in: [arbitrumone_Bytes!]
  root_not_in: [arbitrumone_Bytes!]
  root_contains: arbitrumone_Bytes
  root_not_contains: arbitrumone_Bytes
  count: BigInt
  count_not: BigInt
  count_gt: BigInt
  count_lt: BigInt
  count_gte: BigInt
  count_lte: BigInt
  count_in: [BigInt!]
  count_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: arbitrumone_BlockChangedFilter
  and: [arbitrumone_SnapshotRoot_filter]
  or: [arbitrumone_SnapshotRoot_filter]
}

enum arbitrumone_SnapshotRoot_orderBy {
  id
  spokeDomain
  root
  count
  timestamp
  blockNumber
}

type arbitrumone_SpokeConnectorMode {
  id: ID!
  mode: String!
}

input arbitrumone_SpokeConnectorMode_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  mode: String
  mode_not: String
  mode_gt: String
  mode_lt: String
  mode_gte: String
  mode_lte: String
  mode_in: [String!]
  mode_not_in: [String!]
  mode_contains: String
  mode_contains_nocase: String
  mode_not_contains: String
  mode_not_contains_nocase: String
  mode_starts_with: String
  mode_starts_with_nocase: String
  mode_not_starts_with: String
  mode_not_starts_with_nocase: String
  mode_ends_with: String
  mode_ends_with_nocase: String
  mode_not_ends_with: String
  mode_not_ends_with_nocase: String
  """Filter for the block changed event."""
  _change_block: arbitrumone_BlockChangedFilter
  and: [arbitrumone_SpokeConnectorMode_filter]
  or: [arbitrumone_SpokeConnectorMode_filter]
}

enum arbitrumone_SpokeConnectorMode_orderBy {
  id
  mode
}

enum arbitrumone_TransferStatus {
  XCalled
  Executed
  Reconciled
  CompletedSlow
  CompletedFast
}

type arbitrumone__Block_ {
  """The hash of the block"""
  hash: arbitrumone_Bytes
  """The block number"""
  number: Int!
  """Integer representation of the timestamp stored in blocks for the chain"""
  timestamp: Int
  """The hash of the parent block"""
  parentHash: arbitrumone_Bytes
}

"""The type for the top-level _meta field"""
type arbitrumone__Meta_ {
  """
  Information about a specific subgraph block. The hash of the block
  will be null if the _meta field has a block constraint that asks for
  a block number. It will be filled if the _meta field has no block constraint
  and therefore asks for the latest  block
  
  """
  block: arbitrumone__Block_!
  """The deployment ID"""
  deployment: String!
  """If `true`, the subgraph encountered indexing errors at some past block"""
  hasIndexingErrors: Boolean!
}

type mainnet_AggregateRoot {
  id: ID!
  root: mainnet_Bytes!
  blockNumber: BigInt!
}

type mainnet_AggregateRootProposed {
  id: ID!
  aggregateRoot: mainnet_Bytes!
  rootTimestamp: BigInt!
  endOfDispute: BigInt!
  domain: BigInt!
  timestamp: BigInt!
  blockNumber: BigInt
}

input mainnet_AggregateRootProposed_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  aggregateRoot: mainnet_Bytes
  aggregateRoot_not: mainnet_Bytes
  aggregateRoot_gt: mainnet_Bytes
  aggregateRoot_lt: mainnet_Bytes
  aggregateRoot_gte: mainnet_Bytes
  aggregateRoot_lte: mainnet_Bytes
  aggregateRoot_in: [mainnet_Bytes!]
  aggregateRoot_not_in: [mainnet_Bytes!]
  aggregateRoot_contains: mainnet_Bytes
  aggregateRoot_not_contains: mainnet_Bytes
  rootTimestamp: BigInt
  rootTimestamp_not: BigInt
  rootTimestamp_gt: BigInt
  rootTimestamp_lt: BigInt
  rootTimestamp_gte: BigInt
  rootTimestamp_lte: BigInt
  rootTimestamp_in: [BigInt!]
  rootTimestamp_not_in: [BigInt!]
  endOfDispute: BigInt
  endOfDispute_not: BigInt
  endOfDispute_gt: BigInt
  endOfDispute_lt: BigInt
  endOfDispute_gte: BigInt
  endOfDispute_lte: BigInt
  endOfDispute_in: [BigInt!]
  endOfDispute_not_in: [BigInt!]
  domain: BigInt
  domain_not: BigInt
  domain_gt: BigInt
  domain_lt: BigInt
  domain_gte: BigInt
  domain_lte: BigInt
  domain_in: [BigInt!]
  domain_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: mainnet_BlockChangedFilter
  and: [mainnet_AggregateRootProposed_filter]
  or: [mainnet_AggregateRootProposed_filter]
}

enum mainnet_AggregateRootProposed_orderBy {
  id
  aggregateRoot
  rootTimestamp
  endOfDispute
  domain
  timestamp
  blockNumber
}

input mainnet_AggregateRoot_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  root: mainnet_Bytes
  root_not: mainnet_Bytes
  root_gt: mainnet_Bytes
  root_lt: mainnet_Bytes
  root_gte: mainnet_Bytes
  root_lte: mainnet_Bytes
  root_in: [mainnet_Bytes!]
  root_not_in: [mainnet_Bytes!]
  root_contains: mainnet_Bytes
  root_not_contains: mainnet_Bytes
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: mainnet_BlockChangedFilter
  and: [mainnet_AggregateRoot_filter]
  or: [mainnet_AggregateRoot_filter]
}

enum mainnet_AggregateRoot_orderBy {
  id
  root
  blockNumber
}

type mainnet_Asset {
  id: ID!
  key: mainnet_Bytes
  decimal: BigInt
  adoptedDecimal: BigInt
  canonicalId: mainnet_Bytes
  canonicalDomain: BigInt
  adoptedAsset: mainnet_Bytes
  localAsset: mainnet_Bytes
  blockNumber: BigInt
  status: mainnet_AssetStatus
}

type mainnet_AssetBalance {
  id: ID!
  amount: BigInt!
  locked: BigInt!
  supplied: BigInt!
  removed: BigInt!
  router: mainnet_Router!
  asset: mainnet_Asset!
  feesEarned: BigInt!
}

input mainnet_AssetBalance_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  locked: BigInt
  locked_not: BigInt
  locked_gt: BigInt
  locked_lt: BigInt
  locked_gte: BigInt
  locked_lte: BigInt
  locked_in: [BigInt!]
  locked_not_in: [BigInt!]
  supplied: BigInt
  supplied_not: BigInt
  supplied_gt: BigInt
  supplied_lt: BigInt
  supplied_gte: BigInt
  supplied_lte: BigInt
  supplied_in: [BigInt!]
  supplied_not_in: [BigInt!]
  removed: BigInt
  removed_not: BigInt
  removed_gt: BigInt
  removed_lt: BigInt
  removed_gte: BigInt
  removed_lte: BigInt
  removed_in: [BigInt!]
  removed_not_in: [BigInt!]
  router: String
  router_not: String
  router_gt: String
  router_lt: String
  router_gte: String
  router_lte: String
  router_in: [String!]
  router_not_in: [String!]
  router_contains: String
  router_contains_nocase: String
  router_not_contains: String
  router_not_contains_nocase: String
  router_starts_with: String
  router_starts_with_nocase: String
  router_not_starts_with: String
  router_not_starts_with_nocase: String
  router_ends_with: String
  router_ends_with_nocase: String
  router_not_ends_with: String
  router_not_ends_with_nocase: String
  router_: mainnet_Router_filter
  asset: String
  asset_not: String
  asset_gt: String
  asset_lt: String
  asset_gte: String
  asset_lte: String
  asset_in: [String!]
  asset_not_in: [String!]
  asset_contains: String
  asset_contains_nocase: String
  asset_not_contains: String
  asset_not_contains_nocase: String
  asset_starts_with: String
  asset_starts_with_nocase: String
  asset_not_starts_with: String
  asset_not_starts_with_nocase: String
  asset_ends_with: String
  asset_ends_with_nocase: String
  asset_not_ends_with: String
  asset_not_ends_with_nocase: String
  asset_: mainnet_Asset_filter
  feesEarned: BigInt
  feesEarned_not: BigInt
  feesEarned_gt: BigInt
  feesEarned_lt: BigInt
  feesEarned_gte: BigInt
  feesEarned_lte: BigInt
  feesEarned_in: [BigInt!]
  feesEarned_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: mainnet_BlockChangedFilter
  and: [mainnet_AssetBalance_filter]
  or: [mainnet_AssetBalance_filter]
}

enum mainnet_AssetBalance_orderBy {
  id
  amount
  locked
  supplied
  removed
  router
  router__id
  router__isActive
  router__owner
  router__recipient
  router__proposedOwner
  router__proposedTimestamp
  asset
  asset__id
  asset__key
  asset__decimal
  asset__adoptedDecimal
  asset__canonicalId
  asset__canonicalDomain
  asset__adoptedAsset
  asset__localAsset
  asset__blockNumber
  feesEarned
}

type mainnet_AssetStatus {
  id: ID!
  status: Boolean
}

input mainnet_AssetStatus_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  status: Boolean
  status_not: Boolean
  status_in: [Boolean!]
  status_not_in: [Boolean!]
  """Filter for the block changed event."""
  _change_block: mainnet_BlockChangedFilter
  and: [mainnet_AssetStatus_filter]
  or: [mainnet_AssetStatus_filter]
}

enum mainnet_AssetStatus_orderBy {
  id
  status
}

input mainnet_Asset_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  key: mainnet_Bytes
  key_not: mainnet_Bytes
  key_gt: mainnet_Bytes
  key_lt: mainnet_Bytes
  key_gte: mainnet_Bytes
  key_lte: mainnet_Bytes
  key_in: [mainnet_Bytes!]
  key_not_in: [mainnet_Bytes!]
  key_contains: mainnet_Bytes
  key_not_contains: mainnet_Bytes
  decimal: BigInt
  decimal_not: BigInt
  decimal_gt: BigInt
  decimal_lt: BigInt
  decimal_gte: BigInt
  decimal_lte: BigInt
  decimal_in: [BigInt!]
  decimal_not_in: [BigInt!]
  adoptedDecimal: BigInt
  adoptedDecimal_not: BigInt
  adoptedDecimal_gt: BigInt
  adoptedDecimal_lt: BigInt
  adoptedDecimal_gte: BigInt
  adoptedDecimal_lte: BigInt
  adoptedDecimal_in: [BigInt!]
  adoptedDecimal_not_in: [BigInt!]
  canonicalId: mainnet_Bytes
  canonicalId_not: mainnet_Bytes
  canonicalId_gt: mainnet_Bytes
  canonicalId_lt: mainnet_Bytes
  canonicalId_gte: mainnet_Bytes
  canonicalId_lte: mainnet_Bytes
  canonicalId_in: [mainnet_Bytes!]
  canonicalId_not_in: [mainnet_Bytes!]
  canonicalId_contains: mainnet_Bytes
  canonicalId_not_contains: mainnet_Bytes
  canonicalDomain: BigInt
  canonicalDomain_not: BigInt
  canonicalDomain_gt: BigInt
  canonicalDomain_lt: BigInt
  canonicalDomain_gte: BigInt
  canonicalDomain_lte: BigInt
  canonicalDomain_in: [BigInt!]
  canonicalDomain_not_in: [BigInt!]
  adoptedAsset: mainnet_Bytes
  adoptedAsset_not: mainnet_Bytes
  adoptedAsset_gt: mainnet_Bytes
  adoptedAsset_lt: mainnet_Bytes
  adoptedAsset_gte: mainnet_Bytes
  adoptedAsset_lte: mainnet_Bytes
  adoptedAsset_in: [mainnet_Bytes!]
  adoptedAsset_not_in: [mainnet_Bytes!]
  adoptedAsset_contains: mainnet_Bytes
  adoptedAsset_not_contains: mainnet_Bytes
  localAsset: mainnet_Bytes
  localAsset_not: mainnet_Bytes
  localAsset_gt: mainnet_Bytes
  localAsset_lt: mainnet_Bytes
  localAsset_gte: mainnet_Bytes
  localAsset_lte: mainnet_Bytes
  localAsset_in: [mainnet_Bytes!]
  localAsset_not_in: [mainnet_Bytes!]
  localAsset_contains: mainnet_Bytes
  localAsset_not_contains: mainnet_Bytes
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  status: String
  status_not: String
  status_gt: String
  status_lt: String
  status_gte: String
  status_lte: String
  status_in: [String!]
  status_not_in: [String!]
  status_contains: String
  status_contains_nocase: String
  status_not_contains: String
  status_not_contains_nocase: String
  status_starts_with: String
  status_starts_with_nocase: String
  status_not_starts_with: String
  status_not_starts_with_nocase: String
  status_ends_with: String
  status_ends_with_nocase: String
  status_not_ends_with: String
  status_not_ends_with_nocase: String
  status_: mainnet_AssetStatus_filter
  """Filter for the block changed event."""
  _change_block: mainnet_BlockChangedFilter
  and: [mainnet_Asset_filter]
  or: [mainnet_Asset_filter]
}

enum mainnet_Asset_orderBy {
  id
  key
  decimal
  adoptedDecimal
  canonicalId
  canonicalDomain
  adoptedAsset
  localAsset
  blockNumber
  status
  status__id
  status__status
}

type mainnet_ConnectorMeta {
  id: ID!
  spokeDomain: BigInt
  hubDomain: BigInt
  amb: mainnet_Bytes
  rootManager: mainnet_Bytes
  mirrorConnector: mainnet_Bytes
}

input mainnet_ConnectorMeta_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  spokeDomain: BigInt
  spokeDomain_not: BigInt
  spokeDomain_gt: BigInt
  spokeDomain_lt: BigInt
  spokeDomain_gte: BigInt
  spokeDomain_lte: BigInt
  spokeDomain_in: [BigInt!]
  spokeDomain_not_in: [BigInt!]
  hubDomain: BigInt
  hubDomain_not: BigInt
  hubDomain_gt: BigInt
  hubDomain_lt: BigInt
  hubDomain_gte: BigInt
  hubDomain_lte: BigInt
  hubDomain_in: [BigInt!]
  hubDomain_not_in: [BigInt!]
  amb: mainnet_Bytes
  amb_not: mainnet_Bytes
  amb_gt: mainnet_Bytes
  amb_lt: mainnet_Bytes
  amb_gte: mainnet_Bytes
  amb_lte: mainnet_Bytes
  amb_in: [mainnet_Bytes!]
  amb_not_in: [mainnet_Bytes!]
  amb_contains: mainnet_Bytes
  amb_not_contains: mainnet_Bytes
  rootManager: mainnet_Bytes
  rootManager_not: mainnet_Bytes
  rootManager_gt: mainnet_Bytes
  rootManager_lt: mainnet_Bytes
  rootManager_gte: mainnet_Bytes
  rootManager_lte: mainnet_Bytes
  rootManager_in: [mainnet_Bytes!]
  rootManager_not_in: [mainnet_Bytes!]
  rootManager_contains: mainnet_Bytes
  rootManager_not_contains: mainnet_Bytes
  mirrorConnector: mainnet_Bytes
  mirrorConnector_not: mainnet_Bytes
  mirrorConnector_gt: mainnet_Bytes
  mirrorConnector_lt: mainnet_Bytes
  mirrorConnector_gte: mainnet_Bytes
  mirrorConnector_lte: mainnet_Bytes
  mirrorConnector_in: [mainnet_Bytes!]
  mirrorConnector_not_in: [mainnet_Bytes!]
  mirrorConnector_contains: mainnet_Bytes
  mirrorConnector_not_contains: mainnet_Bytes
  """Filter for the block changed event."""
  _change_block: mainnet_BlockChangedFilter
  and: [mainnet_ConnectorMeta_filter]
  or: [mainnet_ConnectorMeta_filter]
}

enum mainnet_ConnectorMeta_orderBy {
  id
  spokeDomain
  hubDomain
  amb
  rootManager
  mirrorConnector
}

type mainnet_DestinationTransfer {
  id: ID!
  chainId: BigInt
  transferId: mainnet_Bytes
  nonce: BigInt
  status: mainnet_TransferStatus
  routers(skip: Int = 0, first: Int = 100, orderBy: mainnet_Router_orderBy, orderDirection: mainnet_OrderDirection, where: mainnet_Router_filter): [mainnet_Router!]
  originDomain: BigInt
  destinationDomain: BigInt
  canonicalDomain: BigInt
  to: mainnet_Bytes
  delegate: mainnet_Bytes
  receiveLocal: Boolean
  callData: mainnet_Bytes
  slippage: BigInt
  bumpSlippageCount: BigInt
  originSender: mainnet_Bytes
  bridgedAmt: BigInt
  normalizedIn: BigInt
  canonicalId: mainnet_Bytes
  asset: mainnet_Asset
  amount: BigInt
  routersFee: BigInt
  executedCaller: mainnet_Bytes
  executedTransactionHash: mainnet_Bytes
  executedTimestamp: BigInt
  executedGasPrice: BigInt
  executedGasLimit: BigInt
  executedBlockNumber: BigInt
  executedTxOrigin: mainnet_Bytes
  executedTxNonce: BigInt
  reconciledCaller: mainnet_Bytes
  reconciledTransactionHash: mainnet_Bytes
  reconciledTimestamp: BigInt
  reconciledGasPrice: BigInt
  reconciledGasLimit: BigInt
  reconciledBlockNumber: BigInt
  reconciledTxOrigin: mainnet_Bytes
  reconciledTxNonce: BigInt
}

input mainnet_DestinationTransfer_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  chainId: BigInt
  chainId_not: BigInt
  chainId_gt: BigInt
  chainId_lt: BigInt
  chainId_gte: BigInt
  chainId_lte: BigInt
  chainId_in: [BigInt!]
  chainId_not_in: [BigInt!]
  transferId: mainnet_Bytes
  transferId_not: mainnet_Bytes
  transferId_gt: mainnet_Bytes
  transferId_lt: mainnet_Bytes
  transferId_gte: mainnet_Bytes
  transferId_lte: mainnet_Bytes
  transferId_in: [mainnet_Bytes!]
  transferId_not_in: [mainnet_Bytes!]
  transferId_contains: mainnet_Bytes
  transferId_not_contains: mainnet_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  status: mainnet_TransferStatus
  status_not: mainnet_TransferStatus
  status_in: [mainnet_TransferStatus!]
  status_not_in: [mainnet_TransferStatus!]
  routers: [String!]
  routers_not: [String!]
  routers_contains: [String!]
  routers_contains_nocase: [String!]
  routers_not_contains: [String!]
  routers_not_contains_nocase: [String!]
  routers_: mainnet_Router_filter
  originDomain: BigInt
  originDomain_not: BigInt
  originDomain_gt: BigInt
  originDomain_lt: BigInt
  originDomain_gte: BigInt
  originDomain_lte: BigInt
  originDomain_in: [BigInt!]
  originDomain_not_in: [BigInt!]
  destinationDomain: BigInt
  destinationDomain_not: BigInt
  destinationDomain_gt: BigInt
  destinationDomain_lt: BigInt
  destinationDomain_gte: BigInt
  destinationDomain_lte: BigInt
  destinationDomain_in: [BigInt!]
  destinationDomain_not_in: [BigInt!]
  canonicalDomain: BigInt
  canonicalDomain_not: BigInt
  canonicalDomain_gt: BigInt
  canonicalDomain_lt: BigInt
  canonicalDomain_gte: BigInt
  canonicalDomain_lte: BigInt
  canonicalDomain_in: [BigInt!]
  canonicalDomain_not_in: [BigInt!]
  to: mainnet_Bytes
  to_not: mainnet_Bytes
  to_gt: mainnet_Bytes
  to_lt: mainnet_Bytes
  to_gte: mainnet_Bytes
  to_lte: mainnet_Bytes
  to_in: [mainnet_Bytes!]
  to_not_in: [mainnet_Bytes!]
  to_contains: mainnet_Bytes
  to_not_contains: mainnet_Bytes
  delegate: mainnet_Bytes
  delegate_not: mainnet_Bytes
  delegate_gt: mainnet_Bytes
  delegate_lt: mainnet_Bytes
  delegate_gte: mainnet_Bytes
  delegate_lte: mainnet_Bytes
  delegate_in: [mainnet_Bytes!]
  delegate_not_in: [mainnet_Bytes!]
  delegate_contains: mainnet_Bytes
  delegate_not_contains: mainnet_Bytes
  receiveLocal: Boolean
  receiveLocal_not: Boolean
  receiveLocal_in: [Boolean!]
  receiveLocal_not_in: [Boolean!]
  callData: mainnet_Bytes
  callData_not: mainnet_Bytes
  callData_gt: mainnet_Bytes
  callData_lt: mainnet_Bytes
  callData_gte: mainnet_Bytes
  callData_lte: mainnet_Bytes
  callData_in: [mainnet_Bytes!]
  callData_not_in: [mainnet_Bytes!]
  callData_contains: mainnet_Bytes
  callData_not_contains: mainnet_Bytes
  slippage: BigInt
  slippage_not: BigInt
  slippage_gt: BigInt
  slippage_lt: BigInt
  slippage_gte: BigInt
  slippage_lte: BigInt
  slippage_in: [BigInt!]
  slippage_not_in: [BigInt!]
  bumpSlippageCount: BigInt
  bumpSlippageCount_not: BigInt
  bumpSlippageCount_gt: BigInt
  bumpSlippageCount_lt: BigInt
  bumpSlippageCount_gte: BigInt
  bumpSlippageCount_lte: BigInt
  bumpSlippageCount_in: [BigInt!]
  bumpSlippageCount_not_in: [BigInt!]
  originSender: mainnet_Bytes
  originSender_not: mainnet_Bytes
  originSender_gt: mainnet_Bytes
  originSender_lt: mainnet_Bytes
  originSender_gte: mainnet_Bytes
  originSender_lte: mainnet_Bytes
  originSender_in: [mainnet_Bytes!]
  originSender_not_in: [mainnet_Bytes!]
  originSender_contains: mainnet_Bytes
  originSender_not_contains: mainnet_Bytes
  bridgedAmt: BigInt
  bridgedAmt_not: BigInt
  bridgedAmt_gt: BigInt
  bridgedAmt_lt: BigInt
  bridgedAmt_gte: BigInt
  bridgedAmt_lte: BigInt
  bridgedAmt_in: [BigInt!]
  bridgedAmt_not_in: [BigInt!]
  normalizedIn: BigInt
  normalizedIn_not: BigInt
  normalizedIn_gt: BigInt
  normalizedIn_lt: BigInt
  normalizedIn_gte: BigInt
  normalizedIn_lte: BigInt
  normalizedIn_in: [BigInt!]
  normalizedIn_not_in: [BigInt!]
  canonicalId: mainnet_Bytes
  canonicalId_not: mainnet_Bytes
  canonicalId_gt: mainnet_Bytes
  canonicalId_lt: mainnet_Bytes
  canonicalId_gte: mainnet_Bytes
  canonicalId_lte: mainnet_Bytes
  canonicalId_in: [mainnet_Bytes!]
  canonicalId_not_in: [mainnet_Bytes!]
  canonicalId_contains: mainnet_Bytes
  canonicalId_not_contains: mainnet_Bytes
  asset: String
  asset_not: String
  asset_gt: String
  asset_lt: String
  asset_gte: String
  asset_lte: String
  asset_in: [String!]
  asset_not_in: [String!]
  asset_contains: String
  asset_contains_nocase: String
  asset_not_contains: String
  asset_not_contains_nocase: String
  asset_starts_with: String
  asset_starts_with_nocase: String
  asset_not_starts_with: String
  asset_not_starts_with_nocase: String
  asset_ends_with: String
  asset_ends_with_nocase: String
  asset_not_ends_with: String
  asset_not_ends_with_nocase: String
  asset_: mainnet_Asset_filter
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  routersFee: BigInt
  routersFee_not: BigInt
  routersFee_gt: BigInt
  routersFee_lt: BigInt
  routersFee_gte: BigInt
  routersFee_lte: BigInt
  routersFee_in: [BigInt!]
  routersFee_not_in: [BigInt!]
  executedCaller: mainnet_Bytes
  executedCaller_not: mainnet_Bytes
  executedCaller_gt: mainnet_Bytes
  executedCaller_lt: mainnet_Bytes
  executedCaller_gte: mainnet_Bytes
  executedCaller_lte: mainnet_Bytes
  executedCaller_in: [mainnet_Bytes!]
  executedCaller_not_in: [mainnet_Bytes!]
  executedCaller_contains: mainnet_Bytes
  executedCaller_not_contains: mainnet_Bytes
  executedTransactionHash: mainnet_Bytes
  executedTransactionHash_not: mainnet_Bytes
  executedTransactionHash_gt: mainnet_Bytes
  executedTransactionHash_lt: mainnet_Bytes
  executedTransactionHash_gte: mainnet_Bytes
  executedTransactionHash_lte: mainnet_Bytes
  executedTransactionHash_in: [mainnet_Bytes!]
  executedTransactionHash_not_in: [mainnet_Bytes!]
  executedTransactionHash_contains: mainnet_Bytes
  executedTransactionHash_not_contains: mainnet_Bytes
  executedTimestamp: BigInt
  executedTimestamp_not: BigInt
  executedTimestamp_gt: BigInt
  executedTimestamp_lt: BigInt
  executedTimestamp_gte: BigInt
  executedTimestamp_lte: BigInt
  executedTimestamp_in: [BigInt!]
  executedTimestamp_not_in: [BigInt!]
  executedGasPrice: BigInt
  executedGasPrice_not: BigInt
  executedGasPrice_gt: BigInt
  executedGasPrice_lt: BigInt
  executedGasPrice_gte: BigInt
  executedGasPrice_lte: BigInt
  executedGasPrice_in: [BigInt!]
  executedGasPrice_not_in: [BigInt!]
  executedGasLimit: BigInt
  executedGasLimit_not: BigInt
  executedGasLimit_gt: BigInt
  executedGasLimit_lt: BigInt
  executedGasLimit_gte: BigInt
  executedGasLimit_lte: BigInt
  executedGasLimit_in: [BigInt!]
  executedGasLimit_not_in: [BigInt!]
  executedBlockNumber: BigInt
  executedBlockNumber_not: BigInt
  executedBlockNumber_gt: BigInt
  executedBlockNumber_lt: BigInt
  executedBlockNumber_gte: BigInt
  executedBlockNumber_lte: BigInt
  executedBlockNumber_in: [BigInt!]
  executedBlockNumber_not_in: [BigInt!]
  executedTxOrigin: mainnet_Bytes
  executedTxOrigin_not: mainnet_Bytes
  executedTxOrigin_gt: mainnet_Bytes
  executedTxOrigin_lt: mainnet_Bytes
  executedTxOrigin_gte: mainnet_Bytes
  executedTxOrigin_lte: mainnet_Bytes
  executedTxOrigin_in: [mainnet_Bytes!]
  executedTxOrigin_not_in: [mainnet_Bytes!]
  executedTxOrigin_contains: mainnet_Bytes
  executedTxOrigin_not_contains: mainnet_Bytes
  executedTxNonce: BigInt
  executedTxNonce_not: BigInt
  executedTxNonce_gt: BigInt
  executedTxNonce_lt: BigInt
  executedTxNonce_gte: BigInt
  executedTxNonce_lte: BigInt
  executedTxNonce_in: [BigInt!]
  executedTxNonce_not_in: [BigInt!]
  reconciledCaller: mainnet_Bytes
  reconciledCaller_not: mainnet_Bytes
  reconciledCaller_gt: mainnet_Bytes
  reconciledCaller_lt: mainnet_Bytes
  reconciledCaller_gte: mainnet_Bytes
  reconciledCaller_lte: mainnet_Bytes
  reconciledCaller_in: [mainnet_Bytes!]
  reconciledCaller_not_in: [mainnet_Bytes!]
  reconciledCaller_contains: mainnet_Bytes
  reconciledCaller_not_contains: mainnet_Bytes
  reconciledTransactionHash: mainnet_Bytes
  reconciledTransactionHash_not: mainnet_Bytes
  reconciledTransactionHash_gt: mainnet_Bytes
  reconciledTransactionHash_lt: mainnet_Bytes
  reconciledTransactionHash_gte: mainnet_Bytes
  reconciledTransactionHash_lte: mainnet_Bytes
  reconciledTransactionHash_in: [mainnet_Bytes!]
  reconciledTransactionHash_not_in: [mainnet_Bytes!]
  reconciledTransactionHash_contains: mainnet_Bytes
  reconciledTransactionHash_not_contains: mainnet_Bytes
  reconciledTimestamp: BigInt
  reconciledTimestamp_not: BigInt
  reconciledTimestamp_gt: BigInt
  reconciledTimestamp_lt: BigInt
  reconciledTimestamp_gte: BigInt
  reconciledTimestamp_lte: BigInt
  reconciledTimestamp_in: [BigInt!]
  reconciledTimestamp_not_in: [BigInt!]
  reconciledGasPrice: BigInt
  reconciledGasPrice_not: BigInt
  reconciledGasPrice_gt: BigInt
  reconciledGasPrice_lt: BigInt
  reconciledGasPrice_gte: BigInt
  reconciledGasPrice_lte: BigInt
  reconciledGasPrice_in: [BigInt!]
  reconciledGasPrice_not_in: [BigInt!]
  reconciledGasLimit: BigInt
  reconciledGasLimit_not: BigInt
  reconciledGasLimit_gt: BigInt
  reconciledGasLimit_lt: BigInt
  reconciledGasLimit_gte: BigInt
  reconciledGasLimit_lte: BigInt
  reconciledGasLimit_in: [BigInt!]
  reconciledGasLimit_not_in: [BigInt!]
  reconciledBlockNumber: BigInt
  reconciledBlockNumber_not: BigInt
  reconciledBlockNumber_gt: BigInt
  reconciledBlockNumber_lt: BigInt
  reconciledBlockNumber_gte: BigInt
  reconciledBlockNumber_lte: BigInt
  reconciledBlockNumber_in: [BigInt!]
  reconciledBlockNumber_not_in: [BigInt!]
  reconciledTxOrigin: mainnet_Bytes
  reconciledTxOrigin_not: mainnet_Bytes
  reconciledTxOrigin_gt: mainnet_Bytes
  reconciledTxOrigin_lt: mainnet_Bytes
  reconciledTxOrigin_gte: mainnet_Bytes
  reconciledTxOrigin_lte: mainnet_Bytes
  reconciledTxOrigin_in: [mainnet_Bytes!]
  reconciledTxOrigin_not_in: [mainnet_Bytes!]
  reconciledTxOrigin_contains: mainnet_Bytes
  reconciledTxOrigin_not_contains: mainnet_Bytes
  reconciledTxNonce: BigInt
  reconciledTxNonce_not: BigInt
  reconciledTxNonce_gt: BigInt
  reconciledTxNonce_lt: BigInt
  reconciledTxNonce_gte: BigInt
  reconciledTxNonce_lte: BigInt
  reconciledTxNonce_in: [BigInt!]
  reconciledTxNonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: mainnet_BlockChangedFilter
  and: [mainnet_DestinationTransfer_filter]
  or: [mainnet_DestinationTransfer_filter]
}

enum mainnet_DestinationTransfer_orderBy {
  id
  chainId
  transferId
  nonce
  status
  routers
  originDomain
  destinationDomain
  canonicalDomain
  to
  delegate
  receiveLocal
  callData
  slippage
  bumpSlippageCount
  originSender
  bridgedAmt
  normalizedIn
  canonicalId
  asset
  asset__id
  asset__key
  asset__decimal
  asset__adoptedDecimal
  asset__canonicalId
  asset__canonicalDomain
  asset__adoptedAsset
  asset__localAsset
  asset__blockNumber
  amount
  routersFee
  executedCaller
  executedTransactionHash
  executedTimestamp
  executedGasPrice
  executedGasLimit
  executedBlockNumber
  executedTxOrigin
  executedTxNonce
  reconciledCaller
  reconciledTransactionHash
  reconciledTimestamp
  reconciledGasPrice
  reconciledGasLimit
  reconciledBlockNumber
  reconciledTxOrigin
  reconciledTxNonce
}

type mainnet_OptimisticRootFinalized {
  id: ID!
  aggregateRoot: mainnet_Bytes!
  timestamp: BigInt!
  blockNumber: BigInt
}

input mainnet_OptimisticRootFinalized_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  aggregateRoot: mainnet_Bytes
  aggregateRoot_not: mainnet_Bytes
  aggregateRoot_gt: mainnet_Bytes
  aggregateRoot_lt: mainnet_Bytes
  aggregateRoot_gte: mainnet_Bytes
  aggregateRoot_lte: mainnet_Bytes
  aggregateRoot_in: [mainnet_Bytes!]
  aggregateRoot_not_in: [mainnet_Bytes!]
  aggregateRoot_contains: mainnet_Bytes
  aggregateRoot_not_contains: mainnet_Bytes
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: mainnet_BlockChangedFilter
  and: [mainnet_OptimisticRootFinalized_filter]
  or: [mainnet_OptimisticRootFinalized_filter]
}

enum mainnet_OptimisticRootFinalized_orderBy {
  id
  aggregateRoot
  timestamp
  blockNumber
}

type mainnet_OriginMessage {
  id: ID!
  transferId: mainnet_Bytes
  destinationDomain: BigInt
  leaf: mainnet_Bytes
  index: BigInt
  message: mainnet_Bytes
  root: mainnet_Bytes
  transactionHash: mainnet_Bytes
  blockNumber: BigInt
  rootCount: mainnet_RootCount
}

input mainnet_OriginMessage_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transferId: mainnet_Bytes
  transferId_not: mainnet_Bytes
  transferId_gt: mainnet_Bytes
  transferId_lt: mainnet_Bytes
  transferId_gte: mainnet_Bytes
  transferId_lte: mainnet_Bytes
  transferId_in: [mainnet_Bytes!]
  transferId_not_in: [mainnet_Bytes!]
  transferId_contains: mainnet_Bytes
  transferId_not_contains: mainnet_Bytes
  destinationDomain: BigInt
  destinationDomain_not: BigInt
  destinationDomain_gt: BigInt
  destinationDomain_lt: BigInt
  destinationDomain_gte: BigInt
  destinationDomain_lte: BigInt
  destinationDomain_in: [BigInt!]
  destinationDomain_not_in: [BigInt!]
  leaf: mainnet_Bytes
  leaf_not: mainnet_Bytes
  leaf_gt: mainnet_Bytes
  leaf_lt: mainnet_Bytes
  leaf_gte: mainnet_Bytes
  leaf_lte: mainnet_Bytes
  leaf_in: [mainnet_Bytes!]
  leaf_not_in: [mainnet_Bytes!]
  leaf_contains: mainnet_Bytes
  leaf_not_contains: mainnet_Bytes
  index: BigInt
  index_not: BigInt
  index_gt: BigInt
  index_lt: BigInt
  index_gte: BigInt
  index_lte: BigInt
  index_in: [BigInt!]
  index_not_in: [BigInt!]
  message: mainnet_Bytes
  message_not: mainnet_Bytes
  message_gt: mainnet_Bytes
  message_lt: mainnet_Bytes
  message_gte: mainnet_Bytes
  message_lte: mainnet_Bytes
  message_in: [mainnet_Bytes!]
  message_not_in: [mainnet_Bytes!]
  message_contains: mainnet_Bytes
  message_not_contains: mainnet_Bytes
  root: mainnet_Bytes
  root_not: mainnet_Bytes
  root_gt: mainnet_Bytes
  root_lt: mainnet_Bytes
  root_gte: mainnet_Bytes
  root_lte: mainnet_Bytes
  root_in: [mainnet_Bytes!]
  root_not_in: [mainnet_Bytes!]
  root_contains: mainnet_Bytes
  root_not_contains: mainnet_Bytes
  transactionHash: mainnet_Bytes
  transactionHash_not: mainnet_Bytes
  transactionHash_gt: mainnet_Bytes
  transactionHash_lt: mainnet_Bytes
  transactionHash_gte: mainnet_Bytes
  transactionHash_lte: mainnet_Bytes
  transactionHash_in: [mainnet_Bytes!]
  transactionHash_not_in: [mainnet_Bytes!]
  transactionHash_contains: mainnet_Bytes
  transactionHash_not_contains: mainnet_Bytes
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  rootCount: String
  rootCount_not: String
  rootCount_gt: String
  rootCount_lt: String
  rootCount_gte: String
  rootCount_lte: String
  rootCount_in: [String!]
  rootCount_not_in: [String!]
  rootCount_contains: String
  rootCount_contains_nocase: String
  rootCount_not_contains: String
  rootCount_not_contains_nocase: String
  rootCount_starts_with: String
  rootCount_starts_with_nocase: String
  rootCount_not_starts_with: String
  rootCount_not_starts_with_nocase: String
  rootCount_ends_with: String
  rootCount_ends_with_nocase: String
  rootCount_not_ends_with: String
  rootCount_not_ends_with_nocase: String
  rootCount_: mainnet_RootCount_filter
  """Filter for the block changed event."""
  _change_block: mainnet_BlockChangedFilter
  and: [mainnet_OriginMessage_filter]
  or: [mainnet_OriginMessage_filter]
}

enum mainnet_OriginMessage_orderBy {
  id
  transferId
  destinationDomain
  leaf
  index
  message
  root
  transactionHash
  blockNumber
  rootCount
  rootCount__id
  rootCount__count
}

type mainnet_OriginTransfer {
  id: ID!
  chainId: BigInt
  transferId: mainnet_Bytes
  nonce: BigInt
  status: mainnet_TransferStatus
  messageHash: mainnet_Bytes
  originDomain: BigInt
  destinationDomain: BigInt
  canonicalDomain: BigInt
  to: mainnet_Bytes
  delegate: mainnet_Bytes
  receiveLocal: Boolean
  callData: mainnet_Bytes
  slippage: BigInt
  originSender: mainnet_Bytes
  bridgedAmt: BigInt
  normalizedIn: BigInt
  canonicalId: mainnet_Bytes
  asset: mainnet_Asset
  transactingAsset: mainnet_Bytes
  message: mainnet_OriginMessage
  bumpRelayerFeeCount: BigInt
  relayerFees(skip: Int = 0, first: Int = 100, orderBy: mainnet_RelayerFee_orderBy, orderDirection: mainnet_OrderDirection, where: mainnet_RelayerFee_filter): [mainnet_RelayerFee!]
  initialRelayerFeeAsset: mainnet_Bytes
  caller: mainnet_Bytes
  transactionHash: mainnet_Bytes
  timestamp: BigInt
  gasPrice: BigInt
  gasLimit: BigInt
  blockNumber: BigInt
  txOrigin: mainnet_Bytes
  txNonce: BigInt
}

input mainnet_OriginTransfer_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  chainId: BigInt
  chainId_not: BigInt
  chainId_gt: BigInt
  chainId_lt: BigInt
  chainId_gte: BigInt
  chainId_lte: BigInt
  chainId_in: [BigInt!]
  chainId_not_in: [BigInt!]
  transferId: mainnet_Bytes
  transferId_not: mainnet_Bytes
  transferId_gt: mainnet_Bytes
  transferId_lt: mainnet_Bytes
  transferId_gte: mainnet_Bytes
  transferId_lte: mainnet_Bytes
  transferId_in: [mainnet_Bytes!]
  transferId_not_in: [mainnet_Bytes!]
  transferId_contains: mainnet_Bytes
  transferId_not_contains: mainnet_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  status: mainnet_TransferStatus
  status_not: mainnet_TransferStatus
  status_in: [mainnet_TransferStatus!]
  status_not_in: [mainnet_TransferStatus!]
  messageHash: mainnet_Bytes
  messageHash_not: mainnet_Bytes
  messageHash_gt: mainnet_Bytes
  messageHash_lt: mainnet_Bytes
  messageHash_gte: mainnet_Bytes
  messageHash_lte: mainnet_Bytes
  messageHash_in: [mainnet_Bytes!]
  messageHash_not_in: [mainnet_Bytes!]
  messageHash_contains: mainnet_Bytes
  messageHash_not_contains: mainnet_Bytes
  originDomain: BigInt
  originDomain_not: BigInt
  originDomain_gt: BigInt
  originDomain_lt: BigInt
  originDomain_gte: BigInt
  originDomain_lte: BigInt
  originDomain_in: [BigInt!]
  originDomain_not_in: [BigInt!]
  destinationDomain: BigInt
  destinationDomain_not: BigInt
  destinationDomain_gt: BigInt
  destinationDomain_lt: BigInt
  destinationDomain_gte: BigInt
  destinationDomain_lte: BigInt
  destinationDomain_in: [BigInt!]
  destinationDomain_not_in: [BigInt!]
  canonicalDomain: BigInt
  canonicalDomain_not: BigInt
  canonicalDomain_gt: BigInt
  canonicalDomain_lt: BigInt
  canonicalDomain_gte: BigInt
  canonicalDomain_lte: BigInt
  canonicalDomain_in: [BigInt!]
  canonicalDomain_not_in: [BigInt!]
  to: mainnet_Bytes
  to_not: mainnet_Bytes
  to_gt: mainnet_Bytes
  to_lt: mainnet_Bytes
  to_gte: mainnet_Bytes
  to_lte: mainnet_Bytes
  to_in: [mainnet_Bytes!]
  to_not_in: [mainnet_Bytes!]
  to_contains: mainnet_Bytes
  to_not_contains: mainnet_Bytes
  delegate: mainnet_Bytes
  delegate_not: mainnet_Bytes
  delegate_gt: mainnet_Bytes
  delegate_lt: mainnet_Bytes
  delegate_gte: mainnet_Bytes
  delegate_lte: mainnet_Bytes
  delegate_in: [mainnet_Bytes!]
  delegate_not_in: [mainnet_Bytes!]
  delegate_contains: mainnet_Bytes
  delegate_not_contains: mainnet_Bytes
  receiveLocal: Boolean
  receiveLocal_not: Boolean
  receiveLocal_in: [Boolean!]
  receiveLocal_not_in: [Boolean!]
  callData: mainnet_Bytes
  callData_not: mainnet_Bytes
  callData_gt: mainnet_Bytes
  callData_lt: mainnet_Bytes
  callData_gte: mainnet_Bytes
  callData_lte: mainnet_Bytes
  callData_in: [mainnet_Bytes!]
  callData_not_in: [mainnet_Bytes!]
  callData_contains: mainnet_Bytes
  callData_not_contains: mainnet_Bytes
  slippage: BigInt
  slippage_not: BigInt
  slippage_gt: BigInt
  slippage_lt: BigInt
  slippage_gte: BigInt
  slippage_lte: BigInt
  slippage_in: [BigInt!]
  slippage_not_in: [BigInt!]
  originSender: mainnet_Bytes
  originSender_not: mainnet_Bytes
  originSender_gt: mainnet_Bytes
  originSender_lt: mainnet_Bytes
  originSender_gte: mainnet_Bytes
  originSender_lte: mainnet_Bytes
  originSender_in: [mainnet_Bytes!]
  originSender_not_in: [mainnet_Bytes!]
  originSender_contains: mainnet_Bytes
  originSender_not_contains: mainnet_Bytes
  bridgedAmt: BigInt
  bridgedAmt_not: BigInt
  bridgedAmt_gt: BigInt
  bridgedAmt_lt: BigInt
  bridgedAmt_gte: BigInt
  bridgedAmt_lte: BigInt
  bridgedAmt_in: [BigInt!]
  bridgedAmt_not_in: [BigInt!]
  normalizedIn: BigInt
  normalizedIn_not: BigInt
  normalizedIn_gt: BigInt
  normalizedIn_lt: BigInt
  normalizedIn_gte: BigInt
  normalizedIn_lte: BigInt
  normalizedIn_in: [BigInt!]
  normalizedIn_not_in: [BigInt!]
  canonicalId: mainnet_Bytes
  canonicalId_not: mainnet_Bytes
  canonicalId_gt: mainnet_Bytes
  canonicalId_lt: mainnet_Bytes
  canonicalId_gte: mainnet_Bytes
  canonicalId_lte: mainnet_Bytes
  canonicalId_in: [mainnet_Bytes!]
  canonicalId_not_in: [mainnet_Bytes!]
  canonicalId_contains: mainnet_Bytes
  canonicalId_not_contains: mainnet_Bytes
  asset: String
  asset_not: String
  asset_gt: String
  asset_lt: String
  asset_gte: String
  asset_lte: String
  asset_in: [String!]
  asset_not_in: [String!]
  asset_contains: String
  asset_contains_nocase: String
  asset_not_contains: String
  asset_not_contains_nocase: String
  asset_starts_with: String
  asset_starts_with_nocase: String
  asset_not_starts_with: String
  asset_not_starts_with_nocase: String
  asset_ends_with: String
  asset_ends_with_nocase: String
  asset_not_ends_with: String
  asset_not_ends_with_nocase: String
  asset_: mainnet_Asset_filter
  transactingAsset: mainnet_Bytes
  transactingAsset_not: mainnet_Bytes
  transactingAsset_gt: mainnet_Bytes
  transactingAsset_lt: mainnet_Bytes
  transactingAsset_gte: mainnet_Bytes
  transactingAsset_lte: mainnet_Bytes
  transactingAsset_in: [mainnet_Bytes!]
  transactingAsset_not_in: [mainnet_Bytes!]
  transactingAsset_contains: mainnet_Bytes
  transactingAsset_not_contains: mainnet_Bytes
  message: String
  message_not: String
  message_gt: String
  message_lt: String
  message_gte: String
  message_lte: String
  message_in: [String!]
  message_not_in: [String!]
  message_contains: String
  message_contains_nocase: String
  message_not_contains: String
  message_not_contains_nocase: String
  message_starts_with: String
  message_starts_with_nocase: String
  message_not_starts_with: String
  message_not_starts_with_nocase: String
  message_ends_with: String
  message_ends_with_nocase: String
  message_not_ends_with: String
  message_not_ends_with_nocase: String
  message_: mainnet_OriginMessage_filter
  bumpRelayerFeeCount: BigInt
  bumpRelayerFeeCount_not: BigInt
  bumpRelayerFeeCount_gt: BigInt
  bumpRelayerFeeCount_lt: BigInt
  bumpRelayerFeeCount_gte: BigInt
  bumpRelayerFeeCount_lte: BigInt
  bumpRelayerFeeCount_in: [BigInt!]
  bumpRelayerFeeCount_not_in: [BigInt!]
  relayerFees: [String!]
  relayerFees_not: [String!]
  relayerFees_contains: [String!]
  relayerFees_contains_nocase: [String!]
  relayerFees_not_contains: [String!]
  relayerFees_not_contains_nocase: [String!]
  relayerFees_: mainnet_RelayerFee_filter
  initialRelayerFeeAsset: mainnet_Bytes
  initialRelayerFeeAsset_not: mainnet_Bytes
  initialRelayerFeeAsset_gt: mainnet_Bytes
  initialRelayerFeeAsset_lt: mainnet_Bytes
  initialRelayerFeeAsset_gte: mainnet_Bytes
  initialRelayerFeeAsset_lte: mainnet_Bytes
  initialRelayerFeeAsset_in: [mainnet_Bytes!]
  initialRelayerFeeAsset_not_in: [mainnet_Bytes!]
  initialRelayerFeeAsset_contains: mainnet_Bytes
  initialRelayerFeeAsset_not_contains: mainnet_Bytes
  caller: mainnet_Bytes
  caller_not: mainnet_Bytes
  caller_gt: mainnet_Bytes
  caller_lt: mainnet_Bytes
  caller_gte: mainnet_Bytes
  caller_lte: mainnet_Bytes
  caller_in: [mainnet_Bytes!]
  caller_not_in: [mainnet_Bytes!]
  caller_contains: mainnet_Bytes
  caller_not_contains: mainnet_Bytes
  transactionHash: mainnet_Bytes
  transactionHash_not: mainnet_Bytes
  transactionHash_gt: mainnet_Bytes
  transactionHash_lt: mainnet_Bytes
  transactionHash_gte: mainnet_Bytes
  transactionHash_lte: mainnet_Bytes
  transactionHash_in: [mainnet_Bytes!]
  transactionHash_not_in: [mainnet_Bytes!]
  transactionHash_contains: mainnet_Bytes
  transactionHash_not_contains: mainnet_Bytes
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  gasLimit: BigInt
  gasLimit_not: BigInt
  gasLimit_gt: BigInt
  gasLimit_lt: BigInt
  gasLimit_gte: BigInt
  gasLimit_lte: BigInt
  gasLimit_in: [BigInt!]
  gasLimit_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  txOrigin: mainnet_Bytes
  txOrigin_not: mainnet_Bytes
  txOrigin_gt: mainnet_Bytes
  txOrigin_lt: mainnet_Bytes
  txOrigin_gte: mainnet_Bytes
  txOrigin_lte: mainnet_Bytes
  txOrigin_in: [mainnet_Bytes!]
  txOrigin_not_in: [mainnet_Bytes!]
  txOrigin_contains: mainnet_Bytes
  txOrigin_not_contains: mainnet_Bytes
  txNonce: BigInt
  txNonce_not: BigInt
  txNonce_gt: BigInt
  txNonce_lt: BigInt
  txNonce_gte: BigInt
  txNonce_lte: BigInt
  txNonce_in: [BigInt!]
  txNonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: mainnet_BlockChangedFilter
  and: [mainnet_OriginTransfer_filter]
  or: [mainnet_OriginTransfer_filter]
}

enum mainnet_OriginTransfer_orderBy {
  id
  chainId
  transferId
  nonce
  status
  messageHash
  originDomain
  destinationDomain
  canonicalDomain
  to
  delegate
  receiveLocal
  callData
  slippage
  originSender
  bridgedAmt
  normalizedIn
  canonicalId
  asset
  asset__id
  asset__key
  asset__decimal
  asset__adoptedDecimal
  asset__canonicalId
  asset__canonicalDomain
  asset__adoptedAsset
  asset__localAsset
  asset__blockNumber
  transactingAsset
  message
  message__id
  message__transferId
  message__destinationDomain
  message__leaf
  message__index
  message__message
  message__root
  message__transactionHash
  message__blockNumber
  bumpRelayerFeeCount
  relayerFees
  initialRelayerFeeAsset
  caller
  transactionHash
  timestamp
  gasPrice
  gasLimit
  blockNumber
  txOrigin
  txNonce
}

type mainnet_Relayer {
  id: ID!
  isActive: Boolean!
  relayer: mainnet_Bytes
}

type mainnet_RelayerFee {
  id: ID!
  transfer: mainnet_OriginTransfer!
  fee: BigInt!
  asset: mainnet_Bytes!
}

input mainnet_RelayerFee_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transfer: String
  transfer_not: String
  transfer_gt: String
  transfer_lt: String
  transfer_gte: String
  transfer_lte: String
  transfer_in: [String!]
  transfer_not_in: [String!]
  transfer_contains: String
  transfer_contains_nocase: String
  transfer_not_contains: String
  transfer_not_contains_nocase: String
  transfer_starts_with: String
  transfer_starts_with_nocase: String
  transfer_not_starts_with: String
  transfer_not_starts_with_nocase: String
  transfer_ends_with: String
  transfer_ends_with_nocase: String
  transfer_not_ends_with: String
  transfer_not_ends_with_nocase: String
  transfer_: mainnet_OriginTransfer_filter
  fee: BigInt
  fee_not: BigInt
  fee_gt: BigInt
  fee_lt: BigInt
  fee_gte: BigInt
  fee_lte: BigInt
  fee_in: [BigInt!]
  fee_not_in: [BigInt!]
  asset: mainnet_Bytes
  asset_not: mainnet_Bytes
  asset_gt: mainnet_Bytes
  asset_lt: mainnet_Bytes
  asset_gte: mainnet_Bytes
  asset_lte: mainnet_Bytes
  asset_in: [mainnet_Bytes!]
  asset_not_in: [mainnet_Bytes!]
  asset_contains: mainnet_Bytes
  asset_not_contains: mainnet_Bytes
  """Filter for the block changed event."""
  _change_block: mainnet_BlockChangedFilter
  and: [mainnet_RelayerFee_filter]
  or: [mainnet_RelayerFee_filter]
}

enum mainnet_RelayerFee_orderBy {
  id
  transfer
  transfer__id
  transfer__chainId
  transfer__transferId
  transfer__nonce
  transfer__status
  transfer__messageHash
  transfer__originDomain
  transfer__destinationDomain
  transfer__canonicalDomain
  transfer__to
  transfer__delegate
  transfer__receiveLocal
  transfer__callData
  transfer__slippage
  transfer__originSender
  transfer__bridgedAmt
  transfer__normalizedIn
  transfer__canonicalId
  transfer__transactingAsset
  transfer__bumpRelayerFeeCount
  transfer__initialRelayerFeeAsset
  transfer__caller
  transfer__transactionHash
  transfer__timestamp
  transfer__gasPrice
  transfer__gasLimit
  transfer__blockNumber
  transfer__txOrigin
  transfer__txNonce
  fee
  asset
}

type mainnet_RelayerFeesIncrease {
  id: ID!
  transfer: mainnet_OriginTransfer!
  increase: BigInt
  asset: mainnet_Bytes
  caller: mainnet_Bytes!
  transactionHash: mainnet_Bytes!
  timestamp: BigInt!
  gasPrice: BigInt!
  gasLimit: BigInt!
  blockNumber: BigInt!
}

input mainnet_RelayerFeesIncrease_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transfer: String
  transfer_not: String
  transfer_gt: String
  transfer_lt: String
  transfer_gte: String
  transfer_lte: String
  transfer_in: [String!]
  transfer_not_in: [String!]
  transfer_contains: String
  transfer_contains_nocase: String
  transfer_not_contains: String
  transfer_not_contains_nocase: String
  transfer_starts_with: String
  transfer_starts_with_nocase: String
  transfer_not_starts_with: String
  transfer_not_starts_with_nocase: String
  transfer_ends_with: String
  transfer_ends_with_nocase: String
  transfer_not_ends_with: String
  transfer_not_ends_with_nocase: String
  transfer_: mainnet_OriginTransfer_filter
  increase: BigInt
  increase_not: BigInt
  increase_gt: BigInt
  increase_lt: BigInt
  increase_gte: BigInt
  increase_lte: BigInt
  increase_in: [BigInt!]
  increase_not_in: [BigInt!]
  asset: mainnet_Bytes
  asset_not: mainnet_Bytes
  asset_gt: mainnet_Bytes
  asset_lt: mainnet_Bytes
  asset_gte: mainnet_Bytes
  asset_lte: mainnet_Bytes
  asset_in: [mainnet_Bytes!]
  asset_not_in: [mainnet_Bytes!]
  asset_contains: mainnet_Bytes
  asset_not_contains: mainnet_Bytes
  caller: mainnet_Bytes
  caller_not: mainnet_Bytes
  caller_gt: mainnet_Bytes
  caller_lt: mainnet_Bytes
  caller_gte: mainnet_Bytes
  caller_lte: mainnet_Bytes
  caller_in: [mainnet_Bytes!]
  caller_not_in: [mainnet_Bytes!]
  caller_contains: mainnet_Bytes
  caller_not_contains: mainnet_Bytes
  transactionHash: mainnet_Bytes
  transactionHash_not: mainnet_Bytes
  transactionHash_gt: mainnet_Bytes
  transactionHash_lt: mainnet_Bytes
  transactionHash_gte: mainnet_Bytes
  transactionHash_lte: mainnet_Bytes
  transactionHash_in: [mainnet_Bytes!]
  transactionHash_not_in: [mainnet_Bytes!]
  transactionHash_contains: mainnet_Bytes
  transactionHash_not_contains: mainnet_Bytes
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  gasLimit: BigInt
  gasLimit_not: BigInt
  gasLimit_gt: BigInt
  gasLimit_lt: BigInt
  gasLimit_gte: BigInt
  gasLimit_lte: BigInt
  gasLimit_in: [BigInt!]
  gasLimit_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: mainnet_BlockChangedFilter
  and: [mainnet_RelayerFeesIncrease_filter]
  or: [mainnet_RelayerFeesIncrease_filter]
}

enum mainnet_RelayerFeesIncrease_orderBy {
  id
  transfer
  transfer__id
  transfer__chainId
  transfer__transferId
  transfer__nonce
  transfer__status
  transfer__messageHash
  transfer__originDomain
  transfer__destinationDomain
  transfer__canonicalDomain
  transfer__to
  transfer__delegate
  transfer__receiveLocal
  transfer__callData
  transfer__slippage
  transfer__originSender
  transfer__bridgedAmt
  transfer__normalizedIn
  transfer__canonicalId
  transfer__transactingAsset
  transfer__bumpRelayerFeeCount
  transfer__initialRelayerFeeAsset
  transfer__caller
  transfer__transactionHash
  transfer__timestamp
  transfer__gasPrice
  transfer__gasLimit
  transfer__blockNumber
  transfer__txOrigin
  transfer__txNonce
  increase
  asset
  caller
  transactionHash
  timestamp
  gasPrice
  gasLimit
  blockNumber
}

input mainnet_Relayer_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  isActive: Boolean
  isActive_not: Boolean
  isActive_in: [Boolean!]
  isActive_not_in: [Boolean!]
  relayer: mainnet_Bytes
  relayer_not: mainnet_Bytes
  relayer_gt: mainnet_Bytes
  relayer_lt: mainnet_Bytes
  relayer_gte: mainnet_Bytes
  relayer_lte: mainnet_Bytes
  relayer_in: [mainnet_Bytes!]
  relayer_not_in: [mainnet_Bytes!]
  relayer_contains: mainnet_Bytes
  relayer_not_contains: mainnet_Bytes
  """Filter for the block changed event."""
  _change_block: mainnet_BlockChangedFilter
  and: [mainnet_Relayer_filter]
  or: [mainnet_Relayer_filter]
}

enum mainnet_Relayer_orderBy {
  id
  isActive
  relayer
}

type mainnet_RootCount {
  id: ID!
  count: BigInt
}

input mainnet_RootCount_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  count: BigInt
  count_not: BigInt
  count_gt: BigInt
  count_lt: BigInt
  count_gte: BigInt
  count_lte: BigInt
  count_in: [BigInt!]
  count_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: mainnet_BlockChangedFilter
  and: [mainnet_RootCount_filter]
  or: [mainnet_RootCount_filter]
}

enum mainnet_RootCount_orderBy {
  id
  count
}

type mainnet_RootMessageSent {
  id: ID!
  spokeDomain: BigInt
  hubDomain: BigInt
  root: mainnet_Bytes
  count: BigInt
  caller: mainnet_Bytes
  transactionHash: mainnet_Bytes
  timestamp: BigInt
  gasPrice: BigInt
  gasLimit: BigInt
  blockNumber: BigInt
}

input mainnet_RootMessageSent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  spokeDomain: BigInt
  spokeDomain_not: BigInt
  spokeDomain_gt: BigInt
  spokeDomain_lt: BigInt
  spokeDomain_gte: BigInt
  spokeDomain_lte: BigInt
  spokeDomain_in: [BigInt!]
  spokeDomain_not_in: [BigInt!]
  hubDomain: BigInt
  hubDomain_not: BigInt
  hubDomain_gt: BigInt
  hubDomain_lt: BigInt
  hubDomain_gte: BigInt
  hubDomain_lte: BigInt
  hubDomain_in: [BigInt!]
  hubDomain_not_in: [BigInt!]
  root: mainnet_Bytes
  root_not: mainnet_Bytes
  root_gt: mainnet_Bytes
  root_lt: mainnet_Bytes
  root_gte: mainnet_Bytes
  root_lte: mainnet_Bytes
  root_in: [mainnet_Bytes!]
  root_not_in: [mainnet_Bytes!]
  root_contains: mainnet_Bytes
  root_not_contains: mainnet_Bytes
  count: BigInt
  count_not: BigInt
  count_gt: BigInt
  count_lt: BigInt
  count_gte: BigInt
  count_lte: BigInt
  count_in: [BigInt!]
  count_not_in: [BigInt!]
  caller: mainnet_Bytes
  caller_not: mainnet_Bytes
  caller_gt: mainnet_Bytes
  caller_lt: mainnet_Bytes
  caller_gte: mainnet_Bytes
  caller_lte: mainnet_Bytes
  caller_in: [mainnet_Bytes!]
  caller_not_in: [mainnet_Bytes!]
  caller_contains: mainnet_Bytes
  caller_not_contains: mainnet_Bytes
  transactionHash: mainnet_Bytes
  transactionHash_not: mainnet_Bytes
  transactionHash_gt: mainnet_Bytes
  transactionHash_lt: mainnet_Bytes
  transactionHash_gte: mainnet_Bytes
  transactionHash_lte: mainnet_Bytes
  transactionHash_in: [mainnet_Bytes!]
  transactionHash_not_in: [mainnet_Bytes!]
  transactionHash_contains: mainnet_Bytes
  transactionHash_not_contains: mainnet_Bytes
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  gasLimit: BigInt
  gasLimit_not: BigInt
  gasLimit_gt: BigInt
  gasLimit_lt: BigInt
  gasLimit_gte: BigInt
  gasLimit_lte: BigInt
  gasLimit_in: [BigInt!]
  gasLimit_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: mainnet_BlockChangedFilter
  and: [mainnet_RootMessageSent_filter]
  or: [mainnet_RootMessageSent_filter]
}

enum mainnet_RootMessageSent_orderBy {
  id
  spokeDomain
  hubDomain
  root
  count
  caller
  transactionHash
  timestamp
  gasPrice
  gasLimit
  blockNumber
}

type mainnet_Router {
  id: ID!
  isActive: Boolean!
  owner: mainnet_Bytes
  recipient: mainnet_Bytes
  proposedOwner: mainnet_Bytes
  proposedTimestamp: BigInt
  assetBalances(skip: Int = 0, first: Int = 100, orderBy: mainnet_AssetBalance_orderBy, orderDirection: mainnet_OrderDirection, where: mainnet_AssetBalance_filter): [mainnet_AssetBalance!]!
}

type mainnet_RouterDailyTVL {
  id: ID!
  router: mainnet_Router!
  asset: mainnet_Asset!
  timestamp: BigInt!
  balance: BigInt!
}

input mainnet_RouterDailyTVL_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  router: String
  router_not: String
  router_gt: String
  router_lt: String
  router_gte: String
  router_lte: String
  router_in: [String!]
  router_not_in: [String!]
  router_contains: String
  router_contains_nocase: String
  router_not_contains: String
  router_not_contains_nocase: String
  router_starts_with: String
  router_starts_with_nocase: String
  router_not_starts_with: String
  router_not_starts_with_nocase: String
  router_ends_with: String
  router_ends_with_nocase: String
  router_not_ends_with: String
  router_not_ends_with_nocase: String
  router_: mainnet_Router_filter
  asset: String
  asset_not: String
  asset_gt: String
  asset_lt: String
  asset_gte: String
  asset_lte: String
  asset_in: [String!]
  asset_not_in: [String!]
  asset_contains: String
  asset_contains_nocase: String
  asset_not_contains: String
  asset_not_contains_nocase: String
  asset_starts_with: String
  asset_starts_with_nocase: String
  asset_not_starts_with: String
  asset_not_starts_with_nocase: String
  asset_ends_with: String
  asset_ends_with_nocase: String
  asset_not_ends_with: String
  asset_not_ends_with_nocase: String
  asset_: mainnet_Asset_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  balance: BigInt
  balance_not: BigInt
  balance_gt: BigInt
  balance_lt: BigInt
  balance_gte: BigInt
  balance_lte: BigInt
  balance_in: [BigInt!]
  balance_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: mainnet_BlockChangedFilter
  and: [mainnet_RouterDailyTVL_filter]
  or: [mainnet_RouterDailyTVL_filter]
}

enum mainnet_RouterDailyTVL_orderBy {
  id
  router
  router__id
  router__isActive
  router__owner
  router__recipient
  router__proposedOwner
  router__proposedTimestamp
  asset
  asset__id
  asset__key
  asset__decimal
  asset__adoptedDecimal
  asset__canonicalId
  asset__canonicalDomain
  asset__adoptedAsset
  asset__localAsset
  asset__blockNumber
  timestamp
  balance
}

type mainnet_RouterLiquidityEvent {
  id: ID!
  type: mainnet_RouterLiquidityEventType
  router: mainnet_Router!
  asset: mainnet_Asset!
  amount: BigInt!
  balance: BigInt!
  caller: mainnet_Bytes
  blockNumber: BigInt!
  timestamp: BigInt!
  transactionHash: mainnet_Bytes!
  nonce: BigInt!
}

enum mainnet_RouterLiquidityEventType {
  Add
  Remove
}

input mainnet_RouterLiquidityEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  type: mainnet_RouterLiquidityEventType
  type_not: mainnet_RouterLiquidityEventType
  type_in: [mainnet_RouterLiquidityEventType!]
  type_not_in: [mainnet_RouterLiquidityEventType!]
  router: String
  router_not: String
  router_gt: String
  router_lt: String
  router_gte: String
  router_lte: String
  router_in: [String!]
  router_not_in: [String!]
  router_contains: String
  router_contains_nocase: String
  router_not_contains: String
  router_not_contains_nocase: String
  router_starts_with: String
  router_starts_with_nocase: String
  router_not_starts_with: String
  router_not_starts_with_nocase: String
  router_ends_with: String
  router_ends_with_nocase: String
  router_not_ends_with: String
  router_not_ends_with_nocase: String
  router_: mainnet_Router_filter
  asset: String
  asset_not: String
  asset_gt: String
  asset_lt: String
  asset_gte: String
  asset_lte: String
  asset_in: [String!]
  asset_not_in: [String!]
  asset_contains: String
  asset_contains_nocase: String
  asset_not_contains: String
  asset_not_contains_nocase: String
  asset_starts_with: String
  asset_starts_with_nocase: String
  asset_not_starts_with: String
  asset_not_starts_with_nocase: String
  asset_ends_with: String
  asset_ends_with_nocase: String
  asset_not_ends_with: String
  asset_not_ends_with_nocase: String
  asset_: mainnet_Asset_filter
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  balance: BigInt
  balance_not: BigInt
  balance_gt: BigInt
  balance_lt: BigInt
  balance_gte: BigInt
  balance_lte: BigInt
  balance_in: [BigInt!]
  balance_not_in: [BigInt!]
  caller: mainnet_Bytes
  caller_not: mainnet_Bytes
  caller_gt: mainnet_Bytes
  caller_lt: mainnet_Bytes
  caller_gte: mainnet_Bytes
  caller_lte: mainnet_Bytes
  caller_in: [mainnet_Bytes!]
  caller_not_in: [mainnet_Bytes!]
  caller_contains: mainnet_Bytes
  caller_not_contains: mainnet_Bytes
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transactionHash: mainnet_Bytes
  transactionHash_not: mainnet_Bytes
  transactionHash_gt: mainnet_Bytes
  transactionHash_lt: mainnet_Bytes
  transactionHash_gte: mainnet_Bytes
  transactionHash_lte: mainnet_Bytes
  transactionHash_in: [mainnet_Bytes!]
  transactionHash_not_in: [mainnet_Bytes!]
  transactionHash_contains: mainnet_Bytes
  transactionHash_not_contains: mainnet_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: mainnet_BlockChangedFilter
  and: [mainnet_RouterLiquidityEvent_filter]
  or: [mainnet_RouterLiquidityEvent_filter]
}

enum mainnet_RouterLiquidityEvent_orderBy {
  id
  type
  router
  router__id
  router__isActive
  router__owner
  router__recipient
  router__proposedOwner
  router__proposedTimestamp
  asset
  asset__id
  asset__key
  asset__decimal
  asset__adoptedDecimal
  asset__canonicalId
  asset__canonicalDomain
  asset__adoptedAsset
  asset__localAsset
  asset__blockNumber
  amount
  balance
  caller
  blockNumber
  timestamp
  transactionHash
  nonce
}

input mainnet_Router_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  isActive: Boolean
  isActive_not: Boolean
  isActive_in: [Boolean!]
  isActive_not_in: [Boolean!]
  owner: mainnet_Bytes
  owner_not: mainnet_Bytes
  owner_gt: mainnet_Bytes
  owner_lt: mainnet_Bytes
  owner_gte: mainnet_Bytes
  owner_lte: mainnet_Bytes
  owner_in: [mainnet_Bytes!]
  owner_not_in: [mainnet_Bytes!]
  owner_contains: mainnet_Bytes
  owner_not_contains: mainnet_Bytes
  recipient: mainnet_Bytes
  recipient_not: mainnet_Bytes
  recipient_gt: mainnet_Bytes
  recipient_lt: mainnet_Bytes
  recipient_gte: mainnet_Bytes
  recipient_lte: mainnet_Bytes
  recipient_in: [mainnet_Bytes!]
  recipient_not_in: [mainnet_Bytes!]
  recipient_contains: mainnet_Bytes
  recipient_not_contains: mainnet_Bytes
  proposedOwner: mainnet_Bytes
  proposedOwner_not: mainnet_Bytes
  proposedOwner_gt: mainnet_Bytes
  proposedOwner_lt: mainnet_Bytes
  proposedOwner_gte: mainnet_Bytes
  proposedOwner_lte: mainnet_Bytes
  proposedOwner_in: [mainnet_Bytes!]
  proposedOwner_not_in: [mainnet_Bytes!]
  proposedOwner_contains: mainnet_Bytes
  proposedOwner_not_contains: mainnet_Bytes
  proposedTimestamp: BigInt
  proposedTimestamp_not: BigInt
  proposedTimestamp_gt: BigInt
  proposedTimestamp_lt: BigInt
  proposedTimestamp_gte: BigInt
  proposedTimestamp_lte: BigInt
  proposedTimestamp_in: [BigInt!]
  proposedTimestamp_not_in: [BigInt!]
  assetBalances_: mainnet_AssetBalance_filter
  """Filter for the block changed event."""
  _change_block: mainnet_BlockChangedFilter
  and: [mainnet_Router_filter]
  or: [mainnet_Router_filter]
}

enum mainnet_Router_orderBy {
  id
  isActive
  owner
  recipient
  proposedOwner
  proposedTimestamp
  assetBalances
}

type mainnet_Sequencer {
  id: ID!
  isActive: Boolean!
  sequencer: mainnet_Bytes
}

input mainnet_Sequencer_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  isActive: Boolean
  isActive_not: Boolean
  isActive_in: [Boolean!]
  isActive_not_in: [Boolean!]
  sequencer: mainnet_Bytes
  sequencer_not: mainnet_Bytes
  sequencer_gt: mainnet_Bytes
  sequencer_lt: mainnet_Bytes
  sequencer_gte: mainnet_Bytes
  sequencer_lte: mainnet_Bytes
  sequencer_in: [mainnet_Bytes!]
  sequencer_not_in: [mainnet_Bytes!]
  sequencer_contains: mainnet_Bytes
  sequencer_not_contains: mainnet_Bytes
  """Filter for the block changed event."""
  _change_block: mainnet_BlockChangedFilter
  and: [mainnet_Sequencer_filter]
  or: [mainnet_Sequencer_filter]
}

enum mainnet_Sequencer_orderBy {
  id
  isActive
  sequencer
}

type mainnet_Setting {
  id: ID!
  maxRoutersPerTransfer: BigInt!
  caller: mainnet_Bytes!
}

input mainnet_Setting_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  maxRoutersPerTransfer: BigInt
  maxRoutersPerTransfer_not: BigInt
  maxRoutersPerTransfer_gt: BigInt
  maxRoutersPerTransfer_lt: BigInt
  maxRoutersPerTransfer_gte: BigInt
  maxRoutersPerTransfer_lte: BigInt
  maxRoutersPerTransfer_in: [BigInt!]
  maxRoutersPerTransfer_not_in: [BigInt!]
  caller: mainnet_Bytes
  caller_not: mainnet_Bytes
  caller_gt: mainnet_Bytes
  caller_lt: mainnet_Bytes
  caller_gte: mainnet_Bytes
  caller_lte: mainnet_Bytes
  caller_in: [mainnet_Bytes!]
  caller_not_in: [mainnet_Bytes!]
  caller_contains: mainnet_Bytes
  caller_not_contains: mainnet_Bytes
  """Filter for the block changed event."""
  _change_block: mainnet_BlockChangedFilter
  and: [mainnet_Setting_filter]
  or: [mainnet_Setting_filter]
}

enum mainnet_Setting_orderBy {
  id
  maxRoutersPerTransfer
  caller
}

type mainnet_SlippageUpdate {
  id: ID!
  transfer: mainnet_DestinationTransfer!
  slippage: BigInt!
  caller: mainnet_Bytes!
  transactionHash: mainnet_Bytes!
  timestamp: BigInt!
  gasPrice: BigInt!
  gasLimit: BigInt!
  blockNumber: BigInt!
}

input mainnet_SlippageUpdate_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transfer: String
  transfer_not: String
  transfer_gt: String
  transfer_lt: String
  transfer_gte: String
  transfer_lte: String
  transfer_in: [String!]
  transfer_not_in: [String!]
  transfer_contains: String
  transfer_contains_nocase: String
  transfer_not_contains: String
  transfer_not_contains_nocase: String
  transfer_starts_with: String
  transfer_starts_with_nocase: String
  transfer_not_starts_with: String
  transfer_not_starts_with_nocase: String
  transfer_ends_with: String
  transfer_ends_with_nocase: String
  transfer_not_ends_with: String
  transfer_not_ends_with_nocase: String
  transfer_: mainnet_DestinationTransfer_filter
  slippage: BigInt
  slippage_not: BigInt
  slippage_gt: BigInt
  slippage_lt: BigInt
  slippage_gte: BigInt
  slippage_lte: BigInt
  slippage_in: [BigInt!]
  slippage_not_in: [BigInt!]
  caller: mainnet_Bytes
  caller_not: mainnet_Bytes
  caller_gt: mainnet_Bytes
  caller_lt: mainnet_Bytes
  caller_gte: mainnet_Bytes
  caller_lte: mainnet_Bytes
  caller_in: [mainnet_Bytes!]
  caller_not_in: [mainnet_Bytes!]
  caller_contains: mainnet_Bytes
  caller_not_contains: mainnet_Bytes
  transactionHash: mainnet_Bytes
  transactionHash_not: mainnet_Bytes
  transactionHash_gt: mainnet_Bytes
  transactionHash_lt: mainnet_Bytes
  transactionHash_gte: mainnet_Bytes
  transactionHash_lte: mainnet_Bytes
  transactionHash_in: [mainnet_Bytes!]
  transactionHash_not_in: [mainnet_Bytes!]
  transactionHash_contains: mainnet_Bytes
  transactionHash_not_contains: mainnet_Bytes
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  gasLimit: BigInt
  gasLimit_not: BigInt
  gasLimit_gt: BigInt
  gasLimit_lt: BigInt
  gasLimit_gte: BigInt
  gasLimit_lte: BigInt
  gasLimit_in: [BigInt!]
  gasLimit_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: mainnet_BlockChangedFilter
  and: [mainnet_SlippageUpdate_filter]
  or: [mainnet_SlippageUpdate_filter]
}

enum mainnet_SlippageUpdate_orderBy {
  id
  transfer
  transfer__id
  transfer__chainId
  transfer__transferId
  transfer__nonce
  transfer__status
  transfer__originDomain
  transfer__destinationDomain
  transfer__canonicalDomain
  transfer__to
  transfer__delegate
  transfer__receiveLocal
  transfer__callData
  transfer__slippage
  transfer__bumpSlippageCount
  transfer__originSender
  transfer__bridgedAmt
  transfer__normalizedIn
  transfer__canonicalId
  transfer__amount
  transfer__routersFee
  transfer__executedCaller
  transfer__executedTransactionHash
  transfer__executedTimestamp
  transfer__executedGasPrice
  transfer__executedGasLimit
  transfer__executedBlockNumber
  transfer__executedTxOrigin
  transfer__executedTxNonce
  transfer__reconciledCaller
  transfer__reconciledTransactionHash
  transfer__reconciledTimestamp
  transfer__reconciledGasPrice
  transfer__reconciledGasLimit
  transfer__reconciledBlockNumber
  transfer__reconciledTxOrigin
  transfer__reconciledTxNonce
  slippage
  caller
  transactionHash
  timestamp
  gasPrice
  gasLimit
  blockNumber
}

type mainnet_SnapshotRoot {
  id: ID!
  spokeDomain: BigInt
  root: mainnet_Bytes!
  count: BigInt!
  timestamp: BigInt!
  blockNumber: BigInt!
}

input mainnet_SnapshotRoot_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  spokeDomain: BigInt
  spokeDomain_not: BigInt
  spokeDomain_gt: BigInt
  spokeDomain_lt: BigInt
  spokeDomain_gte: BigInt
  spokeDomain_lte: BigInt
  spokeDomain_in: [BigInt!]
  spokeDomain_not_in: [BigInt!]
  root: mainnet_Bytes
  root_not: mainnet_Bytes
  root_gt: mainnet_Bytes
  root_lt: mainnet_Bytes
  root_gte: mainnet_Bytes
  root_lte: mainnet_Bytes
  root_in: [mainnet_Bytes!]
  root_not_in: [mainnet_Bytes!]
  root_contains: mainnet_Bytes
  root_not_contains: mainnet_Bytes
  count: BigInt
  count_not: BigInt
  count_gt: BigInt
  count_lt: BigInt
  count_gte: BigInt
  count_lte: BigInt
  count_in: [BigInt!]
  count_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: mainnet_BlockChangedFilter
  and: [mainnet_SnapshotRoot_filter]
  or: [mainnet_SnapshotRoot_filter]
}

enum mainnet_SnapshotRoot_orderBy {
  id
  spokeDomain
  root
  count
  timestamp
  blockNumber
}

type mainnet_SpokeConnectorMode {
  id: ID!
  mode: String!
}

input mainnet_SpokeConnectorMode_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  mode: String
  mode_not: String
  mode_gt: String
  mode_lt: String
  mode_gte: String
  mode_lte: String
  mode_in: [String!]
  mode_not_in: [String!]
  mode_contains: String
  mode_contains_nocase: String
  mode_not_contains: String
  mode_not_contains_nocase: String
  mode_starts_with: String
  mode_starts_with_nocase: String
  mode_not_starts_with: String
  mode_not_starts_with_nocase: String
  mode_ends_with: String
  mode_ends_with_nocase: String
  mode_not_ends_with: String
  mode_not_ends_with_nocase: String
  """Filter for the block changed event."""
  _change_block: mainnet_BlockChangedFilter
  and: [mainnet_SpokeConnectorMode_filter]
  or: [mainnet_SpokeConnectorMode_filter]
}

enum mainnet_SpokeConnectorMode_orderBy {
  id
  mode
}

enum mainnet_TransferStatus {
  XCalled
  Executed
  Reconciled
  CompletedSlow
  CompletedFast
}

type base_AggregateRoot {
  id: ID!
  root: base_Bytes!
  blockNumber: BigInt!
}

type base_AggregateRootProposed {
  id: ID!
  aggregateRoot: base_Bytes!
  rootTimestamp: BigInt!
  endOfDispute: BigInt!
  domain: BigInt!
  timestamp: BigInt!
  blockNumber: BigInt
}

input base_AggregateRootProposed_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  aggregateRoot: base_Bytes
  aggregateRoot_not: base_Bytes
  aggregateRoot_gt: base_Bytes
  aggregateRoot_lt: base_Bytes
  aggregateRoot_gte: base_Bytes
  aggregateRoot_lte: base_Bytes
  aggregateRoot_in: [base_Bytes!]
  aggregateRoot_not_in: [base_Bytes!]
  aggregateRoot_contains: base_Bytes
  aggregateRoot_not_contains: base_Bytes
  rootTimestamp: BigInt
  rootTimestamp_not: BigInt
  rootTimestamp_gt: BigInt
  rootTimestamp_lt: BigInt
  rootTimestamp_gte: BigInt
  rootTimestamp_lte: BigInt
  rootTimestamp_in: [BigInt!]
  rootTimestamp_not_in: [BigInt!]
  endOfDispute: BigInt
  endOfDispute_not: BigInt
  endOfDispute_gt: BigInt
  endOfDispute_lt: BigInt
  endOfDispute_gte: BigInt
  endOfDispute_lte: BigInt
  endOfDispute_in: [BigInt!]
  endOfDispute_not_in: [BigInt!]
  domain: BigInt
  domain_not: BigInt
  domain_gt: BigInt
  domain_lt: BigInt
  domain_gte: BigInt
  domain_lte: BigInt
  domain_in: [BigInt!]
  domain_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: base_BlockChangedFilter
  and: [base_AggregateRootProposed_filter]
  or: [base_AggregateRootProposed_filter]
}

enum base_AggregateRootProposed_orderBy {
  id
  aggregateRoot
  rootTimestamp
  endOfDispute
  domain
  timestamp
  blockNumber
}

input base_AggregateRoot_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  root: base_Bytes
  root_not: base_Bytes
  root_gt: base_Bytes
  root_lt: base_Bytes
  root_gte: base_Bytes
  root_lte: base_Bytes
  root_in: [base_Bytes!]
  root_not_in: [base_Bytes!]
  root_contains: base_Bytes
  root_not_contains: base_Bytes
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: base_BlockChangedFilter
  and: [base_AggregateRoot_filter]
  or: [base_AggregateRoot_filter]
}

enum base_AggregateRoot_orderBy {
  id
  root
  blockNumber
}

enum base_Aggregation_interval {
  hour
  day
}

type base_Asset {
  id: ID!
  key: base_Bytes
  decimal: BigInt
  adoptedDecimal: BigInt
  canonicalId: base_Bytes
  canonicalDomain: BigInt
  adoptedAsset: base_Bytes
  localAsset: base_Bytes
  blockNumber: BigInt
  status: base_AssetStatus
}

type base_AssetBalance {
  id: ID!
  amount: BigInt!
  locked: BigInt!
  supplied: BigInt!
  removed: BigInt!
  router: base_Router!
  asset: base_Asset!
  feesEarned: BigInt!
}

input base_AssetBalance_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  locked: BigInt
  locked_not: BigInt
  locked_gt: BigInt
  locked_lt: BigInt
  locked_gte: BigInt
  locked_lte: BigInt
  locked_in: [BigInt!]
  locked_not_in: [BigInt!]
  supplied: BigInt
  supplied_not: BigInt
  supplied_gt: BigInt
  supplied_lt: BigInt
  supplied_gte: BigInt
  supplied_lte: BigInt
  supplied_in: [BigInt!]
  supplied_not_in: [BigInt!]
  removed: BigInt
  removed_not: BigInt
  removed_gt: BigInt
  removed_lt: BigInt
  removed_gte: BigInt
  removed_lte: BigInt
  removed_in: [BigInt!]
  removed_not_in: [BigInt!]
  router: String
  router_not: String
  router_gt: String
  router_lt: String
  router_gte: String
  router_lte: String
  router_in: [String!]
  router_not_in: [String!]
  router_contains: String
  router_contains_nocase: String
  router_not_contains: String
  router_not_contains_nocase: String
  router_starts_with: String
  router_starts_with_nocase: String
  router_not_starts_with: String
  router_not_starts_with_nocase: String
  router_ends_with: String
  router_ends_with_nocase: String
  router_not_ends_with: String
  router_not_ends_with_nocase: String
  router_: base_Router_filter
  asset: String
  asset_not: String
  asset_gt: String
  asset_lt: String
  asset_gte: String
  asset_lte: String
  asset_in: [String!]
  asset_not_in: [String!]
  asset_contains: String
  asset_contains_nocase: String
  asset_not_contains: String
  asset_not_contains_nocase: String
  asset_starts_with: String
  asset_starts_with_nocase: String
  asset_not_starts_with: String
  asset_not_starts_with_nocase: String
  asset_ends_with: String
  asset_ends_with_nocase: String
  asset_not_ends_with: String
  asset_not_ends_with_nocase: String
  asset_: base_Asset_filter
  feesEarned: BigInt
  feesEarned_not: BigInt
  feesEarned_gt: BigInt
  feesEarned_lt: BigInt
  feesEarned_gte: BigInt
  feesEarned_lte: BigInt
  feesEarned_in: [BigInt!]
  feesEarned_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: base_BlockChangedFilter
  and: [base_AssetBalance_filter]
  or: [base_AssetBalance_filter]
}

enum base_AssetBalance_orderBy {
  id
  amount
  locked
  supplied
  removed
  router
  router__id
  router__isActive
  router__owner
  router__recipient
  router__proposedOwner
  router__proposedTimestamp
  asset
  asset__id
  asset__key
  asset__decimal
  asset__adoptedDecimal
  asset__canonicalId
  asset__canonicalDomain
  asset__adoptedAsset
  asset__localAsset
  asset__blockNumber
  feesEarned
}

type base_AssetStatus {
  id: ID!
  status: Boolean
}

input base_AssetStatus_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  status: Boolean
  status_not: Boolean
  status_in: [Boolean!]
  status_not_in: [Boolean!]
  """Filter for the block changed event."""
  _change_block: base_BlockChangedFilter
  and: [base_AssetStatus_filter]
  or: [base_AssetStatus_filter]
}

enum base_AssetStatus_orderBy {
  id
  status
}

input base_Asset_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  key: base_Bytes
  key_not: base_Bytes
  key_gt: base_Bytes
  key_lt: base_Bytes
  key_gte: base_Bytes
  key_lte: base_Bytes
  key_in: [base_Bytes!]
  key_not_in: [base_Bytes!]
  key_contains: base_Bytes
  key_not_contains: base_Bytes
  decimal: BigInt
  decimal_not: BigInt
  decimal_gt: BigInt
  decimal_lt: BigInt
  decimal_gte: BigInt
  decimal_lte: BigInt
  decimal_in: [BigInt!]
  decimal_not_in: [BigInt!]
  adoptedDecimal: BigInt
  adoptedDecimal_not: BigInt
  adoptedDecimal_gt: BigInt
  adoptedDecimal_lt: BigInt
  adoptedDecimal_gte: BigInt
  adoptedDecimal_lte: BigInt
  adoptedDecimal_in: [BigInt!]
  adoptedDecimal_not_in: [BigInt!]
  canonicalId: base_Bytes
  canonicalId_not: base_Bytes
  canonicalId_gt: base_Bytes
  canonicalId_lt: base_Bytes
  canonicalId_gte: base_Bytes
  canonicalId_lte: base_Bytes
  canonicalId_in: [base_Bytes!]
  canonicalId_not_in: [base_Bytes!]
  canonicalId_contains: base_Bytes
  canonicalId_not_contains: base_Bytes
  canonicalDomain: BigInt
  canonicalDomain_not: BigInt
  canonicalDomain_gt: BigInt
  canonicalDomain_lt: BigInt
  canonicalDomain_gte: BigInt
  canonicalDomain_lte: BigInt
  canonicalDomain_in: [BigInt!]
  canonicalDomain_not_in: [BigInt!]
  adoptedAsset: base_Bytes
  adoptedAsset_not: base_Bytes
  adoptedAsset_gt: base_Bytes
  adoptedAsset_lt: base_Bytes
  adoptedAsset_gte: base_Bytes
  adoptedAsset_lte: base_Bytes
  adoptedAsset_in: [base_Bytes!]
  adoptedAsset_not_in: [base_Bytes!]
  adoptedAsset_contains: base_Bytes
  adoptedAsset_not_contains: base_Bytes
  localAsset: base_Bytes
  localAsset_not: base_Bytes
  localAsset_gt: base_Bytes
  localAsset_lt: base_Bytes
  localAsset_gte: base_Bytes
  localAsset_lte: base_Bytes
  localAsset_in: [base_Bytes!]
  localAsset_not_in: [base_Bytes!]
  localAsset_contains: base_Bytes
  localAsset_not_contains: base_Bytes
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  status: String
  status_not: String
  status_gt: String
  status_lt: String
  status_gte: String
  status_lte: String
  status_in: [String!]
  status_not_in: [String!]
  status_contains: String
  status_contains_nocase: String
  status_not_contains: String
  status_not_contains_nocase: String
  status_starts_with: String
  status_starts_with_nocase: String
  status_not_starts_with: String
  status_not_starts_with_nocase: String
  status_ends_with: String
  status_ends_with_nocase: String
  status_not_ends_with: String
  status_not_ends_with_nocase: String
  status_: base_AssetStatus_filter
  """Filter for the block changed event."""
  _change_block: base_BlockChangedFilter
  and: [base_Asset_filter]
  or: [base_Asset_filter]
}

enum base_Asset_orderBy {
  id
  key
  decimal
  adoptedDecimal
  canonicalId
  canonicalDomain
  adoptedAsset
  localAsset
  blockNumber
  status
  status__id
  status__status
}

scalar base_BigDecimal

input base_BlockChangedFilter {
  number_gte: Int!
}

input base_Block_height {
  hash: base_Bytes
  number: Int
  number_gte: Int
}

scalar base_Bytes

type base_ConnectorMeta {
  id: ID!
  spokeDomain: BigInt
  hubDomain: BigInt
  amb: base_Bytes
  rootManager: base_Bytes
  mirrorConnector: base_Bytes
}

input base_ConnectorMeta_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  spokeDomain: BigInt
  spokeDomain_not: BigInt
  spokeDomain_gt: BigInt
  spokeDomain_lt: BigInt
  spokeDomain_gte: BigInt
  spokeDomain_lte: BigInt
  spokeDomain_in: [BigInt!]
  spokeDomain_not_in: [BigInt!]
  hubDomain: BigInt
  hubDomain_not: BigInt
  hubDomain_gt: BigInt
  hubDomain_lt: BigInt
  hubDomain_gte: BigInt
  hubDomain_lte: BigInt
  hubDomain_in: [BigInt!]
  hubDomain_not_in: [BigInt!]
  amb: base_Bytes
  amb_not: base_Bytes
  amb_gt: base_Bytes
  amb_lt: base_Bytes
  amb_gte: base_Bytes
  amb_lte: base_Bytes
  amb_in: [base_Bytes!]
  amb_not_in: [base_Bytes!]
  amb_contains: base_Bytes
  amb_not_contains: base_Bytes
  rootManager: base_Bytes
  rootManager_not: base_Bytes
  rootManager_gt: base_Bytes
  rootManager_lt: base_Bytes
  rootManager_gte: base_Bytes
  rootManager_lte: base_Bytes
  rootManager_in: [base_Bytes!]
  rootManager_not_in: [base_Bytes!]
  rootManager_contains: base_Bytes
  rootManager_not_contains: base_Bytes
  mirrorConnector: base_Bytes
  mirrorConnector_not: base_Bytes
  mirrorConnector_gt: base_Bytes
  mirrorConnector_lt: base_Bytes
  mirrorConnector_gte: base_Bytes
  mirrorConnector_lte: base_Bytes
  mirrorConnector_in: [base_Bytes!]
  mirrorConnector_not_in: [base_Bytes!]
  mirrorConnector_contains: base_Bytes
  mirrorConnector_not_contains: base_Bytes
  """Filter for the block changed event."""
  _change_block: base_BlockChangedFilter
  and: [base_ConnectorMeta_filter]
  or: [base_ConnectorMeta_filter]
}

enum base_ConnectorMeta_orderBy {
  id
  spokeDomain
  hubDomain
  amb
  rootManager
  mirrorConnector
}

type base_DestinationTransfer {
  id: ID!
  chainId: BigInt
  transferId: base_Bytes
  nonce: BigInt
  status: base_TransferStatus
  routers(skip: Int = 0, first: Int = 100, orderBy: base_Router_orderBy, orderDirection: base_OrderDirection, where: base_Router_filter): [base_Router!]
  originDomain: BigInt
  destinationDomain: BigInt
  canonicalDomain: BigInt
  to: base_Bytes
  delegate: base_Bytes
  receiveLocal: Boolean
  callData: base_Bytes
  slippage: BigInt
  bumpSlippageCount: BigInt
  originSender: base_Bytes
  bridgedAmt: BigInt
  normalizedIn: BigInt
  canonicalId: base_Bytes
  asset: base_Asset
  amount: BigInt
  routersFee: BigInt
  executedCaller: base_Bytes
  executedTransactionHash: base_Bytes
  executedTimestamp: BigInt
  executedGasPrice: BigInt
  executedGasLimit: BigInt
  executedBlockNumber: BigInt
  executedTxOrigin: base_Bytes
  executedTxNonce: BigInt
  reconciledCaller: base_Bytes
  reconciledTransactionHash: base_Bytes
  reconciledTimestamp: BigInt
  reconciledGasPrice: BigInt
  reconciledGasLimit: BigInt
  reconciledBlockNumber: BigInt
  reconciledTxOrigin: base_Bytes
  reconciledTxNonce: BigInt
}

input base_DestinationTransfer_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  chainId: BigInt
  chainId_not: BigInt
  chainId_gt: BigInt
  chainId_lt: BigInt
  chainId_gte: BigInt
  chainId_lte: BigInt
  chainId_in: [BigInt!]
  chainId_not_in: [BigInt!]
  transferId: base_Bytes
  transferId_not: base_Bytes
  transferId_gt: base_Bytes
  transferId_lt: base_Bytes
  transferId_gte: base_Bytes
  transferId_lte: base_Bytes
  transferId_in: [base_Bytes!]
  transferId_not_in: [base_Bytes!]
  transferId_contains: base_Bytes
  transferId_not_contains: base_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  status: base_TransferStatus
  status_not: base_TransferStatus
  status_in: [base_TransferStatus!]
  status_not_in: [base_TransferStatus!]
  routers: [String!]
  routers_not: [String!]
  routers_contains: [String!]
  routers_contains_nocase: [String!]
  routers_not_contains: [String!]
  routers_not_contains_nocase: [String!]
  routers_: base_Router_filter
  originDomain: BigInt
  originDomain_not: BigInt
  originDomain_gt: BigInt
  originDomain_lt: BigInt
  originDomain_gte: BigInt
  originDomain_lte: BigInt
  originDomain_in: [BigInt!]
  originDomain_not_in: [BigInt!]
  destinationDomain: BigInt
  destinationDomain_not: BigInt
  destinationDomain_gt: BigInt
  destinationDomain_lt: BigInt
  destinationDomain_gte: BigInt
  destinationDomain_lte: BigInt
  destinationDomain_in: [BigInt!]
  destinationDomain_not_in: [BigInt!]
  canonicalDomain: BigInt
  canonicalDomain_not: BigInt
  canonicalDomain_gt: BigInt
  canonicalDomain_lt: BigInt
  canonicalDomain_gte: BigInt
  canonicalDomain_lte: BigInt
  canonicalDomain_in: [BigInt!]
  canonicalDomain_not_in: [BigInt!]
  to: base_Bytes
  to_not: base_Bytes
  to_gt: base_Bytes
  to_lt: base_Bytes
  to_gte: base_Bytes
  to_lte: base_Bytes
  to_in: [base_Bytes!]
  to_not_in: [base_Bytes!]
  to_contains: base_Bytes
  to_not_contains: base_Bytes
  delegate: base_Bytes
  delegate_not: base_Bytes
  delegate_gt: base_Bytes
  delegate_lt: base_Bytes
  delegate_gte: base_Bytes
  delegate_lte: base_Bytes
  delegate_in: [base_Bytes!]
  delegate_not_in: [base_Bytes!]
  delegate_contains: base_Bytes
  delegate_not_contains: base_Bytes
  receiveLocal: Boolean
  receiveLocal_not: Boolean
  receiveLocal_in: [Boolean!]
  receiveLocal_not_in: [Boolean!]
  callData: base_Bytes
  callData_not: base_Bytes
  callData_gt: base_Bytes
  callData_lt: base_Bytes
  callData_gte: base_Bytes
  callData_lte: base_Bytes
  callData_in: [base_Bytes!]
  callData_not_in: [base_Bytes!]
  callData_contains: base_Bytes
  callData_not_contains: base_Bytes
  slippage: BigInt
  slippage_not: BigInt
  slippage_gt: BigInt
  slippage_lt: BigInt
  slippage_gte: BigInt
  slippage_lte: BigInt
  slippage_in: [BigInt!]
  slippage_not_in: [BigInt!]
  bumpSlippageCount: BigInt
  bumpSlippageCount_not: BigInt
  bumpSlippageCount_gt: BigInt
  bumpSlippageCount_lt: BigInt
  bumpSlippageCount_gte: BigInt
  bumpSlippageCount_lte: BigInt
  bumpSlippageCount_in: [BigInt!]
  bumpSlippageCount_not_in: [BigInt!]
  originSender: base_Bytes
  originSender_not: base_Bytes
  originSender_gt: base_Bytes
  originSender_lt: base_Bytes
  originSender_gte: base_Bytes
  originSender_lte: base_Bytes
  originSender_in: [base_Bytes!]
  originSender_not_in: [base_Bytes!]
  originSender_contains: base_Bytes
  originSender_not_contains: base_Bytes
  bridgedAmt: BigInt
  bridgedAmt_not: BigInt
  bridgedAmt_gt: BigInt
  bridgedAmt_lt: BigInt
  bridgedAmt_gte: BigInt
  bridgedAmt_lte: BigInt
  bridgedAmt_in: [BigInt!]
  bridgedAmt_not_in: [BigInt!]
  normalizedIn: BigInt
  normalizedIn_not: BigInt
  normalizedIn_gt: BigInt
  normalizedIn_lt: BigInt
  normalizedIn_gte: BigInt
  normalizedIn_lte: BigInt
  normalizedIn_in: [BigInt!]
  normalizedIn_not_in: [BigInt!]
  canonicalId: base_Bytes
  canonicalId_not: base_Bytes
  canonicalId_gt: base_Bytes
  canonicalId_lt: base_Bytes
  canonicalId_gte: base_Bytes
  canonicalId_lte: base_Bytes
  canonicalId_in: [base_Bytes!]
  canonicalId_not_in: [base_Bytes!]
  canonicalId_contains: base_Bytes
  canonicalId_not_contains: base_Bytes
  asset: String
  asset_not: String
  asset_gt: String
  asset_lt: String
  asset_gte: String
  asset_lte: String
  asset_in: [String!]
  asset_not_in: [String!]
  asset_contains: String
  asset_contains_nocase: String
  asset_not_contains: String
  asset_not_contains_nocase: String
  asset_starts_with: String
  asset_starts_with_nocase: String
  asset_not_starts_with: String
  asset_not_starts_with_nocase: String
  asset_ends_with: String
  asset_ends_with_nocase: String
  asset_not_ends_with: String
  asset_not_ends_with_nocase: String
  asset_: base_Asset_filter
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  routersFee: BigInt
  routersFee_not: BigInt
  routersFee_gt: BigInt
  routersFee_lt: BigInt
  routersFee_gte: BigInt
  routersFee_lte: BigInt
  routersFee_in: [BigInt!]
  routersFee_not_in: [BigInt!]
  executedCaller: base_Bytes
  executedCaller_not: base_Bytes
  executedCaller_gt: base_Bytes
  executedCaller_lt: base_Bytes
  executedCaller_gte: base_Bytes
  executedCaller_lte: base_Bytes
  executedCaller_in: [base_Bytes!]
  executedCaller_not_in: [base_Bytes!]
  executedCaller_contains: base_Bytes
  executedCaller_not_contains: base_Bytes
  executedTransactionHash: base_Bytes
  executedTransactionHash_not: base_Bytes
  executedTransactionHash_gt: base_Bytes
  executedTransactionHash_lt: base_Bytes
  executedTransactionHash_gte: base_Bytes
  executedTransactionHash_lte: base_Bytes
  executedTransactionHash_in: [base_Bytes!]
  executedTransactionHash_not_in: [base_Bytes!]
  executedTransactionHash_contains: base_Bytes
  executedTransactionHash_not_contains: base_Bytes
  executedTimestamp: BigInt
  executedTimestamp_not: BigInt
  executedTimestamp_gt: BigInt
  executedTimestamp_lt: BigInt
  executedTimestamp_gte: BigInt
  executedTimestamp_lte: BigInt
  executedTimestamp_in: [BigInt!]
  executedTimestamp_not_in: [BigInt!]
  executedGasPrice: BigInt
  executedGasPrice_not: BigInt
  executedGasPrice_gt: BigInt
  executedGasPrice_lt: BigInt
  executedGasPrice_gte: BigInt
  executedGasPrice_lte: BigInt
  executedGasPrice_in: [BigInt!]
  executedGasPrice_not_in: [BigInt!]
  executedGasLimit: BigInt
  executedGasLimit_not: BigInt
  executedGasLimit_gt: BigInt
  executedGasLimit_lt: BigInt
  executedGasLimit_gte: BigInt
  executedGasLimit_lte: BigInt
  executedGasLimit_in: [BigInt!]
  executedGasLimit_not_in: [BigInt!]
  executedBlockNumber: BigInt
  executedBlockNumber_not: BigInt
  executedBlockNumber_gt: BigInt
  executedBlockNumber_lt: BigInt
  executedBlockNumber_gte: BigInt
  executedBlockNumber_lte: BigInt
  executedBlockNumber_in: [BigInt!]
  executedBlockNumber_not_in: [BigInt!]
  executedTxOrigin: base_Bytes
  executedTxOrigin_not: base_Bytes
  executedTxOrigin_gt: base_Bytes
  executedTxOrigin_lt: base_Bytes
  executedTxOrigin_gte: base_Bytes
  executedTxOrigin_lte: base_Bytes
  executedTxOrigin_in: [base_Bytes!]
  executedTxOrigin_not_in: [base_Bytes!]
  executedTxOrigin_contains: base_Bytes
  executedTxOrigin_not_contains: base_Bytes
  executedTxNonce: BigInt
  executedTxNonce_not: BigInt
  executedTxNonce_gt: BigInt
  executedTxNonce_lt: BigInt
  executedTxNonce_gte: BigInt
  executedTxNonce_lte: BigInt
  executedTxNonce_in: [BigInt!]
  executedTxNonce_not_in: [BigInt!]
  reconciledCaller: base_Bytes
  reconciledCaller_not: base_Bytes
  reconciledCaller_gt: base_Bytes
  reconciledCaller_lt: base_Bytes
  reconciledCaller_gte: base_Bytes
  reconciledCaller_lte: base_Bytes
  reconciledCaller_in: [base_Bytes!]
  reconciledCaller_not_in: [base_Bytes!]
  reconciledCaller_contains: base_Bytes
  reconciledCaller_not_contains: base_Bytes
  reconciledTransactionHash: base_Bytes
  reconciledTransactionHash_not: base_Bytes
  reconciledTransactionHash_gt: base_Bytes
  reconciledTransactionHash_lt: base_Bytes
  reconciledTransactionHash_gte: base_Bytes
  reconciledTransactionHash_lte: base_Bytes
  reconciledTransactionHash_in: [base_Bytes!]
  reconciledTransactionHash_not_in: [base_Bytes!]
  reconciledTransactionHash_contains: base_Bytes
  reconciledTransactionHash_not_contains: base_Bytes
  reconciledTimestamp: BigInt
  reconciledTimestamp_not: BigInt
  reconciledTimestamp_gt: BigInt
  reconciledTimestamp_lt: BigInt
  reconciledTimestamp_gte: BigInt
  reconciledTimestamp_lte: BigInt
  reconciledTimestamp_in: [BigInt!]
  reconciledTimestamp_not_in: [BigInt!]
  reconciledGasPrice: BigInt
  reconciledGasPrice_not: BigInt
  reconciledGasPrice_gt: BigInt
  reconciledGasPrice_lt: BigInt
  reconciledGasPrice_gte: BigInt
  reconciledGasPrice_lte: BigInt
  reconciledGasPrice_in: [BigInt!]
  reconciledGasPrice_not_in: [BigInt!]
  reconciledGasLimit: BigInt
  reconciledGasLimit_not: BigInt
  reconciledGasLimit_gt: BigInt
  reconciledGasLimit_lt: BigInt
  reconciledGasLimit_gte: BigInt
  reconciledGasLimit_lte: BigInt
  reconciledGasLimit_in: [BigInt!]
  reconciledGasLimit_not_in: [BigInt!]
  reconciledBlockNumber: BigInt
  reconciledBlockNumber_not: BigInt
  reconciledBlockNumber_gt: BigInt
  reconciledBlockNumber_lt: BigInt
  reconciledBlockNumber_gte: BigInt
  reconciledBlockNumber_lte: BigInt
  reconciledBlockNumber_in: [BigInt!]
  reconciledBlockNumber_not_in: [BigInt!]
  reconciledTxOrigin: base_Bytes
  reconciledTxOrigin_not: base_Bytes
  reconciledTxOrigin_gt: base_Bytes
  reconciledTxOrigin_lt: base_Bytes
  reconciledTxOrigin_gte: base_Bytes
  reconciledTxOrigin_lte: base_Bytes
  reconciledTxOrigin_in: [base_Bytes!]
  reconciledTxOrigin_not_in: [base_Bytes!]
  reconciledTxOrigin_contains: base_Bytes
  reconciledTxOrigin_not_contains: base_Bytes
  reconciledTxNonce: BigInt
  reconciledTxNonce_not: BigInt
  reconciledTxNonce_gt: BigInt
  reconciledTxNonce_lt: BigInt
  reconciledTxNonce_gte: BigInt
  reconciledTxNonce_lte: BigInt
  reconciledTxNonce_in: [BigInt!]
  reconciledTxNonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: base_BlockChangedFilter
  and: [base_DestinationTransfer_filter]
  or: [base_DestinationTransfer_filter]
}

enum base_DestinationTransfer_orderBy {
  id
  chainId
  transferId
  nonce
  status
  routers
  originDomain
  destinationDomain
  canonicalDomain
  to
  delegate
  receiveLocal
  callData
  slippage
  bumpSlippageCount
  originSender
  bridgedAmt
  normalizedIn
  canonicalId
  asset
  asset__id
  asset__key
  asset__decimal
  asset__adoptedDecimal
  asset__canonicalId
  asset__canonicalDomain
  asset__adoptedAsset
  asset__localAsset
  asset__blockNumber
  amount
  routersFee
  executedCaller
  executedTransactionHash
  executedTimestamp
  executedGasPrice
  executedGasLimit
  executedBlockNumber
  executedTxOrigin
  executedTxNonce
  reconciledCaller
  reconciledTransactionHash
  reconciledTimestamp
  reconciledGasPrice
  reconciledGasLimit
  reconciledBlockNumber
  reconciledTxOrigin
  reconciledTxNonce
}

"""
8 bytes signed integer

"""
scalar base_Int8

type base_OptimisticRootFinalized {
  id: ID!
  aggregateRoot: base_Bytes!
  timestamp: BigInt!
  blockNumber: BigInt
}

input base_OptimisticRootFinalized_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  aggregateRoot: base_Bytes
  aggregateRoot_not: base_Bytes
  aggregateRoot_gt: base_Bytes
  aggregateRoot_lt: base_Bytes
  aggregateRoot_gte: base_Bytes
  aggregateRoot_lte: base_Bytes
  aggregateRoot_in: [base_Bytes!]
  aggregateRoot_not_in: [base_Bytes!]
  aggregateRoot_contains: base_Bytes
  aggregateRoot_not_contains: base_Bytes
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: base_BlockChangedFilter
  and: [base_OptimisticRootFinalized_filter]
  or: [base_OptimisticRootFinalized_filter]
}

enum base_OptimisticRootFinalized_orderBy {
  id
  aggregateRoot
  timestamp
  blockNumber
}

"""Defines the order direction, either ascending or descending"""
enum base_OrderDirection {
  asc
  desc
}

type base_OriginMessage {
  id: ID!
  transferId: base_Bytes
  destinationDomain: BigInt
  leaf: base_Bytes
  index: BigInt
  message: base_Bytes
  root: base_Bytes
  transactionHash: base_Bytes
  blockNumber: BigInt
  rootCount: base_RootCount
}

input base_OriginMessage_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transferId: base_Bytes
  transferId_not: base_Bytes
  transferId_gt: base_Bytes
  transferId_lt: base_Bytes
  transferId_gte: base_Bytes
  transferId_lte: base_Bytes
  transferId_in: [base_Bytes!]
  transferId_not_in: [base_Bytes!]
  transferId_contains: base_Bytes
  transferId_not_contains: base_Bytes
  destinationDomain: BigInt
  destinationDomain_not: BigInt
  destinationDomain_gt: BigInt
  destinationDomain_lt: BigInt
  destinationDomain_gte: BigInt
  destinationDomain_lte: BigInt
  destinationDomain_in: [BigInt!]
  destinationDomain_not_in: [BigInt!]
  leaf: base_Bytes
  leaf_not: base_Bytes
  leaf_gt: base_Bytes
  leaf_lt: base_Bytes
  leaf_gte: base_Bytes
  leaf_lte: base_Bytes
  leaf_in: [base_Bytes!]
  leaf_not_in: [base_Bytes!]
  leaf_contains: base_Bytes
  leaf_not_contains: base_Bytes
  index: BigInt
  index_not: BigInt
  index_gt: BigInt
  index_lt: BigInt
  index_gte: BigInt
  index_lte: BigInt
  index_in: [BigInt!]
  index_not_in: [BigInt!]
  message: base_Bytes
  message_not: base_Bytes
  message_gt: base_Bytes
  message_lt: base_Bytes
  message_gte: base_Bytes
  message_lte: base_Bytes
  message_in: [base_Bytes!]
  message_not_in: [base_Bytes!]
  message_contains: base_Bytes
  message_not_contains: base_Bytes
  root: base_Bytes
  root_not: base_Bytes
  root_gt: base_Bytes
  root_lt: base_Bytes
  root_gte: base_Bytes
  root_lte: base_Bytes
  root_in: [base_Bytes!]
  root_not_in: [base_Bytes!]
  root_contains: base_Bytes
  root_not_contains: base_Bytes
  transactionHash: base_Bytes
  transactionHash_not: base_Bytes
  transactionHash_gt: base_Bytes
  transactionHash_lt: base_Bytes
  transactionHash_gte: base_Bytes
  transactionHash_lte: base_Bytes
  transactionHash_in: [base_Bytes!]
  transactionHash_not_in: [base_Bytes!]
  transactionHash_contains: base_Bytes
  transactionHash_not_contains: base_Bytes
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  rootCount: String
  rootCount_not: String
  rootCount_gt: String
  rootCount_lt: String
  rootCount_gte: String
  rootCount_lte: String
  rootCount_in: [String!]
  rootCount_not_in: [String!]
  rootCount_contains: String
  rootCount_contains_nocase: String
  rootCount_not_contains: String
  rootCount_not_contains_nocase: String
  rootCount_starts_with: String
  rootCount_starts_with_nocase: String
  rootCount_not_starts_with: String
  rootCount_not_starts_with_nocase: String
  rootCount_ends_with: String
  rootCount_ends_with_nocase: String
  rootCount_not_ends_with: String
  rootCount_not_ends_with_nocase: String
  rootCount_: base_RootCount_filter
  """Filter for the block changed event."""
  _change_block: base_BlockChangedFilter
  and: [base_OriginMessage_filter]
  or: [base_OriginMessage_filter]
}

enum base_OriginMessage_orderBy {
  id
  transferId
  destinationDomain
  leaf
  index
  message
  root
  transactionHash
  blockNumber
  rootCount
  rootCount__id
  rootCount__count
}

type base_OriginTransfer {
  id: ID!
  chainId: BigInt
  transferId: base_Bytes
  nonce: BigInt
  status: base_TransferStatus
  messageHash: base_Bytes
  originDomain: BigInt
  destinationDomain: BigInt
  canonicalDomain: BigInt
  to: base_Bytes
  delegate: base_Bytes
  receiveLocal: Boolean
  callData: base_Bytes
  slippage: BigInt
  originSender: base_Bytes
  bridgedAmt: BigInt
  normalizedIn: BigInt
  canonicalId: base_Bytes
  asset: base_Asset
  transactingAsset: base_Bytes
  message: base_OriginMessage
  bumpRelayerFeeCount: BigInt
  relayerFees(skip: Int = 0, first: Int = 100, orderBy: base_RelayerFee_orderBy, orderDirection: base_OrderDirection, where: base_RelayerFee_filter): [base_RelayerFee!]
  initialRelayerFeeAsset: base_Bytes
  caller: base_Bytes
  transactionHash: base_Bytes
  timestamp: BigInt
  gasPrice: BigInt
  gasLimit: BigInt
  blockNumber: BigInt
  txOrigin: base_Bytes
  txNonce: BigInt
}

input base_OriginTransfer_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  chainId: BigInt
  chainId_not: BigInt
  chainId_gt: BigInt
  chainId_lt: BigInt
  chainId_gte: BigInt
  chainId_lte: BigInt
  chainId_in: [BigInt!]
  chainId_not_in: [BigInt!]
  transferId: base_Bytes
  transferId_not: base_Bytes
  transferId_gt: base_Bytes
  transferId_lt: base_Bytes
  transferId_gte: base_Bytes
  transferId_lte: base_Bytes
  transferId_in: [base_Bytes!]
  transferId_not_in: [base_Bytes!]
  transferId_contains: base_Bytes
  transferId_not_contains: base_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  status: base_TransferStatus
  status_not: base_TransferStatus
  status_in: [base_TransferStatus!]
  status_not_in: [base_TransferStatus!]
  messageHash: base_Bytes
  messageHash_not: base_Bytes
  messageHash_gt: base_Bytes
  messageHash_lt: base_Bytes
  messageHash_gte: base_Bytes
  messageHash_lte: base_Bytes
  messageHash_in: [base_Bytes!]
  messageHash_not_in: [base_Bytes!]
  messageHash_contains: base_Bytes
  messageHash_not_contains: base_Bytes
  originDomain: BigInt
  originDomain_not: BigInt
  originDomain_gt: BigInt
  originDomain_lt: BigInt
  originDomain_gte: BigInt
  originDomain_lte: BigInt
  originDomain_in: [BigInt!]
  originDomain_not_in: [BigInt!]
  destinationDomain: BigInt
  destinationDomain_not: BigInt
  destinationDomain_gt: BigInt
  destinationDomain_lt: BigInt
  destinationDomain_gte: BigInt
  destinationDomain_lte: BigInt
  destinationDomain_in: [BigInt!]
  destinationDomain_not_in: [BigInt!]
  canonicalDomain: BigInt
  canonicalDomain_not: BigInt
  canonicalDomain_gt: BigInt
  canonicalDomain_lt: BigInt
  canonicalDomain_gte: BigInt
  canonicalDomain_lte: BigInt
  canonicalDomain_in: [BigInt!]
  canonicalDomain_not_in: [BigInt!]
  to: base_Bytes
  to_not: base_Bytes
  to_gt: base_Bytes
  to_lt: base_Bytes
  to_gte: base_Bytes
  to_lte: base_Bytes
  to_in: [base_Bytes!]
  to_not_in: [base_Bytes!]
  to_contains: base_Bytes
  to_not_contains: base_Bytes
  delegate: base_Bytes
  delegate_not: base_Bytes
  delegate_gt: base_Bytes
  delegate_lt: base_Bytes
  delegate_gte: base_Bytes
  delegate_lte: base_Bytes
  delegate_in: [base_Bytes!]
  delegate_not_in: [base_Bytes!]
  delegate_contains: base_Bytes
  delegate_not_contains: base_Bytes
  receiveLocal: Boolean
  receiveLocal_not: Boolean
  receiveLocal_in: [Boolean!]
  receiveLocal_not_in: [Boolean!]
  callData: base_Bytes
  callData_not: base_Bytes
  callData_gt: base_Bytes
  callData_lt: base_Bytes
  callData_gte: base_Bytes
  callData_lte: base_Bytes
  callData_in: [base_Bytes!]
  callData_not_in: [base_Bytes!]
  callData_contains: base_Bytes
  callData_not_contains: base_Bytes
  slippage: BigInt
  slippage_not: BigInt
  slippage_gt: BigInt
  slippage_lt: BigInt
  slippage_gte: BigInt
  slippage_lte: BigInt
  slippage_in: [BigInt!]
  slippage_not_in: [BigInt!]
  originSender: base_Bytes
  originSender_not: base_Bytes
  originSender_gt: base_Bytes
  originSender_lt: base_Bytes
  originSender_gte: base_Bytes
  originSender_lte: base_Bytes
  originSender_in: [base_Bytes!]
  originSender_not_in: [base_Bytes!]
  originSender_contains: base_Bytes
  originSender_not_contains: base_Bytes
  bridgedAmt: BigInt
  bridgedAmt_not: BigInt
  bridgedAmt_gt: BigInt
  bridgedAmt_lt: BigInt
  bridgedAmt_gte: BigInt
  bridgedAmt_lte: BigInt
  bridgedAmt_in: [BigInt!]
  bridgedAmt_not_in: [BigInt!]
  normalizedIn: BigInt
  normalizedIn_not: BigInt
  normalizedIn_gt: BigInt
  normalizedIn_lt: BigInt
  normalizedIn_gte: BigInt
  normalizedIn_lte: BigInt
  normalizedIn_in: [BigInt!]
  normalizedIn_not_in: [BigInt!]
  canonicalId: base_Bytes
  canonicalId_not: base_Bytes
  canonicalId_gt: base_Bytes
  canonicalId_lt: base_Bytes
  canonicalId_gte: base_Bytes
  canonicalId_lte: base_Bytes
  canonicalId_in: [base_Bytes!]
  canonicalId_not_in: [base_Bytes!]
  canonicalId_contains: base_Bytes
  canonicalId_not_contains: base_Bytes
  asset: String
  asset_not: String
  asset_gt: String
  asset_lt: String
  asset_gte: String
  asset_lte: String
  asset_in: [String!]
  asset_not_in: [String!]
  asset_contains: String
  asset_contains_nocase: String
  asset_not_contains: String
  asset_not_contains_nocase: String
  asset_starts_with: String
  asset_starts_with_nocase: String
  asset_not_starts_with: String
  asset_not_starts_with_nocase: String
  asset_ends_with: String
  asset_ends_with_nocase: String
  asset_not_ends_with: String
  asset_not_ends_with_nocase: String
  asset_: base_Asset_filter
  transactingAsset: base_Bytes
  transactingAsset_not: base_Bytes
  transactingAsset_gt: base_Bytes
  transactingAsset_lt: base_Bytes
  transactingAsset_gte: base_Bytes
  transactingAsset_lte: base_Bytes
  transactingAsset_in: [base_Bytes!]
  transactingAsset_not_in: [base_Bytes!]
  transactingAsset_contains: base_Bytes
  transactingAsset_not_contains: base_Bytes
  message: String
  message_not: String
  message_gt: String
  message_lt: String
  message_gte: String
  message_lte: String
  message_in: [String!]
  message_not_in: [String!]
  message_contains: String
  message_contains_nocase: String
  message_not_contains: String
  message_not_contains_nocase: String
  message_starts_with: String
  message_starts_with_nocase: String
  message_not_starts_with: String
  message_not_starts_with_nocase: String
  message_ends_with: String
  message_ends_with_nocase: String
  message_not_ends_with: String
  message_not_ends_with_nocase: String
  message_: base_OriginMessage_filter
  bumpRelayerFeeCount: BigInt
  bumpRelayerFeeCount_not: BigInt
  bumpRelayerFeeCount_gt: BigInt
  bumpRelayerFeeCount_lt: BigInt
  bumpRelayerFeeCount_gte: BigInt
  bumpRelayerFeeCount_lte: BigInt
  bumpRelayerFeeCount_in: [BigInt!]
  bumpRelayerFeeCount_not_in: [BigInt!]
  relayerFees: [String!]
  relayerFees_not: [String!]
  relayerFees_contains: [String!]
  relayerFees_contains_nocase: [String!]
  relayerFees_not_contains: [String!]
  relayerFees_not_contains_nocase: [String!]
  relayerFees_: base_RelayerFee_filter
  initialRelayerFeeAsset: base_Bytes
  initialRelayerFeeAsset_not: base_Bytes
  initialRelayerFeeAsset_gt: base_Bytes
  initialRelayerFeeAsset_lt: base_Bytes
  initialRelayerFeeAsset_gte: base_Bytes
  initialRelayerFeeAsset_lte: base_Bytes
  initialRelayerFeeAsset_in: [base_Bytes!]
  initialRelayerFeeAsset_not_in: [base_Bytes!]
  initialRelayerFeeAsset_contains: base_Bytes
  initialRelayerFeeAsset_not_contains: base_Bytes
  caller: base_Bytes
  caller_not: base_Bytes
  caller_gt: base_Bytes
  caller_lt: base_Bytes
  caller_gte: base_Bytes
  caller_lte: base_Bytes
  caller_in: [base_Bytes!]
  caller_not_in: [base_Bytes!]
  caller_contains: base_Bytes
  caller_not_contains: base_Bytes
  transactionHash: base_Bytes
  transactionHash_not: base_Bytes
  transactionHash_gt: base_Bytes
  transactionHash_lt: base_Bytes
  transactionHash_gte: base_Bytes
  transactionHash_lte: base_Bytes
  transactionHash_in: [base_Bytes!]
  transactionHash_not_in: [base_Bytes!]
  transactionHash_contains: base_Bytes
  transactionHash_not_contains: base_Bytes
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  gasLimit: BigInt
  gasLimit_not: BigInt
  gasLimit_gt: BigInt
  gasLimit_lt: BigInt
  gasLimit_gte: BigInt
  gasLimit_lte: BigInt
  gasLimit_in: [BigInt!]
  gasLimit_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  txOrigin: base_Bytes
  txOrigin_not: base_Bytes
  txOrigin_gt: base_Bytes
  txOrigin_lt: base_Bytes
  txOrigin_gte: base_Bytes
  txOrigin_lte: base_Bytes
  txOrigin_in: [base_Bytes!]
  txOrigin_not_in: [base_Bytes!]
  txOrigin_contains: base_Bytes
  txOrigin_not_contains: base_Bytes
  txNonce: BigInt
  txNonce_not: BigInt
  txNonce_gt: BigInt
  txNonce_lt: BigInt
  txNonce_gte: BigInt
  txNonce_lte: BigInt
  txNonce_in: [BigInt!]
  txNonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: base_BlockChangedFilter
  and: [base_OriginTransfer_filter]
  or: [base_OriginTransfer_filter]
}

enum base_OriginTransfer_orderBy {
  id
  chainId
  transferId
  nonce
  status
  messageHash
  originDomain
  destinationDomain
  canonicalDomain
  to
  delegate
  receiveLocal
  callData
  slippage
  originSender
  bridgedAmt
  normalizedIn
  canonicalId
  asset
  asset__id
  asset__key
  asset__decimal
  asset__adoptedDecimal
  asset__canonicalId
  asset__canonicalDomain
  asset__adoptedAsset
  asset__localAsset
  asset__blockNumber
  transactingAsset
  message
  message__id
  message__transferId
  message__destinationDomain
  message__leaf
  message__index
  message__message
  message__root
  message__transactionHash
  message__blockNumber
  bumpRelayerFeeCount
  relayerFees
  initialRelayerFeeAsset
  caller
  transactionHash
  timestamp
  gasPrice
  gasLimit
  blockNumber
  txOrigin
  txNonce
}

type base_Relayer {
  id: ID!
  isActive: Boolean!
  relayer: base_Bytes
}

type base_RelayerFee {
  id: ID!
  transfer: base_OriginTransfer!
  fee: BigInt!
  asset: base_Bytes!
}

input base_RelayerFee_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transfer: String
  transfer_not: String
  transfer_gt: String
  transfer_lt: String
  transfer_gte: String
  transfer_lte: String
  transfer_in: [String!]
  transfer_not_in: [String!]
  transfer_contains: String
  transfer_contains_nocase: String
  transfer_not_contains: String
  transfer_not_contains_nocase: String
  transfer_starts_with: String
  transfer_starts_with_nocase: String
  transfer_not_starts_with: String
  transfer_not_starts_with_nocase: String
  transfer_ends_with: String
  transfer_ends_with_nocase: String
  transfer_not_ends_with: String
  transfer_not_ends_with_nocase: String
  transfer_: base_OriginTransfer_filter
  fee: BigInt
  fee_not: BigInt
  fee_gt: BigInt
  fee_lt: BigInt
  fee_gte: BigInt
  fee_lte: BigInt
  fee_in: [BigInt!]
  fee_not_in: [BigInt!]
  asset: base_Bytes
  asset_not: base_Bytes
  asset_gt: base_Bytes
  asset_lt: base_Bytes
  asset_gte: base_Bytes
  asset_lte: base_Bytes
  asset_in: [base_Bytes!]
  asset_not_in: [base_Bytes!]
  asset_contains: base_Bytes
  asset_not_contains: base_Bytes
  """Filter for the block changed event."""
  _change_block: base_BlockChangedFilter
  and: [base_RelayerFee_filter]
  or: [base_RelayerFee_filter]
}

enum base_RelayerFee_orderBy {
  id
  transfer
  transfer__id
  transfer__chainId
  transfer__transferId
  transfer__nonce
  transfer__status
  transfer__messageHash
  transfer__originDomain
  transfer__destinationDomain
  transfer__canonicalDomain
  transfer__to
  transfer__delegate
  transfer__receiveLocal
  transfer__callData
  transfer__slippage
  transfer__originSender
  transfer__bridgedAmt
  transfer__normalizedIn
  transfer__canonicalId
  transfer__transactingAsset
  transfer__bumpRelayerFeeCount
  transfer__initialRelayerFeeAsset
  transfer__caller
  transfer__transactionHash
  transfer__timestamp
  transfer__gasPrice
  transfer__gasLimit
  transfer__blockNumber
  transfer__txOrigin
  transfer__txNonce
  fee
  asset
}

type base_RelayerFeesIncrease {
  id: ID!
  transfer: base_OriginTransfer!
  increase: BigInt
  asset: base_Bytes
  caller: base_Bytes!
  transactionHash: base_Bytes!
  timestamp: BigInt!
  gasPrice: BigInt!
  gasLimit: BigInt!
  blockNumber: BigInt!
}

input base_RelayerFeesIncrease_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transfer: String
  transfer_not: String
  transfer_gt: String
  transfer_lt: String
  transfer_gte: String
  transfer_lte: String
  transfer_in: [String!]
  transfer_not_in: [String!]
  transfer_contains: String
  transfer_contains_nocase: String
  transfer_not_contains: String
  transfer_not_contains_nocase: String
  transfer_starts_with: String
  transfer_starts_with_nocase: String
  transfer_not_starts_with: String
  transfer_not_starts_with_nocase: String
  transfer_ends_with: String
  transfer_ends_with_nocase: String
  transfer_not_ends_with: String
  transfer_not_ends_with_nocase: String
  transfer_: base_OriginTransfer_filter
  increase: BigInt
  increase_not: BigInt
  increase_gt: BigInt
  increase_lt: BigInt
  increase_gte: BigInt
  increase_lte: BigInt
  increase_in: [BigInt!]
  increase_not_in: [BigInt!]
  asset: base_Bytes
  asset_not: base_Bytes
  asset_gt: base_Bytes
  asset_lt: base_Bytes
  asset_gte: base_Bytes
  asset_lte: base_Bytes
  asset_in: [base_Bytes!]
  asset_not_in: [base_Bytes!]
  asset_contains: base_Bytes
  asset_not_contains: base_Bytes
  caller: base_Bytes
  caller_not: base_Bytes
  caller_gt: base_Bytes
  caller_lt: base_Bytes
  caller_gte: base_Bytes
  caller_lte: base_Bytes
  caller_in: [base_Bytes!]
  caller_not_in: [base_Bytes!]
  caller_contains: base_Bytes
  caller_not_contains: base_Bytes
  transactionHash: base_Bytes
  transactionHash_not: base_Bytes
  transactionHash_gt: base_Bytes
  transactionHash_lt: base_Bytes
  transactionHash_gte: base_Bytes
  transactionHash_lte: base_Bytes
  transactionHash_in: [base_Bytes!]
  transactionHash_not_in: [base_Bytes!]
  transactionHash_contains: base_Bytes
  transactionHash_not_contains: base_Bytes
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  gasLimit: BigInt
  gasLimit_not: BigInt
  gasLimit_gt: BigInt
  gasLimit_lt: BigInt
  gasLimit_gte: BigInt
  gasLimit_lte: BigInt
  gasLimit_in: [BigInt!]
  gasLimit_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: base_BlockChangedFilter
  and: [base_RelayerFeesIncrease_filter]
  or: [base_RelayerFeesIncrease_filter]
}

enum base_RelayerFeesIncrease_orderBy {
  id
  transfer
  transfer__id
  transfer__chainId
  transfer__transferId
  transfer__nonce
  transfer__status
  transfer__messageHash
  transfer__originDomain
  transfer__destinationDomain
  transfer__canonicalDomain
  transfer__to
  transfer__delegate
  transfer__receiveLocal
  transfer__callData
  transfer__slippage
  transfer__originSender
  transfer__bridgedAmt
  transfer__normalizedIn
  transfer__canonicalId
  transfer__transactingAsset
  transfer__bumpRelayerFeeCount
  transfer__initialRelayerFeeAsset
  transfer__caller
  transfer__transactionHash
  transfer__timestamp
  transfer__gasPrice
  transfer__gasLimit
  transfer__blockNumber
  transfer__txOrigin
  transfer__txNonce
  increase
  asset
  caller
  transactionHash
  timestamp
  gasPrice
  gasLimit
  blockNumber
}

input base_Relayer_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  isActive: Boolean
  isActive_not: Boolean
  isActive_in: [Boolean!]
  isActive_not_in: [Boolean!]
  relayer: base_Bytes
  relayer_not: base_Bytes
  relayer_gt: base_Bytes
  relayer_lt: base_Bytes
  relayer_gte: base_Bytes
  relayer_lte: base_Bytes
  relayer_in: [base_Bytes!]
  relayer_not_in: [base_Bytes!]
  relayer_contains: base_Bytes
  relayer_not_contains: base_Bytes
  """Filter for the block changed event."""
  _change_block: base_BlockChangedFilter
  and: [base_Relayer_filter]
  or: [base_Relayer_filter]
}

enum base_Relayer_orderBy {
  id
  isActive
  relayer
}

type base_RootCount {
  id: ID!
  count: BigInt
}

input base_RootCount_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  count: BigInt
  count_not: BigInt
  count_gt: BigInt
  count_lt: BigInt
  count_gte: BigInt
  count_lte: BigInt
  count_in: [BigInt!]
  count_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: base_BlockChangedFilter
  and: [base_RootCount_filter]
  or: [base_RootCount_filter]
}

enum base_RootCount_orderBy {
  id
  count
}

type base_RootMessageSent {
  id: ID!
  spokeDomain: BigInt
  hubDomain: BigInt
  root: base_Bytes
  count: BigInt
  caller: base_Bytes
  transactionHash: base_Bytes
  timestamp: BigInt
  gasPrice: BigInt
  gasLimit: BigInt
  blockNumber: BigInt
}

input base_RootMessageSent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  spokeDomain: BigInt
  spokeDomain_not: BigInt
  spokeDomain_gt: BigInt
  spokeDomain_lt: BigInt
  spokeDomain_gte: BigInt
  spokeDomain_lte: BigInt
  spokeDomain_in: [BigInt!]
  spokeDomain_not_in: [BigInt!]
  hubDomain: BigInt
  hubDomain_not: BigInt
  hubDomain_gt: BigInt
  hubDomain_lt: BigInt
  hubDomain_gte: BigInt
  hubDomain_lte: BigInt
  hubDomain_in: [BigInt!]
  hubDomain_not_in: [BigInt!]
  root: base_Bytes
  root_not: base_Bytes
  root_gt: base_Bytes
  root_lt: base_Bytes
  root_gte: base_Bytes
  root_lte: base_Bytes
  root_in: [base_Bytes!]
  root_not_in: [base_Bytes!]
  root_contains: base_Bytes
  root_not_contains: base_Bytes
  count: BigInt
  count_not: BigInt
  count_gt: BigInt
  count_lt: BigInt
  count_gte: BigInt
  count_lte: BigInt
  count_in: [BigInt!]
  count_not_in: [BigInt!]
  caller: base_Bytes
  caller_not: base_Bytes
  caller_gt: base_Bytes
  caller_lt: base_Bytes
  caller_gte: base_Bytes
  caller_lte: base_Bytes
  caller_in: [base_Bytes!]
  caller_not_in: [base_Bytes!]
  caller_contains: base_Bytes
  caller_not_contains: base_Bytes
  transactionHash: base_Bytes
  transactionHash_not: base_Bytes
  transactionHash_gt: base_Bytes
  transactionHash_lt: base_Bytes
  transactionHash_gte: base_Bytes
  transactionHash_lte: base_Bytes
  transactionHash_in: [base_Bytes!]
  transactionHash_not_in: [base_Bytes!]
  transactionHash_contains: base_Bytes
  transactionHash_not_contains: base_Bytes
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  gasLimit: BigInt
  gasLimit_not: BigInt
  gasLimit_gt: BigInt
  gasLimit_lt: BigInt
  gasLimit_gte: BigInt
  gasLimit_lte: BigInt
  gasLimit_in: [BigInt!]
  gasLimit_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: base_BlockChangedFilter
  and: [base_RootMessageSent_filter]
  or: [base_RootMessageSent_filter]
}

enum base_RootMessageSent_orderBy {
  id
  spokeDomain
  hubDomain
  root
  count
  caller
  transactionHash
  timestamp
  gasPrice
  gasLimit
  blockNumber
}

type base_Router {
  id: ID!
  isActive: Boolean!
  owner: base_Bytes
  recipient: base_Bytes
  proposedOwner: base_Bytes
  proposedTimestamp: BigInt
  assetBalances(skip: Int = 0, first: Int = 100, orderBy: base_AssetBalance_orderBy, orderDirection: base_OrderDirection, where: base_AssetBalance_filter): [base_AssetBalance!]!
}

type base_RouterDailyTVL {
  id: ID!
  router: base_Router!
  asset: base_Asset!
  timestamp: BigInt!
  balance: BigInt!
}

input base_RouterDailyTVL_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  router: String
  router_not: String
  router_gt: String
  router_lt: String
  router_gte: String
  router_lte: String
  router_in: [String!]
  router_not_in: [String!]
  router_contains: String
  router_contains_nocase: String
  router_not_contains: String
  router_not_contains_nocase: String
  router_starts_with: String
  router_starts_with_nocase: String
  router_not_starts_with: String
  router_not_starts_with_nocase: String
  router_ends_with: String
  router_ends_with_nocase: String
  router_not_ends_with: String
  router_not_ends_with_nocase: String
  router_: base_Router_filter
  asset: String
  asset_not: String
  asset_gt: String
  asset_lt: String
  asset_gte: String
  asset_lte: String
  asset_in: [String!]
  asset_not_in: [String!]
  asset_contains: String
  asset_contains_nocase: String
  asset_not_contains: String
  asset_not_contains_nocase: String
  asset_starts_with: String
  asset_starts_with_nocase: String
  asset_not_starts_with: String
  asset_not_starts_with_nocase: String
  asset_ends_with: String
  asset_ends_with_nocase: String
  asset_not_ends_with: String
  asset_not_ends_with_nocase: String
  asset_: base_Asset_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  balance: BigInt
  balance_not: BigInt
  balance_gt: BigInt
  balance_lt: BigInt
  balance_gte: BigInt
  balance_lte: BigInt
  balance_in: [BigInt!]
  balance_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: base_BlockChangedFilter
  and: [base_RouterDailyTVL_filter]
  or: [base_RouterDailyTVL_filter]
}

enum base_RouterDailyTVL_orderBy {
  id
  router
  router__id
  router__isActive
  router__owner
  router__recipient
  router__proposedOwner
  router__proposedTimestamp
  asset
  asset__id
  asset__key
  asset__decimal
  asset__adoptedDecimal
  asset__canonicalId
  asset__canonicalDomain
  asset__adoptedAsset
  asset__localAsset
  asset__blockNumber
  timestamp
  balance
}

type base_RouterLiquidityEvent {
  id: ID!
  type: base_RouterLiquidityEventType
  router: base_Router!
  asset: base_Asset!
  amount: BigInt!
  balance: BigInt!
  caller: base_Bytes
  blockNumber: BigInt!
  timestamp: BigInt!
  transactionHash: base_Bytes!
  nonce: BigInt!
}

enum base_RouterLiquidityEventType {
  Add
  Remove
}

input base_RouterLiquidityEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  type: base_RouterLiquidityEventType
  type_not: base_RouterLiquidityEventType
  type_in: [base_RouterLiquidityEventType!]
  type_not_in: [base_RouterLiquidityEventType!]
  router: String
  router_not: String
  router_gt: String
  router_lt: String
  router_gte: String
  router_lte: String
  router_in: [String!]
  router_not_in: [String!]
  router_contains: String
  router_contains_nocase: String
  router_not_contains: String
  router_not_contains_nocase: String
  router_starts_with: String
  router_starts_with_nocase: String
  router_not_starts_with: String
  router_not_starts_with_nocase: String
  router_ends_with: String
  router_ends_with_nocase: String
  router_not_ends_with: String
  router_not_ends_with_nocase: String
  router_: base_Router_filter
  asset: String
  asset_not: String
  asset_gt: String
  asset_lt: String
  asset_gte: String
  asset_lte: String
  asset_in: [String!]
  asset_not_in: [String!]
  asset_contains: String
  asset_contains_nocase: String
  asset_not_contains: String
  asset_not_contains_nocase: String
  asset_starts_with: String
  asset_starts_with_nocase: String
  asset_not_starts_with: String
  asset_not_starts_with_nocase: String
  asset_ends_with: String
  asset_ends_with_nocase: String
  asset_not_ends_with: String
  asset_not_ends_with_nocase: String
  asset_: base_Asset_filter
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  balance: BigInt
  balance_not: BigInt
  balance_gt: BigInt
  balance_lt: BigInt
  balance_gte: BigInt
  balance_lte: BigInt
  balance_in: [BigInt!]
  balance_not_in: [BigInt!]
  caller: base_Bytes
  caller_not: base_Bytes
  caller_gt: base_Bytes
  caller_lt: base_Bytes
  caller_gte: base_Bytes
  caller_lte: base_Bytes
  caller_in: [base_Bytes!]
  caller_not_in: [base_Bytes!]
  caller_contains: base_Bytes
  caller_not_contains: base_Bytes
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transactionHash: base_Bytes
  transactionHash_not: base_Bytes
  transactionHash_gt: base_Bytes
  transactionHash_lt: base_Bytes
  transactionHash_gte: base_Bytes
  transactionHash_lte: base_Bytes
  transactionHash_in: [base_Bytes!]
  transactionHash_not_in: [base_Bytes!]
  transactionHash_contains: base_Bytes
  transactionHash_not_contains: base_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: base_BlockChangedFilter
  and: [base_RouterLiquidityEvent_filter]
  or: [base_RouterLiquidityEvent_filter]
}

enum base_RouterLiquidityEvent_orderBy {
  id
  type
  router
  router__id
  router__isActive
  router__owner
  router__recipient
  router__proposedOwner
  router__proposedTimestamp
  asset
  asset__id
  asset__key
  asset__decimal
  asset__adoptedDecimal
  asset__canonicalId
  asset__canonicalDomain
  asset__adoptedAsset
  asset__localAsset
  asset__blockNumber
  amount
  balance
  caller
  blockNumber
  timestamp
  transactionHash
  nonce
}

input base_Router_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  isActive: Boolean
  isActive_not: Boolean
  isActive_in: [Boolean!]
  isActive_not_in: [Boolean!]
  owner: base_Bytes
  owner_not: base_Bytes
  owner_gt: base_Bytes
  owner_lt: base_Bytes
  owner_gte: base_Bytes
  owner_lte: base_Bytes
  owner_in: [base_Bytes!]
  owner_not_in: [base_Bytes!]
  owner_contains: base_Bytes
  owner_not_contains: base_Bytes
  recipient: base_Bytes
  recipient_not: base_Bytes
  recipient_gt: base_Bytes
  recipient_lt: base_Bytes
  recipient_gte: base_Bytes
  recipient_lte: base_Bytes
  recipient_in: [base_Bytes!]
  recipient_not_in: [base_Bytes!]
  recipient_contains: base_Bytes
  recipient_not_contains: base_Bytes
  proposedOwner: base_Bytes
  proposedOwner_not: base_Bytes
  proposedOwner_gt: base_Bytes
  proposedOwner_lt: base_Bytes
  proposedOwner_gte: base_Bytes
  proposedOwner_lte: base_Bytes
  proposedOwner_in: [base_Bytes!]
  proposedOwner_not_in: [base_Bytes!]
  proposedOwner_contains: base_Bytes
  proposedOwner_not_contains: base_Bytes
  proposedTimestamp: BigInt
  proposedTimestamp_not: BigInt
  proposedTimestamp_gt: BigInt
  proposedTimestamp_lt: BigInt
  proposedTimestamp_gte: BigInt
  proposedTimestamp_lte: BigInt
  proposedTimestamp_in: [BigInt!]
  proposedTimestamp_not_in: [BigInt!]
  assetBalances_: base_AssetBalance_filter
  """Filter for the block changed event."""
  _change_block: base_BlockChangedFilter
  and: [base_Router_filter]
  or: [base_Router_filter]
}

enum base_Router_orderBy {
  id
  isActive
  owner
  recipient
  proposedOwner
  proposedTimestamp
  assetBalances
}

type base_Sequencer {
  id: ID!
  isActive: Boolean!
  sequencer: base_Bytes
}

input base_Sequencer_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  isActive: Boolean
  isActive_not: Boolean
  isActive_in: [Boolean!]
  isActive_not_in: [Boolean!]
  sequencer: base_Bytes
  sequencer_not: base_Bytes
  sequencer_gt: base_Bytes
  sequencer_lt: base_Bytes
  sequencer_gte: base_Bytes
  sequencer_lte: base_Bytes
  sequencer_in: [base_Bytes!]
  sequencer_not_in: [base_Bytes!]
  sequencer_contains: base_Bytes
  sequencer_not_contains: base_Bytes
  """Filter for the block changed event."""
  _change_block: base_BlockChangedFilter
  and: [base_Sequencer_filter]
  or: [base_Sequencer_filter]
}

enum base_Sequencer_orderBy {
  id
  isActive
  sequencer
}

type base_Setting {
  id: ID!
  maxRoutersPerTransfer: BigInt!
  caller: base_Bytes!
}

input base_Setting_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  maxRoutersPerTransfer: BigInt
  maxRoutersPerTransfer_not: BigInt
  maxRoutersPerTransfer_gt: BigInt
  maxRoutersPerTransfer_lt: BigInt
  maxRoutersPerTransfer_gte: BigInt
  maxRoutersPerTransfer_lte: BigInt
  maxRoutersPerTransfer_in: [BigInt!]
  maxRoutersPerTransfer_not_in: [BigInt!]
  caller: base_Bytes
  caller_not: base_Bytes
  caller_gt: base_Bytes
  caller_lt: base_Bytes
  caller_gte: base_Bytes
  caller_lte: base_Bytes
  caller_in: [base_Bytes!]
  caller_not_in: [base_Bytes!]
  caller_contains: base_Bytes
  caller_not_contains: base_Bytes
  """Filter for the block changed event."""
  _change_block: base_BlockChangedFilter
  and: [base_Setting_filter]
  or: [base_Setting_filter]
}

enum base_Setting_orderBy {
  id
  maxRoutersPerTransfer
  caller
}

type base_SlippageUpdate {
  id: ID!
  transfer: base_DestinationTransfer!
  slippage: BigInt!
  caller: base_Bytes!
  transactionHash: base_Bytes!
  timestamp: BigInt!
  gasPrice: BigInt!
  gasLimit: BigInt!
  blockNumber: BigInt!
}

input base_SlippageUpdate_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transfer: String
  transfer_not: String
  transfer_gt: String
  transfer_lt: String
  transfer_gte: String
  transfer_lte: String
  transfer_in: [String!]
  transfer_not_in: [String!]
  transfer_contains: String
  transfer_contains_nocase: String
  transfer_not_contains: String
  transfer_not_contains_nocase: String
  transfer_starts_with: String
  transfer_starts_with_nocase: String
  transfer_not_starts_with: String
  transfer_not_starts_with_nocase: String
  transfer_ends_with: String
  transfer_ends_with_nocase: String
  transfer_not_ends_with: String
  transfer_not_ends_with_nocase: String
  transfer_: base_DestinationTransfer_filter
  slippage: BigInt
  slippage_not: BigInt
  slippage_gt: BigInt
  slippage_lt: BigInt
  slippage_gte: BigInt
  slippage_lte: BigInt
  slippage_in: [BigInt!]
  slippage_not_in: [BigInt!]
  caller: base_Bytes
  caller_not: base_Bytes
  caller_gt: base_Bytes
  caller_lt: base_Bytes
  caller_gte: base_Bytes
  caller_lte: base_Bytes
  caller_in: [base_Bytes!]
  caller_not_in: [base_Bytes!]
  caller_contains: base_Bytes
  caller_not_contains: base_Bytes
  transactionHash: base_Bytes
  transactionHash_not: base_Bytes
  transactionHash_gt: base_Bytes
  transactionHash_lt: base_Bytes
  transactionHash_gte: base_Bytes
  transactionHash_lte: base_Bytes
  transactionHash_in: [base_Bytes!]
  transactionHash_not_in: [base_Bytes!]
  transactionHash_contains: base_Bytes
  transactionHash_not_contains: base_Bytes
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  gasLimit: BigInt
  gasLimit_not: BigInt
  gasLimit_gt: BigInt
  gasLimit_lt: BigInt
  gasLimit_gte: BigInt
  gasLimit_lte: BigInt
  gasLimit_in: [BigInt!]
  gasLimit_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: base_BlockChangedFilter
  and: [base_SlippageUpdate_filter]
  or: [base_SlippageUpdate_filter]
}

enum base_SlippageUpdate_orderBy {
  id
  transfer
  transfer__id
  transfer__chainId
  transfer__transferId
  transfer__nonce
  transfer__status
  transfer__originDomain
  transfer__destinationDomain
  transfer__canonicalDomain
  transfer__to
  transfer__delegate
  transfer__receiveLocal
  transfer__callData
  transfer__slippage
  transfer__bumpSlippageCount
  transfer__originSender
  transfer__bridgedAmt
  transfer__normalizedIn
  transfer__canonicalId
  transfer__amount
  transfer__routersFee
  transfer__executedCaller
  transfer__executedTransactionHash
  transfer__executedTimestamp
  transfer__executedGasPrice
  transfer__executedGasLimit
  transfer__executedBlockNumber
  transfer__executedTxOrigin
  transfer__executedTxNonce
  transfer__reconciledCaller
  transfer__reconciledTransactionHash
  transfer__reconciledTimestamp
  transfer__reconciledGasPrice
  transfer__reconciledGasLimit
  transfer__reconciledBlockNumber
  transfer__reconciledTxOrigin
  transfer__reconciledTxNonce
  slippage
  caller
  transactionHash
  timestamp
  gasPrice
  gasLimit
  blockNumber
}

type base_SnapshotRoot {
  id: ID!
  spokeDomain: BigInt
  root: base_Bytes!
  count: BigInt!
  timestamp: BigInt!
  blockNumber: BigInt!
}

input base_SnapshotRoot_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  spokeDomain: BigInt
  spokeDomain_not: BigInt
  spokeDomain_gt: BigInt
  spokeDomain_lt: BigInt
  spokeDomain_gte: BigInt
  spokeDomain_lte: BigInt
  spokeDomain_in: [BigInt!]
  spokeDomain_not_in: [BigInt!]
  root: base_Bytes
  root_not: base_Bytes
  root_gt: base_Bytes
  root_lt: base_Bytes
  root_gte: base_Bytes
  root_lte: base_Bytes
  root_in: [base_Bytes!]
  root_not_in: [base_Bytes!]
  root_contains: base_Bytes
  root_not_contains: base_Bytes
  count: BigInt
  count_not: BigInt
  count_gt: BigInt
  count_lt: BigInt
  count_gte: BigInt
  count_lte: BigInt
  count_in: [BigInt!]
  count_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: base_BlockChangedFilter
  and: [base_SnapshotRoot_filter]
  or: [base_SnapshotRoot_filter]
}

enum base_SnapshotRoot_orderBy {
  id
  spokeDomain
  root
  count
  timestamp
  blockNumber
}

type base_SpokeConnectorMode {
  id: ID!
  mode: String!
}

input base_SpokeConnectorMode_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  mode: String
  mode_not: String
  mode_gt: String
  mode_lt: String
  mode_gte: String
  mode_lte: String
  mode_in: [String!]
  mode_not_in: [String!]
  mode_contains: String
  mode_contains_nocase: String
  mode_not_contains: String
  mode_not_contains_nocase: String
  mode_starts_with: String
  mode_starts_with_nocase: String
  mode_not_starts_with: String
  mode_not_starts_with_nocase: String
  mode_ends_with: String
  mode_ends_with_nocase: String
  mode_not_ends_with: String
  mode_not_ends_with_nocase: String
  """Filter for the block changed event."""
  _change_block: base_BlockChangedFilter
  and: [base_SpokeConnectorMode_filter]
  or: [base_SpokeConnectorMode_filter]
}

enum base_SpokeConnectorMode_orderBy {
  id
  mode
}

enum base_TransferStatus {
  XCalled
  Executed
  Reconciled
  CompletedSlow
  CompletedFast
}

type base__Block_ {
  """The hash of the block"""
  hash: base_Bytes
  """The block number"""
  number: Int!
  """Integer representation of the timestamp stored in blocks for the chain"""
  timestamp: Int
  """The hash of the parent block"""
  parentHash: base_Bytes
}

"""The type for the top-level _meta field"""
type base__Meta_ {
  """
  Information about a specific subgraph block. The hash of the block
  will be null if the _meta field has a block constraint that asks for
  a block number. It will be filled if the _meta field has no block constraint
  and therefore asks for the latest  block
  
  """
  block: base__Block_!
  """The deployment ID"""
  deployment: String!
  """If `true`, the subgraph encountered indexing errors at some past block"""
  hasIndexingErrors: Boolean!
}

type xdai_AggregateRoot {
  id: ID!
  root: xdai_Bytes!
  blockNumber: BigInt!
}

type xdai_AggregateRootProposed {
  id: ID!
  aggregateRoot: xdai_Bytes!
  rootTimestamp: BigInt!
  endOfDispute: BigInt!
  domain: BigInt!
  timestamp: BigInt!
  blockNumber: BigInt
}

input xdai_AggregateRootProposed_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  aggregateRoot: xdai_Bytes
  aggregateRoot_not: xdai_Bytes
  aggregateRoot_gt: xdai_Bytes
  aggregateRoot_lt: xdai_Bytes
  aggregateRoot_gte: xdai_Bytes
  aggregateRoot_lte: xdai_Bytes
  aggregateRoot_in: [xdai_Bytes!]
  aggregateRoot_not_in: [xdai_Bytes!]
  aggregateRoot_contains: xdai_Bytes
  aggregateRoot_not_contains: xdai_Bytes
  rootTimestamp: BigInt
  rootTimestamp_not: BigInt
  rootTimestamp_gt: BigInt
  rootTimestamp_lt: BigInt
  rootTimestamp_gte: BigInt
  rootTimestamp_lte: BigInt
  rootTimestamp_in: [BigInt!]
  rootTimestamp_not_in: [BigInt!]
  endOfDispute: BigInt
  endOfDispute_not: BigInt
  endOfDispute_gt: BigInt
  endOfDispute_lt: BigInt
  endOfDispute_gte: BigInt
  endOfDispute_lte: BigInt
  endOfDispute_in: [BigInt!]
  endOfDispute_not_in: [BigInt!]
  domain: BigInt
  domain_not: BigInt
  domain_gt: BigInt
  domain_lt: BigInt
  domain_gte: BigInt
  domain_lte: BigInt
  domain_in: [BigInt!]
  domain_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: xdai_BlockChangedFilter
  and: [xdai_AggregateRootProposed_filter]
  or: [xdai_AggregateRootProposed_filter]
}

enum xdai_AggregateRootProposed_orderBy {
  id
  aggregateRoot
  rootTimestamp
  endOfDispute
  domain
  timestamp
  blockNumber
}

input xdai_AggregateRoot_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  root: xdai_Bytes
  root_not: xdai_Bytes
  root_gt: xdai_Bytes
  root_lt: xdai_Bytes
  root_gte: xdai_Bytes
  root_lte: xdai_Bytes
  root_in: [xdai_Bytes!]
  root_not_in: [xdai_Bytes!]
  root_contains: xdai_Bytes
  root_not_contains: xdai_Bytes
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: xdai_BlockChangedFilter
  and: [xdai_AggregateRoot_filter]
  or: [xdai_AggregateRoot_filter]
}

enum xdai_AggregateRoot_orderBy {
  id
  root
  blockNumber
}

enum xdai_Aggregation_interval {
  hour
  day
}

type xdai_Asset {
  id: ID!
  key: xdai_Bytes
  decimal: BigInt
  adoptedDecimal: BigInt
  canonicalId: xdai_Bytes
  canonicalDomain: BigInt
  adoptedAsset: xdai_Bytes
  localAsset: xdai_Bytes
  blockNumber: BigInt
  status: xdai_AssetStatus
}

type xdai_AssetBalance {
  id: ID!
  amount: BigInt!
  locked: BigInt!
  supplied: BigInt!
  removed: BigInt!
  router: xdai_Router!
  asset: xdai_Asset!
  feesEarned: BigInt!
}

input xdai_AssetBalance_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  locked: BigInt
  locked_not: BigInt
  locked_gt: BigInt
  locked_lt: BigInt
  locked_gte: BigInt
  locked_lte: BigInt
  locked_in: [BigInt!]
  locked_not_in: [BigInt!]
  supplied: BigInt
  supplied_not: BigInt
  supplied_gt: BigInt
  supplied_lt: BigInt
  supplied_gte: BigInt
  supplied_lte: BigInt
  supplied_in: [BigInt!]
  supplied_not_in: [BigInt!]
  removed: BigInt
  removed_not: BigInt
  removed_gt: BigInt
  removed_lt: BigInt
  removed_gte: BigInt
  removed_lte: BigInt
  removed_in: [BigInt!]
  removed_not_in: [BigInt!]
  router: String
  router_not: String
  router_gt: String
  router_lt: String
  router_gte: String
  router_lte: String
  router_in: [String!]
  router_not_in: [String!]
  router_contains: String
  router_contains_nocase: String
  router_not_contains: String
  router_not_contains_nocase: String
  router_starts_with: String
  router_starts_with_nocase: String
  router_not_starts_with: String
  router_not_starts_with_nocase: String
  router_ends_with: String
  router_ends_with_nocase: String
  router_not_ends_with: String
  router_not_ends_with_nocase: String
  router_: xdai_Router_filter
  asset: String
  asset_not: String
  asset_gt: String
  asset_lt: String
  asset_gte: String
  asset_lte: String
  asset_in: [String!]
  asset_not_in: [String!]
  asset_contains: String
  asset_contains_nocase: String
  asset_not_contains: String
  asset_not_contains_nocase: String
  asset_starts_with: String
  asset_starts_with_nocase: String
  asset_not_starts_with: String
  asset_not_starts_with_nocase: String
  asset_ends_with: String
  asset_ends_with_nocase: String
  asset_not_ends_with: String
  asset_not_ends_with_nocase: String
  asset_: xdai_Asset_filter
  feesEarned: BigInt
  feesEarned_not: BigInt
  feesEarned_gt: BigInt
  feesEarned_lt: BigInt
  feesEarned_gte: BigInt
  feesEarned_lte: BigInt
  feesEarned_in: [BigInt!]
  feesEarned_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: xdai_BlockChangedFilter
  and: [xdai_AssetBalance_filter]
  or: [xdai_AssetBalance_filter]
}

enum xdai_AssetBalance_orderBy {
  id
  amount
  locked
  supplied
  removed
  router
  router__id
  router__isActive
  router__owner
  router__recipient
  router__proposedOwner
  router__proposedTimestamp
  asset
  asset__id
  asset__key
  asset__decimal
  asset__adoptedDecimal
  asset__canonicalId
  asset__canonicalDomain
  asset__adoptedAsset
  asset__localAsset
  asset__blockNumber
  feesEarned
}

type xdai_AssetStatus {
  id: ID!
  status: Boolean
}

input xdai_AssetStatus_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  status: Boolean
  status_not: Boolean
  status_in: [Boolean!]
  status_not_in: [Boolean!]
  """Filter for the block changed event."""
  _change_block: xdai_BlockChangedFilter
  and: [xdai_AssetStatus_filter]
  or: [xdai_AssetStatus_filter]
}

enum xdai_AssetStatus_orderBy {
  id
  status
}

input xdai_Asset_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  key: xdai_Bytes
  key_not: xdai_Bytes
  key_gt: xdai_Bytes
  key_lt: xdai_Bytes
  key_gte: xdai_Bytes
  key_lte: xdai_Bytes
  key_in: [xdai_Bytes!]
  key_not_in: [xdai_Bytes!]
  key_contains: xdai_Bytes
  key_not_contains: xdai_Bytes
  decimal: BigInt
  decimal_not: BigInt
  decimal_gt: BigInt
  decimal_lt: BigInt
  decimal_gte: BigInt
  decimal_lte: BigInt
  decimal_in: [BigInt!]
  decimal_not_in: [BigInt!]
  adoptedDecimal: BigInt
  adoptedDecimal_not: BigInt
  adoptedDecimal_gt: BigInt
  adoptedDecimal_lt: BigInt
  adoptedDecimal_gte: BigInt
  adoptedDecimal_lte: BigInt
  adoptedDecimal_in: [BigInt!]
  adoptedDecimal_not_in: [BigInt!]
  canonicalId: xdai_Bytes
  canonicalId_not: xdai_Bytes
  canonicalId_gt: xdai_Bytes
  canonicalId_lt: xdai_Bytes
  canonicalId_gte: xdai_Bytes
  canonicalId_lte: xdai_Bytes
  canonicalId_in: [xdai_Bytes!]
  canonicalId_not_in: [xdai_Bytes!]
  canonicalId_contains: xdai_Bytes
  canonicalId_not_contains: xdai_Bytes
  canonicalDomain: BigInt
  canonicalDomain_not: BigInt
  canonicalDomain_gt: BigInt
  canonicalDomain_lt: BigInt
  canonicalDomain_gte: BigInt
  canonicalDomain_lte: BigInt
  canonicalDomain_in: [BigInt!]
  canonicalDomain_not_in: [BigInt!]
  adoptedAsset: xdai_Bytes
  adoptedAsset_not: xdai_Bytes
  adoptedAsset_gt: xdai_Bytes
  adoptedAsset_lt: xdai_Bytes
  adoptedAsset_gte: xdai_Bytes
  adoptedAsset_lte: xdai_Bytes
  adoptedAsset_in: [xdai_Bytes!]
  adoptedAsset_not_in: [xdai_Bytes!]
  adoptedAsset_contains: xdai_Bytes
  adoptedAsset_not_contains: xdai_Bytes
  localAsset: xdai_Bytes
  localAsset_not: xdai_Bytes
  localAsset_gt: xdai_Bytes
  localAsset_lt: xdai_Bytes
  localAsset_gte: xdai_Bytes
  localAsset_lte: xdai_Bytes
  localAsset_in: [xdai_Bytes!]
  localAsset_not_in: [xdai_Bytes!]
  localAsset_contains: xdai_Bytes
  localAsset_not_contains: xdai_Bytes
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  status: String
  status_not: String
  status_gt: String
  status_lt: String
  status_gte: String
  status_lte: String
  status_in: [String!]
  status_not_in: [String!]
  status_contains: String
  status_contains_nocase: String
  status_not_contains: String
  status_not_contains_nocase: String
  status_starts_with: String
  status_starts_with_nocase: String
  status_not_starts_with: String
  status_not_starts_with_nocase: String
  status_ends_with: String
  status_ends_with_nocase: String
  status_not_ends_with: String
  status_not_ends_with_nocase: String
  status_: xdai_AssetStatus_filter
  """Filter for the block changed event."""
  _change_block: xdai_BlockChangedFilter
  and: [xdai_Asset_filter]
  or: [xdai_Asset_filter]
}

enum xdai_Asset_orderBy {
  id
  key
  decimal
  adoptedDecimal
  canonicalId
  canonicalDomain
  adoptedAsset
  localAsset
  blockNumber
  status
  status__id
  status__status
}

scalar xdai_BigDecimal

input xdai_BlockChangedFilter {
  number_gte: Int!
}

input xdai_Block_height {
  hash: xdai_Bytes
  number: Int
  number_gte: Int
}

scalar xdai_Bytes

type xdai_ConnectorMeta {
  id: ID!
  spokeDomain: BigInt
  hubDomain: BigInt
  amb: xdai_Bytes
  rootManager: xdai_Bytes
  mirrorConnector: xdai_Bytes
}

input xdai_ConnectorMeta_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  spokeDomain: BigInt
  spokeDomain_not: BigInt
  spokeDomain_gt: BigInt
  spokeDomain_lt: BigInt
  spokeDomain_gte: BigInt
  spokeDomain_lte: BigInt
  spokeDomain_in: [BigInt!]
  spokeDomain_not_in: [BigInt!]
  hubDomain: BigInt
  hubDomain_not: BigInt
  hubDomain_gt: BigInt
  hubDomain_lt: BigInt
  hubDomain_gte: BigInt
  hubDomain_lte: BigInt
  hubDomain_in: [BigInt!]
  hubDomain_not_in: [BigInt!]
  amb: xdai_Bytes
  amb_not: xdai_Bytes
  amb_gt: xdai_Bytes
  amb_lt: xdai_Bytes
  amb_gte: xdai_Bytes
  amb_lte: xdai_Bytes
  amb_in: [xdai_Bytes!]
  amb_not_in: [xdai_Bytes!]
  amb_contains: xdai_Bytes
  amb_not_contains: xdai_Bytes
  rootManager: xdai_Bytes
  rootManager_not: xdai_Bytes
  rootManager_gt: xdai_Bytes
  rootManager_lt: xdai_Bytes
  rootManager_gte: xdai_Bytes
  rootManager_lte: xdai_Bytes
  rootManager_in: [xdai_Bytes!]
  rootManager_not_in: [xdai_Bytes!]
  rootManager_contains: xdai_Bytes
  rootManager_not_contains: xdai_Bytes
  mirrorConnector: xdai_Bytes
  mirrorConnector_not: xdai_Bytes
  mirrorConnector_gt: xdai_Bytes
  mirrorConnector_lt: xdai_Bytes
  mirrorConnector_gte: xdai_Bytes
  mirrorConnector_lte: xdai_Bytes
  mirrorConnector_in: [xdai_Bytes!]
  mirrorConnector_not_in: [xdai_Bytes!]
  mirrorConnector_contains: xdai_Bytes
  mirrorConnector_not_contains: xdai_Bytes
  """Filter for the block changed event."""
  _change_block: xdai_BlockChangedFilter
  and: [xdai_ConnectorMeta_filter]
  or: [xdai_ConnectorMeta_filter]
}

enum xdai_ConnectorMeta_orderBy {
  id
  spokeDomain
  hubDomain
  amb
  rootManager
  mirrorConnector
}

type xdai_DestinationTransfer {
  id: ID!
  chainId: BigInt
  transferId: xdai_Bytes
  nonce: BigInt
  status: xdai_TransferStatus
  routers(skip: Int = 0, first: Int = 100, orderBy: xdai_Router_orderBy, orderDirection: xdai_OrderDirection, where: xdai_Router_filter): [xdai_Router!]
  originDomain: BigInt
  destinationDomain: BigInt
  canonicalDomain: BigInt
  to: xdai_Bytes
  delegate: xdai_Bytes
  receiveLocal: Boolean
  callData: xdai_Bytes
  slippage: BigInt
  bumpSlippageCount: BigInt
  originSender: xdai_Bytes
  bridgedAmt: BigInt
  normalizedIn: BigInt
  canonicalId: xdai_Bytes
  asset: xdai_Asset
  amount: BigInt
  routersFee: BigInt
  executedCaller: xdai_Bytes
  executedTransactionHash: xdai_Bytes
  executedTimestamp: BigInt
  executedGasPrice: BigInt
  executedGasLimit: BigInt
  executedBlockNumber: BigInt
  executedTxOrigin: xdai_Bytes
  executedTxNonce: BigInt
  reconciledCaller: xdai_Bytes
  reconciledTransactionHash: xdai_Bytes
  reconciledTimestamp: BigInt
  reconciledGasPrice: BigInt
  reconciledGasLimit: BigInt
  reconciledBlockNumber: BigInt
  reconciledTxOrigin: xdai_Bytes
  reconciledTxNonce: BigInt
}

input xdai_DestinationTransfer_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  chainId: BigInt
  chainId_not: BigInt
  chainId_gt: BigInt
  chainId_lt: BigInt
  chainId_gte: BigInt
  chainId_lte: BigInt
  chainId_in: [BigInt!]
  chainId_not_in: [BigInt!]
  transferId: xdai_Bytes
  transferId_not: xdai_Bytes
  transferId_gt: xdai_Bytes
  transferId_lt: xdai_Bytes
  transferId_gte: xdai_Bytes
  transferId_lte: xdai_Bytes
  transferId_in: [xdai_Bytes!]
  transferId_not_in: [xdai_Bytes!]
  transferId_contains: xdai_Bytes
  transferId_not_contains: xdai_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  status: xdai_TransferStatus
  status_not: xdai_TransferStatus
  status_in: [xdai_TransferStatus!]
  status_not_in: [xdai_TransferStatus!]
  routers: [String!]
  routers_not: [String!]
  routers_contains: [String!]
  routers_contains_nocase: [String!]
  routers_not_contains: [String!]
  routers_not_contains_nocase: [String!]
  routers_: xdai_Router_filter
  originDomain: BigInt
  originDomain_not: BigInt
  originDomain_gt: BigInt
  originDomain_lt: BigInt
  originDomain_gte: BigInt
  originDomain_lte: BigInt
  originDomain_in: [BigInt!]
  originDomain_not_in: [BigInt!]
  destinationDomain: BigInt
  destinationDomain_not: BigInt
  destinationDomain_gt: BigInt
  destinationDomain_lt: BigInt
  destinationDomain_gte: BigInt
  destinationDomain_lte: BigInt
  destinationDomain_in: [BigInt!]
  destinationDomain_not_in: [BigInt!]
  canonicalDomain: BigInt
  canonicalDomain_not: BigInt
  canonicalDomain_gt: BigInt
  canonicalDomain_lt: BigInt
  canonicalDomain_gte: BigInt
  canonicalDomain_lte: BigInt
  canonicalDomain_in: [BigInt!]
  canonicalDomain_not_in: [BigInt!]
  to: xdai_Bytes
  to_not: xdai_Bytes
  to_gt: xdai_Bytes
  to_lt: xdai_Bytes
  to_gte: xdai_Bytes
  to_lte: xdai_Bytes
  to_in: [xdai_Bytes!]
  to_not_in: [xdai_Bytes!]
  to_contains: xdai_Bytes
  to_not_contains: xdai_Bytes
  delegate: xdai_Bytes
  delegate_not: xdai_Bytes
  delegate_gt: xdai_Bytes
  delegate_lt: xdai_Bytes
  delegate_gte: xdai_Bytes
  delegate_lte: xdai_Bytes
  delegate_in: [xdai_Bytes!]
  delegate_not_in: [xdai_Bytes!]
  delegate_contains: xdai_Bytes
  delegate_not_contains: xdai_Bytes
  receiveLocal: Boolean
  receiveLocal_not: Boolean
  receiveLocal_in: [Boolean!]
  receiveLocal_not_in: [Boolean!]
  callData: xdai_Bytes
  callData_not: xdai_Bytes
  callData_gt: xdai_Bytes
  callData_lt: xdai_Bytes
  callData_gte: xdai_Bytes
  callData_lte: xdai_Bytes
  callData_in: [xdai_Bytes!]
  callData_not_in: [xdai_Bytes!]
  callData_contains: xdai_Bytes
  callData_not_contains: xdai_Bytes
  slippage: BigInt
  slippage_not: BigInt
  slippage_gt: BigInt
  slippage_lt: BigInt
  slippage_gte: BigInt
  slippage_lte: BigInt
  slippage_in: [BigInt!]
  slippage_not_in: [BigInt!]
  bumpSlippageCount: BigInt
  bumpSlippageCount_not: BigInt
  bumpSlippageCount_gt: BigInt
  bumpSlippageCount_lt: BigInt
  bumpSlippageCount_gte: BigInt
  bumpSlippageCount_lte: BigInt
  bumpSlippageCount_in: [BigInt!]
  bumpSlippageCount_not_in: [BigInt!]
  originSender: xdai_Bytes
  originSender_not: xdai_Bytes
  originSender_gt: xdai_Bytes
  originSender_lt: xdai_Bytes
  originSender_gte: xdai_Bytes
  originSender_lte: xdai_Bytes
  originSender_in: [xdai_Bytes!]
  originSender_not_in: [xdai_Bytes!]
  originSender_contains: xdai_Bytes
  originSender_not_contains: xdai_Bytes
  bridgedAmt: BigInt
  bridgedAmt_not: BigInt
  bridgedAmt_gt: BigInt
  bridgedAmt_lt: BigInt
  bridgedAmt_gte: BigInt
  bridgedAmt_lte: BigInt
  bridgedAmt_in: [BigInt!]
  bridgedAmt_not_in: [BigInt!]
  normalizedIn: BigInt
  normalizedIn_not: BigInt
  normalizedIn_gt: BigInt
  normalizedIn_lt: BigInt
  normalizedIn_gte: BigInt
  normalizedIn_lte: BigInt
  normalizedIn_in: [BigInt!]
  normalizedIn_not_in: [BigInt!]
  canonicalId: xdai_Bytes
  canonicalId_not: xdai_Bytes
  canonicalId_gt: xdai_Bytes
  canonicalId_lt: xdai_Bytes
  canonicalId_gte: xdai_Bytes
  canonicalId_lte: xdai_Bytes
  canonicalId_in: [xdai_Bytes!]
  canonicalId_not_in: [xdai_Bytes!]
  canonicalId_contains: xdai_Bytes
  canonicalId_not_contains: xdai_Bytes
  asset: String
  asset_not: String
  asset_gt: String
  asset_lt: String
  asset_gte: String
  asset_lte: String
  asset_in: [String!]
  asset_not_in: [String!]
  asset_contains: String
  asset_contains_nocase: String
  asset_not_contains: String
  asset_not_contains_nocase: String
  asset_starts_with: String
  asset_starts_with_nocase: String
  asset_not_starts_with: String
  asset_not_starts_with_nocase: String
  asset_ends_with: String
  asset_ends_with_nocase: String
  asset_not_ends_with: String
  asset_not_ends_with_nocase: String
  asset_: xdai_Asset_filter
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  routersFee: BigInt
  routersFee_not: BigInt
  routersFee_gt: BigInt
  routersFee_lt: BigInt
  routersFee_gte: BigInt
  routersFee_lte: BigInt
  routersFee_in: [BigInt!]
  routersFee_not_in: [BigInt!]
  executedCaller: xdai_Bytes
  executedCaller_not: xdai_Bytes
  executedCaller_gt: xdai_Bytes
  executedCaller_lt: xdai_Bytes
  executedCaller_gte: xdai_Bytes
  executedCaller_lte: xdai_Bytes
  executedCaller_in: [xdai_Bytes!]
  executedCaller_not_in: [xdai_Bytes!]
  executedCaller_contains: xdai_Bytes
  executedCaller_not_contains: xdai_Bytes
  executedTransactionHash: xdai_Bytes
  executedTransactionHash_not: xdai_Bytes
  executedTransactionHash_gt: xdai_Bytes
  executedTransactionHash_lt: xdai_Bytes
  executedTransactionHash_gte: xdai_Bytes
  executedTransactionHash_lte: xdai_Bytes
  executedTransactionHash_in: [xdai_Bytes!]
  executedTransactionHash_not_in: [xdai_Bytes!]
  executedTransactionHash_contains: xdai_Bytes
  executedTransactionHash_not_contains: xdai_Bytes
  executedTimestamp: BigInt
  executedTimestamp_not: BigInt
  executedTimestamp_gt: BigInt
  executedTimestamp_lt: BigInt
  executedTimestamp_gte: BigInt
  executedTimestamp_lte: BigInt
  executedTimestamp_in: [BigInt!]
  executedTimestamp_not_in: [BigInt!]
  executedGasPrice: BigInt
  executedGasPrice_not: BigInt
  executedGasPrice_gt: BigInt
  executedGasPrice_lt: BigInt
  executedGasPrice_gte: BigInt
  executedGasPrice_lte: BigInt
  executedGasPrice_in: [BigInt!]
  executedGasPrice_not_in: [BigInt!]
  executedGasLimit: BigInt
  executedGasLimit_not: BigInt
  executedGasLimit_gt: BigInt
  executedGasLimit_lt: BigInt
  executedGasLimit_gte: BigInt
  executedGasLimit_lte: BigInt
  executedGasLimit_in: [BigInt!]
  executedGasLimit_not_in: [BigInt!]
  executedBlockNumber: BigInt
  executedBlockNumber_not: BigInt
  executedBlockNumber_gt: BigInt
  executedBlockNumber_lt: BigInt
  executedBlockNumber_gte: BigInt
  executedBlockNumber_lte: BigInt
  executedBlockNumber_in: [BigInt!]
  executedBlockNumber_not_in: [BigInt!]
  executedTxOrigin: xdai_Bytes
  executedTxOrigin_not: xdai_Bytes
  executedTxOrigin_gt: xdai_Bytes
  executedTxOrigin_lt: xdai_Bytes
  executedTxOrigin_gte: xdai_Bytes
  executedTxOrigin_lte: xdai_Bytes
  executedTxOrigin_in: [xdai_Bytes!]
  executedTxOrigin_not_in: [xdai_Bytes!]
  executedTxOrigin_contains: xdai_Bytes
  executedTxOrigin_not_contains: xdai_Bytes
  executedTxNonce: BigInt
  executedTxNonce_not: BigInt
  executedTxNonce_gt: BigInt
  executedTxNonce_lt: BigInt
  executedTxNonce_gte: BigInt
  executedTxNonce_lte: BigInt
  executedTxNonce_in: [BigInt!]
  executedTxNonce_not_in: [BigInt!]
  reconciledCaller: xdai_Bytes
  reconciledCaller_not: xdai_Bytes
  reconciledCaller_gt: xdai_Bytes
  reconciledCaller_lt: xdai_Bytes
  reconciledCaller_gte: xdai_Bytes
  reconciledCaller_lte: xdai_Bytes
  reconciledCaller_in: [xdai_Bytes!]
  reconciledCaller_not_in: [xdai_Bytes!]
  reconciledCaller_contains: xdai_Bytes
  reconciledCaller_not_contains: xdai_Bytes
  reconciledTransactionHash: xdai_Bytes
  reconciledTransactionHash_not: xdai_Bytes
  reconciledTransactionHash_gt: xdai_Bytes
  reconciledTransactionHash_lt: xdai_Bytes
  reconciledTransactionHash_gte: xdai_Bytes
  reconciledTransactionHash_lte: xdai_Bytes
  reconciledTransactionHash_in: [xdai_Bytes!]
  reconciledTransactionHash_not_in: [xdai_Bytes!]
  reconciledTransactionHash_contains: xdai_Bytes
  reconciledTransactionHash_not_contains: xdai_Bytes
  reconciledTimestamp: BigInt
  reconciledTimestamp_not: BigInt
  reconciledTimestamp_gt: BigInt
  reconciledTimestamp_lt: BigInt
  reconciledTimestamp_gte: BigInt
  reconciledTimestamp_lte: BigInt
  reconciledTimestamp_in: [BigInt!]
  reconciledTimestamp_not_in: [BigInt!]
  reconciledGasPrice: BigInt
  reconciledGasPrice_not: BigInt
  reconciledGasPrice_gt: BigInt
  reconciledGasPrice_lt: BigInt
  reconciledGasPrice_gte: BigInt
  reconciledGasPrice_lte: BigInt
  reconciledGasPrice_in: [BigInt!]
  reconciledGasPrice_not_in: [BigInt!]
  reconciledGasLimit: BigInt
  reconciledGasLimit_not: BigInt
  reconciledGasLimit_gt: BigInt
  reconciledGasLimit_lt: BigInt
  reconciledGasLimit_gte: BigInt
  reconciledGasLimit_lte: BigInt
  reconciledGasLimit_in: [BigInt!]
  reconciledGasLimit_not_in: [BigInt!]
  reconciledBlockNumber: BigInt
  reconciledBlockNumber_not: BigInt
  reconciledBlockNumber_gt: BigInt
  reconciledBlockNumber_lt: BigInt
  reconciledBlockNumber_gte: BigInt
  reconciledBlockNumber_lte: BigInt
  reconciledBlockNumber_in: [BigInt!]
  reconciledBlockNumber_not_in: [BigInt!]
  reconciledTxOrigin: xdai_Bytes
  reconciledTxOrigin_not: xdai_Bytes
  reconciledTxOrigin_gt: xdai_Bytes
  reconciledTxOrigin_lt: xdai_Bytes
  reconciledTxOrigin_gte: xdai_Bytes
  reconciledTxOrigin_lte: xdai_Bytes
  reconciledTxOrigin_in: [xdai_Bytes!]
  reconciledTxOrigin_not_in: [xdai_Bytes!]
  reconciledTxOrigin_contains: xdai_Bytes
  reconciledTxOrigin_not_contains: xdai_Bytes
  reconciledTxNonce: BigInt
  reconciledTxNonce_not: BigInt
  reconciledTxNonce_gt: BigInt
  reconciledTxNonce_lt: BigInt
  reconciledTxNonce_gte: BigInt
  reconciledTxNonce_lte: BigInt
  reconciledTxNonce_in: [BigInt!]
  reconciledTxNonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: xdai_BlockChangedFilter
  and: [xdai_DestinationTransfer_filter]
  or: [xdai_DestinationTransfer_filter]
}

enum xdai_DestinationTransfer_orderBy {
  id
  chainId
  transferId
  nonce
  status
  routers
  originDomain
  destinationDomain
  canonicalDomain
  to
  delegate
  receiveLocal
  callData
  slippage
  bumpSlippageCount
  originSender
  bridgedAmt
  normalizedIn
  canonicalId
  asset
  asset__id
  asset__key
  asset__decimal
  asset__adoptedDecimal
  asset__canonicalId
  asset__canonicalDomain
  asset__adoptedAsset
  asset__localAsset
  asset__blockNumber
  amount
  routersFee
  executedCaller
  executedTransactionHash
  executedTimestamp
  executedGasPrice
  executedGasLimit
  executedBlockNumber
  executedTxOrigin
  executedTxNonce
  reconciledCaller
  reconciledTransactionHash
  reconciledTimestamp
  reconciledGasPrice
  reconciledGasLimit
  reconciledBlockNumber
  reconciledTxOrigin
  reconciledTxNonce
}

"""
8 bytes signed integer

"""
scalar xdai_Int8

type xdai_OptimisticRootFinalized {
  id: ID!
  aggregateRoot: xdai_Bytes!
  timestamp: BigInt!
  blockNumber: BigInt
}

input xdai_OptimisticRootFinalized_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  aggregateRoot: xdai_Bytes
  aggregateRoot_not: xdai_Bytes
  aggregateRoot_gt: xdai_Bytes
  aggregateRoot_lt: xdai_Bytes
  aggregateRoot_gte: xdai_Bytes
  aggregateRoot_lte: xdai_Bytes
  aggregateRoot_in: [xdai_Bytes!]
  aggregateRoot_not_in: [xdai_Bytes!]
  aggregateRoot_contains: xdai_Bytes
  aggregateRoot_not_contains: xdai_Bytes
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: xdai_BlockChangedFilter
  and: [xdai_OptimisticRootFinalized_filter]
  or: [xdai_OptimisticRootFinalized_filter]
}

enum xdai_OptimisticRootFinalized_orderBy {
  id
  aggregateRoot
  timestamp
  blockNumber
}

"""Defines the order direction, either ascending or descending"""
enum xdai_OrderDirection {
  asc
  desc
}

type xdai_OriginMessage {
  id: ID!
  transferId: xdai_Bytes
  destinationDomain: BigInt
  leaf: xdai_Bytes
  index: BigInt
  message: xdai_Bytes
  root: xdai_Bytes
  transactionHash: xdai_Bytes
  blockNumber: BigInt
  rootCount: xdai_RootCount
}

input xdai_OriginMessage_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transferId: xdai_Bytes
  transferId_not: xdai_Bytes
  transferId_gt: xdai_Bytes
  transferId_lt: xdai_Bytes
  transferId_gte: xdai_Bytes
  transferId_lte: xdai_Bytes
  transferId_in: [xdai_Bytes!]
  transferId_not_in: [xdai_Bytes!]
  transferId_contains: xdai_Bytes
  transferId_not_contains: xdai_Bytes
  destinationDomain: BigInt
  destinationDomain_not: BigInt
  destinationDomain_gt: BigInt
  destinationDomain_lt: BigInt
  destinationDomain_gte: BigInt
  destinationDomain_lte: BigInt
  destinationDomain_in: [BigInt!]
  destinationDomain_not_in: [BigInt!]
  leaf: xdai_Bytes
  leaf_not: xdai_Bytes
  leaf_gt: xdai_Bytes
  leaf_lt: xdai_Bytes
  leaf_gte: xdai_Bytes
  leaf_lte: xdai_Bytes
  leaf_in: [xdai_Bytes!]
  leaf_not_in: [xdai_Bytes!]
  leaf_contains: xdai_Bytes
  leaf_not_contains: xdai_Bytes
  index: BigInt
  index_not: BigInt
  index_gt: BigInt
  index_lt: BigInt
  index_gte: BigInt
  index_lte: BigInt
  index_in: [BigInt!]
  index_not_in: [BigInt!]
  message: xdai_Bytes
  message_not: xdai_Bytes
  message_gt: xdai_Bytes
  message_lt: xdai_Bytes
  message_gte: xdai_Bytes
  message_lte: xdai_Bytes
  message_in: [xdai_Bytes!]
  message_not_in: [xdai_Bytes!]
  message_contains: xdai_Bytes
  message_not_contains: xdai_Bytes
  root: xdai_Bytes
  root_not: xdai_Bytes
  root_gt: xdai_Bytes
  root_lt: xdai_Bytes
  root_gte: xdai_Bytes
  root_lte: xdai_Bytes
  root_in: [xdai_Bytes!]
  root_not_in: [xdai_Bytes!]
  root_contains: xdai_Bytes
  root_not_contains: xdai_Bytes
  transactionHash: xdai_Bytes
  transactionHash_not: xdai_Bytes
  transactionHash_gt: xdai_Bytes
  transactionHash_lt: xdai_Bytes
  transactionHash_gte: xdai_Bytes
  transactionHash_lte: xdai_Bytes
  transactionHash_in: [xdai_Bytes!]
  transactionHash_not_in: [xdai_Bytes!]
  transactionHash_contains: xdai_Bytes
  transactionHash_not_contains: xdai_Bytes
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  rootCount: String
  rootCount_not: String
  rootCount_gt: String
  rootCount_lt: String
  rootCount_gte: String
  rootCount_lte: String
  rootCount_in: [String!]
  rootCount_not_in: [String!]
  rootCount_contains: String
  rootCount_contains_nocase: String
  rootCount_not_contains: String
  rootCount_not_contains_nocase: String
  rootCount_starts_with: String
  rootCount_starts_with_nocase: String
  rootCount_not_starts_with: String
  rootCount_not_starts_with_nocase: String
  rootCount_ends_with: String
  rootCount_ends_with_nocase: String
  rootCount_not_ends_with: String
  rootCount_not_ends_with_nocase: String
  rootCount_: xdai_RootCount_filter
  """Filter for the block changed event."""
  _change_block: xdai_BlockChangedFilter
  and: [xdai_OriginMessage_filter]
  or: [xdai_OriginMessage_filter]
}

enum xdai_OriginMessage_orderBy {
  id
  transferId
  destinationDomain
  leaf
  index
  message
  root
  transactionHash
  blockNumber
  rootCount
  rootCount__id
  rootCount__count
}

type xdai_OriginTransfer {
  id: ID!
  chainId: BigInt
  transferId: xdai_Bytes
  nonce: BigInt
  status: xdai_TransferStatus
  messageHash: xdai_Bytes
  originDomain: BigInt
  destinationDomain: BigInt
  canonicalDomain: BigInt
  to: xdai_Bytes
  delegate: xdai_Bytes
  receiveLocal: Boolean
  callData: xdai_Bytes
  slippage: BigInt
  originSender: xdai_Bytes
  bridgedAmt: BigInt
  normalizedIn: BigInt
  canonicalId: xdai_Bytes
  asset: xdai_Asset
  transactingAsset: xdai_Bytes
  message: xdai_OriginMessage
  bumpRelayerFeeCount: BigInt
  relayerFees(skip: Int = 0, first: Int = 100, orderBy: xdai_RelayerFee_orderBy, orderDirection: xdai_OrderDirection, where: xdai_RelayerFee_filter): [xdai_RelayerFee!]
  initialRelayerFeeAsset: xdai_Bytes
  caller: xdai_Bytes
  transactionHash: xdai_Bytes
  timestamp: BigInt
  gasPrice: BigInt
  gasLimit: BigInt
  blockNumber: BigInt
  txOrigin: xdai_Bytes
  txNonce: BigInt
}

input xdai_OriginTransfer_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  chainId: BigInt
  chainId_not: BigInt
  chainId_gt: BigInt
  chainId_lt: BigInt
  chainId_gte: BigInt
  chainId_lte: BigInt
  chainId_in: [BigInt!]
  chainId_not_in: [BigInt!]
  transferId: xdai_Bytes
  transferId_not: xdai_Bytes
  transferId_gt: xdai_Bytes
  transferId_lt: xdai_Bytes
  transferId_gte: xdai_Bytes
  transferId_lte: xdai_Bytes
  transferId_in: [xdai_Bytes!]
  transferId_not_in: [xdai_Bytes!]
  transferId_contains: xdai_Bytes
  transferId_not_contains: xdai_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  status: xdai_TransferStatus
  status_not: xdai_TransferStatus
  status_in: [xdai_TransferStatus!]
  status_not_in: [xdai_TransferStatus!]
  messageHash: xdai_Bytes
  messageHash_not: xdai_Bytes
  messageHash_gt: xdai_Bytes
  messageHash_lt: xdai_Bytes
  messageHash_gte: xdai_Bytes
  messageHash_lte: xdai_Bytes
  messageHash_in: [xdai_Bytes!]
  messageHash_not_in: [xdai_Bytes!]
  messageHash_contains: xdai_Bytes
  messageHash_not_contains: xdai_Bytes
  originDomain: BigInt
  originDomain_not: BigInt
  originDomain_gt: BigInt
  originDomain_lt: BigInt
  originDomain_gte: BigInt
  originDomain_lte: BigInt
  originDomain_in: [BigInt!]
  originDomain_not_in: [BigInt!]
  destinationDomain: BigInt
  destinationDomain_not: BigInt
  destinationDomain_gt: BigInt
  destinationDomain_lt: BigInt
  destinationDomain_gte: BigInt
  destinationDomain_lte: BigInt
  destinationDomain_in: [BigInt!]
  destinationDomain_not_in: [BigInt!]
  canonicalDomain: BigInt
  canonicalDomain_not: BigInt
  canonicalDomain_gt: BigInt
  canonicalDomain_lt: BigInt
  canonicalDomain_gte: BigInt
  canonicalDomain_lte: BigInt
  canonicalDomain_in: [BigInt!]
  canonicalDomain_not_in: [BigInt!]
  to: xdai_Bytes
  to_not: xdai_Bytes
  to_gt: xdai_Bytes
  to_lt: xdai_Bytes
  to_gte: xdai_Bytes
  to_lte: xdai_Bytes
  to_in: [xdai_Bytes!]
  to_not_in: [xdai_Bytes!]
  to_contains: xdai_Bytes
  to_not_contains: xdai_Bytes
  delegate: xdai_Bytes
  delegate_not: xdai_Bytes
  delegate_gt: xdai_Bytes
  delegate_lt: xdai_Bytes
  delegate_gte: xdai_Bytes
  delegate_lte: xdai_Bytes
  delegate_in: [xdai_Bytes!]
  delegate_not_in: [xdai_Bytes!]
  delegate_contains: xdai_Bytes
  delegate_not_contains: xdai_Bytes
  receiveLocal: Boolean
  receiveLocal_not: Boolean
  receiveLocal_in: [Boolean!]
  receiveLocal_not_in: [Boolean!]
  callData: xdai_Bytes
  callData_not: xdai_Bytes
  callData_gt: xdai_Bytes
  callData_lt: xdai_Bytes
  callData_gte: xdai_Bytes
  callData_lte: xdai_Bytes
  callData_in: [xdai_Bytes!]
  callData_not_in: [xdai_Bytes!]
  callData_contains: xdai_Bytes
  callData_not_contains: xdai_Bytes
  slippage: BigInt
  slippage_not: BigInt
  slippage_gt: BigInt
  slippage_lt: BigInt
  slippage_gte: BigInt
  slippage_lte: BigInt
  slippage_in: [BigInt!]
  slippage_not_in: [BigInt!]
  originSender: xdai_Bytes
  originSender_not: xdai_Bytes
  originSender_gt: xdai_Bytes
  originSender_lt: xdai_Bytes
  originSender_gte: xdai_Bytes
  originSender_lte: xdai_Bytes
  originSender_in: [xdai_Bytes!]
  originSender_not_in: [xdai_Bytes!]
  originSender_contains: xdai_Bytes
  originSender_not_contains: xdai_Bytes
  bridgedAmt: BigInt
  bridgedAmt_not: BigInt
  bridgedAmt_gt: BigInt
  bridgedAmt_lt: BigInt
  bridgedAmt_gte: BigInt
  bridgedAmt_lte: BigInt
  bridgedAmt_in: [BigInt!]
  bridgedAmt_not_in: [BigInt!]
  normalizedIn: BigInt
  normalizedIn_not: BigInt
  normalizedIn_gt: BigInt
  normalizedIn_lt: BigInt
  normalizedIn_gte: BigInt
  normalizedIn_lte: BigInt
  normalizedIn_in: [BigInt!]
  normalizedIn_not_in: [BigInt!]
  canonicalId: xdai_Bytes
  canonicalId_not: xdai_Bytes
  canonicalId_gt: xdai_Bytes
  canonicalId_lt: xdai_Bytes
  canonicalId_gte: xdai_Bytes
  canonicalId_lte: xdai_Bytes
  canonicalId_in: [xdai_Bytes!]
  canonicalId_not_in: [xdai_Bytes!]
  canonicalId_contains: xdai_Bytes
  canonicalId_not_contains: xdai_Bytes
  asset: String
  asset_not: String
  asset_gt: String
  asset_lt: String
  asset_gte: String
  asset_lte: String
  asset_in: [String!]
  asset_not_in: [String!]
  asset_contains: String
  asset_contains_nocase: String
  asset_not_contains: String
  asset_not_contains_nocase: String
  asset_starts_with: String
  asset_starts_with_nocase: String
  asset_not_starts_with: String
  asset_not_starts_with_nocase: String
  asset_ends_with: String
  asset_ends_with_nocase: String
  asset_not_ends_with: String
  asset_not_ends_with_nocase: String
  asset_: xdai_Asset_filter
  transactingAsset: xdai_Bytes
  transactingAsset_not: xdai_Bytes
  transactingAsset_gt: xdai_Bytes
  transactingAsset_lt: xdai_Bytes
  transactingAsset_gte: xdai_Bytes
  transactingAsset_lte: xdai_Bytes
  transactingAsset_in: [xdai_Bytes!]
  transactingAsset_not_in: [xdai_Bytes!]
  transactingAsset_contains: xdai_Bytes
  transactingAsset_not_contains: xdai_Bytes
  message: String
  message_not: String
  message_gt: String
  message_lt: String
  message_gte: String
  message_lte: String
  message_in: [String!]
  message_not_in: [String!]
  message_contains: String
  message_contains_nocase: String
  message_not_contains: String
  message_not_contains_nocase: String
  message_starts_with: String
  message_starts_with_nocase: String
  message_not_starts_with: String
  message_not_starts_with_nocase: String
  message_ends_with: String
  message_ends_with_nocase: String
  message_not_ends_with: String
  message_not_ends_with_nocase: String
  message_: xdai_OriginMessage_filter
  bumpRelayerFeeCount: BigInt
  bumpRelayerFeeCount_not: BigInt
  bumpRelayerFeeCount_gt: BigInt
  bumpRelayerFeeCount_lt: BigInt
  bumpRelayerFeeCount_gte: BigInt
  bumpRelayerFeeCount_lte: BigInt
  bumpRelayerFeeCount_in: [BigInt!]
  bumpRelayerFeeCount_not_in: [BigInt!]
  relayerFees: [String!]
  relayerFees_not: [String!]
  relayerFees_contains: [String!]
  relayerFees_contains_nocase: [String!]
  relayerFees_not_contains: [String!]
  relayerFees_not_contains_nocase: [String!]
  relayerFees_: xdai_RelayerFee_filter
  initialRelayerFeeAsset: xdai_Bytes
  initialRelayerFeeAsset_not: xdai_Bytes
  initialRelayerFeeAsset_gt: xdai_Bytes
  initialRelayerFeeAsset_lt: xdai_Bytes
  initialRelayerFeeAsset_gte: xdai_Bytes
  initialRelayerFeeAsset_lte: xdai_Bytes
  initialRelayerFeeAsset_in: [xdai_Bytes!]
  initialRelayerFeeAsset_not_in: [xdai_Bytes!]
  initialRelayerFeeAsset_contains: xdai_Bytes
  initialRelayerFeeAsset_not_contains: xdai_Bytes
  caller: xdai_Bytes
  caller_not: xdai_Bytes
  caller_gt: xdai_Bytes
  caller_lt: xdai_Bytes
  caller_gte: xdai_Bytes
  caller_lte: xdai_Bytes
  caller_in: [xdai_Bytes!]
  caller_not_in: [xdai_Bytes!]
  caller_contains: xdai_Bytes
  caller_not_contains: xdai_Bytes
  transactionHash: xdai_Bytes
  transactionHash_not: xdai_Bytes
  transactionHash_gt: xdai_Bytes
  transactionHash_lt: xdai_Bytes
  transactionHash_gte: xdai_Bytes
  transactionHash_lte: xdai_Bytes
  transactionHash_in: [xdai_Bytes!]
  transactionHash_not_in: [xdai_Bytes!]
  transactionHash_contains: xdai_Bytes
  transactionHash_not_contains: xdai_Bytes
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  gasLimit: BigInt
  gasLimit_not: BigInt
  gasLimit_gt: BigInt
  gasLimit_lt: BigInt
  gasLimit_gte: BigInt
  gasLimit_lte: BigInt
  gasLimit_in: [BigInt!]
  gasLimit_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  txOrigin: xdai_Bytes
  txOrigin_not: xdai_Bytes
  txOrigin_gt: xdai_Bytes
  txOrigin_lt: xdai_Bytes
  txOrigin_gte: xdai_Bytes
  txOrigin_lte: xdai_Bytes
  txOrigin_in: [xdai_Bytes!]
  txOrigin_not_in: [xdai_Bytes!]
  txOrigin_contains: xdai_Bytes
  txOrigin_not_contains: xdai_Bytes
  txNonce: BigInt
  txNonce_not: BigInt
  txNonce_gt: BigInt
  txNonce_lt: BigInt
  txNonce_gte: BigInt
  txNonce_lte: BigInt
  txNonce_in: [BigInt!]
  txNonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: xdai_BlockChangedFilter
  and: [xdai_OriginTransfer_filter]
  or: [xdai_OriginTransfer_filter]
}

enum xdai_OriginTransfer_orderBy {
  id
  chainId
  transferId
  nonce
  status
  messageHash
  originDomain
  destinationDomain
  canonicalDomain
  to
  delegate
  receiveLocal
  callData
  slippage
  originSender
  bridgedAmt
  normalizedIn
  canonicalId
  asset
  asset__id
  asset__key
  asset__decimal
  asset__adoptedDecimal
  asset__canonicalId
  asset__canonicalDomain
  asset__adoptedAsset
  asset__localAsset
  asset__blockNumber
  transactingAsset
  message
  message__id
  message__transferId
  message__destinationDomain
  message__leaf
  message__index
  message__message
  message__root
  message__transactionHash
  message__blockNumber
  bumpRelayerFeeCount
  relayerFees
  initialRelayerFeeAsset
  caller
  transactionHash
  timestamp
  gasPrice
  gasLimit
  blockNumber
  txOrigin
  txNonce
}

type xdai_Relayer {
  id: ID!
  isActive: Boolean!
  relayer: xdai_Bytes
}

type xdai_RelayerFee {
  id: ID!
  transfer: xdai_OriginTransfer!
  fee: BigInt!
  asset: xdai_Bytes!
}

input xdai_RelayerFee_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transfer: String
  transfer_not: String
  transfer_gt: String
  transfer_lt: String
  transfer_gte: String
  transfer_lte: String
  transfer_in: [String!]
  transfer_not_in: [String!]
  transfer_contains: String
  transfer_contains_nocase: String
  transfer_not_contains: String
  transfer_not_contains_nocase: String
  transfer_starts_with: String
  transfer_starts_with_nocase: String
  transfer_not_starts_with: String
  transfer_not_starts_with_nocase: String
  transfer_ends_with: String
  transfer_ends_with_nocase: String
  transfer_not_ends_with: String
  transfer_not_ends_with_nocase: String
  transfer_: xdai_OriginTransfer_filter
  fee: BigInt
  fee_not: BigInt
  fee_gt: BigInt
  fee_lt: BigInt
  fee_gte: BigInt
  fee_lte: BigInt
  fee_in: [BigInt!]
  fee_not_in: [BigInt!]
  asset: xdai_Bytes
  asset_not: xdai_Bytes
  asset_gt: xdai_Bytes
  asset_lt: xdai_Bytes
  asset_gte: xdai_Bytes
  asset_lte: xdai_Bytes
  asset_in: [xdai_Bytes!]
  asset_not_in: [xdai_Bytes!]
  asset_contains: xdai_Bytes
  asset_not_contains: xdai_Bytes
  """Filter for the block changed event."""
  _change_block: xdai_BlockChangedFilter
  and: [xdai_RelayerFee_filter]
  or: [xdai_RelayerFee_filter]
}

enum xdai_RelayerFee_orderBy {
  id
  transfer
  transfer__id
  transfer__chainId
  transfer__transferId
  transfer__nonce
  transfer__status
  transfer__messageHash
  transfer__originDomain
  transfer__destinationDomain
  transfer__canonicalDomain
  transfer__to
  transfer__delegate
  transfer__receiveLocal
  transfer__callData
  transfer__slippage
  transfer__originSender
  transfer__bridgedAmt
  transfer__normalizedIn
  transfer__canonicalId
  transfer__transactingAsset
  transfer__bumpRelayerFeeCount
  transfer__initialRelayerFeeAsset
  transfer__caller
  transfer__transactionHash
  transfer__timestamp
  transfer__gasPrice
  transfer__gasLimit
  transfer__blockNumber
  transfer__txOrigin
  transfer__txNonce
  fee
  asset
}

type xdai_RelayerFeesIncrease {
  id: ID!
  transfer: xdai_OriginTransfer!
  increase: BigInt
  asset: xdai_Bytes
  caller: xdai_Bytes!
  transactionHash: xdai_Bytes!
  timestamp: BigInt!
  gasPrice: BigInt!
  gasLimit: BigInt!
  blockNumber: BigInt!
}

input xdai_RelayerFeesIncrease_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transfer: String
  transfer_not: String
  transfer_gt: String
  transfer_lt: String
  transfer_gte: String
  transfer_lte: String
  transfer_in: [String!]
  transfer_not_in: [String!]
  transfer_contains: String
  transfer_contains_nocase: String
  transfer_not_contains: String
  transfer_not_contains_nocase: String
  transfer_starts_with: String
  transfer_starts_with_nocase: String
  transfer_not_starts_with: String
  transfer_not_starts_with_nocase: String
  transfer_ends_with: String
  transfer_ends_with_nocase: String
  transfer_not_ends_with: String
  transfer_not_ends_with_nocase: String
  transfer_: xdai_OriginTransfer_filter
  increase: BigInt
  increase_not: BigInt
  increase_gt: BigInt
  increase_lt: BigInt
  increase_gte: BigInt
  increase_lte: BigInt
  increase_in: [BigInt!]
  increase_not_in: [BigInt!]
  asset: xdai_Bytes
  asset_not: xdai_Bytes
  asset_gt: xdai_Bytes
  asset_lt: xdai_Bytes
  asset_gte: xdai_Bytes
  asset_lte: xdai_Bytes
  asset_in: [xdai_Bytes!]
  asset_not_in: [xdai_Bytes!]
  asset_contains: xdai_Bytes
  asset_not_contains: xdai_Bytes
  caller: xdai_Bytes
  caller_not: xdai_Bytes
  caller_gt: xdai_Bytes
  caller_lt: xdai_Bytes
  caller_gte: xdai_Bytes
  caller_lte: xdai_Bytes
  caller_in: [xdai_Bytes!]
  caller_not_in: [xdai_Bytes!]
  caller_contains: xdai_Bytes
  caller_not_contains: xdai_Bytes
  transactionHash: xdai_Bytes
  transactionHash_not: xdai_Bytes
  transactionHash_gt: xdai_Bytes
  transactionHash_lt: xdai_Bytes
  transactionHash_gte: xdai_Bytes
  transactionHash_lte: xdai_Bytes
  transactionHash_in: [xdai_Bytes!]
  transactionHash_not_in: [xdai_Bytes!]
  transactionHash_contains: xdai_Bytes
  transactionHash_not_contains: xdai_Bytes
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  gasLimit: BigInt
  gasLimit_not: BigInt
  gasLimit_gt: BigInt
  gasLimit_lt: BigInt
  gasLimit_gte: BigInt
  gasLimit_lte: BigInt
  gasLimit_in: [BigInt!]
  gasLimit_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: xdai_BlockChangedFilter
  and: [xdai_RelayerFeesIncrease_filter]
  or: [xdai_RelayerFeesIncrease_filter]
}

enum xdai_RelayerFeesIncrease_orderBy {
  id
  transfer
  transfer__id
  transfer__chainId
  transfer__transferId
  transfer__nonce
  transfer__status
  transfer__messageHash
  transfer__originDomain
  transfer__destinationDomain
  transfer__canonicalDomain
  transfer__to
  transfer__delegate
  transfer__receiveLocal
  transfer__callData
  transfer__slippage
  transfer__originSender
  transfer__bridgedAmt
  transfer__normalizedIn
  transfer__canonicalId
  transfer__transactingAsset
  transfer__bumpRelayerFeeCount
  transfer__initialRelayerFeeAsset
  transfer__caller
  transfer__transactionHash
  transfer__timestamp
  transfer__gasPrice
  transfer__gasLimit
  transfer__blockNumber
  transfer__txOrigin
  transfer__txNonce
  increase
  asset
  caller
  transactionHash
  timestamp
  gasPrice
  gasLimit
  blockNumber
}

input xdai_Relayer_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  isActive: Boolean
  isActive_not: Boolean
  isActive_in: [Boolean!]
  isActive_not_in: [Boolean!]
  relayer: xdai_Bytes
  relayer_not: xdai_Bytes
  relayer_gt: xdai_Bytes
  relayer_lt: xdai_Bytes
  relayer_gte: xdai_Bytes
  relayer_lte: xdai_Bytes
  relayer_in: [xdai_Bytes!]
  relayer_not_in: [xdai_Bytes!]
  relayer_contains: xdai_Bytes
  relayer_not_contains: xdai_Bytes
  """Filter for the block changed event."""
  _change_block: xdai_BlockChangedFilter
  and: [xdai_Relayer_filter]
  or: [xdai_Relayer_filter]
}

enum xdai_Relayer_orderBy {
  id
  isActive
  relayer
}

type xdai_RootCount {
  id: ID!
  count: BigInt
}

input xdai_RootCount_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  count: BigInt
  count_not: BigInt
  count_gt: BigInt
  count_lt: BigInt
  count_gte: BigInt
  count_lte: BigInt
  count_in: [BigInt!]
  count_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: xdai_BlockChangedFilter
  and: [xdai_RootCount_filter]
  or: [xdai_RootCount_filter]
}

enum xdai_RootCount_orderBy {
  id
  count
}

type xdai_RootMessageSent {
  id: ID!
  spokeDomain: BigInt
  hubDomain: BigInt
  root: xdai_Bytes
  count: BigInt
  caller: xdai_Bytes
  transactionHash: xdai_Bytes
  timestamp: BigInt
  gasPrice: BigInt
  gasLimit: BigInt
  blockNumber: BigInt
}

input xdai_RootMessageSent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  spokeDomain: BigInt
  spokeDomain_not: BigInt
  spokeDomain_gt: BigInt
  spokeDomain_lt: BigInt
  spokeDomain_gte: BigInt
  spokeDomain_lte: BigInt
  spokeDomain_in: [BigInt!]
  spokeDomain_not_in: [BigInt!]
  hubDomain: BigInt
  hubDomain_not: BigInt
  hubDomain_gt: BigInt
  hubDomain_lt: BigInt
  hubDomain_gte: BigInt
  hubDomain_lte: BigInt
  hubDomain_in: [BigInt!]
  hubDomain_not_in: [BigInt!]
  root: xdai_Bytes
  root_not: xdai_Bytes
  root_gt: xdai_Bytes
  root_lt: xdai_Bytes
  root_gte: xdai_Bytes
  root_lte: xdai_Bytes
  root_in: [xdai_Bytes!]
  root_not_in: [xdai_Bytes!]
  root_contains: xdai_Bytes
  root_not_contains: xdai_Bytes
  count: BigInt
  count_not: BigInt
  count_gt: BigInt
  count_lt: BigInt
  count_gte: BigInt
  count_lte: BigInt
  count_in: [BigInt!]
  count_not_in: [BigInt!]
  caller: xdai_Bytes
  caller_not: xdai_Bytes
  caller_gt: xdai_Bytes
  caller_lt: xdai_Bytes
  caller_gte: xdai_Bytes
  caller_lte: xdai_Bytes
  caller_in: [xdai_Bytes!]
  caller_not_in: [xdai_Bytes!]
  caller_contains: xdai_Bytes
  caller_not_contains: xdai_Bytes
  transactionHash: xdai_Bytes
  transactionHash_not: xdai_Bytes
  transactionHash_gt: xdai_Bytes
  transactionHash_lt: xdai_Bytes
  transactionHash_gte: xdai_Bytes
  transactionHash_lte: xdai_Bytes
  transactionHash_in: [xdai_Bytes!]
  transactionHash_not_in: [xdai_Bytes!]
  transactionHash_contains: xdai_Bytes
  transactionHash_not_contains: xdai_Bytes
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  gasLimit: BigInt
  gasLimit_not: BigInt
  gasLimit_gt: BigInt
  gasLimit_lt: BigInt
  gasLimit_gte: BigInt
  gasLimit_lte: BigInt
  gasLimit_in: [BigInt!]
  gasLimit_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: xdai_BlockChangedFilter
  and: [xdai_RootMessageSent_filter]
  or: [xdai_RootMessageSent_filter]
}

enum xdai_RootMessageSent_orderBy {
  id
  spokeDomain
  hubDomain
  root
  count
  caller
  transactionHash
  timestamp
  gasPrice
  gasLimit
  blockNumber
}

type xdai_Router {
  id: ID!
  isActive: Boolean!
  owner: xdai_Bytes
  recipient: xdai_Bytes
  proposedOwner: xdai_Bytes
  proposedTimestamp: BigInt
  assetBalances(skip: Int = 0, first: Int = 100, orderBy: xdai_AssetBalance_orderBy, orderDirection: xdai_OrderDirection, where: xdai_AssetBalance_filter): [xdai_AssetBalance!]!
}

type xdai_RouterDailyTVL {
  id: ID!
  router: xdai_Router!
  asset: xdai_Asset!
  timestamp: BigInt!
  balance: BigInt!
}

input xdai_RouterDailyTVL_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  router: String
  router_not: String
  router_gt: String
  router_lt: String
  router_gte: String
  router_lte: String
  router_in: [String!]
  router_not_in: [String!]
  router_contains: String
  router_contains_nocase: String
  router_not_contains: String
  router_not_contains_nocase: String
  router_starts_with: String
  router_starts_with_nocase: String
  router_not_starts_with: String
  router_not_starts_with_nocase: String
  router_ends_with: String
  router_ends_with_nocase: String
  router_not_ends_with: String
  router_not_ends_with_nocase: String
  router_: xdai_Router_filter
  asset: String
  asset_not: String
  asset_gt: String
  asset_lt: String
  asset_gte: String
  asset_lte: String
  asset_in: [String!]
  asset_not_in: [String!]
  asset_contains: String
  asset_contains_nocase: String
  asset_not_contains: String
  asset_not_contains_nocase: String
  asset_starts_with: String
  asset_starts_with_nocase: String
  asset_not_starts_with: String
  asset_not_starts_with_nocase: String
  asset_ends_with: String
  asset_ends_with_nocase: String
  asset_not_ends_with: String
  asset_not_ends_with_nocase: String
  asset_: xdai_Asset_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  balance: BigInt
  balance_not: BigInt
  balance_gt: BigInt
  balance_lt: BigInt
  balance_gte: BigInt
  balance_lte: BigInt
  balance_in: [BigInt!]
  balance_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: xdai_BlockChangedFilter
  and: [xdai_RouterDailyTVL_filter]
  or: [xdai_RouterDailyTVL_filter]
}

enum xdai_RouterDailyTVL_orderBy {
  id
  router
  router__id
  router__isActive
  router__owner
  router__recipient
  router__proposedOwner
  router__proposedTimestamp
  asset
  asset__id
  asset__key
  asset__decimal
  asset__adoptedDecimal
  asset__canonicalId
  asset__canonicalDomain
  asset__adoptedAsset
  asset__localAsset
  asset__blockNumber
  timestamp
  balance
}

type xdai_RouterLiquidityEvent {
  id: ID!
  type: xdai_RouterLiquidityEventType
  router: xdai_Router!
  asset: xdai_Asset!
  amount: BigInt!
  balance: BigInt!
  caller: xdai_Bytes
  blockNumber: BigInt!
  timestamp: BigInt!
  transactionHash: xdai_Bytes!
  nonce: BigInt!
}

enum xdai_RouterLiquidityEventType {
  Add
  Remove
}

input xdai_RouterLiquidityEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  type: xdai_RouterLiquidityEventType
  type_not: xdai_RouterLiquidityEventType
  type_in: [xdai_RouterLiquidityEventType!]
  type_not_in: [xdai_RouterLiquidityEventType!]
  router: String
  router_not: String
  router_gt: String
  router_lt: String
  router_gte: String
  router_lte: String
  router_in: [String!]
  router_not_in: [String!]
  router_contains: String
  router_contains_nocase: String
  router_not_contains: String
  router_not_contains_nocase: String
  router_starts_with: String
  router_starts_with_nocase: String
  router_not_starts_with: String
  router_not_starts_with_nocase: String
  router_ends_with: String
  router_ends_with_nocase: String
  router_not_ends_with: String
  router_not_ends_with_nocase: String
  router_: xdai_Router_filter
  asset: String
  asset_not: String
  asset_gt: String
  asset_lt: String
  asset_gte: String
  asset_lte: String
  asset_in: [String!]
  asset_not_in: [String!]
  asset_contains: String
  asset_contains_nocase: String
  asset_not_contains: String
  asset_not_contains_nocase: String
  asset_starts_with: String
  asset_starts_with_nocase: String
  asset_not_starts_with: String
  asset_not_starts_with_nocase: String
  asset_ends_with: String
  asset_ends_with_nocase: String
  asset_not_ends_with: String
  asset_not_ends_with_nocase: String
  asset_: xdai_Asset_filter
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  balance: BigInt
  balance_not: BigInt
  balance_gt: BigInt
  balance_lt: BigInt
  balance_gte: BigInt
  balance_lte: BigInt
  balance_in: [BigInt!]
  balance_not_in: [BigInt!]
  caller: xdai_Bytes
  caller_not: xdai_Bytes
  caller_gt: xdai_Bytes
  caller_lt: xdai_Bytes
  caller_gte: xdai_Bytes
  caller_lte: xdai_Bytes
  caller_in: [xdai_Bytes!]
  caller_not_in: [xdai_Bytes!]
  caller_contains: xdai_Bytes
  caller_not_contains: xdai_Bytes
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transactionHash: xdai_Bytes
  transactionHash_not: xdai_Bytes
  transactionHash_gt: xdai_Bytes
  transactionHash_lt: xdai_Bytes
  transactionHash_gte: xdai_Bytes
  transactionHash_lte: xdai_Bytes
  transactionHash_in: [xdai_Bytes!]
  transactionHash_not_in: [xdai_Bytes!]
  transactionHash_contains: xdai_Bytes
  transactionHash_not_contains: xdai_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: xdai_BlockChangedFilter
  and: [xdai_RouterLiquidityEvent_filter]
  or: [xdai_RouterLiquidityEvent_filter]
}

enum xdai_RouterLiquidityEvent_orderBy {
  id
  type
  router
  router__id
  router__isActive
  router__owner
  router__recipient
  router__proposedOwner
  router__proposedTimestamp
  asset
  asset__id
  asset__key
  asset__decimal
  asset__adoptedDecimal
  asset__canonicalId
  asset__canonicalDomain
  asset__adoptedAsset
  asset__localAsset
  asset__blockNumber
  amount
  balance
  caller
  blockNumber
  timestamp
  transactionHash
  nonce
}

input xdai_Router_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  isActive: Boolean
  isActive_not: Boolean
  isActive_in: [Boolean!]
  isActive_not_in: [Boolean!]
  owner: xdai_Bytes
  owner_not: xdai_Bytes
  owner_gt: xdai_Bytes
  owner_lt: xdai_Bytes
  owner_gte: xdai_Bytes
  owner_lte: xdai_Bytes
  owner_in: [xdai_Bytes!]
  owner_not_in: [xdai_Bytes!]
  owner_contains: xdai_Bytes
  owner_not_contains: xdai_Bytes
  recipient: xdai_Bytes
  recipient_not: xdai_Bytes
  recipient_gt: xdai_Bytes
  recipient_lt: xdai_Bytes
  recipient_gte: xdai_Bytes
  recipient_lte: xdai_Bytes
  recipient_in: [xdai_Bytes!]
  recipient_not_in: [xdai_Bytes!]
  recipient_contains: xdai_Bytes
  recipient_not_contains: xdai_Bytes
  proposedOwner: xdai_Bytes
  proposedOwner_not: xdai_Bytes
  proposedOwner_gt: xdai_Bytes
  proposedOwner_lt: xdai_Bytes
  proposedOwner_gte: xdai_Bytes
  proposedOwner_lte: xdai_Bytes
  proposedOwner_in: [xdai_Bytes!]
  proposedOwner_not_in: [xdai_Bytes!]
  proposedOwner_contains: xdai_Bytes
  proposedOwner_not_contains: xdai_Bytes
  proposedTimestamp: BigInt
  proposedTimestamp_not: BigInt
  proposedTimestamp_gt: BigInt
  proposedTimestamp_lt: BigInt
  proposedTimestamp_gte: BigInt
  proposedTimestamp_lte: BigInt
  proposedTimestamp_in: [BigInt!]
  proposedTimestamp_not_in: [BigInt!]
  assetBalances_: xdai_AssetBalance_filter
  """Filter for the block changed event."""
  _change_block: xdai_BlockChangedFilter
  and: [xdai_Router_filter]
  or: [xdai_Router_filter]
}

enum xdai_Router_orderBy {
  id
  isActive
  owner
  recipient
  proposedOwner
  proposedTimestamp
  assetBalances
}

type xdai_Sequencer {
  id: ID!
  isActive: Boolean!
  sequencer: xdai_Bytes
}

input xdai_Sequencer_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  isActive: Boolean
  isActive_not: Boolean
  isActive_in: [Boolean!]
  isActive_not_in: [Boolean!]
  sequencer: xdai_Bytes
  sequencer_not: xdai_Bytes
  sequencer_gt: xdai_Bytes
  sequencer_lt: xdai_Bytes
  sequencer_gte: xdai_Bytes
  sequencer_lte: xdai_Bytes
  sequencer_in: [xdai_Bytes!]
  sequencer_not_in: [xdai_Bytes!]
  sequencer_contains: xdai_Bytes
  sequencer_not_contains: xdai_Bytes
  """Filter for the block changed event."""
  _change_block: xdai_BlockChangedFilter
  and: [xdai_Sequencer_filter]
  or: [xdai_Sequencer_filter]
}

enum xdai_Sequencer_orderBy {
  id
  isActive
  sequencer
}

type xdai_Setting {
  id: ID!
  maxRoutersPerTransfer: BigInt!
  caller: xdai_Bytes!
}

input xdai_Setting_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  maxRoutersPerTransfer: BigInt
  maxRoutersPerTransfer_not: BigInt
  maxRoutersPerTransfer_gt: BigInt
  maxRoutersPerTransfer_lt: BigInt
  maxRoutersPerTransfer_gte: BigInt
  maxRoutersPerTransfer_lte: BigInt
  maxRoutersPerTransfer_in: [BigInt!]
  maxRoutersPerTransfer_not_in: [BigInt!]
  caller: xdai_Bytes
  caller_not: xdai_Bytes
  caller_gt: xdai_Bytes
  caller_lt: xdai_Bytes
  caller_gte: xdai_Bytes
  caller_lte: xdai_Bytes
  caller_in: [xdai_Bytes!]
  caller_not_in: [xdai_Bytes!]
  caller_contains: xdai_Bytes
  caller_not_contains: xdai_Bytes
  """Filter for the block changed event."""
  _change_block: xdai_BlockChangedFilter
  and: [xdai_Setting_filter]
  or: [xdai_Setting_filter]
}

enum xdai_Setting_orderBy {
  id
  maxRoutersPerTransfer
  caller
}

type xdai_SlippageUpdate {
  id: ID!
  transfer: xdai_DestinationTransfer!
  slippage: BigInt!
  caller: xdai_Bytes!
  transactionHash: xdai_Bytes!
  timestamp: BigInt!
  gasPrice: BigInt!
  gasLimit: BigInt!
  blockNumber: BigInt!
}

input xdai_SlippageUpdate_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transfer: String
  transfer_not: String
  transfer_gt: String
  transfer_lt: String
  transfer_gte: String
  transfer_lte: String
  transfer_in: [String!]
  transfer_not_in: [String!]
  transfer_contains: String
  transfer_contains_nocase: String
  transfer_not_contains: String
  transfer_not_contains_nocase: String
  transfer_starts_with: String
  transfer_starts_with_nocase: String
  transfer_not_starts_with: String
  transfer_not_starts_with_nocase: String
  transfer_ends_with: String
  transfer_ends_with_nocase: String
  transfer_not_ends_with: String
  transfer_not_ends_with_nocase: String
  transfer_: xdai_DestinationTransfer_filter
  slippage: BigInt
  slippage_not: BigInt
  slippage_gt: BigInt
  slippage_lt: BigInt
  slippage_gte: BigInt
  slippage_lte: BigInt
  slippage_in: [BigInt!]
  slippage_not_in: [BigInt!]
  caller: xdai_Bytes
  caller_not: xdai_Bytes
  caller_gt: xdai_Bytes
  caller_lt: xdai_Bytes
  caller_gte: xdai_Bytes
  caller_lte: xdai_Bytes
  caller_in: [xdai_Bytes!]
  caller_not_in: [xdai_Bytes!]
  caller_contains: xdai_Bytes
  caller_not_contains: xdai_Bytes
  transactionHash: xdai_Bytes
  transactionHash_not: xdai_Bytes
  transactionHash_gt: xdai_Bytes
  transactionHash_lt: xdai_Bytes
  transactionHash_gte: xdai_Bytes
  transactionHash_lte: xdai_Bytes
  transactionHash_in: [xdai_Bytes!]
  transactionHash_not_in: [xdai_Bytes!]
  transactionHash_contains: xdai_Bytes
  transactionHash_not_contains: xdai_Bytes
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  gasLimit: BigInt
  gasLimit_not: BigInt
  gasLimit_gt: BigInt
  gasLimit_lt: BigInt
  gasLimit_gte: BigInt
  gasLimit_lte: BigInt
  gasLimit_in: [BigInt!]
  gasLimit_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: xdai_BlockChangedFilter
  and: [xdai_SlippageUpdate_filter]
  or: [xdai_SlippageUpdate_filter]
}

enum xdai_SlippageUpdate_orderBy {
  id
  transfer
  transfer__id
  transfer__chainId
  transfer__transferId
  transfer__nonce
  transfer__status
  transfer__originDomain
  transfer__destinationDomain
  transfer__canonicalDomain
  transfer__to
  transfer__delegate
  transfer__receiveLocal
  transfer__callData
  transfer__slippage
  transfer__bumpSlippageCount
  transfer__originSender
  transfer__bridgedAmt
  transfer__normalizedIn
  transfer__canonicalId
  transfer__amount
  transfer__routersFee
  transfer__executedCaller
  transfer__executedTransactionHash
  transfer__executedTimestamp
  transfer__executedGasPrice
  transfer__executedGasLimit
  transfer__executedBlockNumber
  transfer__executedTxOrigin
  transfer__executedTxNonce
  transfer__reconciledCaller
  transfer__reconciledTransactionHash
  transfer__reconciledTimestamp
  transfer__reconciledGasPrice
  transfer__reconciledGasLimit
  transfer__reconciledBlockNumber
  transfer__reconciledTxOrigin
  transfer__reconciledTxNonce
  slippage
  caller
  transactionHash
  timestamp
  gasPrice
  gasLimit
  blockNumber
}

type xdai_SnapshotRoot {
  id: ID!
  spokeDomain: BigInt
  root: xdai_Bytes!
  count: BigInt!
  timestamp: BigInt!
  blockNumber: BigInt!
}

input xdai_SnapshotRoot_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  spokeDomain: BigInt
  spokeDomain_not: BigInt
  spokeDomain_gt: BigInt
  spokeDomain_lt: BigInt
  spokeDomain_gte: BigInt
  spokeDomain_lte: BigInt
  spokeDomain_in: [BigInt!]
  spokeDomain_not_in: [BigInt!]
  root: xdai_Bytes
  root_not: xdai_Bytes
  root_gt: xdai_Bytes
  root_lt: xdai_Bytes
  root_gte: xdai_Bytes
  root_lte: xdai_Bytes
  root_in: [xdai_Bytes!]
  root_not_in: [xdai_Bytes!]
  root_contains: xdai_Bytes
  root_not_contains: xdai_Bytes
  count: BigInt
  count_not: BigInt
  count_gt: BigInt
  count_lt: BigInt
  count_gte: BigInt
  count_lte: BigInt
  count_in: [BigInt!]
  count_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: xdai_BlockChangedFilter
  and: [xdai_SnapshotRoot_filter]
  or: [xdai_SnapshotRoot_filter]
}

enum xdai_SnapshotRoot_orderBy {
  id
  spokeDomain
  root
  count
  timestamp
  blockNumber
}

type xdai_SpokeConnectorMode {
  id: ID!
  mode: String!
}

input xdai_SpokeConnectorMode_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  mode: String
  mode_not: String
  mode_gt: String
  mode_lt: String
  mode_gte: String
  mode_lte: String
  mode_in: [String!]
  mode_not_in: [String!]
  mode_contains: String
  mode_contains_nocase: String
  mode_not_contains: String
  mode_not_contains_nocase: String
  mode_starts_with: String
  mode_starts_with_nocase: String
  mode_not_starts_with: String
  mode_not_starts_with_nocase: String
  mode_ends_with: String
  mode_ends_with_nocase: String
  mode_not_ends_with: String
  mode_not_ends_with_nocase: String
  """Filter for the block changed event."""
  _change_block: xdai_BlockChangedFilter
  and: [xdai_SpokeConnectorMode_filter]
  or: [xdai_SpokeConnectorMode_filter]
}

enum xdai_SpokeConnectorMode_orderBy {
  id
  mode
}

enum xdai_TransferStatus {
  XCalled
  Executed
  Reconciled
  CompletedSlow
  CompletedFast
}

type xdai__Block_ {
  """The hash of the block"""
  hash: xdai_Bytes
  """The block number"""
  number: Int!
  """Integer representation of the timestamp stored in blocks for the chain"""
  timestamp: Int
  """The hash of the parent block"""
  parentHash: xdai_Bytes
}

"""The type for the top-level _meta field"""
type xdai__Meta_ {
  """
  Information about a specific subgraph block. The hash of the block
  will be null if the _meta field has a block constraint that asks for
  a block number. It will be filled if the _meta field has no block constraint
  and therefore asks for the latest  block
  
  """
  block: xdai__Block_!
  """The deployment ID"""
  deployment: String!
  """If `true`, the subgraph encountered indexing errors at some past block"""
  hasIndexingErrors: Boolean!
}

enum avalanche_swap_Aggregation_interval {
  hour
  day
}

scalar avalanche_swap_BigDecimal

input avalanche_swap_BlockChangedFilter {
  number_gte: Int!
}

input avalanche_swap_Block_height {
  hash: avalanche_swap_Bytes
  number: Int
  number_gte: Int
}

scalar avalanche_swap_Bytes

"""
8 bytes signed integer

"""
scalar avalanche_swap_Int8

type avalanche_swap_LpAccount {
  id: ID!
  address: avalanche_swap_Bytes!
  balances(skip: Int = 0, first: Int = 100, orderBy: avalanche_swap_LpAccountBalance_orderBy, orderDirection: avalanche_swap_OrderDirection, where: avalanche_swap_LpAccountBalance_filter): [avalanche_swap_LpAccountBalance!]!
}

type avalanche_swap_LpAccountBalance {
  id: ID!
  account: avalanche_swap_LpAccount!
  token: avalanche_swap_LpToken!
  amount: avalanche_swap_BigDecimal!
  block: BigInt
  modified: BigInt
  transaction: avalanche_swap_Bytes
}

input avalanche_swap_LpAccountBalance_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  account: String
  account_not: String
  account_gt: String
  account_lt: String
  account_gte: String
  account_lte: String
  account_in: [String!]
  account_not_in: [String!]
  account_contains: String
  account_contains_nocase: String
  account_not_contains: String
  account_not_contains_nocase: String
  account_starts_with: String
  account_starts_with_nocase: String
  account_not_starts_with: String
  account_not_starts_with_nocase: String
  account_ends_with: String
  account_ends_with_nocase: String
  account_not_ends_with: String
  account_not_ends_with_nocase: String
  account_: avalanche_swap_LpAccount_filter
  token: String
  token_not: String
  token_gt: String
  token_lt: String
  token_gte: String
  token_lte: String
  token_in: [String!]
  token_not_in: [String!]
  token_contains: String
  token_contains_nocase: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_: avalanche_swap_LpToken_filter
  amount: avalanche_swap_BigDecimal
  amount_not: avalanche_swap_BigDecimal
  amount_gt: avalanche_swap_BigDecimal
  amount_lt: avalanche_swap_BigDecimal
  amount_gte: avalanche_swap_BigDecimal
  amount_lte: avalanche_swap_BigDecimal
  amount_in: [avalanche_swap_BigDecimal!]
  amount_not_in: [avalanche_swap_BigDecimal!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  modified: BigInt
  modified_not: BigInt
  modified_gt: BigInt
  modified_lt: BigInt
  modified_gte: BigInt
  modified_lte: BigInt
  modified_in: [BigInt!]
  modified_not_in: [BigInt!]
  transaction: avalanche_swap_Bytes
  transaction_not: avalanche_swap_Bytes
  transaction_gt: avalanche_swap_Bytes
  transaction_lt: avalanche_swap_Bytes
  transaction_gte: avalanche_swap_Bytes
  transaction_lte: avalanche_swap_Bytes
  transaction_in: [avalanche_swap_Bytes!]
  transaction_not_in: [avalanche_swap_Bytes!]
  transaction_contains: avalanche_swap_Bytes
  transaction_not_contains: avalanche_swap_Bytes
  """Filter for the block changed event."""
  _change_block: avalanche_swap_BlockChangedFilter
  and: [avalanche_swap_LpAccountBalance_filter]
  or: [avalanche_swap_LpAccountBalance_filter]
}

enum avalanche_swap_LpAccountBalance_orderBy {
  id
  account
  account__id
  account__address
  token
  token__id
  token__address
  token__decimals
  token__name
  token__symbol
  token__totalSupply
  amount
  block
  modified
  transaction
}

input avalanche_swap_LpAccount_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  address: avalanche_swap_Bytes
  address_not: avalanche_swap_Bytes
  address_gt: avalanche_swap_Bytes
  address_lt: avalanche_swap_Bytes
  address_gte: avalanche_swap_Bytes
  address_lte: avalanche_swap_Bytes
  address_in: [avalanche_swap_Bytes!]
  address_not_in: [avalanche_swap_Bytes!]
  address_contains: avalanche_swap_Bytes
  address_not_contains: avalanche_swap_Bytes
  balances_: avalanche_swap_LpAccountBalance_filter
  """Filter for the block changed event."""
  _change_block: avalanche_swap_BlockChangedFilter
  and: [avalanche_swap_LpAccount_filter]
  or: [avalanche_swap_LpAccount_filter]
}

enum avalanche_swap_LpAccount_orderBy {
  id
  address
  balances
}

type avalanche_swap_LpToken {
  id: ID!
  address: avalanche_swap_Bytes!
  stableSwap: avalanche_swap_StableSwap!
  decimals: Int!
  name: String!
  symbol: String!
  totalSupply: avalanche_swap_BigDecimal!
  events(skip: Int = 0, first: Int = 100, orderBy: avalanche_swap_LpTokenEvent_orderBy, orderDirection: avalanche_swap_OrderDirection, where: avalanche_swap_LpTokenEvent_filter): [avalanche_swap_LpTokenEvent!]!
}

interface avalanche_swap_LpTokenEvent {
  id: ID!
  token: avalanche_swap_LpToken!
  amount: avalanche_swap_BigDecimal!
  block: BigInt!
  timestamp: BigInt!
  transaction: avalanche_swap_Bytes!
  nonce: BigInt!
}

input avalanche_swap_LpTokenEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  token: String
  token_not: String
  token_gt: String
  token_lt: String
  token_gte: String
  token_lte: String
  token_in: [String!]
  token_not_in: [String!]
  token_contains: String
  token_contains_nocase: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_: avalanche_swap_LpToken_filter
  amount: avalanche_swap_BigDecimal
  amount_not: avalanche_swap_BigDecimal
  amount_gt: avalanche_swap_BigDecimal
  amount_lt: avalanche_swap_BigDecimal
  amount_gte: avalanche_swap_BigDecimal
  amount_lte: avalanche_swap_BigDecimal
  amount_in: [avalanche_swap_BigDecimal!]
  amount_not_in: [avalanche_swap_BigDecimal!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: avalanche_swap_Bytes
  transaction_not: avalanche_swap_Bytes
  transaction_gt: avalanche_swap_Bytes
  transaction_lt: avalanche_swap_Bytes
  transaction_gte: avalanche_swap_Bytes
  transaction_lte: avalanche_swap_Bytes
  transaction_in: [avalanche_swap_Bytes!]
  transaction_not_in: [avalanche_swap_Bytes!]
  transaction_contains: avalanche_swap_Bytes
  transaction_not_contains: avalanche_swap_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: avalanche_swap_BlockChangedFilter
  and: [avalanche_swap_LpTokenEvent_filter]
  or: [avalanche_swap_LpTokenEvent_filter]
}

enum avalanche_swap_LpTokenEvent_orderBy {
  id
  token
  token__id
  token__address
  token__decimals
  token__name
  token__symbol
  token__totalSupply
  amount
  block
  timestamp
  transaction
  nonce
}

input avalanche_swap_LpToken_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  address: avalanche_swap_Bytes
  address_not: avalanche_swap_Bytes
  address_gt: avalanche_swap_Bytes
  address_lt: avalanche_swap_Bytes
  address_gte: avalanche_swap_Bytes
  address_lte: avalanche_swap_Bytes
  address_in: [avalanche_swap_Bytes!]
  address_not_in: [avalanche_swap_Bytes!]
  address_contains: avalanche_swap_Bytes
  address_not_contains: avalanche_swap_Bytes
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: avalanche_swap_StableSwap_filter
  decimals: Int
  decimals_not: Int
  decimals_gt: Int
  decimals_lt: Int
  decimals_gte: Int
  decimals_lte: Int
  decimals_in: [Int!]
  decimals_not_in: [Int!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  symbol: String
  symbol_not: String
  symbol_gt: String
  symbol_lt: String
  symbol_gte: String
  symbol_lte: String
  symbol_in: [String!]
  symbol_not_in: [String!]
  symbol_contains: String
  symbol_contains_nocase: String
  symbol_not_contains: String
  symbol_not_contains_nocase: String
  symbol_starts_with: String
  symbol_starts_with_nocase: String
  symbol_not_starts_with: String
  symbol_not_starts_with_nocase: String
  symbol_ends_with: String
  symbol_ends_with_nocase: String
  symbol_not_ends_with: String
  symbol_not_ends_with_nocase: String
  totalSupply: avalanche_swap_BigDecimal
  totalSupply_not: avalanche_swap_BigDecimal
  totalSupply_gt: avalanche_swap_BigDecimal
  totalSupply_lt: avalanche_swap_BigDecimal
  totalSupply_gte: avalanche_swap_BigDecimal
  totalSupply_lte: avalanche_swap_BigDecimal
  totalSupply_in: [avalanche_swap_BigDecimal!]
  totalSupply_not_in: [avalanche_swap_BigDecimal!]
  events_: avalanche_swap_LpTokenEvent_filter
  """Filter for the block changed event."""
  _change_block: avalanche_swap_BlockChangedFilter
  and: [avalanche_swap_LpToken_filter]
  or: [avalanche_swap_LpToken_filter]
}

enum avalanche_swap_LpToken_orderBy {
  id
  address
  stableSwap
  stableSwap__id
  stableSwap__isActive
  stableSwap__key
  stableSwap__canonicalId
  stableSwap__domain
  stableSwap__swapPool
  stableSwap__lpToken
  stableSwap__initialA
  stableSwap__futureA
  stableSwap__initialATime
  stableSwap__futureATime
  stableSwap__swapFee
  stableSwap__adminFee
  stableSwap__virtualPrice
  stableSwap__invariant
  stableSwap__lpTokenSupply
  decimals
  name
  symbol
  totalSupply
  events
}

type avalanche_swap_LpTransferEvent implements avalanche_swap_LpTokenEvent {
  id: ID!
  token: avalanche_swap_LpToken!
  amount: avalanche_swap_BigDecimal!
  from: avalanche_swap_Bytes!
  to: avalanche_swap_Bytes!
  fromBalance: avalanche_swap_BigDecimal!
  toBalance: avalanche_swap_BigDecimal!
  block: BigInt!
  timestamp: BigInt!
  transaction: avalanche_swap_Bytes!
  nonce: BigInt!
}

input avalanche_swap_LpTransferEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  token: String
  token_not: String
  token_gt: String
  token_lt: String
  token_gte: String
  token_lte: String
  token_in: [String!]
  token_not_in: [String!]
  token_contains: String
  token_contains_nocase: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_: avalanche_swap_LpToken_filter
  amount: avalanche_swap_BigDecimal
  amount_not: avalanche_swap_BigDecimal
  amount_gt: avalanche_swap_BigDecimal
  amount_lt: avalanche_swap_BigDecimal
  amount_gte: avalanche_swap_BigDecimal
  amount_lte: avalanche_swap_BigDecimal
  amount_in: [avalanche_swap_BigDecimal!]
  amount_not_in: [avalanche_swap_BigDecimal!]
  from: avalanche_swap_Bytes
  from_not: avalanche_swap_Bytes
  from_gt: avalanche_swap_Bytes
  from_lt: avalanche_swap_Bytes
  from_gte: avalanche_swap_Bytes
  from_lte: avalanche_swap_Bytes
  from_in: [avalanche_swap_Bytes!]
  from_not_in: [avalanche_swap_Bytes!]
  from_contains: avalanche_swap_Bytes
  from_not_contains: avalanche_swap_Bytes
  to: avalanche_swap_Bytes
  to_not: avalanche_swap_Bytes
  to_gt: avalanche_swap_Bytes
  to_lt: avalanche_swap_Bytes
  to_gte: avalanche_swap_Bytes
  to_lte: avalanche_swap_Bytes
  to_in: [avalanche_swap_Bytes!]
  to_not_in: [avalanche_swap_Bytes!]
  to_contains: avalanche_swap_Bytes
  to_not_contains: avalanche_swap_Bytes
  fromBalance: avalanche_swap_BigDecimal
  fromBalance_not: avalanche_swap_BigDecimal
  fromBalance_gt: avalanche_swap_BigDecimal
  fromBalance_lt: avalanche_swap_BigDecimal
  fromBalance_gte: avalanche_swap_BigDecimal
  fromBalance_lte: avalanche_swap_BigDecimal
  fromBalance_in: [avalanche_swap_BigDecimal!]
  fromBalance_not_in: [avalanche_swap_BigDecimal!]
  toBalance: avalanche_swap_BigDecimal
  toBalance_not: avalanche_swap_BigDecimal
  toBalance_gt: avalanche_swap_BigDecimal
  toBalance_lt: avalanche_swap_BigDecimal
  toBalance_gte: avalanche_swap_BigDecimal
  toBalance_lte: avalanche_swap_BigDecimal
  toBalance_in: [avalanche_swap_BigDecimal!]
  toBalance_not_in: [avalanche_swap_BigDecimal!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: avalanche_swap_Bytes
  transaction_not: avalanche_swap_Bytes
  transaction_gt: avalanche_swap_Bytes
  transaction_lt: avalanche_swap_Bytes
  transaction_gte: avalanche_swap_Bytes
  transaction_lte: avalanche_swap_Bytes
  transaction_in: [avalanche_swap_Bytes!]
  transaction_not_in: [avalanche_swap_Bytes!]
  transaction_contains: avalanche_swap_Bytes
  transaction_not_contains: avalanche_swap_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: avalanche_swap_BlockChangedFilter
  and: [avalanche_swap_LpTransferEvent_filter]
  or: [avalanche_swap_LpTransferEvent_filter]
}

enum avalanche_swap_LpTransferEvent_orderBy {
  id
  token
  token__id
  token__address
  token__decimals
  token__name
  token__symbol
  token__totalSupply
  amount
  from
  to
  fromBalance
  toBalance
  block
  timestamp
  transaction
  nonce
}

"""Defines the order direction, either ascending or descending"""
enum avalanche_swap_OrderDirection {
  asc
  desc
}

type avalanche_swap_PooledToken {
  id: ID!
  asset: avalanche_swap_Bytes!
}

input avalanche_swap_PooledToken_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  asset: avalanche_swap_Bytes
  asset_not: avalanche_swap_Bytes
  asset_gt: avalanche_swap_Bytes
  asset_lt: avalanche_swap_Bytes
  asset_gte: avalanche_swap_Bytes
  asset_lte: avalanche_swap_Bytes
  asset_in: [avalanche_swap_Bytes!]
  asset_not_in: [avalanche_swap_Bytes!]
  asset_contains: avalanche_swap_Bytes
  asset_not_contains: avalanche_swap_Bytes
  """Filter for the block changed event."""
  _change_block: avalanche_swap_BlockChangedFilter
  and: [avalanche_swap_PooledToken_filter]
  or: [avalanche_swap_PooledToken_filter]
}

enum avalanche_swap_PooledToken_orderBy {
  id
  asset
}

type avalanche_swap_StableSwap {
  id: ID!
  isActive: Boolean
  key: avalanche_swap_Bytes!
  canonicalId: avalanche_swap_Bytes
  domain: BigInt
  swapPool: avalanche_swap_Bytes
  lpToken: avalanche_swap_Bytes
  initialA: BigInt
  futureA: BigInt
  initialATime: BigInt
  futureATime: BigInt
  swapFee: BigInt
  adminFee: BigInt
  pooledTokens: [avalanche_swap_Bytes!]!
  tokenPrecisionMultipliers: [BigInt!]!
  balances: [BigInt!]!
  adminFees: [BigInt!]!
  virtualPrice: BigInt!
  invariant: BigInt!
  lpTokenSupply: BigInt!
  events(skip: Int = 0, first: Int = 100, orderBy: avalanche_swap_StableSwapEvent_orderBy, orderDirection: avalanche_swap_OrderDirection, where: avalanche_swap_StableSwapEvent_filter): [avalanche_swap_StableSwapEvent!]
  exchanges(skip: Int = 0, first: Int = 100, orderBy: avalanche_swap_StableSwapExchange_orderBy, orderDirection: avalanche_swap_OrderDirection, where: avalanche_swap_StableSwapExchange_filter): [avalanche_swap_StableSwapExchange!]
  hourlyVolumes(skip: Int = 0, first: Int = 100, orderBy: avalanche_swap_SwapHourlyVolume_orderBy, orderDirection: avalanche_swap_OrderDirection, where: avalanche_swap_SwapHourlyVolume_filter): [avalanche_swap_SwapHourlyVolume!]
  dailyVolumes(skip: Int = 0, first: Int = 100, orderBy: avalanche_swap_SwapDailyVolume_orderBy, orderDirection: avalanche_swap_OrderDirection, where: avalanche_swap_SwapDailyVolume_filter): [avalanche_swap_SwapDailyVolume!]
  weeklyVolumes(skip: Int = 0, first: Int = 100, orderBy: avalanche_swap_SwapWeeklyVolume_orderBy, orderDirection: avalanche_swap_OrderDirection, where: avalanche_swap_SwapWeeklyVolume_filter): [avalanche_swap_SwapWeeklyVolume!]
}

type avalanche_swap_StableSwapAddLiquidityEvent implements avalanche_swap_StableSwapEvent {
  id: ID!
  stableSwap: avalanche_swap_StableSwap!
  provider: avalanche_swap_Bytes!
  tokenAmounts: [BigInt!]!
  fees: [BigInt!]!
  invariant: BigInt
  lpTokenSupply: BigInt!
  lpTokenAmount: BigInt!
  balances: [BigInt!]!
  block: BigInt!
  timestamp: BigInt!
  transaction: avalanche_swap_Bytes!
  nonce: BigInt!
}

input avalanche_swap_StableSwapAddLiquidityEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: avalanche_swap_StableSwap_filter
  provider: avalanche_swap_Bytes
  provider_not: avalanche_swap_Bytes
  provider_gt: avalanche_swap_Bytes
  provider_lt: avalanche_swap_Bytes
  provider_gte: avalanche_swap_Bytes
  provider_lte: avalanche_swap_Bytes
  provider_in: [avalanche_swap_Bytes!]
  provider_not_in: [avalanche_swap_Bytes!]
  provider_contains: avalanche_swap_Bytes
  provider_not_contains: avalanche_swap_Bytes
  tokenAmounts: [BigInt!]
  tokenAmounts_not: [BigInt!]
  tokenAmounts_contains: [BigInt!]
  tokenAmounts_contains_nocase: [BigInt!]
  tokenAmounts_not_contains: [BigInt!]
  tokenAmounts_not_contains_nocase: [BigInt!]
  fees: [BigInt!]
  fees_not: [BigInt!]
  fees_contains: [BigInt!]
  fees_contains_nocase: [BigInt!]
  fees_not_contains: [BigInt!]
  fees_not_contains_nocase: [BigInt!]
  invariant: BigInt
  invariant_not: BigInt
  invariant_gt: BigInt
  invariant_lt: BigInt
  invariant_gte: BigInt
  invariant_lte: BigInt
  invariant_in: [BigInt!]
  invariant_not_in: [BigInt!]
  lpTokenSupply: BigInt
  lpTokenSupply_not: BigInt
  lpTokenSupply_gt: BigInt
  lpTokenSupply_lt: BigInt
  lpTokenSupply_gte: BigInt
  lpTokenSupply_lte: BigInt
  lpTokenSupply_in: [BigInt!]
  lpTokenSupply_not_in: [BigInt!]
  lpTokenAmount: BigInt
  lpTokenAmount_not: BigInt
  lpTokenAmount_gt: BigInt
  lpTokenAmount_lt: BigInt
  lpTokenAmount_gte: BigInt
  lpTokenAmount_lte: BigInt
  lpTokenAmount_in: [BigInt!]
  lpTokenAmount_not_in: [BigInt!]
  balances: [BigInt!]
  balances_not: [BigInt!]
  balances_contains: [BigInt!]
  balances_contains_nocase: [BigInt!]
  balances_not_contains: [BigInt!]
  balances_not_contains_nocase: [BigInt!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: avalanche_swap_Bytes
  transaction_not: avalanche_swap_Bytes
  transaction_gt: avalanche_swap_Bytes
  transaction_lt: avalanche_swap_Bytes
  transaction_gte: avalanche_swap_Bytes
  transaction_lte: avalanche_swap_Bytes
  transaction_in: [avalanche_swap_Bytes!]
  transaction_not_in: [avalanche_swap_Bytes!]
  transaction_contains: avalanche_swap_Bytes
  transaction_not_contains: avalanche_swap_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: avalanche_swap_BlockChangedFilter
  and: [avalanche_swap_StableSwapAddLiquidityEvent_filter]
  or: [avalanche_swap_StableSwapAddLiquidityEvent_filter]
}

enum avalanche_swap_StableSwapAddLiquidityEvent_orderBy {
  id
  stableSwap
  stableSwap__id
  stableSwap__isActive
  stableSwap__key
  stableSwap__canonicalId
  stableSwap__domain
  stableSwap__swapPool
  stableSwap__lpToken
  stableSwap__initialA
  stableSwap__futureA
  stableSwap__initialATime
  stableSwap__futureATime
  stableSwap__swapFee
  stableSwap__adminFee
  stableSwap__virtualPrice
  stableSwap__invariant
  stableSwap__lpTokenSupply
  provider
  tokenAmounts
  fees
  invariant
  lpTokenSupply
  lpTokenAmount
  balances
  block
  timestamp
  transaction
  nonce
}

interface avalanche_swap_StableSwapEvent {
  id: ID!
  stableSwap: avalanche_swap_StableSwap!
  block: BigInt!
  timestamp: BigInt!
  transaction: avalanche_swap_Bytes!
  nonce: BigInt!
}

input avalanche_swap_StableSwapEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: avalanche_swap_StableSwap_filter
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: avalanche_swap_Bytes
  transaction_not: avalanche_swap_Bytes
  transaction_gt: avalanche_swap_Bytes
  transaction_lt: avalanche_swap_Bytes
  transaction_gte: avalanche_swap_Bytes
  transaction_lte: avalanche_swap_Bytes
  transaction_in: [avalanche_swap_Bytes!]
  transaction_not_in: [avalanche_swap_Bytes!]
  transaction_contains: avalanche_swap_Bytes
  transaction_not_contains: avalanche_swap_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: avalanche_swap_BlockChangedFilter
  and: [avalanche_swap_StableSwapEvent_filter]
  or: [avalanche_swap_StableSwapEvent_filter]
}

enum avalanche_swap_StableSwapEvent_orderBy {
  id
  stableSwap
  stableSwap__id
  stableSwap__isActive
  stableSwap__key
  stableSwap__canonicalId
  stableSwap__domain
  stableSwap__swapPool
  stableSwap__lpToken
  stableSwap__initialA
  stableSwap__futureA
  stableSwap__initialATime
  stableSwap__futureATime
  stableSwap__swapFee
  stableSwap__adminFee
  stableSwap__virtualPrice
  stableSwap__invariant
  stableSwap__lpTokenSupply
  block
  timestamp
  transaction
  nonce
}

type avalanche_swap_StableSwapExchange {
  id: ID!
  stableSwap: avalanche_swap_StableSwap!
  buyer: avalanche_swap_Bytes!
  boughtId: BigInt!
  tokensBought: BigInt!
  soldId: BigInt!
  tokensSold: BigInt!
  balances: [BigInt!]!
  fee: BigInt!
  block: BigInt!
  timestamp: BigInt!
  transaction: avalanche_swap_Bytes!
  nonce: BigInt!
}

input avalanche_swap_StableSwapExchange_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: avalanche_swap_StableSwap_filter
  buyer: avalanche_swap_Bytes
  buyer_not: avalanche_swap_Bytes
  buyer_gt: avalanche_swap_Bytes
  buyer_lt: avalanche_swap_Bytes
  buyer_gte: avalanche_swap_Bytes
  buyer_lte: avalanche_swap_Bytes
  buyer_in: [avalanche_swap_Bytes!]
  buyer_not_in: [avalanche_swap_Bytes!]
  buyer_contains: avalanche_swap_Bytes
  buyer_not_contains: avalanche_swap_Bytes
  boughtId: BigInt
  boughtId_not: BigInt
  boughtId_gt: BigInt
  boughtId_lt: BigInt
  boughtId_gte: BigInt
  boughtId_lte: BigInt
  boughtId_in: [BigInt!]
  boughtId_not_in: [BigInt!]
  tokensBought: BigInt
  tokensBought_not: BigInt
  tokensBought_gt: BigInt
  tokensBought_lt: BigInt
  tokensBought_gte: BigInt
  tokensBought_lte: BigInt
  tokensBought_in: [BigInt!]
  tokensBought_not_in: [BigInt!]
  soldId: BigInt
  soldId_not: BigInt
  soldId_gt: BigInt
  soldId_lt: BigInt
  soldId_gte: BigInt
  soldId_lte: BigInt
  soldId_in: [BigInt!]
  soldId_not_in: [BigInt!]
  tokensSold: BigInt
  tokensSold_not: BigInt
  tokensSold_gt: BigInt
  tokensSold_lt: BigInt
  tokensSold_gte: BigInt
  tokensSold_lte: BigInt
  tokensSold_in: [BigInt!]
  tokensSold_not_in: [BigInt!]
  balances: [BigInt!]
  balances_not: [BigInt!]
  balances_contains: [BigInt!]
  balances_contains_nocase: [BigInt!]
  balances_not_contains: [BigInt!]
  balances_not_contains_nocase: [BigInt!]
  fee: BigInt
  fee_not: BigInt
  fee_gt: BigInt
  fee_lt: BigInt
  fee_gte: BigInt
  fee_lte: BigInt
  fee_in: [BigInt!]
  fee_not_in: [BigInt!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: avalanche_swap_Bytes
  transaction_not: avalanche_swap_Bytes
  transaction_gt: avalanche_swap_Bytes
  transaction_lt: avalanche_swap_Bytes
  transaction_gte: avalanche_swap_Bytes
  transaction_lte: avalanche_swap_Bytes
  transaction_in: [avalanche_swap_Bytes!]
  transaction_not_in: [avalanche_swap_Bytes!]
  transaction_contains: avalanche_swap_Bytes
  transaction_not_contains: avalanche_swap_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: avalanche_swap_BlockChangedFilter
  and: [avalanche_swap_StableSwapExchange_filter]
  or: [avalanche_swap_StableSwapExchange_filter]
}

enum avalanche_swap_StableSwapExchange_orderBy {
  id
  stableSwap
  stableSwap__id
  stableSwap__isActive
  stableSwap__key
  stableSwap__canonicalId
  stableSwap__domain
  stableSwap__swapPool
  stableSwap__lpToken
  stableSwap__initialA
  stableSwap__futureA
  stableSwap__initialATime
  stableSwap__futureATime
  stableSwap__swapFee
  stableSwap__adminFee
  stableSwap__virtualPrice
  stableSwap__invariant
  stableSwap__lpTokenSupply
  buyer
  boughtId
  tokensBought
  soldId
  tokensSold
  balances
  fee
  block
  timestamp
  transaction
  nonce
}

type avalanche_swap_StableSwapRemoveLiquidityEvent implements avalanche_swap_StableSwapEvent {
  id: ID!
  stableSwap: avalanche_swap_StableSwap!
  provider: avalanche_swap_Bytes!
  tokenAmounts: [BigInt!]!
  fees: [BigInt!]
  invariant: BigInt
  lpTokenSupply: BigInt!
  lpTokenAmount: BigInt!
  balances: [BigInt!]!
  block: BigInt!
  timestamp: BigInt!
  transaction: avalanche_swap_Bytes!
  nonce: BigInt!
}

input avalanche_swap_StableSwapRemoveLiquidityEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: avalanche_swap_StableSwap_filter
  provider: avalanche_swap_Bytes
  provider_not: avalanche_swap_Bytes
  provider_gt: avalanche_swap_Bytes
  provider_lt: avalanche_swap_Bytes
  provider_gte: avalanche_swap_Bytes
  provider_lte: avalanche_swap_Bytes
  provider_in: [avalanche_swap_Bytes!]
  provider_not_in: [avalanche_swap_Bytes!]
  provider_contains: avalanche_swap_Bytes
  provider_not_contains: avalanche_swap_Bytes
  tokenAmounts: [BigInt!]
  tokenAmounts_not: [BigInt!]
  tokenAmounts_contains: [BigInt!]
  tokenAmounts_contains_nocase: [BigInt!]
  tokenAmounts_not_contains: [BigInt!]
  tokenAmounts_not_contains_nocase: [BigInt!]
  fees: [BigInt!]
  fees_not: [BigInt!]
  fees_contains: [BigInt!]
  fees_contains_nocase: [BigInt!]
  fees_not_contains: [BigInt!]
  fees_not_contains_nocase: [BigInt!]
  invariant: BigInt
  invariant_not: BigInt
  invariant_gt: BigInt
  invariant_lt: BigInt
  invariant_gte: BigInt
  invariant_lte: BigInt
  invariant_in: [BigInt!]
  invariant_not_in: [BigInt!]
  lpTokenSupply: BigInt
  lpTokenSupply_not: BigInt
  lpTokenSupply_gt: BigInt
  lpTokenSupply_lt: BigInt
  lpTokenSupply_gte: BigInt
  lpTokenSupply_lte: BigInt
  lpTokenSupply_in: [BigInt!]
  lpTokenSupply_not_in: [BigInt!]
  lpTokenAmount: BigInt
  lpTokenAmount_not: BigInt
  lpTokenAmount_gt: BigInt
  lpTokenAmount_lt: BigInt
  lpTokenAmount_gte: BigInt
  lpTokenAmount_lte: BigInt
  lpTokenAmount_in: [BigInt!]
  lpTokenAmount_not_in: [BigInt!]
  balances: [BigInt!]
  balances_not: [BigInt!]
  balances_contains: [BigInt!]
  balances_contains_nocase: [BigInt!]
  balances_not_contains: [BigInt!]
  balances_not_contains_nocase: [BigInt!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: avalanche_swap_Bytes
  transaction_not: avalanche_swap_Bytes
  transaction_gt: avalanche_swap_Bytes
  transaction_lt: avalanche_swap_Bytes
  transaction_gte: avalanche_swap_Bytes
  transaction_lte: avalanche_swap_Bytes
  transaction_in: [avalanche_swap_Bytes!]
  transaction_not_in: [avalanche_swap_Bytes!]
  transaction_contains: avalanche_swap_Bytes
  transaction_not_contains: avalanche_swap_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: avalanche_swap_BlockChangedFilter
  and: [avalanche_swap_StableSwapRemoveLiquidityEvent_filter]
  or: [avalanche_swap_StableSwapRemoveLiquidityEvent_filter]
}

enum avalanche_swap_StableSwapRemoveLiquidityEvent_orderBy {
  id
  stableSwap
  stableSwap__id
  stableSwap__isActive
  stableSwap__key
  stableSwap__canonicalId
  stableSwap__domain
  stableSwap__swapPool
  stableSwap__lpToken
  stableSwap__initialA
  stableSwap__futureA
  stableSwap__initialATime
  stableSwap__futureATime
  stableSwap__swapFee
  stableSwap__adminFee
  stableSwap__virtualPrice
  stableSwap__invariant
  stableSwap__lpTokenSupply
  provider
  tokenAmounts
  fees
  invariant
  lpTokenSupply
  lpTokenAmount
  balances
  block
  timestamp
  transaction
  nonce
}

input avalanche_swap_StableSwap_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  isActive: Boolean
  isActive_not: Boolean
  isActive_in: [Boolean!]
  isActive_not_in: [Boolean!]
  key: avalanche_swap_Bytes
  key_not: avalanche_swap_Bytes
  key_gt: avalanche_swap_Bytes
  key_lt: avalanche_swap_Bytes
  key_gte: avalanche_swap_Bytes
  key_lte: avalanche_swap_Bytes
  key_in: [avalanche_swap_Bytes!]
  key_not_in: [avalanche_swap_Bytes!]
  key_contains: avalanche_swap_Bytes
  key_not_contains: avalanche_swap_Bytes
  canonicalId: avalanche_swap_Bytes
  canonicalId_not: avalanche_swap_Bytes
  canonicalId_gt: avalanche_swap_Bytes
  canonicalId_lt: avalanche_swap_Bytes
  canonicalId_gte: avalanche_swap_Bytes
  canonicalId_lte: avalanche_swap_Bytes
  canonicalId_in: [avalanche_swap_Bytes!]
  canonicalId_not_in: [avalanche_swap_Bytes!]
  canonicalId_contains: avalanche_swap_Bytes
  canonicalId_not_contains: avalanche_swap_Bytes
  domain: BigInt
  domain_not: BigInt
  domain_gt: BigInt
  domain_lt: BigInt
  domain_gte: BigInt
  domain_lte: BigInt
  domain_in: [BigInt!]
  domain_not_in: [BigInt!]
  swapPool: avalanche_swap_Bytes
  swapPool_not: avalanche_swap_Bytes
  swapPool_gt: avalanche_swap_Bytes
  swapPool_lt: avalanche_swap_Bytes
  swapPool_gte: avalanche_swap_Bytes
  swapPool_lte: avalanche_swap_Bytes
  swapPool_in: [avalanche_swap_Bytes!]
  swapPool_not_in: [avalanche_swap_Bytes!]
  swapPool_contains: avalanche_swap_Bytes
  swapPool_not_contains: avalanche_swap_Bytes
  lpToken: avalanche_swap_Bytes
  lpToken_not: avalanche_swap_Bytes
  lpToken_gt: avalanche_swap_Bytes
  lpToken_lt: avalanche_swap_Bytes
  lpToken_gte: avalanche_swap_Bytes
  lpToken_lte: avalanche_swap_Bytes
  lpToken_in: [avalanche_swap_Bytes!]
  lpToken_not_in: [avalanche_swap_Bytes!]
  lpToken_contains: avalanche_swap_Bytes
  lpToken_not_contains: avalanche_swap_Bytes
  initialA: BigInt
  initialA_not: BigInt
  initialA_gt: BigInt
  initialA_lt: BigInt
  initialA_gte: BigInt
  initialA_lte: BigInt
  initialA_in: [BigInt!]
  initialA_not_in: [BigInt!]
  futureA: BigInt
  futureA_not: BigInt
  futureA_gt: BigInt
  futureA_lt: BigInt
  futureA_gte: BigInt
  futureA_lte: BigInt
  futureA_in: [BigInt!]
  futureA_not_in: [BigInt!]
  initialATime: BigInt
  initialATime_not: BigInt
  initialATime_gt: BigInt
  initialATime_lt: BigInt
  initialATime_gte: BigInt
  initialATime_lte: BigInt
  initialATime_in: [BigInt!]
  initialATime_not_in: [BigInt!]
  futureATime: BigInt
  futureATime_not: BigInt
  futureATime_gt: BigInt
  futureATime_lt: BigInt
  futureATime_gte: BigInt
  futureATime_lte: BigInt
  futureATime_in: [BigInt!]
  futureATime_not_in: [BigInt!]
  swapFee: BigInt
  swapFee_not: BigInt
  swapFee_gt: BigInt
  swapFee_lt: BigInt
  swapFee_gte: BigInt
  swapFee_lte: BigInt
  swapFee_in: [BigInt!]
  swapFee_not_in: [BigInt!]
  adminFee: BigInt
  adminFee_not: BigInt
  adminFee_gt: BigInt
  adminFee_lt: BigInt
  adminFee_gte: BigInt
  adminFee_lte: BigInt
  adminFee_in: [BigInt!]
  adminFee_not_in: [BigInt!]
  pooledTokens: [avalanche_swap_Bytes!]
  pooledTokens_not: [avalanche_swap_Bytes!]
  pooledTokens_contains: [avalanche_swap_Bytes!]
  pooledTokens_contains_nocase: [avalanche_swap_Bytes!]
  pooledTokens_not_contains: [avalanche_swap_Bytes!]
  pooledTokens_not_contains_nocase: [avalanche_swap_Bytes!]
  tokenPrecisionMultipliers: [BigInt!]
  tokenPrecisionMultipliers_not: [BigInt!]
  tokenPrecisionMultipliers_contains: [BigInt!]
  tokenPrecisionMultipliers_contains_nocase: [BigInt!]
  tokenPrecisionMultipliers_not_contains: [BigInt!]
  tokenPrecisionMultipliers_not_contains_nocase: [BigInt!]
  balances: [BigInt!]
  balances_not: [BigInt!]
  balances_contains: [BigInt!]
  balances_contains_nocase: [BigInt!]
  balances_not_contains: [BigInt!]
  balances_not_contains_nocase: [BigInt!]
  adminFees: [BigInt!]
  adminFees_not: [BigInt!]
  adminFees_contains: [BigInt!]
  adminFees_contains_nocase: [BigInt!]
  adminFees_not_contains: [BigInt!]
  adminFees_not_contains_nocase: [BigInt!]
  virtualPrice: BigInt
  virtualPrice_not: BigInt
  virtualPrice_gt: BigInt
  virtualPrice_lt: BigInt
  virtualPrice_gte: BigInt
  virtualPrice_lte: BigInt
  virtualPrice_in: [BigInt!]
  virtualPrice_not_in: [BigInt!]
  invariant: BigInt
  invariant_not: BigInt
  invariant_gt: BigInt
  invariant_lt: BigInt
  invariant_gte: BigInt
  invariant_lte: BigInt
  invariant_in: [BigInt!]
  invariant_not_in: [BigInt!]
  lpTokenSupply: BigInt
  lpTokenSupply_not: BigInt
  lpTokenSupply_gt: BigInt
  lpTokenSupply_lt: BigInt
  lpTokenSupply_gte: BigInt
  lpTokenSupply_lte: BigInt
  lpTokenSupply_in: [BigInt!]
  lpTokenSupply_not_in: [BigInt!]
  events_: avalanche_swap_StableSwapEvent_filter
  exchanges_: avalanche_swap_StableSwapExchange_filter
  hourlyVolumes_: avalanche_swap_SwapHourlyVolume_filter
  dailyVolumes_: avalanche_swap_SwapDailyVolume_filter
  weeklyVolumes_: avalanche_swap_SwapWeeklyVolume_filter
  """Filter for the block changed event."""
  _change_block: avalanche_swap_BlockChangedFilter
  and: [avalanche_swap_StableSwap_filter]
  or: [avalanche_swap_StableSwap_filter]
}

enum avalanche_swap_StableSwap_orderBy {
  id
  isActive
  key
  canonicalId
  domain
  swapPool
  lpToken
  initialA
  futureA
  initialATime
  futureATime
  swapFee
  adminFee
  pooledTokens
  tokenPrecisionMultipliers
  balances
  adminFees
  virtualPrice
  invariant
  lpTokenSupply
  events
  exchanges
  hourlyVolumes
  dailyVolumes
  weeklyVolumes
}

type avalanche_swap_SwapDailyVolume implements avalanche_swap_SwapTradeVolume {
  id: ID!
  stableSwap: avalanche_swap_StableSwap!
  timestamp: BigInt!
  volume: avalanche_swap_BigDecimal!
}

input avalanche_swap_SwapDailyVolume_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: avalanche_swap_StableSwap_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  volume: avalanche_swap_BigDecimal
  volume_not: avalanche_swap_BigDecimal
  volume_gt: avalanche_swap_BigDecimal
  volume_lt: avalanche_swap_BigDecimal
  volume_gte: avalanche_swap_BigDecimal
  volume_lte: avalanche_swap_BigDecimal
  volume_in: [avalanche_swap_BigDecimal!]
  volume_not_in: [avalanche_swap_BigDecimal!]
  """Filter for the block changed event."""
  _change_block: avalanche_swap_BlockChangedFilter
  and: [avalanche_swap_SwapDailyVolume_filter]
  or: [avalanche_swap_SwapDailyVolume_filter]
}

enum avalanche_swap_SwapDailyVolume_orderBy {
  id
  stableSwap
  stableSwap__id
  stableSwap__isActive
  stableSwap__key
  stableSwap__canonicalId
  stableSwap__domain
  stableSwap__swapPool
  stableSwap__lpToken
  stableSwap__initialA
  stableSwap__futureA
  stableSwap__initialATime
  stableSwap__futureATime
  stableSwap__swapFee
  stableSwap__adminFee
  stableSwap__virtualPrice
  stableSwap__invariant
  stableSwap__lpTokenSupply
  timestamp
  volume
}

type avalanche_swap_SwapHourlyVolume implements avalanche_swap_SwapTradeVolume {
  id: ID!
  stableSwap: avalanche_swap_StableSwap!
  timestamp: BigInt!
  volume: avalanche_swap_BigDecimal!
}

input avalanche_swap_SwapHourlyVolume_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: avalanche_swap_StableSwap_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  volume: avalanche_swap_BigDecimal
  volume_not: avalanche_swap_BigDecimal
  volume_gt: avalanche_swap_BigDecimal
  volume_lt: avalanche_swap_BigDecimal
  volume_gte: avalanche_swap_BigDecimal
  volume_lte: avalanche_swap_BigDecimal
  volume_in: [avalanche_swap_BigDecimal!]
  volume_not_in: [avalanche_swap_BigDecimal!]
  """Filter for the block changed event."""
  _change_block: avalanche_swap_BlockChangedFilter
  and: [avalanche_swap_SwapHourlyVolume_filter]
  or: [avalanche_swap_SwapHourlyVolume_filter]
}

enum avalanche_swap_SwapHourlyVolume_orderBy {
  id
  stableSwap
  stableSwap__id
  stableSwap__isActive
  stableSwap__key
  stableSwap__canonicalId
  stableSwap__domain
  stableSwap__swapPool
  stableSwap__lpToken
  stableSwap__initialA
  stableSwap__futureA
  stableSwap__initialATime
  stableSwap__futureATime
  stableSwap__swapFee
  stableSwap__adminFee
  stableSwap__virtualPrice
  stableSwap__invariant
  stableSwap__lpTokenSupply
  timestamp
  volume
}

interface avalanche_swap_SwapTradeVolume {
  stableSwap: avalanche_swap_StableSwap!
  timestamp: BigInt!
  volume: avalanche_swap_BigDecimal!
}

input avalanche_swap_SwapTradeVolume_filter {
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: avalanche_swap_StableSwap_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  volume: avalanche_swap_BigDecimal
  volume_not: avalanche_swap_BigDecimal
  volume_gt: avalanche_swap_BigDecimal
  volume_lt: avalanche_swap_BigDecimal
  volume_gte: avalanche_swap_BigDecimal
  volume_lte: avalanche_swap_BigDecimal
  volume_in: [avalanche_swap_BigDecimal!]
  volume_not_in: [avalanche_swap_BigDecimal!]
  """Filter for the block changed event."""
  _change_block: avalanche_swap_BlockChangedFilter
  and: [avalanche_swap_SwapTradeVolume_filter]
  or: [avalanche_swap_SwapTradeVolume_filter]
}

enum avalanche_swap_SwapTradeVolume_orderBy {
  stableSwap
  stableSwap__id
  stableSwap__isActive
  stableSwap__key
  stableSwap__canonicalId
  stableSwap__domain
  stableSwap__swapPool
  stableSwap__lpToken
  stableSwap__initialA
  stableSwap__futureA
  stableSwap__initialATime
  stableSwap__futureATime
  stableSwap__swapFee
  stableSwap__adminFee
  stableSwap__virtualPrice
  stableSwap__invariant
  stableSwap__lpTokenSupply
  timestamp
  volume
}

type avalanche_swap_SwapWeeklyVolume implements avalanche_swap_SwapTradeVolume {
  id: ID!
  stableSwap: avalanche_swap_StableSwap!
  timestamp: BigInt!
  volume: avalanche_swap_BigDecimal!
}

input avalanche_swap_SwapWeeklyVolume_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: avalanche_swap_StableSwap_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  volume: avalanche_swap_BigDecimal
  volume_not: avalanche_swap_BigDecimal
  volume_gt: avalanche_swap_BigDecimal
  volume_lt: avalanche_swap_BigDecimal
  volume_gte: avalanche_swap_BigDecimal
  volume_lte: avalanche_swap_BigDecimal
  volume_in: [avalanche_swap_BigDecimal!]
  volume_not_in: [avalanche_swap_BigDecimal!]
  """Filter for the block changed event."""
  _change_block: avalanche_swap_BlockChangedFilter
  and: [avalanche_swap_SwapWeeklyVolume_filter]
  or: [avalanche_swap_SwapWeeklyVolume_filter]
}

enum avalanche_swap_SwapWeeklyVolume_orderBy {
  id
  stableSwap
  stableSwap__id
  stableSwap__isActive
  stableSwap__key
  stableSwap__canonicalId
  stableSwap__domain
  stableSwap__swapPool
  stableSwap__lpToken
  stableSwap__initialA
  stableSwap__futureA
  stableSwap__initialATime
  stableSwap__futureATime
  stableSwap__swapFee
  stableSwap__adminFee
  stableSwap__virtualPrice
  stableSwap__invariant
  stableSwap__lpTokenSupply
  timestamp
  volume
}

type avalanche_swap_SystemInfo {
  id: ID!
  exchangeCount: BigInt!
  swapCount: BigInt!
}

input avalanche_swap_SystemInfo_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  exchangeCount: BigInt
  exchangeCount_not: BigInt
  exchangeCount_gt: BigInt
  exchangeCount_lt: BigInt
  exchangeCount_gte: BigInt
  exchangeCount_lte: BigInt
  exchangeCount_in: [BigInt!]
  exchangeCount_not_in: [BigInt!]
  swapCount: BigInt
  swapCount_not: BigInt
  swapCount_gt: BigInt
  swapCount_lt: BigInt
  swapCount_gte: BigInt
  swapCount_lte: BigInt
  swapCount_in: [BigInt!]
  swapCount_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: avalanche_swap_BlockChangedFilter
  and: [avalanche_swap_SystemInfo_filter]
  or: [avalanche_swap_SystemInfo_filter]
}

enum avalanche_swap_SystemInfo_orderBy {
  id
  exchangeCount
  swapCount
}

type avalanche_swap__Block_ {
  """The hash of the block"""
  hash: avalanche_swap_Bytes
  """The block number"""
  number: Int!
  """Integer representation of the timestamp stored in blocks for the chain"""
  timestamp: Int
  """The hash of the parent block"""
  parentHash: avalanche_swap_Bytes
}

"""The type for the top-level _meta field"""
type avalanche_swap__Meta_ {
  """
  Information about a specific subgraph block. The hash of the block
  will be null if the _meta field has a block constraint that asks for
  a block number. It will be filled if the _meta field has no block constraint
  and therefore asks for the latest  block
  
  """
  block: avalanche_swap__Block_!
  """The deployment ID"""
  deployment: String!
  """If `true`, the subgraph encountered indexing errors at some past block"""
  hasIndexingErrors: Boolean!
}

enum polygon_swap_Aggregation_interval {
  hour
  day
}

scalar polygon_swap_BigDecimal

input polygon_swap_BlockChangedFilter {
  number_gte: Int!
}

input polygon_swap_Block_height {
  hash: polygon_swap_Bytes
  number: Int
  number_gte: Int
}

scalar polygon_swap_Bytes

"""
8 bytes signed integer

"""
scalar polygon_swap_Int8

type polygon_swap_LpAccount {
  id: ID!
  address: polygon_swap_Bytes!
  balances(skip: Int = 0, first: Int = 100, orderBy: polygon_swap_LpAccountBalance_orderBy, orderDirection: polygon_swap_OrderDirection, where: polygon_swap_LpAccountBalance_filter): [polygon_swap_LpAccountBalance!]!
}

type polygon_swap_LpAccountBalance {
  id: ID!
  account: polygon_swap_LpAccount!
  token: polygon_swap_LpToken!
  amount: polygon_swap_BigDecimal!
  block: BigInt
  modified: BigInt
  transaction: polygon_swap_Bytes
}

input polygon_swap_LpAccountBalance_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  account: String
  account_not: String
  account_gt: String
  account_lt: String
  account_gte: String
  account_lte: String
  account_in: [String!]
  account_not_in: [String!]
  account_contains: String
  account_contains_nocase: String
  account_not_contains: String
  account_not_contains_nocase: String
  account_starts_with: String
  account_starts_with_nocase: String
  account_not_starts_with: String
  account_not_starts_with_nocase: String
  account_ends_with: String
  account_ends_with_nocase: String
  account_not_ends_with: String
  account_not_ends_with_nocase: String
  account_: polygon_swap_LpAccount_filter
  token: String
  token_not: String
  token_gt: String
  token_lt: String
  token_gte: String
  token_lte: String
  token_in: [String!]
  token_not_in: [String!]
  token_contains: String
  token_contains_nocase: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_: polygon_swap_LpToken_filter
  amount: polygon_swap_BigDecimal
  amount_not: polygon_swap_BigDecimal
  amount_gt: polygon_swap_BigDecimal
  amount_lt: polygon_swap_BigDecimal
  amount_gte: polygon_swap_BigDecimal
  amount_lte: polygon_swap_BigDecimal
  amount_in: [polygon_swap_BigDecimal!]
  amount_not_in: [polygon_swap_BigDecimal!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  modified: BigInt
  modified_not: BigInt
  modified_gt: BigInt
  modified_lt: BigInt
  modified_gte: BigInt
  modified_lte: BigInt
  modified_in: [BigInt!]
  modified_not_in: [BigInt!]
  transaction: polygon_swap_Bytes
  transaction_not: polygon_swap_Bytes
  transaction_gt: polygon_swap_Bytes
  transaction_lt: polygon_swap_Bytes
  transaction_gte: polygon_swap_Bytes
  transaction_lte: polygon_swap_Bytes
  transaction_in: [polygon_swap_Bytes!]
  transaction_not_in: [polygon_swap_Bytes!]
  transaction_contains: polygon_swap_Bytes
  transaction_not_contains: polygon_swap_Bytes
  """Filter for the block changed event."""
  _change_block: polygon_swap_BlockChangedFilter
  and: [polygon_swap_LpAccountBalance_filter]
  or: [polygon_swap_LpAccountBalance_filter]
}

enum polygon_swap_LpAccountBalance_orderBy {
  id
  account
  account__id
  account__address
  token
  token__id
  token__address
  token__decimals
  token__name
  token__symbol
  token__totalSupply
  amount
  block
  modified
  transaction
}

input polygon_swap_LpAccount_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  address: polygon_swap_Bytes
  address_not: polygon_swap_Bytes
  address_gt: polygon_swap_Bytes
  address_lt: polygon_swap_Bytes
  address_gte: polygon_swap_Bytes
  address_lte: polygon_swap_Bytes
  address_in: [polygon_swap_Bytes!]
  address_not_in: [polygon_swap_Bytes!]
  address_contains: polygon_swap_Bytes
  address_not_contains: polygon_swap_Bytes
  balances_: polygon_swap_LpAccountBalance_filter
  """Filter for the block changed event."""
  _change_block: polygon_swap_BlockChangedFilter
  and: [polygon_swap_LpAccount_filter]
  or: [polygon_swap_LpAccount_filter]
}

enum polygon_swap_LpAccount_orderBy {
  id
  address
  balances
}

type polygon_swap_LpToken {
  id: ID!
  address: polygon_swap_Bytes!
  stableSwap: polygon_swap_StableSwap!
  decimals: Int!
  name: String!
  symbol: String!
  totalSupply: polygon_swap_BigDecimal!
  events(skip: Int = 0, first: Int = 100, orderBy: polygon_swap_LpTokenEvent_orderBy, orderDirection: polygon_swap_OrderDirection, where: polygon_swap_LpTokenEvent_filter): [polygon_swap_LpTokenEvent!]!
}

interface polygon_swap_LpTokenEvent {
  id: ID!
  token: polygon_swap_LpToken!
  amount: polygon_swap_BigDecimal!
  block: BigInt!
  timestamp: BigInt!
  transaction: polygon_swap_Bytes!
  nonce: BigInt!
}

input polygon_swap_LpTokenEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  token: String
  token_not: String
  token_gt: String
  token_lt: String
  token_gte: String
  token_lte: String
  token_in: [String!]
  token_not_in: [String!]
  token_contains: String
  token_contains_nocase: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_: polygon_swap_LpToken_filter
  amount: polygon_swap_BigDecimal
  amount_not: polygon_swap_BigDecimal
  amount_gt: polygon_swap_BigDecimal
  amount_lt: polygon_swap_BigDecimal
  amount_gte: polygon_swap_BigDecimal
  amount_lte: polygon_swap_BigDecimal
  amount_in: [polygon_swap_BigDecimal!]
  amount_not_in: [polygon_swap_BigDecimal!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: polygon_swap_Bytes
  transaction_not: polygon_swap_Bytes
  transaction_gt: polygon_swap_Bytes
  transaction_lt: polygon_swap_Bytes
  transaction_gte: polygon_swap_Bytes
  transaction_lte: polygon_swap_Bytes
  transaction_in: [polygon_swap_Bytes!]
  transaction_not_in: [polygon_swap_Bytes!]
  transaction_contains: polygon_swap_Bytes
  transaction_not_contains: polygon_swap_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: polygon_swap_BlockChangedFilter
  and: [polygon_swap_LpTokenEvent_filter]
  or: [polygon_swap_LpTokenEvent_filter]
}

enum polygon_swap_LpTokenEvent_orderBy {
  id
  token
  token__id
  token__address
  token__decimals
  token__name
  token__symbol
  token__totalSupply
  amount
  block
  timestamp
  transaction
  nonce
}

input polygon_swap_LpToken_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  address: polygon_swap_Bytes
  address_not: polygon_swap_Bytes
  address_gt: polygon_swap_Bytes
  address_lt: polygon_swap_Bytes
  address_gte: polygon_swap_Bytes
  address_lte: polygon_swap_Bytes
  address_in: [polygon_swap_Bytes!]
  address_not_in: [polygon_swap_Bytes!]
  address_contains: polygon_swap_Bytes
  address_not_contains: polygon_swap_Bytes
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: polygon_swap_StableSwap_filter
  decimals: Int
  decimals_not: Int
  decimals_gt: Int
  decimals_lt: Int
  decimals_gte: Int
  decimals_lte: Int
  decimals_in: [Int!]
  decimals_not_in: [Int!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  symbol: String
  symbol_not: String
  symbol_gt: String
  symbol_lt: String
  symbol_gte: String
  symbol_lte: String
  symbol_in: [String!]
  symbol_not_in: [String!]
  symbol_contains: String
  symbol_contains_nocase: String
  symbol_not_contains: String
  symbol_not_contains_nocase: String
  symbol_starts_with: String
  symbol_starts_with_nocase: String
  symbol_not_starts_with: String
  symbol_not_starts_with_nocase: String
  symbol_ends_with: String
  symbol_ends_with_nocase: String
  symbol_not_ends_with: String
  symbol_not_ends_with_nocase: String
  totalSupply: polygon_swap_BigDecimal
  totalSupply_not: polygon_swap_BigDecimal
  totalSupply_gt: polygon_swap_BigDecimal
  totalSupply_lt: polygon_swap_BigDecimal
  totalSupply_gte: polygon_swap_BigDecimal
  totalSupply_lte: polygon_swap_BigDecimal
  totalSupply_in: [polygon_swap_BigDecimal!]
  totalSupply_not_in: [polygon_swap_BigDecimal!]
  events_: polygon_swap_LpTokenEvent_filter
  """Filter for the block changed event."""
  _change_block: polygon_swap_BlockChangedFilter
  and: [polygon_swap_LpToken_filter]
  or: [polygon_swap_LpToken_filter]
}

enum polygon_swap_LpToken_orderBy {
  id
  address
  stableSwap
  stableSwap__id
  stableSwap__isActive
  stableSwap__key
  stableSwap__canonicalId
  stableSwap__domain
  stableSwap__swapPool
  stableSwap__lpToken
  stableSwap__initialA
  stableSwap__futureA
  stableSwap__initialATime
  stableSwap__futureATime
  stableSwap__swapFee
  stableSwap__adminFee
  stableSwap__virtualPrice
  stableSwap__invariant
  stableSwap__lpTokenSupply
  decimals
  name
  symbol
  totalSupply
  events
}

type polygon_swap_LpTransferEvent implements polygon_swap_LpTokenEvent {
  id: ID!
  token: polygon_swap_LpToken!
  amount: polygon_swap_BigDecimal!
  from: polygon_swap_Bytes!
  to: polygon_swap_Bytes!
  fromBalance: polygon_swap_BigDecimal!
  toBalance: polygon_swap_BigDecimal!
  block: BigInt!
  timestamp: BigInt!
  transaction: polygon_swap_Bytes!
  nonce: BigInt!
}

input polygon_swap_LpTransferEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  token: String
  token_not: String
  token_gt: String
  token_lt: String
  token_gte: String
  token_lte: String
  token_in: [String!]
  token_not_in: [String!]
  token_contains: String
  token_contains_nocase: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_: polygon_swap_LpToken_filter
  amount: polygon_swap_BigDecimal
  amount_not: polygon_swap_BigDecimal
  amount_gt: polygon_swap_BigDecimal
  amount_lt: polygon_swap_BigDecimal
  amount_gte: polygon_swap_BigDecimal
  amount_lte: polygon_swap_BigDecimal
  amount_in: [polygon_swap_BigDecimal!]
  amount_not_in: [polygon_swap_BigDecimal!]
  from: polygon_swap_Bytes
  from_not: polygon_swap_Bytes
  from_gt: polygon_swap_Bytes
  from_lt: polygon_swap_Bytes
  from_gte: polygon_swap_Bytes
  from_lte: polygon_swap_Bytes
  from_in: [polygon_swap_Bytes!]
  from_not_in: [polygon_swap_Bytes!]
  from_contains: polygon_swap_Bytes
  from_not_contains: polygon_swap_Bytes
  to: polygon_swap_Bytes
  to_not: polygon_swap_Bytes
  to_gt: polygon_swap_Bytes
  to_lt: polygon_swap_Bytes
  to_gte: polygon_swap_Bytes
  to_lte: polygon_swap_Bytes
  to_in: [polygon_swap_Bytes!]
  to_not_in: [polygon_swap_Bytes!]
  to_contains: polygon_swap_Bytes
  to_not_contains: polygon_swap_Bytes
  fromBalance: polygon_swap_BigDecimal
  fromBalance_not: polygon_swap_BigDecimal
  fromBalance_gt: polygon_swap_BigDecimal
  fromBalance_lt: polygon_swap_BigDecimal
  fromBalance_gte: polygon_swap_BigDecimal
  fromBalance_lte: polygon_swap_BigDecimal
  fromBalance_in: [polygon_swap_BigDecimal!]
  fromBalance_not_in: [polygon_swap_BigDecimal!]
  toBalance: polygon_swap_BigDecimal
  toBalance_not: polygon_swap_BigDecimal
  toBalance_gt: polygon_swap_BigDecimal
  toBalance_lt: polygon_swap_BigDecimal
  toBalance_gte: polygon_swap_BigDecimal
  toBalance_lte: polygon_swap_BigDecimal
  toBalance_in: [polygon_swap_BigDecimal!]
  toBalance_not_in: [polygon_swap_BigDecimal!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: polygon_swap_Bytes
  transaction_not: polygon_swap_Bytes
  transaction_gt: polygon_swap_Bytes
  transaction_lt: polygon_swap_Bytes
  transaction_gte: polygon_swap_Bytes
  transaction_lte: polygon_swap_Bytes
  transaction_in: [polygon_swap_Bytes!]
  transaction_not_in: [polygon_swap_Bytes!]
  transaction_contains: polygon_swap_Bytes
  transaction_not_contains: polygon_swap_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: polygon_swap_BlockChangedFilter
  and: [polygon_swap_LpTransferEvent_filter]
  or: [polygon_swap_LpTransferEvent_filter]
}

enum polygon_swap_LpTransferEvent_orderBy {
  id
  token
  token__id
  token__address
  token__decimals
  token__name
  token__symbol
  token__totalSupply
  amount
  from
  to
  fromBalance
  toBalance
  block
  timestamp
  transaction
  nonce
}

"""Defines the order direction, either ascending or descending"""
enum polygon_swap_OrderDirection {
  asc
  desc
}

type polygon_swap_PooledToken {
  id: ID!
  asset: polygon_swap_Bytes!
}

input polygon_swap_PooledToken_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  asset: polygon_swap_Bytes
  asset_not: polygon_swap_Bytes
  asset_gt: polygon_swap_Bytes
  asset_lt: polygon_swap_Bytes
  asset_gte: polygon_swap_Bytes
  asset_lte: polygon_swap_Bytes
  asset_in: [polygon_swap_Bytes!]
  asset_not_in: [polygon_swap_Bytes!]
  asset_contains: polygon_swap_Bytes
  asset_not_contains: polygon_swap_Bytes
  """Filter for the block changed event."""
  _change_block: polygon_swap_BlockChangedFilter
  and: [polygon_swap_PooledToken_filter]
  or: [polygon_swap_PooledToken_filter]
}

enum polygon_swap_PooledToken_orderBy {
  id
  asset
}

type polygon_swap_StableSwap {
  id: ID!
  isActive: Boolean
  key: polygon_swap_Bytes!
  canonicalId: polygon_swap_Bytes
  domain: BigInt
  swapPool: polygon_swap_Bytes
  lpToken: polygon_swap_Bytes
  initialA: BigInt
  futureA: BigInt
  initialATime: BigInt
  futureATime: BigInt
  swapFee: BigInt
  adminFee: BigInt
  pooledTokens: [polygon_swap_Bytes!]!
  tokenPrecisionMultipliers: [BigInt!]!
  balances: [BigInt!]!
  adminFees: [BigInt!]!
  virtualPrice: BigInt!
  invariant: BigInt!
  lpTokenSupply: BigInt!
  events(skip: Int = 0, first: Int = 100, orderBy: polygon_swap_StableSwapEvent_orderBy, orderDirection: polygon_swap_OrderDirection, where: polygon_swap_StableSwapEvent_filter): [polygon_swap_StableSwapEvent!]
  exchanges(skip: Int = 0, first: Int = 100, orderBy: polygon_swap_StableSwapExchange_orderBy, orderDirection: polygon_swap_OrderDirection, where: polygon_swap_StableSwapExchange_filter): [polygon_swap_StableSwapExchange!]
  hourlyVolumes(skip: Int = 0, first: Int = 100, orderBy: polygon_swap_SwapHourlyVolume_orderBy, orderDirection: polygon_swap_OrderDirection, where: polygon_swap_SwapHourlyVolume_filter): [polygon_swap_SwapHourlyVolume!]
  dailyVolumes(skip: Int = 0, first: Int = 100, orderBy: polygon_swap_SwapDailyVolume_orderBy, orderDirection: polygon_swap_OrderDirection, where: polygon_swap_SwapDailyVolume_filter): [polygon_swap_SwapDailyVolume!]
  weeklyVolumes(skip: Int = 0, first: Int = 100, orderBy: polygon_swap_SwapWeeklyVolume_orderBy, orderDirection: polygon_swap_OrderDirection, where: polygon_swap_SwapWeeklyVolume_filter): [polygon_swap_SwapWeeklyVolume!]
}

type polygon_swap_StableSwapAddLiquidityEvent implements polygon_swap_StableSwapEvent {
  id: ID!
  stableSwap: polygon_swap_StableSwap!
  provider: polygon_swap_Bytes!
  tokenAmounts: [BigInt!]!
  fees: [BigInt!]!
  invariant: BigInt
  lpTokenSupply: BigInt!
  lpTokenAmount: BigInt!
  balances: [BigInt!]!
  block: BigInt!
  timestamp: BigInt!
  transaction: polygon_swap_Bytes!
  nonce: BigInt!
}

input polygon_swap_StableSwapAddLiquidityEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: polygon_swap_StableSwap_filter
  provider: polygon_swap_Bytes
  provider_not: polygon_swap_Bytes
  provider_gt: polygon_swap_Bytes
  provider_lt: polygon_swap_Bytes
  provider_gte: polygon_swap_Bytes
  provider_lte: polygon_swap_Bytes
  provider_in: [polygon_swap_Bytes!]
  provider_not_in: [polygon_swap_Bytes!]
  provider_contains: polygon_swap_Bytes
  provider_not_contains: polygon_swap_Bytes
  tokenAmounts: [BigInt!]
  tokenAmounts_not: [BigInt!]
  tokenAmounts_contains: [BigInt!]
  tokenAmounts_contains_nocase: [BigInt!]
  tokenAmounts_not_contains: [BigInt!]
  tokenAmounts_not_contains_nocase: [BigInt!]
  fees: [BigInt!]
  fees_not: [BigInt!]
  fees_contains: [BigInt!]
  fees_contains_nocase: [BigInt!]
  fees_not_contains: [BigInt!]
  fees_not_contains_nocase: [BigInt!]
  invariant: BigInt
  invariant_not: BigInt
  invariant_gt: BigInt
  invariant_lt: BigInt
  invariant_gte: BigInt
  invariant_lte: BigInt
  invariant_in: [BigInt!]
  invariant_not_in: [BigInt!]
  lpTokenSupply: BigInt
  lpTokenSupply_not: BigInt
  lpTokenSupply_gt: BigInt
  lpTokenSupply_lt: BigInt
  lpTokenSupply_gte: BigInt
  lpTokenSupply_lte: BigInt
  lpTokenSupply_in: [BigInt!]
  lpTokenSupply_not_in: [BigInt!]
  lpTokenAmount: BigInt
  lpTokenAmount_not: BigInt
  lpTokenAmount_gt: BigInt
  lpTokenAmount_lt: BigInt
  lpTokenAmount_gte: BigInt
  lpTokenAmount_lte: BigInt
  lpTokenAmount_in: [BigInt!]
  lpTokenAmount_not_in: [BigInt!]
  balances: [BigInt!]
  balances_not: [BigInt!]
  balances_contains: [BigInt!]
  balances_contains_nocase: [BigInt!]
  balances_not_contains: [BigInt!]
  balances_not_contains_nocase: [BigInt!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: polygon_swap_Bytes
  transaction_not: polygon_swap_Bytes
  transaction_gt: polygon_swap_Bytes
  transaction_lt: polygon_swap_Bytes
  transaction_gte: polygon_swap_Bytes
  transaction_lte: polygon_swap_Bytes
  transaction_in: [polygon_swap_Bytes!]
  transaction_not_in: [polygon_swap_Bytes!]
  transaction_contains: polygon_swap_Bytes
  transaction_not_contains: polygon_swap_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: polygon_swap_BlockChangedFilter
  and: [polygon_swap_StableSwapAddLiquidityEvent_filter]
  or: [polygon_swap_StableSwapAddLiquidityEvent_filter]
}

enum polygon_swap_StableSwapAddLiquidityEvent_orderBy {
  id
  stableSwap
  stableSwap__id
  stableSwap__isActive
  stableSwap__key
  stableSwap__canonicalId
  stableSwap__domain
  stableSwap__swapPool
  stableSwap__lpToken
  stableSwap__initialA
  stableSwap__futureA
  stableSwap__initialATime
  stableSwap__futureATime
  stableSwap__swapFee
  stableSwap__adminFee
  stableSwap__virtualPrice
  stableSwap__invariant
  stableSwap__lpTokenSupply
  provider
  tokenAmounts
  fees
  invariant
  lpTokenSupply
  lpTokenAmount
  balances
  block
  timestamp
  transaction
  nonce
}

interface polygon_swap_StableSwapEvent {
  id: ID!
  stableSwap: polygon_swap_StableSwap!
  block: BigInt!
  timestamp: BigInt!
  transaction: polygon_swap_Bytes!
  nonce: BigInt!
}

input polygon_swap_StableSwapEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: polygon_swap_StableSwap_filter
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: polygon_swap_Bytes
  transaction_not: polygon_swap_Bytes
  transaction_gt: polygon_swap_Bytes
  transaction_lt: polygon_swap_Bytes
  transaction_gte: polygon_swap_Bytes
  transaction_lte: polygon_swap_Bytes
  transaction_in: [polygon_swap_Bytes!]
  transaction_not_in: [polygon_swap_Bytes!]
  transaction_contains: polygon_swap_Bytes
  transaction_not_contains: polygon_swap_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: polygon_swap_BlockChangedFilter
  and: [polygon_swap_StableSwapEvent_filter]
  or: [polygon_swap_StableSwapEvent_filter]
}

enum polygon_swap_StableSwapEvent_orderBy {
  id
  stableSwap
  stableSwap__id
  stableSwap__isActive
  stableSwap__key
  stableSwap__canonicalId
  stableSwap__domain
  stableSwap__swapPool
  stableSwap__lpToken
  stableSwap__initialA
  stableSwap__futureA
  stableSwap__initialATime
  stableSwap__futureATime
  stableSwap__swapFee
  stableSwap__adminFee
  stableSwap__virtualPrice
  stableSwap__invariant
  stableSwap__lpTokenSupply
  block
  timestamp
  transaction
  nonce
}

type polygon_swap_StableSwapExchange {
  id: ID!
  stableSwap: polygon_swap_StableSwap!
  buyer: polygon_swap_Bytes!
  boughtId: BigInt!
  tokensBought: BigInt!
  soldId: BigInt!
  tokensSold: BigInt!
  balances: [BigInt!]!
  fee: BigInt!
  block: BigInt!
  timestamp: BigInt!
  transaction: polygon_swap_Bytes!
  nonce: BigInt!
}

input polygon_swap_StableSwapExchange_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: polygon_swap_StableSwap_filter
  buyer: polygon_swap_Bytes
  buyer_not: polygon_swap_Bytes
  buyer_gt: polygon_swap_Bytes
  buyer_lt: polygon_swap_Bytes
  buyer_gte: polygon_swap_Bytes
  buyer_lte: polygon_swap_Bytes
  buyer_in: [polygon_swap_Bytes!]
  buyer_not_in: [polygon_swap_Bytes!]
  buyer_contains: polygon_swap_Bytes
  buyer_not_contains: polygon_swap_Bytes
  boughtId: BigInt
  boughtId_not: BigInt
  boughtId_gt: BigInt
  boughtId_lt: BigInt
  boughtId_gte: BigInt
  boughtId_lte: BigInt
  boughtId_in: [BigInt!]
  boughtId_not_in: [BigInt!]
  tokensBought: BigInt
  tokensBought_not: BigInt
  tokensBought_gt: BigInt
  tokensBought_lt: BigInt
  tokensBought_gte: BigInt
  tokensBought_lte: BigInt
  tokensBought_in: [BigInt!]
  tokensBought_not_in: [BigInt!]
  soldId: BigInt
  soldId_not: BigInt
  soldId_gt: BigInt
  soldId_lt: BigInt
  soldId_gte: BigInt
  soldId_lte: BigInt
  soldId_in: [BigInt!]
  soldId_not_in: [BigInt!]
  tokensSold: BigInt
  tokensSold_not: BigInt
  tokensSold_gt: BigInt
  tokensSold_lt: BigInt
  tokensSold_gte: BigInt
  tokensSold_lte: BigInt
  tokensSold_in: [BigInt!]
  tokensSold_not_in: [BigInt!]
  balances: [BigInt!]
  balances_not: [BigInt!]
  balances_contains: [BigInt!]
  balances_contains_nocase: [BigInt!]
  balances_not_contains: [BigInt!]
  balances_not_contains_nocase: [BigInt!]
  fee: BigInt
  fee_not: BigInt
  fee_gt: BigInt
  fee_lt: BigInt
  fee_gte: BigInt
  fee_lte: BigInt
  fee_in: [BigInt!]
  fee_not_in: [BigInt!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: polygon_swap_Bytes
  transaction_not: polygon_swap_Bytes
  transaction_gt: polygon_swap_Bytes
  transaction_lt: polygon_swap_Bytes
  transaction_gte: polygon_swap_Bytes
  transaction_lte: polygon_swap_Bytes
  transaction_in: [polygon_swap_Bytes!]
  transaction_not_in: [polygon_swap_Bytes!]
  transaction_contains: polygon_swap_Bytes
  transaction_not_contains: polygon_swap_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: polygon_swap_BlockChangedFilter
  and: [polygon_swap_StableSwapExchange_filter]
  or: [polygon_swap_StableSwapExchange_filter]
}

enum polygon_swap_StableSwapExchange_orderBy {
  id
  stableSwap
  stableSwap__id
  stableSwap__isActive
  stableSwap__key
  stableSwap__canonicalId
  stableSwap__domain
  stableSwap__swapPool
  stableSwap__lpToken
  stableSwap__initialA
  stableSwap__futureA
  stableSwap__initialATime
  stableSwap__futureATime
  stableSwap__swapFee
  stableSwap__adminFee
  stableSwap__virtualPrice
  stableSwap__invariant
  stableSwap__lpTokenSupply
  buyer
  boughtId
  tokensBought
  soldId
  tokensSold
  balances
  fee
  block
  timestamp
  transaction
  nonce
}

type polygon_swap_StableSwapRemoveLiquidityEvent implements polygon_swap_StableSwapEvent {
  id: ID!
  stableSwap: polygon_swap_StableSwap!
  provider: polygon_swap_Bytes!
  tokenAmounts: [BigInt!]!
  fees: [BigInt!]
  invariant: BigInt
  lpTokenSupply: BigInt!
  lpTokenAmount: BigInt!
  balances: [BigInt!]!
  block: BigInt!
  timestamp: BigInt!
  transaction: polygon_swap_Bytes!
  nonce: BigInt!
}

input polygon_swap_StableSwapRemoveLiquidityEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: polygon_swap_StableSwap_filter
  provider: polygon_swap_Bytes
  provider_not: polygon_swap_Bytes
  provider_gt: polygon_swap_Bytes
  provider_lt: polygon_swap_Bytes
  provider_gte: polygon_swap_Bytes
  provider_lte: polygon_swap_Bytes
  provider_in: [polygon_swap_Bytes!]
  provider_not_in: [polygon_swap_Bytes!]
  provider_contains: polygon_swap_Bytes
  provider_not_contains: polygon_swap_Bytes
  tokenAmounts: [BigInt!]
  tokenAmounts_not: [BigInt!]
  tokenAmounts_contains: [BigInt!]
  tokenAmounts_contains_nocase: [BigInt!]
  tokenAmounts_not_contains: [BigInt!]
  tokenAmounts_not_contains_nocase: [BigInt!]
  fees: [BigInt!]
  fees_not: [BigInt!]
  fees_contains: [BigInt!]
  fees_contains_nocase: [BigInt!]
  fees_not_contains: [BigInt!]
  fees_not_contains_nocase: [BigInt!]
  invariant: BigInt
  invariant_not: BigInt
  invariant_gt: BigInt
  invariant_lt: BigInt
  invariant_gte: BigInt
  invariant_lte: BigInt
  invariant_in: [BigInt!]
  invariant_not_in: [BigInt!]
  lpTokenSupply: BigInt
  lpTokenSupply_not: BigInt
  lpTokenSupply_gt: BigInt
  lpTokenSupply_lt: BigInt
  lpTokenSupply_gte: BigInt
  lpTokenSupply_lte: BigInt
  lpTokenSupply_in: [BigInt!]
  lpTokenSupply_not_in: [BigInt!]
  lpTokenAmount: BigInt
  lpTokenAmount_not: BigInt
  lpTokenAmount_gt: BigInt
  lpTokenAmount_lt: BigInt
  lpTokenAmount_gte: BigInt
  lpTokenAmount_lte: BigInt
  lpTokenAmount_in: [BigInt!]
  lpTokenAmount_not_in: [BigInt!]
  balances: [BigInt!]
  balances_not: [BigInt!]
  balances_contains: [BigInt!]
  balances_contains_nocase: [BigInt!]
  balances_not_contains: [BigInt!]
  balances_not_contains_nocase: [BigInt!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: polygon_swap_Bytes
  transaction_not: polygon_swap_Bytes
  transaction_gt: polygon_swap_Bytes
  transaction_lt: polygon_swap_Bytes
  transaction_gte: polygon_swap_Bytes
  transaction_lte: polygon_swap_Bytes
  transaction_in: [polygon_swap_Bytes!]
  transaction_not_in: [polygon_swap_Bytes!]
  transaction_contains: polygon_swap_Bytes
  transaction_not_contains: polygon_swap_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: polygon_swap_BlockChangedFilter
  and: [polygon_swap_StableSwapRemoveLiquidityEvent_filter]
  or: [polygon_swap_StableSwapRemoveLiquidityEvent_filter]
}

enum polygon_swap_StableSwapRemoveLiquidityEvent_orderBy {
  id
  stableSwap
  stableSwap__id
  stableSwap__isActive
  stableSwap__key
  stableSwap__canonicalId
  stableSwap__domain
  stableSwap__swapPool
  stableSwap__lpToken
  stableSwap__initialA
  stableSwap__futureA
  stableSwap__initialATime
  stableSwap__futureATime
  stableSwap__swapFee
  stableSwap__adminFee
  stableSwap__virtualPrice
  stableSwap__invariant
  stableSwap__lpTokenSupply
  provider
  tokenAmounts
  fees
  invariant
  lpTokenSupply
  lpTokenAmount
  balances
  block
  timestamp
  transaction
  nonce
}

input polygon_swap_StableSwap_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  isActive: Boolean
  isActive_not: Boolean
  isActive_in: [Boolean!]
  isActive_not_in: [Boolean!]
  key: polygon_swap_Bytes
  key_not: polygon_swap_Bytes
  key_gt: polygon_swap_Bytes
  key_lt: polygon_swap_Bytes
  key_gte: polygon_swap_Bytes
  key_lte: polygon_swap_Bytes
  key_in: [polygon_swap_Bytes!]
  key_not_in: [polygon_swap_Bytes!]
  key_contains: polygon_swap_Bytes
  key_not_contains: polygon_swap_Bytes
  canonicalId: polygon_swap_Bytes
  canonicalId_not: polygon_swap_Bytes
  canonicalId_gt: polygon_swap_Bytes
  canonicalId_lt: polygon_swap_Bytes
  canonicalId_gte: polygon_swap_Bytes
  canonicalId_lte: polygon_swap_Bytes
  canonicalId_in: [polygon_swap_Bytes!]
  canonicalId_not_in: [polygon_swap_Bytes!]
  canonicalId_contains: polygon_swap_Bytes
  canonicalId_not_contains: polygon_swap_Bytes
  domain: BigInt
  domain_not: BigInt
  domain_gt: BigInt
  domain_lt: BigInt
  domain_gte: BigInt
  domain_lte: BigInt
  domain_in: [BigInt!]
  domain_not_in: [BigInt!]
  swapPool: polygon_swap_Bytes
  swapPool_not: polygon_swap_Bytes
  swapPool_gt: polygon_swap_Bytes
  swapPool_lt: polygon_swap_Bytes
  swapPool_gte: polygon_swap_Bytes
  swapPool_lte: polygon_swap_Bytes
  swapPool_in: [polygon_swap_Bytes!]
  swapPool_not_in: [polygon_swap_Bytes!]
  swapPool_contains: polygon_swap_Bytes
  swapPool_not_contains: polygon_swap_Bytes
  lpToken: polygon_swap_Bytes
  lpToken_not: polygon_swap_Bytes
  lpToken_gt: polygon_swap_Bytes
  lpToken_lt: polygon_swap_Bytes
  lpToken_gte: polygon_swap_Bytes
  lpToken_lte: polygon_swap_Bytes
  lpToken_in: [polygon_swap_Bytes!]
  lpToken_not_in: [polygon_swap_Bytes!]
  lpToken_contains: polygon_swap_Bytes
  lpToken_not_contains: polygon_swap_Bytes
  initialA: BigInt
  initialA_not: BigInt
  initialA_gt: BigInt
  initialA_lt: BigInt
  initialA_gte: BigInt
  initialA_lte: BigInt
  initialA_in: [BigInt!]
  initialA_not_in: [BigInt!]
  futureA: BigInt
  futureA_not: BigInt
  futureA_gt: BigInt
  futureA_lt: BigInt
  futureA_gte: BigInt
  futureA_lte: BigInt
  futureA_in: [BigInt!]
  futureA_not_in: [BigInt!]
  initialATime: BigInt
  initialATime_not: BigInt
  initialATime_gt: BigInt
  initialATime_lt: BigInt
  initialATime_gte: BigInt
  initialATime_lte: BigInt
  initialATime_in: [BigInt!]
  initialATime_not_in: [BigInt!]
  futureATime: BigInt
  futureATime_not: BigInt
  futureATime_gt: BigInt
  futureATime_lt: BigInt
  futureATime_gte: BigInt
  futureATime_lte: BigInt
  futureATime_in: [BigInt!]
  futureATime_not_in: [BigInt!]
  swapFee: BigInt
  swapFee_not: BigInt
  swapFee_gt: BigInt
  swapFee_lt: BigInt
  swapFee_gte: BigInt
  swapFee_lte: BigInt
  swapFee_in: [BigInt!]
  swapFee_not_in: [BigInt!]
  adminFee: BigInt
  adminFee_not: BigInt
  adminFee_gt: BigInt
  adminFee_lt: BigInt
  adminFee_gte: BigInt
  adminFee_lte: BigInt
  adminFee_in: [BigInt!]
  adminFee_not_in: [BigInt!]
  pooledTokens: [polygon_swap_Bytes!]
  pooledTokens_not: [polygon_swap_Bytes!]
  pooledTokens_contains: [polygon_swap_Bytes!]
  pooledTokens_contains_nocase: [polygon_swap_Bytes!]
  pooledTokens_not_contains: [polygon_swap_Bytes!]
  pooledTokens_not_contains_nocase: [polygon_swap_Bytes!]
  tokenPrecisionMultipliers: [BigInt!]
  tokenPrecisionMultipliers_not: [BigInt!]
  tokenPrecisionMultipliers_contains: [BigInt!]
  tokenPrecisionMultipliers_contains_nocase: [BigInt!]
  tokenPrecisionMultipliers_not_contains: [BigInt!]
  tokenPrecisionMultipliers_not_contains_nocase: [BigInt!]
  balances: [BigInt!]
  balances_not: [BigInt!]
  balances_contains: [BigInt!]
  balances_contains_nocase: [BigInt!]
  balances_not_contains: [BigInt!]
  balances_not_contains_nocase: [BigInt!]
  adminFees: [BigInt!]
  adminFees_not: [BigInt!]
  adminFees_contains: [BigInt!]
  adminFees_contains_nocase: [BigInt!]
  adminFees_not_contains: [BigInt!]
  adminFees_not_contains_nocase: [BigInt!]
  virtualPrice: BigInt
  virtualPrice_not: BigInt
  virtualPrice_gt: BigInt
  virtualPrice_lt: BigInt
  virtualPrice_gte: BigInt
  virtualPrice_lte: BigInt
  virtualPrice_in: [BigInt!]
  virtualPrice_not_in: [BigInt!]
  invariant: BigInt
  invariant_not: BigInt
  invariant_gt: BigInt
  invariant_lt: BigInt
  invariant_gte: BigInt
  invariant_lte: BigInt
  invariant_in: [BigInt!]
  invariant_not_in: [BigInt!]
  lpTokenSupply: BigInt
  lpTokenSupply_not: BigInt
  lpTokenSupply_gt: BigInt
  lpTokenSupply_lt: BigInt
  lpTokenSupply_gte: BigInt
  lpTokenSupply_lte: BigInt
  lpTokenSupply_in: [BigInt!]
  lpTokenSupply_not_in: [BigInt!]
  events_: polygon_swap_StableSwapEvent_filter
  exchanges_: polygon_swap_StableSwapExchange_filter
  hourlyVolumes_: polygon_swap_SwapHourlyVolume_filter
  dailyVolumes_: polygon_swap_SwapDailyVolume_filter
  weeklyVolumes_: polygon_swap_SwapWeeklyVolume_filter
  """Filter for the block changed event."""
  _change_block: polygon_swap_BlockChangedFilter
  and: [polygon_swap_StableSwap_filter]
  or: [polygon_swap_StableSwap_filter]
}

enum polygon_swap_StableSwap_orderBy {
  id
  isActive
  key
  canonicalId
  domain
  swapPool
  lpToken
  initialA
  futureA
  initialATime
  futureATime
  swapFee
  adminFee
  pooledTokens
  tokenPrecisionMultipliers
  balances
  adminFees
  virtualPrice
  invariant
  lpTokenSupply
  events
  exchanges
  hourlyVolumes
  dailyVolumes
  weeklyVolumes
}

type polygon_swap_SwapDailyVolume implements polygon_swap_SwapTradeVolume {
  id: ID!
  stableSwap: polygon_swap_StableSwap!
  timestamp: BigInt!
  volume: polygon_swap_BigDecimal!
}

input polygon_swap_SwapDailyVolume_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: polygon_swap_StableSwap_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  volume: polygon_swap_BigDecimal
  volume_not: polygon_swap_BigDecimal
  volume_gt: polygon_swap_BigDecimal
  volume_lt: polygon_swap_BigDecimal
  volume_gte: polygon_swap_BigDecimal
  volume_lte: polygon_swap_BigDecimal
  volume_in: [polygon_swap_BigDecimal!]
  volume_not_in: [polygon_swap_BigDecimal!]
  """Filter for the block changed event."""
  _change_block: polygon_swap_BlockChangedFilter
  and: [polygon_swap_SwapDailyVolume_filter]
  or: [polygon_swap_SwapDailyVolume_filter]
}

enum polygon_swap_SwapDailyVolume_orderBy {
  id
  stableSwap
  stableSwap__id
  stableSwap__isActive
  stableSwap__key
  stableSwap__canonicalId
  stableSwap__domain
  stableSwap__swapPool
  stableSwap__lpToken
  stableSwap__initialA
  stableSwap__futureA
  stableSwap__initialATime
  stableSwap__futureATime
  stableSwap__swapFee
  stableSwap__adminFee
  stableSwap__virtualPrice
  stableSwap__invariant
  stableSwap__lpTokenSupply
  timestamp
  volume
}

type polygon_swap_SwapHourlyVolume implements polygon_swap_SwapTradeVolume {
  id: ID!
  stableSwap: polygon_swap_StableSwap!
  timestamp: BigInt!
  volume: polygon_swap_BigDecimal!
}

input polygon_swap_SwapHourlyVolume_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: polygon_swap_StableSwap_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  volume: polygon_swap_BigDecimal
  volume_not: polygon_swap_BigDecimal
  volume_gt: polygon_swap_BigDecimal
  volume_lt: polygon_swap_BigDecimal
  volume_gte: polygon_swap_BigDecimal
  volume_lte: polygon_swap_BigDecimal
  volume_in: [polygon_swap_BigDecimal!]
  volume_not_in: [polygon_swap_BigDecimal!]
  """Filter for the block changed event."""
  _change_block: polygon_swap_BlockChangedFilter
  and: [polygon_swap_SwapHourlyVolume_filter]
  or: [polygon_swap_SwapHourlyVolume_filter]
}

enum polygon_swap_SwapHourlyVolume_orderBy {
  id
  stableSwap
  stableSwap__id
  stableSwap__isActive
  stableSwap__key
  stableSwap__canonicalId
  stableSwap__domain
  stableSwap__swapPool
  stableSwap__lpToken
  stableSwap__initialA
  stableSwap__futureA
  stableSwap__initialATime
  stableSwap__futureATime
  stableSwap__swapFee
  stableSwap__adminFee
  stableSwap__virtualPrice
  stableSwap__invariant
  stableSwap__lpTokenSupply
  timestamp
  volume
}

interface polygon_swap_SwapTradeVolume {
  stableSwap: polygon_swap_StableSwap!
  timestamp: BigInt!
  volume: polygon_swap_BigDecimal!
}

input polygon_swap_SwapTradeVolume_filter {
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: polygon_swap_StableSwap_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  volume: polygon_swap_BigDecimal
  volume_not: polygon_swap_BigDecimal
  volume_gt: polygon_swap_BigDecimal
  volume_lt: polygon_swap_BigDecimal
  volume_gte: polygon_swap_BigDecimal
  volume_lte: polygon_swap_BigDecimal
  volume_in: [polygon_swap_BigDecimal!]
  volume_not_in: [polygon_swap_BigDecimal!]
  """Filter for the block changed event."""
  _change_block: polygon_swap_BlockChangedFilter
  and: [polygon_swap_SwapTradeVolume_filter]
  or: [polygon_swap_SwapTradeVolume_filter]
}

enum polygon_swap_SwapTradeVolume_orderBy {
  stableSwap
  stableSwap__id
  stableSwap__isActive
  stableSwap__key
  stableSwap__canonicalId
  stableSwap__domain
  stableSwap__swapPool
  stableSwap__lpToken
  stableSwap__initialA
  stableSwap__futureA
  stableSwap__initialATime
  stableSwap__futureATime
  stableSwap__swapFee
  stableSwap__adminFee
  stableSwap__virtualPrice
  stableSwap__invariant
  stableSwap__lpTokenSupply
  timestamp
  volume
}

type polygon_swap_SwapWeeklyVolume implements polygon_swap_SwapTradeVolume {
  id: ID!
  stableSwap: polygon_swap_StableSwap!
  timestamp: BigInt!
  volume: polygon_swap_BigDecimal!
}

input polygon_swap_SwapWeeklyVolume_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: polygon_swap_StableSwap_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  volume: polygon_swap_BigDecimal
  volume_not: polygon_swap_BigDecimal
  volume_gt: polygon_swap_BigDecimal
  volume_lt: polygon_swap_BigDecimal
  volume_gte: polygon_swap_BigDecimal
  volume_lte: polygon_swap_BigDecimal
  volume_in: [polygon_swap_BigDecimal!]
  volume_not_in: [polygon_swap_BigDecimal!]
  """Filter for the block changed event."""
  _change_block: polygon_swap_BlockChangedFilter
  and: [polygon_swap_SwapWeeklyVolume_filter]
  or: [polygon_swap_SwapWeeklyVolume_filter]
}

enum polygon_swap_SwapWeeklyVolume_orderBy {
  id
  stableSwap
  stableSwap__id
  stableSwap__isActive
  stableSwap__key
  stableSwap__canonicalId
  stableSwap__domain
  stableSwap__swapPool
  stableSwap__lpToken
  stableSwap__initialA
  stableSwap__futureA
  stableSwap__initialATime
  stableSwap__futureATime
  stableSwap__swapFee
  stableSwap__adminFee
  stableSwap__virtualPrice
  stableSwap__invariant
  stableSwap__lpTokenSupply
  timestamp
  volume
}

type polygon_swap_SystemInfo {
  id: ID!
  exchangeCount: BigInt!
  swapCount: BigInt!
}

input polygon_swap_SystemInfo_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  exchangeCount: BigInt
  exchangeCount_not: BigInt
  exchangeCount_gt: BigInt
  exchangeCount_lt: BigInt
  exchangeCount_gte: BigInt
  exchangeCount_lte: BigInt
  exchangeCount_in: [BigInt!]
  exchangeCount_not_in: [BigInt!]
  swapCount: BigInt
  swapCount_not: BigInt
  swapCount_gt: BigInt
  swapCount_lt: BigInt
  swapCount_gte: BigInt
  swapCount_lte: BigInt
  swapCount_in: [BigInt!]
  swapCount_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: polygon_swap_BlockChangedFilter
  and: [polygon_swap_SystemInfo_filter]
  or: [polygon_swap_SystemInfo_filter]
}

enum polygon_swap_SystemInfo_orderBy {
  id
  exchangeCount
  swapCount
}

type polygon_swap__Block_ {
  """The hash of the block"""
  hash: polygon_swap_Bytes
  """The block number"""
  number: Int!
  """Integer representation of the timestamp stored in blocks for the chain"""
  timestamp: Int
  """The hash of the parent block"""
  parentHash: polygon_swap_Bytes
}

"""The type for the top-level _meta field"""
type polygon_swap__Meta_ {
  """
  Information about a specific subgraph block. The hash of the block
  will be null if the _meta field has a block constraint that asks for
  a block number. It will be filled if the _meta field has no block constraint
  and therefore asks for the latest  block
  
  """
  block: polygon_swap__Block_!
  """The deployment ID"""
  deployment: String!
  """If `true`, the subgraph encountered indexing errors at some past block"""
  hasIndexingErrors: Boolean!
}

enum optimism_swap_Aggregation_interval {
  hour
  day
}

scalar optimism_swap_BigDecimal

input optimism_swap_BlockChangedFilter {
  number_gte: Int!
}

input optimism_swap_Block_height {
  hash: optimism_swap_Bytes
  number: Int
  number_gte: Int
}

scalar optimism_swap_Bytes

"""
8 bytes signed integer

"""
scalar optimism_swap_Int8

type optimism_swap_LpAccount {
  id: ID!
  address: optimism_swap_Bytes!
  balances(skip: Int = 0, first: Int = 100, orderBy: optimism_swap_LpAccountBalance_orderBy, orderDirection: optimism_swap_OrderDirection, where: optimism_swap_LpAccountBalance_filter): [optimism_swap_LpAccountBalance!]!
}

type optimism_swap_LpAccountBalance {
  id: ID!
  account: optimism_swap_LpAccount!
  token: optimism_swap_LpToken!
  amount: optimism_swap_BigDecimal!
  block: BigInt
  modified: BigInt
  transaction: optimism_swap_Bytes
}

input optimism_swap_LpAccountBalance_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  account: String
  account_not: String
  account_gt: String
  account_lt: String
  account_gte: String
  account_lte: String
  account_in: [String!]
  account_not_in: [String!]
  account_contains: String
  account_contains_nocase: String
  account_not_contains: String
  account_not_contains_nocase: String
  account_starts_with: String
  account_starts_with_nocase: String
  account_not_starts_with: String
  account_not_starts_with_nocase: String
  account_ends_with: String
  account_ends_with_nocase: String
  account_not_ends_with: String
  account_not_ends_with_nocase: String
  account_: optimism_swap_LpAccount_filter
  token: String
  token_not: String
  token_gt: String
  token_lt: String
  token_gte: String
  token_lte: String
  token_in: [String!]
  token_not_in: [String!]
  token_contains: String
  token_contains_nocase: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_: optimism_swap_LpToken_filter
  amount: optimism_swap_BigDecimal
  amount_not: optimism_swap_BigDecimal
  amount_gt: optimism_swap_BigDecimal
  amount_lt: optimism_swap_BigDecimal
  amount_gte: optimism_swap_BigDecimal
  amount_lte: optimism_swap_BigDecimal
  amount_in: [optimism_swap_BigDecimal!]
  amount_not_in: [optimism_swap_BigDecimal!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  modified: BigInt
  modified_not: BigInt
  modified_gt: BigInt
  modified_lt: BigInt
  modified_gte: BigInt
  modified_lte: BigInt
  modified_in: [BigInt!]
  modified_not_in: [BigInt!]
  transaction: optimism_swap_Bytes
  transaction_not: optimism_swap_Bytes
  transaction_gt: optimism_swap_Bytes
  transaction_lt: optimism_swap_Bytes
  transaction_gte: optimism_swap_Bytes
  transaction_lte: optimism_swap_Bytes
  transaction_in: [optimism_swap_Bytes!]
  transaction_not_in: [optimism_swap_Bytes!]
  transaction_contains: optimism_swap_Bytes
  transaction_not_contains: optimism_swap_Bytes
  """Filter for the block changed event."""
  _change_block: optimism_swap_BlockChangedFilter
  and: [optimism_swap_LpAccountBalance_filter]
  or: [optimism_swap_LpAccountBalance_filter]
}

enum optimism_swap_LpAccountBalance_orderBy {
  id
  account
  account__id
  account__address
  token
  token__id
  token__address
  token__decimals
  token__name
  token__symbol
  token__totalSupply
  amount
  block
  modified
  transaction
}

input optimism_swap_LpAccount_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  address: optimism_swap_Bytes
  address_not: optimism_swap_Bytes
  address_gt: optimism_swap_Bytes
  address_lt: optimism_swap_Bytes
  address_gte: optimism_swap_Bytes
  address_lte: optimism_swap_Bytes
  address_in: [optimism_swap_Bytes!]
  address_not_in: [optimism_swap_Bytes!]
  address_contains: optimism_swap_Bytes
  address_not_contains: optimism_swap_Bytes
  balances_: optimism_swap_LpAccountBalance_filter
  """Filter for the block changed event."""
  _change_block: optimism_swap_BlockChangedFilter
  and: [optimism_swap_LpAccount_filter]
  or: [optimism_swap_LpAccount_filter]
}

enum optimism_swap_LpAccount_orderBy {
  id
  address
  balances
}

type optimism_swap_LpToken {
  id: ID!
  address: optimism_swap_Bytes!
  stableSwap: optimism_swap_StableSwap!
  decimals: Int!
  name: String!
  symbol: String!
  totalSupply: optimism_swap_BigDecimal!
  events(skip: Int = 0, first: Int = 100, orderBy: optimism_swap_LpTokenEvent_orderBy, orderDirection: optimism_swap_OrderDirection, where: optimism_swap_LpTokenEvent_filter): [optimism_swap_LpTokenEvent!]!
}

interface optimism_swap_LpTokenEvent {
  id: ID!
  token: optimism_swap_LpToken!
  amount: optimism_swap_BigDecimal!
  block: BigInt!
  timestamp: BigInt!
  transaction: optimism_swap_Bytes!
  nonce: BigInt!
}

input optimism_swap_LpTokenEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  token: String
  token_not: String
  token_gt: String
  token_lt: String
  token_gte: String
  token_lte: String
  token_in: [String!]
  token_not_in: [String!]
  token_contains: String
  token_contains_nocase: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_: optimism_swap_LpToken_filter
  amount: optimism_swap_BigDecimal
  amount_not: optimism_swap_BigDecimal
  amount_gt: optimism_swap_BigDecimal
  amount_lt: optimism_swap_BigDecimal
  amount_gte: optimism_swap_BigDecimal
  amount_lte: optimism_swap_BigDecimal
  amount_in: [optimism_swap_BigDecimal!]
  amount_not_in: [optimism_swap_BigDecimal!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: optimism_swap_Bytes
  transaction_not: optimism_swap_Bytes
  transaction_gt: optimism_swap_Bytes
  transaction_lt: optimism_swap_Bytes
  transaction_gte: optimism_swap_Bytes
  transaction_lte: optimism_swap_Bytes
  transaction_in: [optimism_swap_Bytes!]
  transaction_not_in: [optimism_swap_Bytes!]
  transaction_contains: optimism_swap_Bytes
  transaction_not_contains: optimism_swap_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: optimism_swap_BlockChangedFilter
  and: [optimism_swap_LpTokenEvent_filter]
  or: [optimism_swap_LpTokenEvent_filter]
}

enum optimism_swap_LpTokenEvent_orderBy {
  id
  token
  token__id
  token__address
  token__decimals
  token__name
  token__symbol
  token__totalSupply
  amount
  block
  timestamp
  transaction
  nonce
}

input optimism_swap_LpToken_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  address: optimism_swap_Bytes
  address_not: optimism_swap_Bytes
  address_gt: optimism_swap_Bytes
  address_lt: optimism_swap_Bytes
  address_gte: optimism_swap_Bytes
  address_lte: optimism_swap_Bytes
  address_in: [optimism_swap_Bytes!]
  address_not_in: [optimism_swap_Bytes!]
  address_contains: optimism_swap_Bytes
  address_not_contains: optimism_swap_Bytes
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: optimism_swap_StableSwap_filter
  decimals: Int
  decimals_not: Int
  decimals_gt: Int
  decimals_lt: Int
  decimals_gte: Int
  decimals_lte: Int
  decimals_in: [Int!]
  decimals_not_in: [Int!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  symbol: String
  symbol_not: String
  symbol_gt: String
  symbol_lt: String
  symbol_gte: String
  symbol_lte: String
  symbol_in: [String!]
  symbol_not_in: [String!]
  symbol_contains: String
  symbol_contains_nocase: String
  symbol_not_contains: String
  symbol_not_contains_nocase: String
  symbol_starts_with: String
  symbol_starts_with_nocase: String
  symbol_not_starts_with: String
  symbol_not_starts_with_nocase: String
  symbol_ends_with: String
  symbol_ends_with_nocase: String
  symbol_not_ends_with: String
  symbol_not_ends_with_nocase: String
  totalSupply: optimism_swap_BigDecimal
  totalSupply_not: optimism_swap_BigDecimal
  totalSupply_gt: optimism_swap_BigDecimal
  totalSupply_lt: optimism_swap_BigDecimal
  totalSupply_gte: optimism_swap_BigDecimal
  totalSupply_lte: optimism_swap_BigDecimal
  totalSupply_in: [optimism_swap_BigDecimal!]
  totalSupply_not_in: [optimism_swap_BigDecimal!]
  events_: optimism_swap_LpTokenEvent_filter
  """Filter for the block changed event."""
  _change_block: optimism_swap_BlockChangedFilter
  and: [optimism_swap_LpToken_filter]
  or: [optimism_swap_LpToken_filter]
}

enum optimism_swap_LpToken_orderBy {
  id
  address
  stableSwap
  stableSwap__id
  stableSwap__isActive
  stableSwap__key
  stableSwap__canonicalId
  stableSwap__domain
  stableSwap__swapPool
  stableSwap__lpToken
  stableSwap__initialA
  stableSwap__futureA
  stableSwap__initialATime
  stableSwap__futureATime
  stableSwap__swapFee
  stableSwap__adminFee
  stableSwap__virtualPrice
  stableSwap__invariant
  stableSwap__lpTokenSupply
  decimals
  name
  symbol
  totalSupply
  events
}

type optimism_swap_LpTransferEvent implements optimism_swap_LpTokenEvent {
  id: ID!
  token: optimism_swap_LpToken!
  amount: optimism_swap_BigDecimal!
  from: optimism_swap_Bytes!
  to: optimism_swap_Bytes!
  fromBalance: optimism_swap_BigDecimal!
  toBalance: optimism_swap_BigDecimal!
  block: BigInt!
  timestamp: BigInt!
  transaction: optimism_swap_Bytes!
  nonce: BigInt!
}

input optimism_swap_LpTransferEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  token: String
  token_not: String
  token_gt: String
  token_lt: String
  token_gte: String
  token_lte: String
  token_in: [String!]
  token_not_in: [String!]
  token_contains: String
  token_contains_nocase: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_: optimism_swap_LpToken_filter
  amount: optimism_swap_BigDecimal
  amount_not: optimism_swap_BigDecimal
  amount_gt: optimism_swap_BigDecimal
  amount_lt: optimism_swap_BigDecimal
  amount_gte: optimism_swap_BigDecimal
  amount_lte: optimism_swap_BigDecimal
  amount_in: [optimism_swap_BigDecimal!]
  amount_not_in: [optimism_swap_BigDecimal!]
  from: optimism_swap_Bytes
  from_not: optimism_swap_Bytes
  from_gt: optimism_swap_Bytes
  from_lt: optimism_swap_Bytes
  from_gte: optimism_swap_Bytes
  from_lte: optimism_swap_Bytes
  from_in: [optimism_swap_Bytes!]
  from_not_in: [optimism_swap_Bytes!]
  from_contains: optimism_swap_Bytes
  from_not_contains: optimism_swap_Bytes
  to: optimism_swap_Bytes
  to_not: optimism_swap_Bytes
  to_gt: optimism_swap_Bytes
  to_lt: optimism_swap_Bytes
  to_gte: optimism_swap_Bytes
  to_lte: optimism_swap_Bytes
  to_in: [optimism_swap_Bytes!]
  to_not_in: [optimism_swap_Bytes!]
  to_contains: optimism_swap_Bytes
  to_not_contains: optimism_swap_Bytes
  fromBalance: optimism_swap_BigDecimal
  fromBalance_not: optimism_swap_BigDecimal
  fromBalance_gt: optimism_swap_BigDecimal
  fromBalance_lt: optimism_swap_BigDecimal
  fromBalance_gte: optimism_swap_BigDecimal
  fromBalance_lte: optimism_swap_BigDecimal
  fromBalance_in: [optimism_swap_BigDecimal!]
  fromBalance_not_in: [optimism_swap_BigDecimal!]
  toBalance: optimism_swap_BigDecimal
  toBalance_not: optimism_swap_BigDecimal
  toBalance_gt: optimism_swap_BigDecimal
  toBalance_lt: optimism_swap_BigDecimal
  toBalance_gte: optimism_swap_BigDecimal
  toBalance_lte: optimism_swap_BigDecimal
  toBalance_in: [optimism_swap_BigDecimal!]
  toBalance_not_in: [optimism_swap_BigDecimal!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: optimism_swap_Bytes
  transaction_not: optimism_swap_Bytes
  transaction_gt: optimism_swap_Bytes
  transaction_lt: optimism_swap_Bytes
  transaction_gte: optimism_swap_Bytes
  transaction_lte: optimism_swap_Bytes
  transaction_in: [optimism_swap_Bytes!]
  transaction_not_in: [optimism_swap_Bytes!]
  transaction_contains: optimism_swap_Bytes
  transaction_not_contains: optimism_swap_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: optimism_swap_BlockChangedFilter
  and: [optimism_swap_LpTransferEvent_filter]
  or: [optimism_swap_LpTransferEvent_filter]
}

enum optimism_swap_LpTransferEvent_orderBy {
  id
  token
  token__id
  token__address
  token__decimals
  token__name
  token__symbol
  token__totalSupply
  amount
  from
  to
  fromBalance
  toBalance
  block
  timestamp
  transaction
  nonce
}

"""Defines the order direction, either ascending or descending"""
enum optimism_swap_OrderDirection {
  asc
  desc
}

type optimism_swap_PooledToken {
  id: ID!
  asset: optimism_swap_Bytes!
}

input optimism_swap_PooledToken_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  asset: optimism_swap_Bytes
  asset_not: optimism_swap_Bytes
  asset_gt: optimism_swap_Bytes
  asset_lt: optimism_swap_Bytes
  asset_gte: optimism_swap_Bytes
  asset_lte: optimism_swap_Bytes
  asset_in: [optimism_swap_Bytes!]
  asset_not_in: [optimism_swap_Bytes!]
  asset_contains: optimism_swap_Bytes
  asset_not_contains: optimism_swap_Bytes
  """Filter for the block changed event."""
  _change_block: optimism_swap_BlockChangedFilter
  and: [optimism_swap_PooledToken_filter]
  or: [optimism_swap_PooledToken_filter]
}

enum optimism_swap_PooledToken_orderBy {
  id
  asset
}

type optimism_swap_StableSwap {
  id: ID!
  isActive: Boolean
  key: optimism_swap_Bytes!
  canonicalId: optimism_swap_Bytes
  domain: BigInt
  swapPool: optimism_swap_Bytes
  lpToken: optimism_swap_Bytes
  initialA: BigInt
  futureA: BigInt
  initialATime: BigInt
  futureATime: BigInt
  swapFee: BigInt
  adminFee: BigInt
  pooledTokens: [optimism_swap_Bytes!]!
  tokenPrecisionMultipliers: [BigInt!]!
  balances: [BigInt!]!
  adminFees: [BigInt!]!
  virtualPrice: BigInt!
  invariant: BigInt!
  lpTokenSupply: BigInt!
  events(skip: Int = 0, first: Int = 100, orderBy: optimism_swap_StableSwapEvent_orderBy, orderDirection: optimism_swap_OrderDirection, where: optimism_swap_StableSwapEvent_filter): [optimism_swap_StableSwapEvent!]
  exchanges(skip: Int = 0, first: Int = 100, orderBy: optimism_swap_StableSwapExchange_orderBy, orderDirection: optimism_swap_OrderDirection, where: optimism_swap_StableSwapExchange_filter): [optimism_swap_StableSwapExchange!]
  hourlyVolumes(skip: Int = 0, first: Int = 100, orderBy: optimism_swap_SwapHourlyVolume_orderBy, orderDirection: optimism_swap_OrderDirection, where: optimism_swap_SwapHourlyVolume_filter): [optimism_swap_SwapHourlyVolume!]
  dailyVolumes(skip: Int = 0, first: Int = 100, orderBy: optimism_swap_SwapDailyVolume_orderBy, orderDirection: optimism_swap_OrderDirection, where: optimism_swap_SwapDailyVolume_filter): [optimism_swap_SwapDailyVolume!]
  weeklyVolumes(skip: Int = 0, first: Int = 100, orderBy: optimism_swap_SwapWeeklyVolume_orderBy, orderDirection: optimism_swap_OrderDirection, where: optimism_swap_SwapWeeklyVolume_filter): [optimism_swap_SwapWeeklyVolume!]
}

type optimism_swap_StableSwapAddLiquidityEvent implements optimism_swap_StableSwapEvent {
  id: ID!
  stableSwap: optimism_swap_StableSwap!
  provider: optimism_swap_Bytes!
  tokenAmounts: [BigInt!]!
  fees: [BigInt!]!
  invariant: BigInt
  lpTokenSupply: BigInt!
  lpTokenAmount: BigInt!
  balances: [BigInt!]!
  block: BigInt!
  timestamp: BigInt!
  transaction: optimism_swap_Bytes!
  nonce: BigInt!
}

input optimism_swap_StableSwapAddLiquidityEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: optimism_swap_StableSwap_filter
  provider: optimism_swap_Bytes
  provider_not: optimism_swap_Bytes
  provider_gt: optimism_swap_Bytes
  provider_lt: optimism_swap_Bytes
  provider_gte: optimism_swap_Bytes
  provider_lte: optimism_swap_Bytes
  provider_in: [optimism_swap_Bytes!]
  provider_not_in: [optimism_swap_Bytes!]
  provider_contains: optimism_swap_Bytes
  provider_not_contains: optimism_swap_Bytes
  tokenAmounts: [BigInt!]
  tokenAmounts_not: [BigInt!]
  tokenAmounts_contains: [BigInt!]
  tokenAmounts_contains_nocase: [BigInt!]
  tokenAmounts_not_contains: [BigInt!]
  tokenAmounts_not_contains_nocase: [BigInt!]
  fees: [BigInt!]
  fees_not: [BigInt!]
  fees_contains: [BigInt!]
  fees_contains_nocase: [BigInt!]
  fees_not_contains: [BigInt!]
  fees_not_contains_nocase: [BigInt!]
  invariant: BigInt
  invariant_not: BigInt
  invariant_gt: BigInt
  invariant_lt: BigInt
  invariant_gte: BigInt
  invariant_lte: BigInt
  invariant_in: [BigInt!]
  invariant_not_in: [BigInt!]
  lpTokenSupply: BigInt
  lpTokenSupply_not: BigInt
  lpTokenSupply_gt: BigInt
  lpTokenSupply_lt: BigInt
  lpTokenSupply_gte: BigInt
  lpTokenSupply_lte: BigInt
  lpTokenSupply_in: [BigInt!]
  lpTokenSupply_not_in: [BigInt!]
  lpTokenAmount: BigInt
  lpTokenAmount_not: BigInt
  lpTokenAmount_gt: BigInt
  lpTokenAmount_lt: BigInt
  lpTokenAmount_gte: BigInt
  lpTokenAmount_lte: BigInt
  lpTokenAmount_in: [BigInt!]
  lpTokenAmount_not_in: [BigInt!]
  balances: [BigInt!]
  balances_not: [BigInt!]
  balances_contains: [BigInt!]
  balances_contains_nocase: [BigInt!]
  balances_not_contains: [BigInt!]
  balances_not_contains_nocase: [BigInt!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: optimism_swap_Bytes
  transaction_not: optimism_swap_Bytes
  transaction_gt: optimism_swap_Bytes
  transaction_lt: optimism_swap_Bytes
  transaction_gte: optimism_swap_Bytes
  transaction_lte: optimism_swap_Bytes
  transaction_in: [optimism_swap_Bytes!]
  transaction_not_in: [optimism_swap_Bytes!]
  transaction_contains: optimism_swap_Bytes
  transaction_not_contains: optimism_swap_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: optimism_swap_BlockChangedFilter
  and: [optimism_swap_StableSwapAddLiquidityEvent_filter]
  or: [optimism_swap_StableSwapAddLiquidityEvent_filter]
}

enum optimism_swap_StableSwapAddLiquidityEvent_orderBy {
  id
  stableSwap
  stableSwap__id
  stableSwap__isActive
  stableSwap__key
  stableSwap__canonicalId
  stableSwap__domain
  stableSwap__swapPool
  stableSwap__lpToken
  stableSwap__initialA
  stableSwap__futureA
  stableSwap__initialATime
  stableSwap__futureATime
  stableSwap__swapFee
  stableSwap__adminFee
  stableSwap__virtualPrice
  stableSwap__invariant
  stableSwap__lpTokenSupply
  provider
  tokenAmounts
  fees
  invariant
  lpTokenSupply
  lpTokenAmount
  balances
  block
  timestamp
  transaction
  nonce
}

interface optimism_swap_StableSwapEvent {
  id: ID!
  stableSwap: optimism_swap_StableSwap!
  block: BigInt!
  timestamp: BigInt!
  transaction: optimism_swap_Bytes!
  nonce: BigInt!
}

input optimism_swap_StableSwapEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: optimism_swap_StableSwap_filter
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: optimism_swap_Bytes
  transaction_not: optimism_swap_Bytes
  transaction_gt: optimism_swap_Bytes
  transaction_lt: optimism_swap_Bytes
  transaction_gte: optimism_swap_Bytes
  transaction_lte: optimism_swap_Bytes
  transaction_in: [optimism_swap_Bytes!]
  transaction_not_in: [optimism_swap_Bytes!]
  transaction_contains: optimism_swap_Bytes
  transaction_not_contains: optimism_swap_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: optimism_swap_BlockChangedFilter
  and: [optimism_swap_StableSwapEvent_filter]
  or: [optimism_swap_StableSwapEvent_filter]
}

enum optimism_swap_StableSwapEvent_orderBy {
  id
  stableSwap
  stableSwap__id
  stableSwap__isActive
  stableSwap__key
  stableSwap__canonicalId
  stableSwap__domain
  stableSwap__swapPool
  stableSwap__lpToken
  stableSwap__initialA
  stableSwap__futureA
  stableSwap__initialATime
  stableSwap__futureATime
  stableSwap__swapFee
  stableSwap__adminFee
  stableSwap__virtualPrice
  stableSwap__invariant
  stableSwap__lpTokenSupply
  block
  timestamp
  transaction
  nonce
}

type optimism_swap_StableSwapExchange {
  id: ID!
  stableSwap: optimism_swap_StableSwap!
  buyer: optimism_swap_Bytes!
  boughtId: BigInt!
  tokensBought: BigInt!
  soldId: BigInt!
  tokensSold: BigInt!
  balances: [BigInt!]!
  fee: BigInt!
  block: BigInt!
  timestamp: BigInt!
  transaction: optimism_swap_Bytes!
  nonce: BigInt!
}

input optimism_swap_StableSwapExchange_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: optimism_swap_StableSwap_filter
  buyer: optimism_swap_Bytes
  buyer_not: optimism_swap_Bytes
  buyer_gt: optimism_swap_Bytes
  buyer_lt: optimism_swap_Bytes
  buyer_gte: optimism_swap_Bytes
  buyer_lte: optimism_swap_Bytes
  buyer_in: [optimism_swap_Bytes!]
  buyer_not_in: [optimism_swap_Bytes!]
  buyer_contains: optimism_swap_Bytes
  buyer_not_contains: optimism_swap_Bytes
  boughtId: BigInt
  boughtId_not: BigInt
  boughtId_gt: BigInt
  boughtId_lt: BigInt
  boughtId_gte: BigInt
  boughtId_lte: BigInt
  boughtId_in: [BigInt!]
  boughtId_not_in: [BigInt!]
  tokensBought: BigInt
  tokensBought_not: BigInt
  tokensBought_gt: BigInt
  tokensBought_lt: BigInt
  tokensBought_gte: BigInt
  tokensBought_lte: BigInt
  tokensBought_in: [BigInt!]
  tokensBought_not_in: [BigInt!]
  soldId: BigInt
  soldId_not: BigInt
  soldId_gt: BigInt
  soldId_lt: BigInt
  soldId_gte: BigInt
  soldId_lte: BigInt
  soldId_in: [BigInt!]
  soldId_not_in: [BigInt!]
  tokensSold: BigInt
  tokensSold_not: BigInt
  tokensSold_gt: BigInt
  tokensSold_lt: BigInt
  tokensSold_gte: BigInt
  tokensSold_lte: BigInt
  tokensSold_in: [BigInt!]
  tokensSold_not_in: [BigInt!]
  balances: [BigInt!]
  balances_not: [BigInt!]
  balances_contains: [BigInt!]
  balances_contains_nocase: [BigInt!]
  balances_not_contains: [BigInt!]
  balances_not_contains_nocase: [BigInt!]
  fee: BigInt
  fee_not: BigInt
  fee_gt: BigInt
  fee_lt: BigInt
  fee_gte: BigInt
  fee_lte: BigInt
  fee_in: [BigInt!]
  fee_not_in: [BigInt!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: optimism_swap_Bytes
  transaction_not: optimism_swap_Bytes
  transaction_gt: optimism_swap_Bytes
  transaction_lt: optimism_swap_Bytes
  transaction_gte: optimism_swap_Bytes
  transaction_lte: optimism_swap_Bytes
  transaction_in: [optimism_swap_Bytes!]
  transaction_not_in: [optimism_swap_Bytes!]
  transaction_contains: optimism_swap_Bytes
  transaction_not_contains: optimism_swap_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: optimism_swap_BlockChangedFilter
  and: [optimism_swap_StableSwapExchange_filter]
  or: [optimism_swap_StableSwapExchange_filter]
}

enum optimism_swap_StableSwapExchange_orderBy {
  id
  stableSwap
  stableSwap__id
  stableSwap__isActive
  stableSwap__key
  stableSwap__canonicalId
  stableSwap__domain
  stableSwap__swapPool
  stableSwap__lpToken
  stableSwap__initialA
  stableSwap__futureA
  stableSwap__initialATime
  stableSwap__futureATime
  stableSwap__swapFee
  stableSwap__adminFee
  stableSwap__virtualPrice
  stableSwap__invariant
  stableSwap__lpTokenSupply
  buyer
  boughtId
  tokensBought
  soldId
  tokensSold
  balances
  fee
  block
  timestamp
  transaction
  nonce
}

type optimism_swap_StableSwapRemoveLiquidityEvent implements optimism_swap_StableSwapEvent {
  id: ID!
  stableSwap: optimism_swap_StableSwap!
  provider: optimism_swap_Bytes!
  tokenAmounts: [BigInt!]!
  fees: [BigInt!]
  invariant: BigInt
  lpTokenSupply: BigInt!
  lpTokenAmount: BigInt!
  balances: [BigInt!]!
  block: BigInt!
  timestamp: BigInt!
  transaction: optimism_swap_Bytes!
  nonce: BigInt!
}

input optimism_swap_StableSwapRemoveLiquidityEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: optimism_swap_StableSwap_filter
  provider: optimism_swap_Bytes
  provider_not: optimism_swap_Bytes
  provider_gt: optimism_swap_Bytes
  provider_lt: optimism_swap_Bytes
  provider_gte: optimism_swap_Bytes
  provider_lte: optimism_swap_Bytes
  provider_in: [optimism_swap_Bytes!]
  provider_not_in: [optimism_swap_Bytes!]
  provider_contains: optimism_swap_Bytes
  provider_not_contains: optimism_swap_Bytes
  tokenAmounts: [BigInt!]
  tokenAmounts_not: [BigInt!]
  tokenAmounts_contains: [BigInt!]
  tokenAmounts_contains_nocase: [BigInt!]
  tokenAmounts_not_contains: [BigInt!]
  tokenAmounts_not_contains_nocase: [BigInt!]
  fees: [BigInt!]
  fees_not: [BigInt!]
  fees_contains: [BigInt!]
  fees_contains_nocase: [BigInt!]
  fees_not_contains: [BigInt!]
  fees_not_contains_nocase: [BigInt!]
  invariant: BigInt
  invariant_not: BigInt
  invariant_gt: BigInt
  invariant_lt: BigInt
  invariant_gte: BigInt
  invariant_lte: BigInt
  invariant_in: [BigInt!]
  invariant_not_in: [BigInt!]
  lpTokenSupply: BigInt
  lpTokenSupply_not: BigInt
  lpTokenSupply_gt: BigInt
  lpTokenSupply_lt: BigInt
  lpTokenSupply_gte: BigInt
  lpTokenSupply_lte: BigInt
  lpTokenSupply_in: [BigInt!]
  lpTokenSupply_not_in: [BigInt!]
  lpTokenAmount: BigInt
  lpTokenAmount_not: BigInt
  lpTokenAmount_gt: BigInt
  lpTokenAmount_lt: BigInt
  lpTokenAmount_gte: BigInt
  lpTokenAmount_lte: BigInt
  lpTokenAmount_in: [BigInt!]
  lpTokenAmount_not_in: [BigInt!]
  balances: [BigInt!]
  balances_not: [BigInt!]
  balances_contains: [BigInt!]
  balances_contains_nocase: [BigInt!]
  balances_not_contains: [BigInt!]
  balances_not_contains_nocase: [BigInt!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: optimism_swap_Bytes
  transaction_not: optimism_swap_Bytes
  transaction_gt: optimism_swap_Bytes
  transaction_lt: optimism_swap_Bytes
  transaction_gte: optimism_swap_Bytes
  transaction_lte: optimism_swap_Bytes
  transaction_in: [optimism_swap_Bytes!]
  transaction_not_in: [optimism_swap_Bytes!]
  transaction_contains: optimism_swap_Bytes
  transaction_not_contains: optimism_swap_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: optimism_swap_BlockChangedFilter
  and: [optimism_swap_StableSwapRemoveLiquidityEvent_filter]
  or: [optimism_swap_StableSwapRemoveLiquidityEvent_filter]
}

enum optimism_swap_StableSwapRemoveLiquidityEvent_orderBy {
  id
  stableSwap
  stableSwap__id
  stableSwap__isActive
  stableSwap__key
  stableSwap__canonicalId
  stableSwap__domain
  stableSwap__swapPool
  stableSwap__lpToken
  stableSwap__initialA
  stableSwap__futureA
  stableSwap__initialATime
  stableSwap__futureATime
  stableSwap__swapFee
  stableSwap__adminFee
  stableSwap__virtualPrice
  stableSwap__invariant
  stableSwap__lpTokenSupply
  provider
  tokenAmounts
  fees
  invariant
  lpTokenSupply
  lpTokenAmount
  balances
  block
  timestamp
  transaction
  nonce
}

input optimism_swap_StableSwap_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  isActive: Boolean
  isActive_not: Boolean
  isActive_in: [Boolean!]
  isActive_not_in: [Boolean!]
  key: optimism_swap_Bytes
  key_not: optimism_swap_Bytes
  key_gt: optimism_swap_Bytes
  key_lt: optimism_swap_Bytes
  key_gte: optimism_swap_Bytes
  key_lte: optimism_swap_Bytes
  key_in: [optimism_swap_Bytes!]
  key_not_in: [optimism_swap_Bytes!]
  key_contains: optimism_swap_Bytes
  key_not_contains: optimism_swap_Bytes
  canonicalId: optimism_swap_Bytes
  canonicalId_not: optimism_swap_Bytes
  canonicalId_gt: optimism_swap_Bytes
  canonicalId_lt: optimism_swap_Bytes
  canonicalId_gte: optimism_swap_Bytes
  canonicalId_lte: optimism_swap_Bytes
  canonicalId_in: [optimism_swap_Bytes!]
  canonicalId_not_in: [optimism_swap_Bytes!]
  canonicalId_contains: optimism_swap_Bytes
  canonicalId_not_contains: optimism_swap_Bytes
  domain: BigInt
  domain_not: BigInt
  domain_gt: BigInt
  domain_lt: BigInt
  domain_gte: BigInt
  domain_lte: BigInt
  domain_in: [BigInt!]
  domain_not_in: [BigInt!]
  swapPool: optimism_swap_Bytes
  swapPool_not: optimism_swap_Bytes
  swapPool_gt: optimism_swap_Bytes
  swapPool_lt: optimism_swap_Bytes
  swapPool_gte: optimism_swap_Bytes
  swapPool_lte: optimism_swap_Bytes
  swapPool_in: [optimism_swap_Bytes!]
  swapPool_not_in: [optimism_swap_Bytes!]
  swapPool_contains: optimism_swap_Bytes
  swapPool_not_contains: optimism_swap_Bytes
  lpToken: optimism_swap_Bytes
  lpToken_not: optimism_swap_Bytes
  lpToken_gt: optimism_swap_Bytes
  lpToken_lt: optimism_swap_Bytes
  lpToken_gte: optimism_swap_Bytes
  lpToken_lte: optimism_swap_Bytes
  lpToken_in: [optimism_swap_Bytes!]
  lpToken_not_in: [optimism_swap_Bytes!]
  lpToken_contains: optimism_swap_Bytes
  lpToken_not_contains: optimism_swap_Bytes
  initialA: BigInt
  initialA_not: BigInt
  initialA_gt: BigInt
  initialA_lt: BigInt
  initialA_gte: BigInt
  initialA_lte: BigInt
  initialA_in: [BigInt!]
  initialA_not_in: [BigInt!]
  futureA: BigInt
  futureA_not: BigInt
  futureA_gt: BigInt
  futureA_lt: BigInt
  futureA_gte: BigInt
  futureA_lte: BigInt
  futureA_in: [BigInt!]
  futureA_not_in: [BigInt!]
  initialATime: BigInt
  initialATime_not: BigInt
  initialATime_gt: BigInt
  initialATime_lt: BigInt
  initialATime_gte: BigInt
  initialATime_lte: BigInt
  initialATime_in: [BigInt!]
  initialATime_not_in: [BigInt!]
  futureATime: BigInt
  futureATime_not: BigInt
  futureATime_gt: BigInt
  futureATime_lt: BigInt
  futureATime_gte: BigInt
  futureATime_lte: BigInt
  futureATime_in: [BigInt!]
  futureATime_not_in: [BigInt!]
  swapFee: BigInt
  swapFee_not: BigInt
  swapFee_gt: BigInt
  swapFee_lt: BigInt
  swapFee_gte: BigInt
  swapFee_lte: BigInt
  swapFee_in: [BigInt!]
  swapFee_not_in: [BigInt!]
  adminFee: BigInt
  adminFee_not: BigInt
  adminFee_gt: BigInt
  adminFee_lt: BigInt
  adminFee_gte: BigInt
  adminFee_lte: BigInt
  adminFee_in: [BigInt!]
  adminFee_not_in: [BigInt!]
  pooledTokens: [optimism_swap_Bytes!]
  pooledTokens_not: [optimism_swap_Bytes!]
  pooledTokens_contains: [optimism_swap_Bytes!]
  pooledTokens_contains_nocase: [optimism_swap_Bytes!]
  pooledTokens_not_contains: [optimism_swap_Bytes!]
  pooledTokens_not_contains_nocase: [optimism_swap_Bytes!]
  tokenPrecisionMultipliers: [BigInt!]
  tokenPrecisionMultipliers_not: [BigInt!]
  tokenPrecisionMultipliers_contains: [BigInt!]
  tokenPrecisionMultipliers_contains_nocase: [BigInt!]
  tokenPrecisionMultipliers_not_contains: [BigInt!]
  tokenPrecisionMultipliers_not_contains_nocase: [BigInt!]
  balances: [BigInt!]
  balances_not: [BigInt!]
  balances_contains: [BigInt!]
  balances_contains_nocase: [BigInt!]
  balances_not_contains: [BigInt!]
  balances_not_contains_nocase: [BigInt!]
  adminFees: [BigInt!]
  adminFees_not: [BigInt!]
  adminFees_contains: [BigInt!]
  adminFees_contains_nocase: [BigInt!]
  adminFees_not_contains: [BigInt!]
  adminFees_not_contains_nocase: [BigInt!]
  virtualPrice: BigInt
  virtualPrice_not: BigInt
  virtualPrice_gt: BigInt
  virtualPrice_lt: BigInt
  virtualPrice_gte: BigInt
  virtualPrice_lte: BigInt
  virtualPrice_in: [BigInt!]
  virtualPrice_not_in: [BigInt!]
  invariant: BigInt
  invariant_not: BigInt
  invariant_gt: BigInt
  invariant_lt: BigInt
  invariant_gte: BigInt
  invariant_lte: BigInt
  invariant_in: [BigInt!]
  invariant_not_in: [BigInt!]
  lpTokenSupply: BigInt
  lpTokenSupply_not: BigInt
  lpTokenSupply_gt: BigInt
  lpTokenSupply_lt: BigInt
  lpTokenSupply_gte: BigInt
  lpTokenSupply_lte: BigInt
  lpTokenSupply_in: [BigInt!]
  lpTokenSupply_not_in: [BigInt!]
  events_: optimism_swap_StableSwapEvent_filter
  exchanges_: optimism_swap_StableSwapExchange_filter
  hourlyVolumes_: optimism_swap_SwapHourlyVolume_filter
  dailyVolumes_: optimism_swap_SwapDailyVolume_filter
  weeklyVolumes_: optimism_swap_SwapWeeklyVolume_filter
  """Filter for the block changed event."""
  _change_block: optimism_swap_BlockChangedFilter
  and: [optimism_swap_StableSwap_filter]
  or: [optimism_swap_StableSwap_filter]
}

enum optimism_swap_StableSwap_orderBy {
  id
  isActive
  key
  canonicalId
  domain
  swapPool
  lpToken
  initialA
  futureA
  initialATime
  futureATime
  swapFee
  adminFee
  pooledTokens
  tokenPrecisionMultipliers
  balances
  adminFees
  virtualPrice
  invariant
  lpTokenSupply
  events
  exchanges
  hourlyVolumes
  dailyVolumes
  weeklyVolumes
}

type optimism_swap_SwapDailyVolume implements optimism_swap_SwapTradeVolume {
  id: ID!
  stableSwap: optimism_swap_StableSwap!
  timestamp: BigInt!
  volume: optimism_swap_BigDecimal!
}

input optimism_swap_SwapDailyVolume_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: optimism_swap_StableSwap_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  volume: optimism_swap_BigDecimal
  volume_not: optimism_swap_BigDecimal
  volume_gt: optimism_swap_BigDecimal
  volume_lt: optimism_swap_BigDecimal
  volume_gte: optimism_swap_BigDecimal
  volume_lte: optimism_swap_BigDecimal
  volume_in: [optimism_swap_BigDecimal!]
  volume_not_in: [optimism_swap_BigDecimal!]
  """Filter for the block changed event."""
  _change_block: optimism_swap_BlockChangedFilter
  and: [optimism_swap_SwapDailyVolume_filter]
  or: [optimism_swap_SwapDailyVolume_filter]
}

enum optimism_swap_SwapDailyVolume_orderBy {
  id
  stableSwap
  stableSwap__id
  stableSwap__isActive
  stableSwap__key
  stableSwap__canonicalId
  stableSwap__domain
  stableSwap__swapPool
  stableSwap__lpToken
  stableSwap__initialA
  stableSwap__futureA
  stableSwap__initialATime
  stableSwap__futureATime
  stableSwap__swapFee
  stableSwap__adminFee
  stableSwap__virtualPrice
  stableSwap__invariant
  stableSwap__lpTokenSupply
  timestamp
  volume
}

type optimism_swap_SwapHourlyVolume implements optimism_swap_SwapTradeVolume {
  id: ID!
  stableSwap: optimism_swap_StableSwap!
  timestamp: BigInt!
  volume: optimism_swap_BigDecimal!
}

input optimism_swap_SwapHourlyVolume_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: optimism_swap_StableSwap_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  volume: optimism_swap_BigDecimal
  volume_not: optimism_swap_BigDecimal
  volume_gt: optimism_swap_BigDecimal
  volume_lt: optimism_swap_BigDecimal
  volume_gte: optimism_swap_BigDecimal
  volume_lte: optimism_swap_BigDecimal
  volume_in: [optimism_swap_BigDecimal!]
  volume_not_in: [optimism_swap_BigDecimal!]
  """Filter for the block changed event."""
  _change_block: optimism_swap_BlockChangedFilter
  and: [optimism_swap_SwapHourlyVolume_filter]
  or: [optimism_swap_SwapHourlyVolume_filter]
}

enum optimism_swap_SwapHourlyVolume_orderBy {
  id
  stableSwap
  stableSwap__id
  stableSwap__isActive
  stableSwap__key
  stableSwap__canonicalId
  stableSwap__domain
  stableSwap__swapPool
  stableSwap__lpToken
  stableSwap__initialA
  stableSwap__futureA
  stableSwap__initialATime
  stableSwap__futureATime
  stableSwap__swapFee
  stableSwap__adminFee
  stableSwap__virtualPrice
  stableSwap__invariant
  stableSwap__lpTokenSupply
  timestamp
  volume
}

interface optimism_swap_SwapTradeVolume {
  stableSwap: optimism_swap_StableSwap!
  timestamp: BigInt!
  volume: optimism_swap_BigDecimal!
}

input optimism_swap_SwapTradeVolume_filter {
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: optimism_swap_StableSwap_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  volume: optimism_swap_BigDecimal
  volume_not: optimism_swap_BigDecimal
  volume_gt: optimism_swap_BigDecimal
  volume_lt: optimism_swap_BigDecimal
  volume_gte: optimism_swap_BigDecimal
  volume_lte: optimism_swap_BigDecimal
  volume_in: [optimism_swap_BigDecimal!]
  volume_not_in: [optimism_swap_BigDecimal!]
  """Filter for the block changed event."""
  _change_block: optimism_swap_BlockChangedFilter
  and: [optimism_swap_SwapTradeVolume_filter]
  or: [optimism_swap_SwapTradeVolume_filter]
}

enum optimism_swap_SwapTradeVolume_orderBy {
  stableSwap
  stableSwap__id
  stableSwap__isActive
  stableSwap__key
  stableSwap__canonicalId
  stableSwap__domain
  stableSwap__swapPool
  stableSwap__lpToken
  stableSwap__initialA
  stableSwap__futureA
  stableSwap__initialATime
  stableSwap__futureATime
  stableSwap__swapFee
  stableSwap__adminFee
  stableSwap__virtualPrice
  stableSwap__invariant
  stableSwap__lpTokenSupply
  timestamp
  volume
}

type optimism_swap_SwapWeeklyVolume implements optimism_swap_SwapTradeVolume {
  id: ID!
  stableSwap: optimism_swap_StableSwap!
  timestamp: BigInt!
  volume: optimism_swap_BigDecimal!
}

input optimism_swap_SwapWeeklyVolume_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: optimism_swap_StableSwap_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  volume: optimism_swap_BigDecimal
  volume_not: optimism_swap_BigDecimal
  volume_gt: optimism_swap_BigDecimal
  volume_lt: optimism_swap_BigDecimal
  volume_gte: optimism_swap_BigDecimal
  volume_lte: optimism_swap_BigDecimal
  volume_in: [optimism_swap_BigDecimal!]
  volume_not_in: [optimism_swap_BigDecimal!]
  """Filter for the block changed event."""
  _change_block: optimism_swap_BlockChangedFilter
  and: [optimism_swap_SwapWeeklyVolume_filter]
  or: [optimism_swap_SwapWeeklyVolume_filter]
}

enum optimism_swap_SwapWeeklyVolume_orderBy {
  id
  stableSwap
  stableSwap__id
  stableSwap__isActive
  stableSwap__key
  stableSwap__canonicalId
  stableSwap__domain
  stableSwap__swapPool
  stableSwap__lpToken
  stableSwap__initialA
  stableSwap__futureA
  stableSwap__initialATime
  stableSwap__futureATime
  stableSwap__swapFee
  stableSwap__adminFee
  stableSwap__virtualPrice
  stableSwap__invariant
  stableSwap__lpTokenSupply
  timestamp
  volume
}

type optimism_swap_SystemInfo {
  id: ID!
  exchangeCount: BigInt!
  swapCount: BigInt!
}

input optimism_swap_SystemInfo_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  exchangeCount: BigInt
  exchangeCount_not: BigInt
  exchangeCount_gt: BigInt
  exchangeCount_lt: BigInt
  exchangeCount_gte: BigInt
  exchangeCount_lte: BigInt
  exchangeCount_in: [BigInt!]
  exchangeCount_not_in: [BigInt!]
  swapCount: BigInt
  swapCount_not: BigInt
  swapCount_gt: BigInt
  swapCount_lt: BigInt
  swapCount_gte: BigInt
  swapCount_lte: BigInt
  swapCount_in: [BigInt!]
  swapCount_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: optimism_swap_BlockChangedFilter
  and: [optimism_swap_SystemInfo_filter]
  or: [optimism_swap_SystemInfo_filter]
}

enum optimism_swap_SystemInfo_orderBy {
  id
  exchangeCount
  swapCount
}

type optimism_swap__Block_ {
  """The hash of the block"""
  hash: optimism_swap_Bytes
  """The block number"""
  number: Int!
  """Integer representation of the timestamp stored in blocks for the chain"""
  timestamp: Int
  """The hash of the parent block"""
  parentHash: optimism_swap_Bytes
}

"""The type for the top-level _meta field"""
type optimism_swap__Meta_ {
  """
  Information about a specific subgraph block. The hash of the block
  will be null if the _meta field has a block constraint that asks for
  a block number. It will be filled if the _meta field has no block constraint
  and therefore asks for the latest  block
  
  """
  block: optimism_swap__Block_!
  """The deployment ID"""
  deployment: String!
  """If `true`, the subgraph encountered indexing errors at some past block"""
  hasIndexingErrors: Boolean!
}

enum xdai_swap_Aggregation_interval {
  hour
  day
}

scalar xdai_swap_BigDecimal

input xdai_swap_BlockChangedFilter {
  number_gte: Int!
}

input xdai_swap_Block_height {
  hash: xdai_swap_Bytes
  number: Int
  number_gte: Int
}

scalar xdai_swap_Bytes

"""
8 bytes signed integer

"""
scalar xdai_swap_Int8

type xdai_swap_LpAccount {
  id: ID!
  address: xdai_swap_Bytes!
  balances(skip: Int = 0, first: Int = 100, orderBy: xdai_swap_LpAccountBalance_orderBy, orderDirection: xdai_swap_OrderDirection, where: xdai_swap_LpAccountBalance_filter): [xdai_swap_LpAccountBalance!]!
}

type xdai_swap_LpAccountBalance {
  id: ID!
  account: xdai_swap_LpAccount!
  token: xdai_swap_LpToken!
  amount: xdai_swap_BigDecimal!
  block: BigInt
  modified: BigInt
  transaction: xdai_swap_Bytes
}

input xdai_swap_LpAccountBalance_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  account: String
  account_not: String
  account_gt: String
  account_lt: String
  account_gte: String
  account_lte: String
  account_in: [String!]
  account_not_in: [String!]
  account_contains: String
  account_contains_nocase: String
  account_not_contains: String
  account_not_contains_nocase: String
  account_starts_with: String
  account_starts_with_nocase: String
  account_not_starts_with: String
  account_not_starts_with_nocase: String
  account_ends_with: String
  account_ends_with_nocase: String
  account_not_ends_with: String
  account_not_ends_with_nocase: String
  account_: xdai_swap_LpAccount_filter
  token: String
  token_not: String
  token_gt: String
  token_lt: String
  token_gte: String
  token_lte: String
  token_in: [String!]
  token_not_in: [String!]
  token_contains: String
  token_contains_nocase: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_: xdai_swap_LpToken_filter
  amount: xdai_swap_BigDecimal
  amount_not: xdai_swap_BigDecimal
  amount_gt: xdai_swap_BigDecimal
  amount_lt: xdai_swap_BigDecimal
  amount_gte: xdai_swap_BigDecimal
  amount_lte: xdai_swap_BigDecimal
  amount_in: [xdai_swap_BigDecimal!]
  amount_not_in: [xdai_swap_BigDecimal!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  modified: BigInt
  modified_not: BigInt
  modified_gt: BigInt
  modified_lt: BigInt
  modified_gte: BigInt
  modified_lte: BigInt
  modified_in: [BigInt!]
  modified_not_in: [BigInt!]
  transaction: xdai_swap_Bytes
  transaction_not: xdai_swap_Bytes
  transaction_gt: xdai_swap_Bytes
  transaction_lt: xdai_swap_Bytes
  transaction_gte: xdai_swap_Bytes
  transaction_lte: xdai_swap_Bytes
  transaction_in: [xdai_swap_Bytes!]
  transaction_not_in: [xdai_swap_Bytes!]
  transaction_contains: xdai_swap_Bytes
  transaction_not_contains: xdai_swap_Bytes
  """Filter for the block changed event."""
  _change_block: xdai_swap_BlockChangedFilter
  and: [xdai_swap_LpAccountBalance_filter]
  or: [xdai_swap_LpAccountBalance_filter]
}

enum xdai_swap_LpAccountBalance_orderBy {
  id
  account
  account__id
  account__address
  token
  token__id
  token__address
  token__decimals
  token__name
  token__symbol
  token__totalSupply
  amount
  block
  modified
  transaction
}

input xdai_swap_LpAccount_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  address: xdai_swap_Bytes
  address_not: xdai_swap_Bytes
  address_gt: xdai_swap_Bytes
  address_lt: xdai_swap_Bytes
  address_gte: xdai_swap_Bytes
  address_lte: xdai_swap_Bytes
  address_in: [xdai_swap_Bytes!]
  address_not_in: [xdai_swap_Bytes!]
  address_contains: xdai_swap_Bytes
  address_not_contains: xdai_swap_Bytes
  balances_: xdai_swap_LpAccountBalance_filter
  """Filter for the block changed event."""
  _change_block: xdai_swap_BlockChangedFilter
  and: [xdai_swap_LpAccount_filter]
  or: [xdai_swap_LpAccount_filter]
}

enum xdai_swap_LpAccount_orderBy {
  id
  address
  balances
}

type xdai_swap_LpToken {
  id: ID!
  address: xdai_swap_Bytes!
  stableSwap: xdai_swap_StableSwap!
  decimals: Int!
  name: String!
  symbol: String!
  totalSupply: xdai_swap_BigDecimal!
  events(skip: Int = 0, first: Int = 100, orderBy: xdai_swap_LpTokenEvent_orderBy, orderDirection: xdai_swap_OrderDirection, where: xdai_swap_LpTokenEvent_filter): [xdai_swap_LpTokenEvent!]!
}

interface xdai_swap_LpTokenEvent {
  id: ID!
  token: xdai_swap_LpToken!
  amount: xdai_swap_BigDecimal!
  block: BigInt!
  timestamp: BigInt!
  transaction: xdai_swap_Bytes!
  nonce: BigInt!
}

input xdai_swap_LpTokenEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  token: String
  token_not: String
  token_gt: String
  token_lt: String
  token_gte: String
  token_lte: String
  token_in: [String!]
  token_not_in: [String!]
  token_contains: String
  token_contains_nocase: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_: xdai_swap_LpToken_filter
  amount: xdai_swap_BigDecimal
  amount_not: xdai_swap_BigDecimal
  amount_gt: xdai_swap_BigDecimal
  amount_lt: xdai_swap_BigDecimal
  amount_gte: xdai_swap_BigDecimal
  amount_lte: xdai_swap_BigDecimal
  amount_in: [xdai_swap_BigDecimal!]
  amount_not_in: [xdai_swap_BigDecimal!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: xdai_swap_Bytes
  transaction_not: xdai_swap_Bytes
  transaction_gt: xdai_swap_Bytes
  transaction_lt: xdai_swap_Bytes
  transaction_gte: xdai_swap_Bytes
  transaction_lte: xdai_swap_Bytes
  transaction_in: [xdai_swap_Bytes!]
  transaction_not_in: [xdai_swap_Bytes!]
  transaction_contains: xdai_swap_Bytes
  transaction_not_contains: xdai_swap_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: xdai_swap_BlockChangedFilter
  and: [xdai_swap_LpTokenEvent_filter]
  or: [xdai_swap_LpTokenEvent_filter]
}

enum xdai_swap_LpTokenEvent_orderBy {
  id
  token
  token__id
  token__address
  token__decimals
  token__name
  token__symbol
  token__totalSupply
  amount
  block
  timestamp
  transaction
  nonce
}

input xdai_swap_LpToken_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  address: xdai_swap_Bytes
  address_not: xdai_swap_Bytes
  address_gt: xdai_swap_Bytes
  address_lt: xdai_swap_Bytes
  address_gte: xdai_swap_Bytes
  address_lte: xdai_swap_Bytes
  address_in: [xdai_swap_Bytes!]
  address_not_in: [xdai_swap_Bytes!]
  address_contains: xdai_swap_Bytes
  address_not_contains: xdai_swap_Bytes
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: xdai_swap_StableSwap_filter
  decimals: Int
  decimals_not: Int
  decimals_gt: Int
  decimals_lt: Int
  decimals_gte: Int
  decimals_lte: Int
  decimals_in: [Int!]
  decimals_not_in: [Int!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  symbol: String
  symbol_not: String
  symbol_gt: String
  symbol_lt: String
  symbol_gte: String
  symbol_lte: String
  symbol_in: [String!]
  symbol_not_in: [String!]
  symbol_contains: String
  symbol_contains_nocase: String
  symbol_not_contains: String
  symbol_not_contains_nocase: String
  symbol_starts_with: String
  symbol_starts_with_nocase: String
  symbol_not_starts_with: String
  symbol_not_starts_with_nocase: String
  symbol_ends_with: String
  symbol_ends_with_nocase: String
  symbol_not_ends_with: String
  symbol_not_ends_with_nocase: String
  totalSupply: xdai_swap_BigDecimal
  totalSupply_not: xdai_swap_BigDecimal
  totalSupply_gt: xdai_swap_BigDecimal
  totalSupply_lt: xdai_swap_BigDecimal
  totalSupply_gte: xdai_swap_BigDecimal
  totalSupply_lte: xdai_swap_BigDecimal
  totalSupply_in: [xdai_swap_BigDecimal!]
  totalSupply_not_in: [xdai_swap_BigDecimal!]
  events_: xdai_swap_LpTokenEvent_filter
  """Filter for the block changed event."""
  _change_block: xdai_swap_BlockChangedFilter
  and: [xdai_swap_LpToken_filter]
  or: [xdai_swap_LpToken_filter]
}

enum xdai_swap_LpToken_orderBy {
  id
  address
  stableSwap
  stableSwap__id
  stableSwap__isActive
  stableSwap__key
  stableSwap__canonicalId
  stableSwap__domain
  stableSwap__swapPool
  stableSwap__lpToken
  stableSwap__initialA
  stableSwap__futureA
  stableSwap__initialATime
  stableSwap__futureATime
  stableSwap__swapFee
  stableSwap__adminFee
  stableSwap__virtualPrice
  stableSwap__invariant
  stableSwap__lpTokenSupply
  decimals
  name
  symbol
  totalSupply
  events
}

type xdai_swap_LpTransferEvent implements xdai_swap_LpTokenEvent {
  id: ID!
  token: xdai_swap_LpToken!
  amount: xdai_swap_BigDecimal!
  from: xdai_swap_Bytes!
  to: xdai_swap_Bytes!
  fromBalance: xdai_swap_BigDecimal!
  toBalance: xdai_swap_BigDecimal!
  block: BigInt!
  timestamp: BigInt!
  transaction: xdai_swap_Bytes!
  nonce: BigInt!
}

input xdai_swap_LpTransferEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  token: String
  token_not: String
  token_gt: String
  token_lt: String
  token_gte: String
  token_lte: String
  token_in: [String!]
  token_not_in: [String!]
  token_contains: String
  token_contains_nocase: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_: xdai_swap_LpToken_filter
  amount: xdai_swap_BigDecimal
  amount_not: xdai_swap_BigDecimal
  amount_gt: xdai_swap_BigDecimal
  amount_lt: xdai_swap_BigDecimal
  amount_gte: xdai_swap_BigDecimal
  amount_lte: xdai_swap_BigDecimal
  amount_in: [xdai_swap_BigDecimal!]
  amount_not_in: [xdai_swap_BigDecimal!]
  from: xdai_swap_Bytes
  from_not: xdai_swap_Bytes
  from_gt: xdai_swap_Bytes
  from_lt: xdai_swap_Bytes
  from_gte: xdai_swap_Bytes
  from_lte: xdai_swap_Bytes
  from_in: [xdai_swap_Bytes!]
  from_not_in: [xdai_swap_Bytes!]
  from_contains: xdai_swap_Bytes
  from_not_contains: xdai_swap_Bytes
  to: xdai_swap_Bytes
  to_not: xdai_swap_Bytes
  to_gt: xdai_swap_Bytes
  to_lt: xdai_swap_Bytes
  to_gte: xdai_swap_Bytes
  to_lte: xdai_swap_Bytes
  to_in: [xdai_swap_Bytes!]
  to_not_in: [xdai_swap_Bytes!]
  to_contains: xdai_swap_Bytes
  to_not_contains: xdai_swap_Bytes
  fromBalance: xdai_swap_BigDecimal
  fromBalance_not: xdai_swap_BigDecimal
  fromBalance_gt: xdai_swap_BigDecimal
  fromBalance_lt: xdai_swap_BigDecimal
  fromBalance_gte: xdai_swap_BigDecimal
  fromBalance_lte: xdai_swap_BigDecimal
  fromBalance_in: [xdai_swap_BigDecimal!]
  fromBalance_not_in: [xdai_swap_BigDecimal!]
  toBalance: xdai_swap_BigDecimal
  toBalance_not: xdai_swap_BigDecimal
  toBalance_gt: xdai_swap_BigDecimal
  toBalance_lt: xdai_swap_BigDecimal
  toBalance_gte: xdai_swap_BigDecimal
  toBalance_lte: xdai_swap_BigDecimal
  toBalance_in: [xdai_swap_BigDecimal!]
  toBalance_not_in: [xdai_swap_BigDecimal!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: xdai_swap_Bytes
  transaction_not: xdai_swap_Bytes
  transaction_gt: xdai_swap_Bytes
  transaction_lt: xdai_swap_Bytes
  transaction_gte: xdai_swap_Bytes
  transaction_lte: xdai_swap_Bytes
  transaction_in: [xdai_swap_Bytes!]
  transaction_not_in: [xdai_swap_Bytes!]
  transaction_contains: xdai_swap_Bytes
  transaction_not_contains: xdai_swap_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: xdai_swap_BlockChangedFilter
  and: [xdai_swap_LpTransferEvent_filter]
  or: [xdai_swap_LpTransferEvent_filter]
}

enum xdai_swap_LpTransferEvent_orderBy {
  id
  token
  token__id
  token__address
  token__decimals
  token__name
  token__symbol
  token__totalSupply
  amount
  from
  to
  fromBalance
  toBalance
  block
  timestamp
  transaction
  nonce
}

"""Defines the order direction, either ascending or descending"""
enum xdai_swap_OrderDirection {
  asc
  desc
}

type xdai_swap_PooledToken {
  id: ID!
  asset: xdai_swap_Bytes!
}

input xdai_swap_PooledToken_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  asset: xdai_swap_Bytes
  asset_not: xdai_swap_Bytes
  asset_gt: xdai_swap_Bytes
  asset_lt: xdai_swap_Bytes
  asset_gte: xdai_swap_Bytes
  asset_lte: xdai_swap_Bytes
  asset_in: [xdai_swap_Bytes!]
  asset_not_in: [xdai_swap_Bytes!]
  asset_contains: xdai_swap_Bytes
  asset_not_contains: xdai_swap_Bytes
  """Filter for the block changed event."""
  _change_block: xdai_swap_BlockChangedFilter
  and: [xdai_swap_PooledToken_filter]
  or: [xdai_swap_PooledToken_filter]
}

enum xdai_swap_PooledToken_orderBy {
  id
  asset
}

type xdai_swap_StableSwap {
  id: ID!
  isActive: Boolean
  key: xdai_swap_Bytes!
  canonicalId: xdai_swap_Bytes
  domain: BigInt
  swapPool: xdai_swap_Bytes
  lpToken: xdai_swap_Bytes
  initialA: BigInt
  futureA: BigInt
  initialATime: BigInt
  futureATime: BigInt
  swapFee: BigInt
  adminFee: BigInt
  pooledTokens: [xdai_swap_Bytes!]!
  tokenPrecisionMultipliers: [BigInt!]!
  balances: [BigInt!]!
  adminFees: [BigInt!]!
  virtualPrice: BigInt!
  invariant: BigInt!
  lpTokenSupply: BigInt!
  events(skip: Int = 0, first: Int = 100, orderBy: xdai_swap_StableSwapEvent_orderBy, orderDirection: xdai_swap_OrderDirection, where: xdai_swap_StableSwapEvent_filter): [xdai_swap_StableSwapEvent!]
  exchanges(skip: Int = 0, first: Int = 100, orderBy: xdai_swap_StableSwapExchange_orderBy, orderDirection: xdai_swap_OrderDirection, where: xdai_swap_StableSwapExchange_filter): [xdai_swap_StableSwapExchange!]
  hourlyVolumes(skip: Int = 0, first: Int = 100, orderBy: xdai_swap_SwapHourlyVolume_orderBy, orderDirection: xdai_swap_OrderDirection, where: xdai_swap_SwapHourlyVolume_filter): [xdai_swap_SwapHourlyVolume!]
  dailyVolumes(skip: Int = 0, first: Int = 100, orderBy: xdai_swap_SwapDailyVolume_orderBy, orderDirection: xdai_swap_OrderDirection, where: xdai_swap_SwapDailyVolume_filter): [xdai_swap_SwapDailyVolume!]
  weeklyVolumes(skip: Int = 0, first: Int = 100, orderBy: xdai_swap_SwapWeeklyVolume_orderBy, orderDirection: xdai_swap_OrderDirection, where: xdai_swap_SwapWeeklyVolume_filter): [xdai_swap_SwapWeeklyVolume!]
}

type xdai_swap_StableSwapAddLiquidityEvent implements xdai_swap_StableSwapEvent {
  id: ID!
  stableSwap: xdai_swap_StableSwap!
  provider: xdai_swap_Bytes!
  tokenAmounts: [BigInt!]!
  fees: [BigInt!]!
  invariant: BigInt
  lpTokenSupply: BigInt!
  lpTokenAmount: BigInt!
  balances: [BigInt!]!
  block: BigInt!
  timestamp: BigInt!
  transaction: xdai_swap_Bytes!
  nonce: BigInt!
}

input xdai_swap_StableSwapAddLiquidityEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: xdai_swap_StableSwap_filter
  provider: xdai_swap_Bytes
  provider_not: xdai_swap_Bytes
  provider_gt: xdai_swap_Bytes
  provider_lt: xdai_swap_Bytes
  provider_gte: xdai_swap_Bytes
  provider_lte: xdai_swap_Bytes
  provider_in: [xdai_swap_Bytes!]
  provider_not_in: [xdai_swap_Bytes!]
  provider_contains: xdai_swap_Bytes
  provider_not_contains: xdai_swap_Bytes
  tokenAmounts: [BigInt!]
  tokenAmounts_not: [BigInt!]
  tokenAmounts_contains: [BigInt!]
  tokenAmounts_contains_nocase: [BigInt!]
  tokenAmounts_not_contains: [BigInt!]
  tokenAmounts_not_contains_nocase: [BigInt!]
  fees: [BigInt!]
  fees_not: [BigInt!]
  fees_contains: [BigInt!]
  fees_contains_nocase: [BigInt!]
  fees_not_contains: [BigInt!]
  fees_not_contains_nocase: [BigInt!]
  invariant: BigInt
  invariant_not: BigInt
  invariant_gt: BigInt
  invariant_lt: BigInt
  invariant_gte: BigInt
  invariant_lte: BigInt
  invariant_in: [BigInt!]
  invariant_not_in: [BigInt!]
  lpTokenSupply: BigInt
  lpTokenSupply_not: BigInt
  lpTokenSupply_gt: BigInt
  lpTokenSupply_lt: BigInt
  lpTokenSupply_gte: BigInt
  lpTokenSupply_lte: BigInt
  lpTokenSupply_in: [BigInt!]
  lpTokenSupply_not_in: [BigInt!]
  lpTokenAmount: BigInt
  lpTokenAmount_not: BigInt
  lpTokenAmount_gt: BigInt
  lpTokenAmount_lt: BigInt
  lpTokenAmount_gte: BigInt
  lpTokenAmount_lte: BigInt
  lpTokenAmount_in: [BigInt!]
  lpTokenAmount_not_in: [BigInt!]
  balances: [BigInt!]
  balances_not: [BigInt!]
  balances_contains: [BigInt!]
  balances_contains_nocase: [BigInt!]
  balances_not_contains: [BigInt!]
  balances_not_contains_nocase: [BigInt!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: xdai_swap_Bytes
  transaction_not: xdai_swap_Bytes
  transaction_gt: xdai_swap_Bytes
  transaction_lt: xdai_swap_Bytes
  transaction_gte: xdai_swap_Bytes
  transaction_lte: xdai_swap_Bytes
  transaction_in: [xdai_swap_Bytes!]
  transaction_not_in: [xdai_swap_Bytes!]
  transaction_contains: xdai_swap_Bytes
  transaction_not_contains: xdai_swap_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: xdai_swap_BlockChangedFilter
  and: [xdai_swap_StableSwapAddLiquidityEvent_filter]
  or: [xdai_swap_StableSwapAddLiquidityEvent_filter]
}

enum xdai_swap_StableSwapAddLiquidityEvent_orderBy {
  id
  stableSwap
  stableSwap__id
  stableSwap__isActive
  stableSwap__key
  stableSwap__canonicalId
  stableSwap__domain
  stableSwap__swapPool
  stableSwap__lpToken
  stableSwap__initialA
  stableSwap__futureA
  stableSwap__initialATime
  stableSwap__futureATime
  stableSwap__swapFee
  stableSwap__adminFee
  stableSwap__virtualPrice
  stableSwap__invariant
  stableSwap__lpTokenSupply
  provider
  tokenAmounts
  fees
  invariant
  lpTokenSupply
  lpTokenAmount
  balances
  block
  timestamp
  transaction
  nonce
}

interface xdai_swap_StableSwapEvent {
  id: ID!
  stableSwap: xdai_swap_StableSwap!
  block: BigInt!
  timestamp: BigInt!
  transaction: xdai_swap_Bytes!
  nonce: BigInt!
}

input xdai_swap_StableSwapEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: xdai_swap_StableSwap_filter
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: xdai_swap_Bytes
  transaction_not: xdai_swap_Bytes
  transaction_gt: xdai_swap_Bytes
  transaction_lt: xdai_swap_Bytes
  transaction_gte: xdai_swap_Bytes
  transaction_lte: xdai_swap_Bytes
  transaction_in: [xdai_swap_Bytes!]
  transaction_not_in: [xdai_swap_Bytes!]
  transaction_contains: xdai_swap_Bytes
  transaction_not_contains: xdai_swap_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: xdai_swap_BlockChangedFilter
  and: [xdai_swap_StableSwapEvent_filter]
  or: [xdai_swap_StableSwapEvent_filter]
}

enum xdai_swap_StableSwapEvent_orderBy {
  id
  stableSwap
  stableSwap__id
  stableSwap__isActive
  stableSwap__key
  stableSwap__canonicalId
  stableSwap__domain
  stableSwap__swapPool
  stableSwap__lpToken
  stableSwap__initialA
  stableSwap__futureA
  stableSwap__initialATime
  stableSwap__futureATime
  stableSwap__swapFee
  stableSwap__adminFee
  stableSwap__virtualPrice
  stableSwap__invariant
  stableSwap__lpTokenSupply
  block
  timestamp
  transaction
  nonce
}

type xdai_swap_StableSwapExchange {
  id: ID!
  stableSwap: xdai_swap_StableSwap!
  buyer: xdai_swap_Bytes!
  boughtId: BigInt!
  tokensBought: BigInt!
  soldId: BigInt!
  tokensSold: BigInt!
  balances: [BigInt!]!
  fee: BigInt!
  block: BigInt!
  timestamp: BigInt!
  transaction: xdai_swap_Bytes!
  nonce: BigInt!
}

input xdai_swap_StableSwapExchange_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: xdai_swap_StableSwap_filter
  buyer: xdai_swap_Bytes
  buyer_not: xdai_swap_Bytes
  buyer_gt: xdai_swap_Bytes
  buyer_lt: xdai_swap_Bytes
  buyer_gte: xdai_swap_Bytes
  buyer_lte: xdai_swap_Bytes
  buyer_in: [xdai_swap_Bytes!]
  buyer_not_in: [xdai_swap_Bytes!]
  buyer_contains: xdai_swap_Bytes
  buyer_not_contains: xdai_swap_Bytes
  boughtId: BigInt
  boughtId_not: BigInt
  boughtId_gt: BigInt
  boughtId_lt: BigInt
  boughtId_gte: BigInt
  boughtId_lte: BigInt
  boughtId_in: [BigInt!]
  boughtId_not_in: [BigInt!]
  tokensBought: BigInt
  tokensBought_not: BigInt
  tokensBought_gt: BigInt
  tokensBought_lt: BigInt
  tokensBought_gte: BigInt
  tokensBought_lte: BigInt
  tokensBought_in: [BigInt!]
  tokensBought_not_in: [BigInt!]
  soldId: BigInt
  soldId_not: BigInt
  soldId_gt: BigInt
  soldId_lt: BigInt
  soldId_gte: BigInt
  soldId_lte: BigInt
  soldId_in: [BigInt!]
  soldId_not_in: [BigInt!]
  tokensSold: BigInt
  tokensSold_not: BigInt
  tokensSold_gt: BigInt
  tokensSold_lt: BigInt
  tokensSold_gte: BigInt
  tokensSold_lte: BigInt
  tokensSold_in: [BigInt!]
  tokensSold_not_in: [BigInt!]
  balances: [BigInt!]
  balances_not: [BigInt!]
  balances_contains: [BigInt!]
  balances_contains_nocase: [BigInt!]
  balances_not_contains: [BigInt!]
  balances_not_contains_nocase: [BigInt!]
  fee: BigInt
  fee_not: BigInt
  fee_gt: BigInt
  fee_lt: BigInt
  fee_gte: BigInt
  fee_lte: BigInt
  fee_in: [BigInt!]
  fee_not_in: [BigInt!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: xdai_swap_Bytes
  transaction_not: xdai_swap_Bytes
  transaction_gt: xdai_swap_Bytes
  transaction_lt: xdai_swap_Bytes
  transaction_gte: xdai_swap_Bytes
  transaction_lte: xdai_swap_Bytes
  transaction_in: [xdai_swap_Bytes!]
  transaction_not_in: [xdai_swap_Bytes!]
  transaction_contains: xdai_swap_Bytes
  transaction_not_contains: xdai_swap_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: xdai_swap_BlockChangedFilter
  and: [xdai_swap_StableSwapExchange_filter]
  or: [xdai_swap_StableSwapExchange_filter]
}

enum xdai_swap_StableSwapExchange_orderBy {
  id
  stableSwap
  stableSwap__id
  stableSwap__isActive
  stableSwap__key
  stableSwap__canonicalId
  stableSwap__domain
  stableSwap__swapPool
  stableSwap__lpToken
  stableSwap__initialA
  stableSwap__futureA
  stableSwap__initialATime
  stableSwap__futureATime
  stableSwap__swapFee
  stableSwap__adminFee
  stableSwap__virtualPrice
  stableSwap__invariant
  stableSwap__lpTokenSupply
  buyer
  boughtId
  tokensBought
  soldId
  tokensSold
  balances
  fee
  block
  timestamp
  transaction
  nonce
}

type xdai_swap_StableSwapRemoveLiquidityEvent implements xdai_swap_StableSwapEvent {
  id: ID!
  stableSwap: xdai_swap_StableSwap!
  provider: xdai_swap_Bytes!
  tokenAmounts: [BigInt!]!
  fees: [BigInt!]
  invariant: BigInt
  lpTokenSupply: BigInt!
  lpTokenAmount: BigInt!
  balances: [BigInt!]!
  block: BigInt!
  timestamp: BigInt!
  transaction: xdai_swap_Bytes!
  nonce: BigInt!
}

input xdai_swap_StableSwapRemoveLiquidityEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: xdai_swap_StableSwap_filter
  provider: xdai_swap_Bytes
  provider_not: xdai_swap_Bytes
  provider_gt: xdai_swap_Bytes
  provider_lt: xdai_swap_Bytes
  provider_gte: xdai_swap_Bytes
  provider_lte: xdai_swap_Bytes
  provider_in: [xdai_swap_Bytes!]
  provider_not_in: [xdai_swap_Bytes!]
  provider_contains: xdai_swap_Bytes
  provider_not_contains: xdai_swap_Bytes
  tokenAmounts: [BigInt!]
  tokenAmounts_not: [BigInt!]
  tokenAmounts_contains: [BigInt!]
  tokenAmounts_contains_nocase: [BigInt!]
  tokenAmounts_not_contains: [BigInt!]
  tokenAmounts_not_contains_nocase: [BigInt!]
  fees: [BigInt!]
  fees_not: [BigInt!]
  fees_contains: [BigInt!]
  fees_contains_nocase: [BigInt!]
  fees_not_contains: [BigInt!]
  fees_not_contains_nocase: [BigInt!]
  invariant: BigInt
  invariant_not: BigInt
  invariant_gt: BigInt
  invariant_lt: BigInt
  invariant_gte: BigInt
  invariant_lte: BigInt
  invariant_in: [BigInt!]
  invariant_not_in: [BigInt!]
  lpTokenSupply: BigInt
  lpTokenSupply_not: BigInt
  lpTokenSupply_gt: BigInt
  lpTokenSupply_lt: BigInt
  lpTokenSupply_gte: BigInt
  lpTokenSupply_lte: BigInt
  lpTokenSupply_in: [BigInt!]
  lpTokenSupply_not_in: [BigInt!]
  lpTokenAmount: BigInt
  lpTokenAmount_not: BigInt
  lpTokenAmount_gt: BigInt
  lpTokenAmount_lt: BigInt
  lpTokenAmount_gte: BigInt
  lpTokenAmount_lte: BigInt
  lpTokenAmount_in: [BigInt!]
  lpTokenAmount_not_in: [BigInt!]
  balances: [BigInt!]
  balances_not: [BigInt!]
  balances_contains: [BigInt!]
  balances_contains_nocase: [BigInt!]
  balances_not_contains: [BigInt!]
  balances_not_contains_nocase: [BigInt!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: xdai_swap_Bytes
  transaction_not: xdai_swap_Bytes
  transaction_gt: xdai_swap_Bytes
  transaction_lt: xdai_swap_Bytes
  transaction_gte: xdai_swap_Bytes
  transaction_lte: xdai_swap_Bytes
  transaction_in: [xdai_swap_Bytes!]
  transaction_not_in: [xdai_swap_Bytes!]
  transaction_contains: xdai_swap_Bytes
  transaction_not_contains: xdai_swap_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: xdai_swap_BlockChangedFilter
  and: [xdai_swap_StableSwapRemoveLiquidityEvent_filter]
  or: [xdai_swap_StableSwapRemoveLiquidityEvent_filter]
}

enum xdai_swap_StableSwapRemoveLiquidityEvent_orderBy {
  id
  stableSwap
  stableSwap__id
  stableSwap__isActive
  stableSwap__key
  stableSwap__canonicalId
  stableSwap__domain
  stableSwap__swapPool
  stableSwap__lpToken
  stableSwap__initialA
  stableSwap__futureA
  stableSwap__initialATime
  stableSwap__futureATime
  stableSwap__swapFee
  stableSwap__adminFee
  stableSwap__virtualPrice
  stableSwap__invariant
  stableSwap__lpTokenSupply
  provider
  tokenAmounts
  fees
  invariant
  lpTokenSupply
  lpTokenAmount
  balances
  block
  timestamp
  transaction
  nonce
}

input xdai_swap_StableSwap_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  isActive: Boolean
  isActive_not: Boolean
  isActive_in: [Boolean!]
  isActive_not_in: [Boolean!]
  key: xdai_swap_Bytes
  key_not: xdai_swap_Bytes
  key_gt: xdai_swap_Bytes
  key_lt: xdai_swap_Bytes
  key_gte: xdai_swap_Bytes
  key_lte: xdai_swap_Bytes
  key_in: [xdai_swap_Bytes!]
  key_not_in: [xdai_swap_Bytes!]
  key_contains: xdai_swap_Bytes
  key_not_contains: xdai_swap_Bytes
  canonicalId: xdai_swap_Bytes
  canonicalId_not: xdai_swap_Bytes
  canonicalId_gt: xdai_swap_Bytes
  canonicalId_lt: xdai_swap_Bytes
  canonicalId_gte: xdai_swap_Bytes
  canonicalId_lte: xdai_swap_Bytes
  canonicalId_in: [xdai_swap_Bytes!]
  canonicalId_not_in: [xdai_swap_Bytes!]
  canonicalId_contains: xdai_swap_Bytes
  canonicalId_not_contains: xdai_swap_Bytes
  domain: BigInt
  domain_not: BigInt
  domain_gt: BigInt
  domain_lt: BigInt
  domain_gte: BigInt
  domain_lte: BigInt
  domain_in: [BigInt!]
  domain_not_in: [BigInt!]
  swapPool: xdai_swap_Bytes
  swapPool_not: xdai_swap_Bytes
  swapPool_gt: xdai_swap_Bytes
  swapPool_lt: xdai_swap_Bytes
  swapPool_gte: xdai_swap_Bytes
  swapPool_lte: xdai_swap_Bytes
  swapPool_in: [xdai_swap_Bytes!]
  swapPool_not_in: [xdai_swap_Bytes!]
  swapPool_contains: xdai_swap_Bytes
  swapPool_not_contains: xdai_swap_Bytes
  lpToken: xdai_swap_Bytes
  lpToken_not: xdai_swap_Bytes
  lpToken_gt: xdai_swap_Bytes
  lpToken_lt: xdai_swap_Bytes
  lpToken_gte: xdai_swap_Bytes
  lpToken_lte: xdai_swap_Bytes
  lpToken_in: [xdai_swap_Bytes!]
  lpToken_not_in: [xdai_swap_Bytes!]
  lpToken_contains: xdai_swap_Bytes
  lpToken_not_contains: xdai_swap_Bytes
  initialA: BigInt
  initialA_not: BigInt
  initialA_gt: BigInt
  initialA_lt: BigInt
  initialA_gte: BigInt
  initialA_lte: BigInt
  initialA_in: [BigInt!]
  initialA_not_in: [BigInt!]
  futureA: BigInt
  futureA_not: BigInt
  futureA_gt: BigInt
  futureA_lt: BigInt
  futureA_gte: BigInt
  futureA_lte: BigInt
  futureA_in: [BigInt!]
  futureA_not_in: [BigInt!]
  initialATime: BigInt
  initialATime_not: BigInt
  initialATime_gt: BigInt
  initialATime_lt: BigInt
  initialATime_gte: BigInt
  initialATime_lte: BigInt
  initialATime_in: [BigInt!]
  initialATime_not_in: [BigInt!]
  futureATime: BigInt
  futureATime_not: BigInt
  futureATime_gt: BigInt
  futureATime_lt: BigInt
  futureATime_gte: BigInt
  futureATime_lte: BigInt
  futureATime_in: [BigInt!]
  futureATime_not_in: [BigInt!]
  swapFee: BigInt
  swapFee_not: BigInt
  swapFee_gt: BigInt
  swapFee_lt: BigInt
  swapFee_gte: BigInt
  swapFee_lte: BigInt
  swapFee_in: [BigInt!]
  swapFee_not_in: [BigInt!]
  adminFee: BigInt
  adminFee_not: BigInt
  adminFee_gt: BigInt
  adminFee_lt: BigInt
  adminFee_gte: BigInt
  adminFee_lte: BigInt
  adminFee_in: [BigInt!]
  adminFee_not_in: [BigInt!]
  pooledTokens: [xdai_swap_Bytes!]
  pooledTokens_not: [xdai_swap_Bytes!]
  pooledTokens_contains: [xdai_swap_Bytes!]
  pooledTokens_contains_nocase: [xdai_swap_Bytes!]
  pooledTokens_not_contains: [xdai_swap_Bytes!]
  pooledTokens_not_contains_nocase: [xdai_swap_Bytes!]
  tokenPrecisionMultipliers: [BigInt!]
  tokenPrecisionMultipliers_not: [BigInt!]
  tokenPrecisionMultipliers_contains: [BigInt!]
  tokenPrecisionMultipliers_contains_nocase: [BigInt!]
  tokenPrecisionMultipliers_not_contains: [BigInt!]
  tokenPrecisionMultipliers_not_contains_nocase: [BigInt!]
  balances: [BigInt!]
  balances_not: [BigInt!]
  balances_contains: [BigInt!]
  balances_contains_nocase: [BigInt!]
  balances_not_contains: [BigInt!]
  balances_not_contains_nocase: [BigInt!]
  adminFees: [BigInt!]
  adminFees_not: [BigInt!]
  adminFees_contains: [BigInt!]
  adminFees_contains_nocase: [BigInt!]
  adminFees_not_contains: [BigInt!]
  adminFees_not_contains_nocase: [BigInt!]
  virtualPrice: BigInt
  virtualPrice_not: BigInt
  virtualPrice_gt: BigInt
  virtualPrice_lt: BigInt
  virtualPrice_gte: BigInt
  virtualPrice_lte: BigInt
  virtualPrice_in: [BigInt!]
  virtualPrice_not_in: [BigInt!]
  invariant: BigInt
  invariant_not: BigInt
  invariant_gt: BigInt
  invariant_lt: BigInt
  invariant_gte: BigInt
  invariant_lte: BigInt
  invariant_in: [BigInt!]
  invariant_not_in: [BigInt!]
  lpTokenSupply: BigInt
  lpTokenSupply_not: BigInt
  lpTokenSupply_gt: BigInt
  lpTokenSupply_lt: BigInt
  lpTokenSupply_gte: BigInt
  lpTokenSupply_lte: BigInt
  lpTokenSupply_in: [BigInt!]
  lpTokenSupply_not_in: [BigInt!]
  events_: xdai_swap_StableSwapEvent_filter
  exchanges_: xdai_swap_StableSwapExchange_filter
  hourlyVolumes_: xdai_swap_SwapHourlyVolume_filter
  dailyVolumes_: xdai_swap_SwapDailyVolume_filter
  weeklyVolumes_: xdai_swap_SwapWeeklyVolume_filter
  """Filter for the block changed event."""
  _change_block: xdai_swap_BlockChangedFilter
  and: [xdai_swap_StableSwap_filter]
  or: [xdai_swap_StableSwap_filter]
}

enum xdai_swap_StableSwap_orderBy {
  id
  isActive
  key
  canonicalId
  domain
  swapPool
  lpToken
  initialA
  futureA
  initialATime
  futureATime
  swapFee
  adminFee
  pooledTokens
  tokenPrecisionMultipliers
  balances
  adminFees
  virtualPrice
  invariant
  lpTokenSupply
  events
  exchanges
  hourlyVolumes
  dailyVolumes
  weeklyVolumes
}

type xdai_swap_SwapDailyVolume implements xdai_swap_SwapTradeVolume {
  id: ID!
  stableSwap: xdai_swap_StableSwap!
  timestamp: BigInt!
  volume: xdai_swap_BigDecimal!
}

input xdai_swap_SwapDailyVolume_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: xdai_swap_StableSwap_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  volume: xdai_swap_BigDecimal
  volume_not: xdai_swap_BigDecimal
  volume_gt: xdai_swap_BigDecimal
  volume_lt: xdai_swap_BigDecimal
  volume_gte: xdai_swap_BigDecimal
  volume_lte: xdai_swap_BigDecimal
  volume_in: [xdai_swap_BigDecimal!]
  volume_not_in: [xdai_swap_BigDecimal!]
  """Filter for the block changed event."""
  _change_block: xdai_swap_BlockChangedFilter
  and: [xdai_swap_SwapDailyVolume_filter]
  or: [xdai_swap_SwapDailyVolume_filter]
}

enum xdai_swap_SwapDailyVolume_orderBy {
  id
  stableSwap
  stableSwap__id
  stableSwap__isActive
  stableSwap__key
  stableSwap__canonicalId
  stableSwap__domain
  stableSwap__swapPool
  stableSwap__lpToken
  stableSwap__initialA
  stableSwap__futureA
  stableSwap__initialATime
  stableSwap__futureATime
  stableSwap__swapFee
  stableSwap__adminFee
  stableSwap__virtualPrice
  stableSwap__invariant
  stableSwap__lpTokenSupply
  timestamp
  volume
}

type xdai_swap_SwapHourlyVolume implements xdai_swap_SwapTradeVolume {
  id: ID!
  stableSwap: xdai_swap_StableSwap!
  timestamp: BigInt!
  volume: xdai_swap_BigDecimal!
}

input xdai_swap_SwapHourlyVolume_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: xdai_swap_StableSwap_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  volume: xdai_swap_BigDecimal
  volume_not: xdai_swap_BigDecimal
  volume_gt: xdai_swap_BigDecimal
  volume_lt: xdai_swap_BigDecimal
  volume_gte: xdai_swap_BigDecimal
  volume_lte: xdai_swap_BigDecimal
  volume_in: [xdai_swap_BigDecimal!]
  volume_not_in: [xdai_swap_BigDecimal!]
  """Filter for the block changed event."""
  _change_block: xdai_swap_BlockChangedFilter
  and: [xdai_swap_SwapHourlyVolume_filter]
  or: [xdai_swap_SwapHourlyVolume_filter]
}

enum xdai_swap_SwapHourlyVolume_orderBy {
  id
  stableSwap
  stableSwap__id
  stableSwap__isActive
  stableSwap__key
  stableSwap__canonicalId
  stableSwap__domain
  stableSwap__swapPool
  stableSwap__lpToken
  stableSwap__initialA
  stableSwap__futureA
  stableSwap__initialATime
  stableSwap__futureATime
  stableSwap__swapFee
  stableSwap__adminFee
  stableSwap__virtualPrice
  stableSwap__invariant
  stableSwap__lpTokenSupply
  timestamp
  volume
}

interface xdai_swap_SwapTradeVolume {
  stableSwap: xdai_swap_StableSwap!
  timestamp: BigInt!
  volume: xdai_swap_BigDecimal!
}

input xdai_swap_SwapTradeVolume_filter {
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: xdai_swap_StableSwap_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  volume: xdai_swap_BigDecimal
  volume_not: xdai_swap_BigDecimal
  volume_gt: xdai_swap_BigDecimal
  volume_lt: xdai_swap_BigDecimal
  volume_gte: xdai_swap_BigDecimal
  volume_lte: xdai_swap_BigDecimal
  volume_in: [xdai_swap_BigDecimal!]
  volume_not_in: [xdai_swap_BigDecimal!]
  """Filter for the block changed event."""
  _change_block: xdai_swap_BlockChangedFilter
  and: [xdai_swap_SwapTradeVolume_filter]
  or: [xdai_swap_SwapTradeVolume_filter]
}

enum xdai_swap_SwapTradeVolume_orderBy {
  stableSwap
  stableSwap__id
  stableSwap__isActive
  stableSwap__key
  stableSwap__canonicalId
  stableSwap__domain
  stableSwap__swapPool
  stableSwap__lpToken
  stableSwap__initialA
  stableSwap__futureA
  stableSwap__initialATime
  stableSwap__futureATime
  stableSwap__swapFee
  stableSwap__adminFee
  stableSwap__virtualPrice
  stableSwap__invariant
  stableSwap__lpTokenSupply
  timestamp
  volume
}

type xdai_swap_SwapWeeklyVolume implements xdai_swap_SwapTradeVolume {
  id: ID!
  stableSwap: xdai_swap_StableSwap!
  timestamp: BigInt!
  volume: xdai_swap_BigDecimal!
}

input xdai_swap_SwapWeeklyVolume_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: xdai_swap_StableSwap_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  volume: xdai_swap_BigDecimal
  volume_not: xdai_swap_BigDecimal
  volume_gt: xdai_swap_BigDecimal
  volume_lt: xdai_swap_BigDecimal
  volume_gte: xdai_swap_BigDecimal
  volume_lte: xdai_swap_BigDecimal
  volume_in: [xdai_swap_BigDecimal!]
  volume_not_in: [xdai_swap_BigDecimal!]
  """Filter for the block changed event."""
  _change_block: xdai_swap_BlockChangedFilter
  and: [xdai_swap_SwapWeeklyVolume_filter]
  or: [xdai_swap_SwapWeeklyVolume_filter]
}

enum xdai_swap_SwapWeeklyVolume_orderBy {
  id
  stableSwap
  stableSwap__id
  stableSwap__isActive
  stableSwap__key
  stableSwap__canonicalId
  stableSwap__domain
  stableSwap__swapPool
  stableSwap__lpToken
  stableSwap__initialA
  stableSwap__futureA
  stableSwap__initialATime
  stableSwap__futureATime
  stableSwap__swapFee
  stableSwap__adminFee
  stableSwap__virtualPrice
  stableSwap__invariant
  stableSwap__lpTokenSupply
  timestamp
  volume
}

type xdai_swap_SystemInfo {
  id: ID!
  exchangeCount: BigInt!
  swapCount: BigInt!
}

input xdai_swap_SystemInfo_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  exchangeCount: BigInt
  exchangeCount_not: BigInt
  exchangeCount_gt: BigInt
  exchangeCount_lt: BigInt
  exchangeCount_gte: BigInt
  exchangeCount_lte: BigInt
  exchangeCount_in: [BigInt!]
  exchangeCount_not_in: [BigInt!]
  swapCount: BigInt
  swapCount_not: BigInt
  swapCount_gt: BigInt
  swapCount_lt: BigInt
  swapCount_gte: BigInt
  swapCount_lte: BigInt
  swapCount_in: [BigInt!]
  swapCount_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: xdai_swap_BlockChangedFilter
  and: [xdai_swap_SystemInfo_filter]
  or: [xdai_swap_SystemInfo_filter]
}

enum xdai_swap_SystemInfo_orderBy {
  id
  exchangeCount
  swapCount
}

type xdai_swap__Block_ {
  """The hash of the block"""
  hash: xdai_swap_Bytes
  """The block number"""
  number: Int!
  """Integer representation of the timestamp stored in blocks for the chain"""
  timestamp: Int
  """The hash of the parent block"""
  parentHash: xdai_swap_Bytes
}

"""The type for the top-level _meta field"""
type xdai_swap__Meta_ {
  """
  Information about a specific subgraph block. The hash of the block
  will be null if the _meta field has a block constraint that asks for
  a block number. It will be filled if the _meta field has no block constraint
  and therefore asks for the latest  block
  
  """
  block: xdai_swap__Block_!
  """The deployment ID"""
  deployment: String!
  """If `true`, the subgraph encountered indexing errors at some past block"""
  hasIndexingErrors: Boolean!
}

enum arbitrumone_swap_Aggregation_interval {
  hour
  day
}

scalar arbitrumone_swap_BigDecimal

input arbitrumone_swap_BlockChangedFilter {
  number_gte: Int!
}

input arbitrumone_swap_Block_height {
  hash: arbitrumone_swap_Bytes
  number: Int
  number_gte: Int
}

scalar arbitrumone_swap_Bytes

"""
8 bytes signed integer

"""
scalar arbitrumone_swap_Int8

type arbitrumone_swap_LpAccount {
  id: ID!
  address: arbitrumone_swap_Bytes!
  balances(skip: Int = 0, first: Int = 100, orderBy: arbitrumone_swap_LpAccountBalance_orderBy, orderDirection: arbitrumone_swap_OrderDirection, where: arbitrumone_swap_LpAccountBalance_filter): [arbitrumone_swap_LpAccountBalance!]!
}

type arbitrumone_swap_LpAccountBalance {
  id: ID!
  account: arbitrumone_swap_LpAccount!
  token: arbitrumone_swap_LpToken!
  amount: arbitrumone_swap_BigDecimal!
  block: BigInt
  modified: BigInt
  transaction: arbitrumone_swap_Bytes
}

input arbitrumone_swap_LpAccountBalance_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  account: String
  account_not: String
  account_gt: String
  account_lt: String
  account_gte: String
  account_lte: String
  account_in: [String!]
  account_not_in: [String!]
  account_contains: String
  account_contains_nocase: String
  account_not_contains: String
  account_not_contains_nocase: String
  account_starts_with: String
  account_starts_with_nocase: String
  account_not_starts_with: String
  account_not_starts_with_nocase: String
  account_ends_with: String
  account_ends_with_nocase: String
  account_not_ends_with: String
  account_not_ends_with_nocase: String
  account_: arbitrumone_swap_LpAccount_filter
  token: String
  token_not: String
  token_gt: String
  token_lt: String
  token_gte: String
  token_lte: String
  token_in: [String!]
  token_not_in: [String!]
  token_contains: String
  token_contains_nocase: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_: arbitrumone_swap_LpToken_filter
  amount: arbitrumone_swap_BigDecimal
  amount_not: arbitrumone_swap_BigDecimal
  amount_gt: arbitrumone_swap_BigDecimal
  amount_lt: arbitrumone_swap_BigDecimal
  amount_gte: arbitrumone_swap_BigDecimal
  amount_lte: arbitrumone_swap_BigDecimal
  amount_in: [arbitrumone_swap_BigDecimal!]
  amount_not_in: [arbitrumone_swap_BigDecimal!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  modified: BigInt
  modified_not: BigInt
  modified_gt: BigInt
  modified_lt: BigInt
  modified_gte: BigInt
  modified_lte: BigInt
  modified_in: [BigInt!]
  modified_not_in: [BigInt!]
  transaction: arbitrumone_swap_Bytes
  transaction_not: arbitrumone_swap_Bytes
  transaction_gt: arbitrumone_swap_Bytes
  transaction_lt: arbitrumone_swap_Bytes
  transaction_gte: arbitrumone_swap_Bytes
  transaction_lte: arbitrumone_swap_Bytes
  transaction_in: [arbitrumone_swap_Bytes!]
  transaction_not_in: [arbitrumone_swap_Bytes!]
  transaction_contains: arbitrumone_swap_Bytes
  transaction_not_contains: arbitrumone_swap_Bytes
  """Filter for the block changed event."""
  _change_block: arbitrumone_swap_BlockChangedFilter
  and: [arbitrumone_swap_LpAccountBalance_filter]
  or: [arbitrumone_swap_LpAccountBalance_filter]
}

enum arbitrumone_swap_LpAccountBalance_orderBy {
  id
  account
  account__id
  account__address
  token
  token__id
  token__address
  token__decimals
  token__name
  token__symbol
  token__totalSupply
  amount
  block
  modified
  transaction
}

input arbitrumone_swap_LpAccount_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  address: arbitrumone_swap_Bytes
  address_not: arbitrumone_swap_Bytes
  address_gt: arbitrumone_swap_Bytes
  address_lt: arbitrumone_swap_Bytes
  address_gte: arbitrumone_swap_Bytes
  address_lte: arbitrumone_swap_Bytes
  address_in: [arbitrumone_swap_Bytes!]
  address_not_in: [arbitrumone_swap_Bytes!]
  address_contains: arbitrumone_swap_Bytes
  address_not_contains: arbitrumone_swap_Bytes
  balances_: arbitrumone_swap_LpAccountBalance_filter
  """Filter for the block changed event."""
  _change_block: arbitrumone_swap_BlockChangedFilter
  and: [arbitrumone_swap_LpAccount_filter]
  or: [arbitrumone_swap_LpAccount_filter]
}

enum arbitrumone_swap_LpAccount_orderBy {
  id
  address
  balances
}

type arbitrumone_swap_LpToken {
  id: ID!
  address: arbitrumone_swap_Bytes!
  stableSwap: arbitrumone_swap_StableSwap!
  decimals: Int!
  name: String!
  symbol: String!
  totalSupply: arbitrumone_swap_BigDecimal!
  events(skip: Int = 0, first: Int = 100, orderBy: arbitrumone_swap_LpTokenEvent_orderBy, orderDirection: arbitrumone_swap_OrderDirection, where: arbitrumone_swap_LpTokenEvent_filter): [arbitrumone_swap_LpTokenEvent!]!
}

interface arbitrumone_swap_LpTokenEvent {
  id: ID!
  token: arbitrumone_swap_LpToken!
  amount: arbitrumone_swap_BigDecimal!
  block: BigInt!
  timestamp: BigInt!
  transaction: arbitrumone_swap_Bytes!
  nonce: BigInt!
}

input arbitrumone_swap_LpTokenEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  token: String
  token_not: String
  token_gt: String
  token_lt: String
  token_gte: String
  token_lte: String
  token_in: [String!]
  token_not_in: [String!]
  token_contains: String
  token_contains_nocase: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_: arbitrumone_swap_LpToken_filter
  amount: arbitrumone_swap_BigDecimal
  amount_not: arbitrumone_swap_BigDecimal
  amount_gt: arbitrumone_swap_BigDecimal
  amount_lt: arbitrumone_swap_BigDecimal
  amount_gte: arbitrumone_swap_BigDecimal
  amount_lte: arbitrumone_swap_BigDecimal
  amount_in: [arbitrumone_swap_BigDecimal!]
  amount_not_in: [arbitrumone_swap_BigDecimal!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: arbitrumone_swap_Bytes
  transaction_not: arbitrumone_swap_Bytes
  transaction_gt: arbitrumone_swap_Bytes
  transaction_lt: arbitrumone_swap_Bytes
  transaction_gte: arbitrumone_swap_Bytes
  transaction_lte: arbitrumone_swap_Bytes
  transaction_in: [arbitrumone_swap_Bytes!]
  transaction_not_in: [arbitrumone_swap_Bytes!]
  transaction_contains: arbitrumone_swap_Bytes
  transaction_not_contains: arbitrumone_swap_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: arbitrumone_swap_BlockChangedFilter
  and: [arbitrumone_swap_LpTokenEvent_filter]
  or: [arbitrumone_swap_LpTokenEvent_filter]
}

enum arbitrumone_swap_LpTokenEvent_orderBy {
  id
  token
  token__id
  token__address
  token__decimals
  token__name
  token__symbol
  token__totalSupply
  amount
  block
  timestamp
  transaction
  nonce
}

input arbitrumone_swap_LpToken_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  address: arbitrumone_swap_Bytes
  address_not: arbitrumone_swap_Bytes
  address_gt: arbitrumone_swap_Bytes
  address_lt: arbitrumone_swap_Bytes
  address_gte: arbitrumone_swap_Bytes
  address_lte: arbitrumone_swap_Bytes
  address_in: [arbitrumone_swap_Bytes!]
  address_not_in: [arbitrumone_swap_Bytes!]
  address_contains: arbitrumone_swap_Bytes
  address_not_contains: arbitrumone_swap_Bytes
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: arbitrumone_swap_StableSwap_filter
  decimals: Int
  decimals_not: Int
  decimals_gt: Int
  decimals_lt: Int
  decimals_gte: Int
  decimals_lte: Int
  decimals_in: [Int!]
  decimals_not_in: [Int!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  symbol: String
  symbol_not: String
  symbol_gt: String
  symbol_lt: String
  symbol_gte: String
  symbol_lte: String
  symbol_in: [String!]
  symbol_not_in: [String!]
  symbol_contains: String
  symbol_contains_nocase: String
  symbol_not_contains: String
  symbol_not_contains_nocase: String
  symbol_starts_with: String
  symbol_starts_with_nocase: String
  symbol_not_starts_with: String
  symbol_not_starts_with_nocase: String
  symbol_ends_with: String
  symbol_ends_with_nocase: String
  symbol_not_ends_with: String
  symbol_not_ends_with_nocase: String
  totalSupply: arbitrumone_swap_BigDecimal
  totalSupply_not: arbitrumone_swap_BigDecimal
  totalSupply_gt: arbitrumone_swap_BigDecimal
  totalSupply_lt: arbitrumone_swap_BigDecimal
  totalSupply_gte: arbitrumone_swap_BigDecimal
  totalSupply_lte: arbitrumone_swap_BigDecimal
  totalSupply_in: [arbitrumone_swap_BigDecimal!]
  totalSupply_not_in: [arbitrumone_swap_BigDecimal!]
  events_: arbitrumone_swap_LpTokenEvent_filter
  """Filter for the block changed event."""
  _change_block: arbitrumone_swap_BlockChangedFilter
  and: [arbitrumone_swap_LpToken_filter]
  or: [arbitrumone_swap_LpToken_filter]
}

enum arbitrumone_swap_LpToken_orderBy {
  id
  address
  stableSwap
  stableSwap__id
  stableSwap__isActive
  stableSwap__key
  stableSwap__canonicalId
  stableSwap__domain
  stableSwap__swapPool
  stableSwap__lpToken
  stableSwap__initialA
  stableSwap__futureA
  stableSwap__initialATime
  stableSwap__futureATime
  stableSwap__swapFee
  stableSwap__adminFee
  stableSwap__virtualPrice
  stableSwap__invariant
  stableSwap__lpTokenSupply
  decimals
  name
  symbol
  totalSupply
  events
}

type arbitrumone_swap_LpTransferEvent implements arbitrumone_swap_LpTokenEvent {
  id: ID!
  token: arbitrumone_swap_LpToken!
  amount: arbitrumone_swap_BigDecimal!
  from: arbitrumone_swap_Bytes!
  to: arbitrumone_swap_Bytes!
  fromBalance: arbitrumone_swap_BigDecimal!
  toBalance: arbitrumone_swap_BigDecimal!
  block: BigInt!
  timestamp: BigInt!
  transaction: arbitrumone_swap_Bytes!
  nonce: BigInt!
}

input arbitrumone_swap_LpTransferEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  token: String
  token_not: String
  token_gt: String
  token_lt: String
  token_gte: String
  token_lte: String
  token_in: [String!]
  token_not_in: [String!]
  token_contains: String
  token_contains_nocase: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_: arbitrumone_swap_LpToken_filter
  amount: arbitrumone_swap_BigDecimal
  amount_not: arbitrumone_swap_BigDecimal
  amount_gt: arbitrumone_swap_BigDecimal
  amount_lt: arbitrumone_swap_BigDecimal
  amount_gte: arbitrumone_swap_BigDecimal
  amount_lte: arbitrumone_swap_BigDecimal
  amount_in: [arbitrumone_swap_BigDecimal!]
  amount_not_in: [arbitrumone_swap_BigDecimal!]
  from: arbitrumone_swap_Bytes
  from_not: arbitrumone_swap_Bytes
  from_gt: arbitrumone_swap_Bytes
  from_lt: arbitrumone_swap_Bytes
  from_gte: arbitrumone_swap_Bytes
  from_lte: arbitrumone_swap_Bytes
  from_in: [arbitrumone_swap_Bytes!]
  from_not_in: [arbitrumone_swap_Bytes!]
  from_contains: arbitrumone_swap_Bytes
  from_not_contains: arbitrumone_swap_Bytes
  to: arbitrumone_swap_Bytes
  to_not: arbitrumone_swap_Bytes
  to_gt: arbitrumone_swap_Bytes
  to_lt: arbitrumone_swap_Bytes
  to_gte: arbitrumone_swap_Bytes
  to_lte: arbitrumone_swap_Bytes
  to_in: [arbitrumone_swap_Bytes!]
  to_not_in: [arbitrumone_swap_Bytes!]
  to_contains: arbitrumone_swap_Bytes
  to_not_contains: arbitrumone_swap_Bytes
  fromBalance: arbitrumone_swap_BigDecimal
  fromBalance_not: arbitrumone_swap_BigDecimal
  fromBalance_gt: arbitrumone_swap_BigDecimal
  fromBalance_lt: arbitrumone_swap_BigDecimal
  fromBalance_gte: arbitrumone_swap_BigDecimal
  fromBalance_lte: arbitrumone_swap_BigDecimal
  fromBalance_in: [arbitrumone_swap_BigDecimal!]
  fromBalance_not_in: [arbitrumone_swap_BigDecimal!]
  toBalance: arbitrumone_swap_BigDecimal
  toBalance_not: arbitrumone_swap_BigDecimal
  toBalance_gt: arbitrumone_swap_BigDecimal
  toBalance_lt: arbitrumone_swap_BigDecimal
  toBalance_gte: arbitrumone_swap_BigDecimal
  toBalance_lte: arbitrumone_swap_BigDecimal
  toBalance_in: [arbitrumone_swap_BigDecimal!]
  toBalance_not_in: [arbitrumone_swap_BigDecimal!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: arbitrumone_swap_Bytes
  transaction_not: arbitrumone_swap_Bytes
  transaction_gt: arbitrumone_swap_Bytes
  transaction_lt: arbitrumone_swap_Bytes
  transaction_gte: arbitrumone_swap_Bytes
  transaction_lte: arbitrumone_swap_Bytes
  transaction_in: [arbitrumone_swap_Bytes!]
  transaction_not_in: [arbitrumone_swap_Bytes!]
  transaction_contains: arbitrumone_swap_Bytes
  transaction_not_contains: arbitrumone_swap_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: arbitrumone_swap_BlockChangedFilter
  and: [arbitrumone_swap_LpTransferEvent_filter]
  or: [arbitrumone_swap_LpTransferEvent_filter]
}

enum arbitrumone_swap_LpTransferEvent_orderBy {
  id
  token
  token__id
  token__address
  token__decimals
  token__name
  token__symbol
  token__totalSupply
  amount
  from
  to
  fromBalance
  toBalance
  block
  timestamp
  transaction
  nonce
}

"""Defines the order direction, either ascending or descending"""
enum arbitrumone_swap_OrderDirection {
  asc
  desc
}

type arbitrumone_swap_PooledToken {
  id: ID!
  asset: arbitrumone_swap_Bytes!
}

input arbitrumone_swap_PooledToken_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  asset: arbitrumone_swap_Bytes
  asset_not: arbitrumone_swap_Bytes
  asset_gt: arbitrumone_swap_Bytes
  asset_lt: arbitrumone_swap_Bytes
  asset_gte: arbitrumone_swap_Bytes
  asset_lte: arbitrumone_swap_Bytes
  asset_in: [arbitrumone_swap_Bytes!]
  asset_not_in: [arbitrumone_swap_Bytes!]
  asset_contains: arbitrumone_swap_Bytes
  asset_not_contains: arbitrumone_swap_Bytes
  """Filter for the block changed event."""
  _change_block: arbitrumone_swap_BlockChangedFilter
  and: [arbitrumone_swap_PooledToken_filter]
  or: [arbitrumone_swap_PooledToken_filter]
}

enum arbitrumone_swap_PooledToken_orderBy {
  id
  asset
}

type arbitrumone_swap_StableSwap {
  id: ID!
  isActive: Boolean
  key: arbitrumone_swap_Bytes!
  canonicalId: arbitrumone_swap_Bytes
  domain: BigInt
  swapPool: arbitrumone_swap_Bytes
  lpToken: arbitrumone_swap_Bytes
  initialA: BigInt
  futureA: BigInt
  initialATime: BigInt
  futureATime: BigInt
  swapFee: BigInt
  adminFee: BigInt
  pooledTokens: [arbitrumone_swap_Bytes!]!
  tokenPrecisionMultipliers: [BigInt!]!
  balances: [BigInt!]!
  adminFees: [BigInt!]!
  virtualPrice: BigInt!
  invariant: BigInt!
  lpTokenSupply: BigInt!
  events(skip: Int = 0, first: Int = 100, orderBy: arbitrumone_swap_StableSwapEvent_orderBy, orderDirection: arbitrumone_swap_OrderDirection, where: arbitrumone_swap_StableSwapEvent_filter): [arbitrumone_swap_StableSwapEvent!]
  exchanges(skip: Int = 0, first: Int = 100, orderBy: arbitrumone_swap_StableSwapExchange_orderBy, orderDirection: arbitrumone_swap_OrderDirection, where: arbitrumone_swap_StableSwapExchange_filter): [arbitrumone_swap_StableSwapExchange!]
  hourlyVolumes(skip: Int = 0, first: Int = 100, orderBy: arbitrumone_swap_SwapHourlyVolume_orderBy, orderDirection: arbitrumone_swap_OrderDirection, where: arbitrumone_swap_SwapHourlyVolume_filter): [arbitrumone_swap_SwapHourlyVolume!]
  dailyVolumes(skip: Int = 0, first: Int = 100, orderBy: arbitrumone_swap_SwapDailyVolume_orderBy, orderDirection: arbitrumone_swap_OrderDirection, where: arbitrumone_swap_SwapDailyVolume_filter): [arbitrumone_swap_SwapDailyVolume!]
  weeklyVolumes(skip: Int = 0, first: Int = 100, orderBy: arbitrumone_swap_SwapWeeklyVolume_orderBy, orderDirection: arbitrumone_swap_OrderDirection, where: arbitrumone_swap_SwapWeeklyVolume_filter): [arbitrumone_swap_SwapWeeklyVolume!]
}

type arbitrumone_swap_StableSwapAddLiquidityEvent implements arbitrumone_swap_StableSwapEvent {
  id: ID!
  stableSwap: arbitrumone_swap_StableSwap!
  provider: arbitrumone_swap_Bytes!
  tokenAmounts: [BigInt!]!
  fees: [BigInt!]!
  invariant: BigInt
  lpTokenSupply: BigInt!
  lpTokenAmount: BigInt!
  balances: [BigInt!]!
  block: BigInt!
  timestamp: BigInt!
  transaction: arbitrumone_swap_Bytes!
  nonce: BigInt!
}

input arbitrumone_swap_StableSwapAddLiquidityEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: arbitrumone_swap_StableSwap_filter
  provider: arbitrumone_swap_Bytes
  provider_not: arbitrumone_swap_Bytes
  provider_gt: arbitrumone_swap_Bytes
  provider_lt: arbitrumone_swap_Bytes
  provider_gte: arbitrumone_swap_Bytes
  provider_lte: arbitrumone_swap_Bytes
  provider_in: [arbitrumone_swap_Bytes!]
  provider_not_in: [arbitrumone_swap_Bytes!]
  provider_contains: arbitrumone_swap_Bytes
  provider_not_contains: arbitrumone_swap_Bytes
  tokenAmounts: [BigInt!]
  tokenAmounts_not: [BigInt!]
  tokenAmounts_contains: [BigInt!]
  tokenAmounts_contains_nocase: [BigInt!]
  tokenAmounts_not_contains: [BigInt!]
  tokenAmounts_not_contains_nocase: [BigInt!]
  fees: [BigInt!]
  fees_not: [BigInt!]
  fees_contains: [BigInt!]
  fees_contains_nocase: [BigInt!]
  fees_not_contains: [BigInt!]
  fees_not_contains_nocase: [BigInt!]
  invariant: BigInt
  invariant_not: BigInt
  invariant_gt: BigInt
  invariant_lt: BigInt
  invariant_gte: BigInt
  invariant_lte: BigInt
  invariant_in: [BigInt!]
  invariant_not_in: [BigInt!]
  lpTokenSupply: BigInt
  lpTokenSupply_not: BigInt
  lpTokenSupply_gt: BigInt
  lpTokenSupply_lt: BigInt
  lpTokenSupply_gte: BigInt
  lpTokenSupply_lte: BigInt
  lpTokenSupply_in: [BigInt!]
  lpTokenSupply_not_in: [BigInt!]
  lpTokenAmount: BigInt
  lpTokenAmount_not: BigInt
  lpTokenAmount_gt: BigInt
  lpTokenAmount_lt: BigInt
  lpTokenAmount_gte: BigInt
  lpTokenAmount_lte: BigInt
  lpTokenAmount_in: [BigInt!]
  lpTokenAmount_not_in: [BigInt!]
  balances: [BigInt!]
  balances_not: [BigInt!]
  balances_contains: [BigInt!]
  balances_contains_nocase: [BigInt!]
  balances_not_contains: [BigInt!]
  balances_not_contains_nocase: [BigInt!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: arbitrumone_swap_Bytes
  transaction_not: arbitrumone_swap_Bytes
  transaction_gt: arbitrumone_swap_Bytes
  transaction_lt: arbitrumone_swap_Bytes
  transaction_gte: arbitrumone_swap_Bytes
  transaction_lte: arbitrumone_swap_Bytes
  transaction_in: [arbitrumone_swap_Bytes!]
  transaction_not_in: [arbitrumone_swap_Bytes!]
  transaction_contains: arbitrumone_swap_Bytes
  transaction_not_contains: arbitrumone_swap_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: arbitrumone_swap_BlockChangedFilter
  and: [arbitrumone_swap_StableSwapAddLiquidityEvent_filter]
  or: [arbitrumone_swap_StableSwapAddLiquidityEvent_filter]
}

enum arbitrumone_swap_StableSwapAddLiquidityEvent_orderBy {
  id
  stableSwap
  stableSwap__id
  stableSwap__isActive
  stableSwap__key
  stableSwap__canonicalId
  stableSwap__domain
  stableSwap__swapPool
  stableSwap__lpToken
  stableSwap__initialA
  stableSwap__futureA
  stableSwap__initialATime
  stableSwap__futureATime
  stableSwap__swapFee
  stableSwap__adminFee
  stableSwap__virtualPrice
  stableSwap__invariant
  stableSwap__lpTokenSupply
  provider
  tokenAmounts
  fees
  invariant
  lpTokenSupply
  lpTokenAmount
  balances
  block
  timestamp
  transaction
  nonce
}

interface arbitrumone_swap_StableSwapEvent {
  id: ID!
  stableSwap: arbitrumone_swap_StableSwap!
  block: BigInt!
  timestamp: BigInt!
  transaction: arbitrumone_swap_Bytes!
  nonce: BigInt!
}

input arbitrumone_swap_StableSwapEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: arbitrumone_swap_StableSwap_filter
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: arbitrumone_swap_Bytes
  transaction_not: arbitrumone_swap_Bytes
  transaction_gt: arbitrumone_swap_Bytes
  transaction_lt: arbitrumone_swap_Bytes
  transaction_gte: arbitrumone_swap_Bytes
  transaction_lte: arbitrumone_swap_Bytes
  transaction_in: [arbitrumone_swap_Bytes!]
  transaction_not_in: [arbitrumone_swap_Bytes!]
  transaction_contains: arbitrumone_swap_Bytes
  transaction_not_contains: arbitrumone_swap_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: arbitrumone_swap_BlockChangedFilter
  and: [arbitrumone_swap_StableSwapEvent_filter]
  or: [arbitrumone_swap_StableSwapEvent_filter]
}

enum arbitrumone_swap_StableSwapEvent_orderBy {
  id
  stableSwap
  stableSwap__id
  stableSwap__isActive
  stableSwap__key
  stableSwap__canonicalId
  stableSwap__domain
  stableSwap__swapPool
  stableSwap__lpToken
  stableSwap__initialA
  stableSwap__futureA
  stableSwap__initialATime
  stableSwap__futureATime
  stableSwap__swapFee
  stableSwap__adminFee
  stableSwap__virtualPrice
  stableSwap__invariant
  stableSwap__lpTokenSupply
  block
  timestamp
  transaction
  nonce
}

type arbitrumone_swap_StableSwapExchange {
  id: ID!
  stableSwap: arbitrumone_swap_StableSwap!
  buyer: arbitrumone_swap_Bytes!
  boughtId: BigInt!
  tokensBought: BigInt!
  soldId: BigInt!
  tokensSold: BigInt!
  balances: [BigInt!]!
  fee: BigInt!
  block: BigInt!
  timestamp: BigInt!
  transaction: arbitrumone_swap_Bytes!
  nonce: BigInt!
}

input arbitrumone_swap_StableSwapExchange_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: arbitrumone_swap_StableSwap_filter
  buyer: arbitrumone_swap_Bytes
  buyer_not: arbitrumone_swap_Bytes
  buyer_gt: arbitrumone_swap_Bytes
  buyer_lt: arbitrumone_swap_Bytes
  buyer_gte: arbitrumone_swap_Bytes
  buyer_lte: arbitrumone_swap_Bytes
  buyer_in: [arbitrumone_swap_Bytes!]
  buyer_not_in: [arbitrumone_swap_Bytes!]
  buyer_contains: arbitrumone_swap_Bytes
  buyer_not_contains: arbitrumone_swap_Bytes
  boughtId: BigInt
  boughtId_not: BigInt
  boughtId_gt: BigInt
  boughtId_lt: BigInt
  boughtId_gte: BigInt
  boughtId_lte: BigInt
  boughtId_in: [BigInt!]
  boughtId_not_in: [BigInt!]
  tokensBought: BigInt
  tokensBought_not: BigInt
  tokensBought_gt: BigInt
  tokensBought_lt: BigInt
  tokensBought_gte: BigInt
  tokensBought_lte: BigInt
  tokensBought_in: [BigInt!]
  tokensBought_not_in: [BigInt!]
  soldId: BigInt
  soldId_not: BigInt
  soldId_gt: BigInt
  soldId_lt: BigInt
  soldId_gte: BigInt
  soldId_lte: BigInt
  soldId_in: [BigInt!]
  soldId_not_in: [BigInt!]
  tokensSold: BigInt
  tokensSold_not: BigInt
  tokensSold_gt: BigInt
  tokensSold_lt: BigInt
  tokensSold_gte: BigInt
  tokensSold_lte: BigInt
  tokensSold_in: [BigInt!]
  tokensSold_not_in: [BigInt!]
  balances: [BigInt!]
  balances_not: [BigInt!]
  balances_contains: [BigInt!]
  balances_contains_nocase: [BigInt!]
  balances_not_contains: [BigInt!]
  balances_not_contains_nocase: [BigInt!]
  fee: BigInt
  fee_not: BigInt
  fee_gt: BigInt
  fee_lt: BigInt
  fee_gte: BigInt
  fee_lte: BigInt
  fee_in: [BigInt!]
  fee_not_in: [BigInt!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: arbitrumone_swap_Bytes
  transaction_not: arbitrumone_swap_Bytes
  transaction_gt: arbitrumone_swap_Bytes
  transaction_lt: arbitrumone_swap_Bytes
  transaction_gte: arbitrumone_swap_Bytes
  transaction_lte: arbitrumone_swap_Bytes
  transaction_in: [arbitrumone_swap_Bytes!]
  transaction_not_in: [arbitrumone_swap_Bytes!]
  transaction_contains: arbitrumone_swap_Bytes
  transaction_not_contains: arbitrumone_swap_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: arbitrumone_swap_BlockChangedFilter
  and: [arbitrumone_swap_StableSwapExchange_filter]
  or: [arbitrumone_swap_StableSwapExchange_filter]
}

enum arbitrumone_swap_StableSwapExchange_orderBy {
  id
  stableSwap
  stableSwap__id
  stableSwap__isActive
  stableSwap__key
  stableSwap__canonicalId
  stableSwap__domain
  stableSwap__swapPool
  stableSwap__lpToken
  stableSwap__initialA
  stableSwap__futureA
  stableSwap__initialATime
  stableSwap__futureATime
  stableSwap__swapFee
  stableSwap__adminFee
  stableSwap__virtualPrice
  stableSwap__invariant
  stableSwap__lpTokenSupply
  buyer
  boughtId
  tokensBought
  soldId
  tokensSold
  balances
  fee
  block
  timestamp
  transaction
  nonce
}

type arbitrumone_swap_StableSwapRemoveLiquidityEvent implements arbitrumone_swap_StableSwapEvent {
  id: ID!
  stableSwap: arbitrumone_swap_StableSwap!
  provider: arbitrumone_swap_Bytes!
  tokenAmounts: [BigInt!]!
  fees: [BigInt!]
  invariant: BigInt
  lpTokenSupply: BigInt!
  lpTokenAmount: BigInt!
  balances: [BigInt!]!
  block: BigInt!
  timestamp: BigInt!
  transaction: arbitrumone_swap_Bytes!
  nonce: BigInt!
}

input arbitrumone_swap_StableSwapRemoveLiquidityEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: arbitrumone_swap_StableSwap_filter
  provider: arbitrumone_swap_Bytes
  provider_not: arbitrumone_swap_Bytes
  provider_gt: arbitrumone_swap_Bytes
  provider_lt: arbitrumone_swap_Bytes
  provider_gte: arbitrumone_swap_Bytes
  provider_lte: arbitrumone_swap_Bytes
  provider_in: [arbitrumone_swap_Bytes!]
  provider_not_in: [arbitrumone_swap_Bytes!]
  provider_contains: arbitrumone_swap_Bytes
  provider_not_contains: arbitrumone_swap_Bytes
  tokenAmounts: [BigInt!]
  tokenAmounts_not: [BigInt!]
  tokenAmounts_contains: [BigInt!]
  tokenAmounts_contains_nocase: [BigInt!]
  tokenAmounts_not_contains: [BigInt!]
  tokenAmounts_not_contains_nocase: [BigInt!]
  fees: [BigInt!]
  fees_not: [BigInt!]
  fees_contains: [BigInt!]
  fees_contains_nocase: [BigInt!]
  fees_not_contains: [BigInt!]
  fees_not_contains_nocase: [BigInt!]
  invariant: BigInt
  invariant_not: BigInt
  invariant_gt: BigInt
  invariant_lt: BigInt
  invariant_gte: BigInt
  invariant_lte: BigInt
  invariant_in: [BigInt!]
  invariant_not_in: [BigInt!]
  lpTokenSupply: BigInt
  lpTokenSupply_not: BigInt
  lpTokenSupply_gt: BigInt
  lpTokenSupply_lt: BigInt
  lpTokenSupply_gte: BigInt
  lpTokenSupply_lte: BigInt
  lpTokenSupply_in: [BigInt!]
  lpTokenSupply_not_in: [BigInt!]
  lpTokenAmount: BigInt
  lpTokenAmount_not: BigInt
  lpTokenAmount_gt: BigInt
  lpTokenAmount_lt: BigInt
  lpTokenAmount_gte: BigInt
  lpTokenAmount_lte: BigInt
  lpTokenAmount_in: [BigInt!]
  lpTokenAmount_not_in: [BigInt!]
  balances: [BigInt!]
  balances_not: [BigInt!]
  balances_contains: [BigInt!]
  balances_contains_nocase: [BigInt!]
  balances_not_contains: [BigInt!]
  balances_not_contains_nocase: [BigInt!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: arbitrumone_swap_Bytes
  transaction_not: arbitrumone_swap_Bytes
  transaction_gt: arbitrumone_swap_Bytes
  transaction_lt: arbitrumone_swap_Bytes
  transaction_gte: arbitrumone_swap_Bytes
  transaction_lte: arbitrumone_swap_Bytes
  transaction_in: [arbitrumone_swap_Bytes!]
  transaction_not_in: [arbitrumone_swap_Bytes!]
  transaction_contains: arbitrumone_swap_Bytes
  transaction_not_contains: arbitrumone_swap_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: arbitrumone_swap_BlockChangedFilter
  and: [arbitrumone_swap_StableSwapRemoveLiquidityEvent_filter]
  or: [arbitrumone_swap_StableSwapRemoveLiquidityEvent_filter]
}

enum arbitrumone_swap_StableSwapRemoveLiquidityEvent_orderBy {
  id
  stableSwap
  stableSwap__id
  stableSwap__isActive
  stableSwap__key
  stableSwap__canonicalId
  stableSwap__domain
  stableSwap__swapPool
  stableSwap__lpToken
  stableSwap__initialA
  stableSwap__futureA
  stableSwap__initialATime
  stableSwap__futureATime
  stableSwap__swapFee
  stableSwap__adminFee
  stableSwap__virtualPrice
  stableSwap__invariant
  stableSwap__lpTokenSupply
  provider
  tokenAmounts
  fees
  invariant
  lpTokenSupply
  lpTokenAmount
  balances
  block
  timestamp
  transaction
  nonce
}

input arbitrumone_swap_StableSwap_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  isActive: Boolean
  isActive_not: Boolean
  isActive_in: [Boolean!]
  isActive_not_in: [Boolean!]
  key: arbitrumone_swap_Bytes
  key_not: arbitrumone_swap_Bytes
  key_gt: arbitrumone_swap_Bytes
  key_lt: arbitrumone_swap_Bytes
  key_gte: arbitrumone_swap_Bytes
  key_lte: arbitrumone_swap_Bytes
  key_in: [arbitrumone_swap_Bytes!]
  key_not_in: [arbitrumone_swap_Bytes!]
  key_contains: arbitrumone_swap_Bytes
  key_not_contains: arbitrumone_swap_Bytes
  canonicalId: arbitrumone_swap_Bytes
  canonicalId_not: arbitrumone_swap_Bytes
  canonicalId_gt: arbitrumone_swap_Bytes
  canonicalId_lt: arbitrumone_swap_Bytes
  canonicalId_gte: arbitrumone_swap_Bytes
  canonicalId_lte: arbitrumone_swap_Bytes
  canonicalId_in: [arbitrumone_swap_Bytes!]
  canonicalId_not_in: [arbitrumone_swap_Bytes!]
  canonicalId_contains: arbitrumone_swap_Bytes
  canonicalId_not_contains: arbitrumone_swap_Bytes
  domain: BigInt
  domain_not: BigInt
  domain_gt: BigInt
  domain_lt: BigInt
  domain_gte: BigInt
  domain_lte: BigInt
  domain_in: [BigInt!]
  domain_not_in: [BigInt!]
  swapPool: arbitrumone_swap_Bytes
  swapPool_not: arbitrumone_swap_Bytes
  swapPool_gt: arbitrumone_swap_Bytes
  swapPool_lt: arbitrumone_swap_Bytes
  swapPool_gte: arbitrumone_swap_Bytes
  swapPool_lte: arbitrumone_swap_Bytes
  swapPool_in: [arbitrumone_swap_Bytes!]
  swapPool_not_in: [arbitrumone_swap_Bytes!]
  swapPool_contains: arbitrumone_swap_Bytes
  swapPool_not_contains: arbitrumone_swap_Bytes
  lpToken: arbitrumone_swap_Bytes
  lpToken_not: arbitrumone_swap_Bytes
  lpToken_gt: arbitrumone_swap_Bytes
  lpToken_lt: arbitrumone_swap_Bytes
  lpToken_gte: arbitrumone_swap_Bytes
  lpToken_lte: arbitrumone_swap_Bytes
  lpToken_in: [arbitrumone_swap_Bytes!]
  lpToken_not_in: [arbitrumone_swap_Bytes!]
  lpToken_contains: arbitrumone_swap_Bytes
  lpToken_not_contains: arbitrumone_swap_Bytes
  initialA: BigInt
  initialA_not: BigInt
  initialA_gt: BigInt
  initialA_lt: BigInt
  initialA_gte: BigInt
  initialA_lte: BigInt
  initialA_in: [BigInt!]
  initialA_not_in: [BigInt!]
  futureA: BigInt
  futureA_not: BigInt
  futureA_gt: BigInt
  futureA_lt: BigInt
  futureA_gte: BigInt
  futureA_lte: BigInt
  futureA_in: [BigInt!]
  futureA_not_in: [BigInt!]
  initialATime: BigInt
  initialATime_not: BigInt
  initialATime_gt: BigInt
  initialATime_lt: BigInt
  initialATime_gte: BigInt
  initialATime_lte: BigInt
  initialATime_in: [BigInt!]
  initialATime_not_in: [BigInt!]
  futureATime: BigInt
  futureATime_not: BigInt
  futureATime_gt: BigInt
  futureATime_lt: BigInt
  futureATime_gte: BigInt
  futureATime_lte: BigInt
  futureATime_in: [BigInt!]
  futureATime_not_in: [BigInt!]
  swapFee: BigInt
  swapFee_not: BigInt
  swapFee_gt: BigInt
  swapFee_lt: BigInt
  swapFee_gte: BigInt
  swapFee_lte: BigInt
  swapFee_in: [BigInt!]
  swapFee_not_in: [BigInt!]
  adminFee: BigInt
  adminFee_not: BigInt
  adminFee_gt: BigInt
  adminFee_lt: BigInt
  adminFee_gte: BigInt
  adminFee_lte: BigInt
  adminFee_in: [BigInt!]
  adminFee_not_in: [BigInt!]
  pooledTokens: [arbitrumone_swap_Bytes!]
  pooledTokens_not: [arbitrumone_swap_Bytes!]
  pooledTokens_contains: [arbitrumone_swap_Bytes!]
  pooledTokens_contains_nocase: [arbitrumone_swap_Bytes!]
  pooledTokens_not_contains: [arbitrumone_swap_Bytes!]
  pooledTokens_not_contains_nocase: [arbitrumone_swap_Bytes!]
  tokenPrecisionMultipliers: [BigInt!]
  tokenPrecisionMultipliers_not: [BigInt!]
  tokenPrecisionMultipliers_contains: [BigInt!]
  tokenPrecisionMultipliers_contains_nocase: [BigInt!]
  tokenPrecisionMultipliers_not_contains: [BigInt!]
  tokenPrecisionMultipliers_not_contains_nocase: [BigInt!]
  balances: [BigInt!]
  balances_not: [BigInt!]
  balances_contains: [BigInt!]
  balances_contains_nocase: [BigInt!]
  balances_not_contains: [BigInt!]
  balances_not_contains_nocase: [BigInt!]
  adminFees: [BigInt!]
  adminFees_not: [BigInt!]
  adminFees_contains: [BigInt!]
  adminFees_contains_nocase: [BigInt!]
  adminFees_not_contains: [BigInt!]
  adminFees_not_contains_nocase: [BigInt!]
  virtualPrice: BigInt
  virtualPrice_not: BigInt
  virtualPrice_gt: BigInt
  virtualPrice_lt: BigInt
  virtualPrice_gte: BigInt
  virtualPrice_lte: BigInt
  virtualPrice_in: [BigInt!]
  virtualPrice_not_in: [BigInt!]
  invariant: BigInt
  invariant_not: BigInt
  invariant_gt: BigInt
  invariant_lt: BigInt
  invariant_gte: BigInt
  invariant_lte: BigInt
  invariant_in: [BigInt!]
  invariant_not_in: [BigInt!]
  lpTokenSupply: BigInt
  lpTokenSupply_not: BigInt
  lpTokenSupply_gt: BigInt
  lpTokenSupply_lt: BigInt
  lpTokenSupply_gte: BigInt
  lpTokenSupply_lte: BigInt
  lpTokenSupply_in: [BigInt!]
  lpTokenSupply_not_in: [BigInt!]
  events_: arbitrumone_swap_StableSwapEvent_filter
  exchanges_: arbitrumone_swap_StableSwapExchange_filter
  hourlyVolumes_: arbitrumone_swap_SwapHourlyVolume_filter
  dailyVolumes_: arbitrumone_swap_SwapDailyVolume_filter
  weeklyVolumes_: arbitrumone_swap_SwapWeeklyVolume_filter
  """Filter for the block changed event."""
  _change_block: arbitrumone_swap_BlockChangedFilter
  and: [arbitrumone_swap_StableSwap_filter]
  or: [arbitrumone_swap_StableSwap_filter]
}

enum arbitrumone_swap_StableSwap_orderBy {
  id
  isActive
  key
  canonicalId
  domain
  swapPool
  lpToken
  initialA
  futureA
  initialATime
  futureATime
  swapFee
  adminFee
  pooledTokens
  tokenPrecisionMultipliers
  balances
  adminFees
  virtualPrice
  invariant
  lpTokenSupply
  events
  exchanges
  hourlyVolumes
  dailyVolumes
  weeklyVolumes
}

type arbitrumone_swap_SwapDailyVolume implements arbitrumone_swap_SwapTradeVolume {
  id: ID!
  stableSwap: arbitrumone_swap_StableSwap!
  timestamp: BigInt!
  volume: arbitrumone_swap_BigDecimal!
}

input arbitrumone_swap_SwapDailyVolume_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: arbitrumone_swap_StableSwap_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  volume: arbitrumone_swap_BigDecimal
  volume_not: arbitrumone_swap_BigDecimal
  volume_gt: arbitrumone_swap_BigDecimal
  volume_lt: arbitrumone_swap_BigDecimal
  volume_gte: arbitrumone_swap_BigDecimal
  volume_lte: arbitrumone_swap_BigDecimal
  volume_in: [arbitrumone_swap_BigDecimal!]
  volume_not_in: [arbitrumone_swap_BigDecimal!]
  """Filter for the block changed event."""
  _change_block: arbitrumone_swap_BlockChangedFilter
  and: [arbitrumone_swap_SwapDailyVolume_filter]
  or: [arbitrumone_swap_SwapDailyVolume_filter]
}

enum arbitrumone_swap_SwapDailyVolume_orderBy {
  id
  stableSwap
  stableSwap__id
  stableSwap__isActive
  stableSwap__key
  stableSwap__canonicalId
  stableSwap__domain
  stableSwap__swapPool
  stableSwap__lpToken
  stableSwap__initialA
  stableSwap__futureA
  stableSwap__initialATime
  stableSwap__futureATime
  stableSwap__swapFee
  stableSwap__adminFee
  stableSwap__virtualPrice
  stableSwap__invariant
  stableSwap__lpTokenSupply
  timestamp
  volume
}

type arbitrumone_swap_SwapHourlyVolume implements arbitrumone_swap_SwapTradeVolume {
  id: ID!
  stableSwap: arbitrumone_swap_StableSwap!
  timestamp: BigInt!
  volume: arbitrumone_swap_BigDecimal!
}

input arbitrumone_swap_SwapHourlyVolume_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: arbitrumone_swap_StableSwap_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  volume: arbitrumone_swap_BigDecimal
  volume_not: arbitrumone_swap_BigDecimal
  volume_gt: arbitrumone_swap_BigDecimal
  volume_lt: arbitrumone_swap_BigDecimal
  volume_gte: arbitrumone_swap_BigDecimal
  volume_lte: arbitrumone_swap_BigDecimal
  volume_in: [arbitrumone_swap_BigDecimal!]
  volume_not_in: [arbitrumone_swap_BigDecimal!]
  """Filter for the block changed event."""
  _change_block: arbitrumone_swap_BlockChangedFilter
  and: [arbitrumone_swap_SwapHourlyVolume_filter]
  or: [arbitrumone_swap_SwapHourlyVolume_filter]
}

enum arbitrumone_swap_SwapHourlyVolume_orderBy {
  id
  stableSwap
  stableSwap__id
  stableSwap__isActive
  stableSwap__key
  stableSwap__canonicalId
  stableSwap__domain
  stableSwap__swapPool
  stableSwap__lpToken
  stableSwap__initialA
  stableSwap__futureA
  stableSwap__initialATime
  stableSwap__futureATime
  stableSwap__swapFee
  stableSwap__adminFee
  stableSwap__virtualPrice
  stableSwap__invariant
  stableSwap__lpTokenSupply
  timestamp
  volume
}

interface arbitrumone_swap_SwapTradeVolume {
  stableSwap: arbitrumone_swap_StableSwap!
  timestamp: BigInt!
  volume: arbitrumone_swap_BigDecimal!
}

input arbitrumone_swap_SwapTradeVolume_filter {
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: arbitrumone_swap_StableSwap_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  volume: arbitrumone_swap_BigDecimal
  volume_not: arbitrumone_swap_BigDecimal
  volume_gt: arbitrumone_swap_BigDecimal
  volume_lt: arbitrumone_swap_BigDecimal
  volume_gte: arbitrumone_swap_BigDecimal
  volume_lte: arbitrumone_swap_BigDecimal
  volume_in: [arbitrumone_swap_BigDecimal!]
  volume_not_in: [arbitrumone_swap_BigDecimal!]
  """Filter for the block changed event."""
  _change_block: arbitrumone_swap_BlockChangedFilter
  and: [arbitrumone_swap_SwapTradeVolume_filter]
  or: [arbitrumone_swap_SwapTradeVolume_filter]
}

enum arbitrumone_swap_SwapTradeVolume_orderBy {
  stableSwap
  stableSwap__id
  stableSwap__isActive
  stableSwap__key
  stableSwap__canonicalId
  stableSwap__domain
  stableSwap__swapPool
  stableSwap__lpToken
  stableSwap__initialA
  stableSwap__futureA
  stableSwap__initialATime
  stableSwap__futureATime
  stableSwap__swapFee
  stableSwap__adminFee
  stableSwap__virtualPrice
  stableSwap__invariant
  stableSwap__lpTokenSupply
  timestamp
  volume
}

type arbitrumone_swap_SwapWeeklyVolume implements arbitrumone_swap_SwapTradeVolume {
  id: ID!
  stableSwap: arbitrumone_swap_StableSwap!
  timestamp: BigInt!
  volume: arbitrumone_swap_BigDecimal!
}

input arbitrumone_swap_SwapWeeklyVolume_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: arbitrumone_swap_StableSwap_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  volume: arbitrumone_swap_BigDecimal
  volume_not: arbitrumone_swap_BigDecimal
  volume_gt: arbitrumone_swap_BigDecimal
  volume_lt: arbitrumone_swap_BigDecimal
  volume_gte: arbitrumone_swap_BigDecimal
  volume_lte: arbitrumone_swap_BigDecimal
  volume_in: [arbitrumone_swap_BigDecimal!]
  volume_not_in: [arbitrumone_swap_BigDecimal!]
  """Filter for the block changed event."""
  _change_block: arbitrumone_swap_BlockChangedFilter
  and: [arbitrumone_swap_SwapWeeklyVolume_filter]
  or: [arbitrumone_swap_SwapWeeklyVolume_filter]
}

enum arbitrumone_swap_SwapWeeklyVolume_orderBy {
  id
  stableSwap
  stableSwap__id
  stableSwap__isActive
  stableSwap__key
  stableSwap__canonicalId
  stableSwap__domain
  stableSwap__swapPool
  stableSwap__lpToken
  stableSwap__initialA
  stableSwap__futureA
  stableSwap__initialATime
  stableSwap__futureATime
  stableSwap__swapFee
  stableSwap__adminFee
  stableSwap__virtualPrice
  stableSwap__invariant
  stableSwap__lpTokenSupply
  timestamp
  volume
}

type arbitrumone_swap_SystemInfo {
  id: ID!
  exchangeCount: BigInt!
  swapCount: BigInt!
}

input arbitrumone_swap_SystemInfo_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  exchangeCount: BigInt
  exchangeCount_not: BigInt
  exchangeCount_gt: BigInt
  exchangeCount_lt: BigInt
  exchangeCount_gte: BigInt
  exchangeCount_lte: BigInt
  exchangeCount_in: [BigInt!]
  exchangeCount_not_in: [BigInt!]
  swapCount: BigInt
  swapCount_not: BigInt
  swapCount_gt: BigInt
  swapCount_lt: BigInt
  swapCount_gte: BigInt
  swapCount_lte: BigInt
  swapCount_in: [BigInt!]
  swapCount_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: arbitrumone_swap_BlockChangedFilter
  and: [arbitrumone_swap_SystemInfo_filter]
  or: [arbitrumone_swap_SystemInfo_filter]
}

enum arbitrumone_swap_SystemInfo_orderBy {
  id
  exchangeCount
  swapCount
}

type arbitrumone_swap__Block_ {
  """The hash of the block"""
  hash: arbitrumone_swap_Bytes
  """The block number"""
  number: Int!
  """Integer representation of the timestamp stored in blocks for the chain"""
  timestamp: Int
  """The hash of the parent block"""
  parentHash: arbitrumone_swap_Bytes
}

"""The type for the top-level _meta field"""
type arbitrumone_swap__Meta_ {
  """
  Information about a specific subgraph block. The hash of the block
  will be null if the _meta field has a block constraint that asks for
  a block number. It will be filled if the _meta field has no block constraint
  and therefore asks for the latest  block
  
  """
  block: arbitrumone_swap__Block_!
  """The deployment ID"""
  deployment: String!
  """If `true`, the subgraph encountered indexing errors at some past block"""
  hasIndexingErrors: Boolean!
}

enum bnb_swap_Aggregation_interval {
  hour
  day
}

scalar bnb_swap_BigDecimal

input bnb_swap_BlockChangedFilter {
  number_gte: Int!
}

input bnb_swap_Block_height {
  hash: bnb_swap_Bytes
  number: Int
  number_gte: Int
}

scalar bnb_swap_Bytes

"""
8 bytes signed integer

"""
scalar bnb_swap_Int8

type bnb_swap_LpAccount {
  id: ID!
  address: bnb_swap_Bytes!
  balances(skip: Int = 0, first: Int = 100, orderBy: bnb_swap_LpAccountBalance_orderBy, orderDirection: bnb_swap_OrderDirection, where: bnb_swap_LpAccountBalance_filter): [bnb_swap_LpAccountBalance!]!
}

type bnb_swap_LpAccountBalance {
  id: ID!
  account: bnb_swap_LpAccount!
  token: bnb_swap_LpToken!
  amount: bnb_swap_BigDecimal!
  block: BigInt
  modified: BigInt
  transaction: bnb_swap_Bytes
}

input bnb_swap_LpAccountBalance_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  account: String
  account_not: String
  account_gt: String
  account_lt: String
  account_gte: String
  account_lte: String
  account_in: [String!]
  account_not_in: [String!]
  account_contains: String
  account_contains_nocase: String
  account_not_contains: String
  account_not_contains_nocase: String
  account_starts_with: String
  account_starts_with_nocase: String
  account_not_starts_with: String
  account_not_starts_with_nocase: String
  account_ends_with: String
  account_ends_with_nocase: String
  account_not_ends_with: String
  account_not_ends_with_nocase: String
  account_: bnb_swap_LpAccount_filter
  token: String
  token_not: String
  token_gt: String
  token_lt: String
  token_gte: String
  token_lte: String
  token_in: [String!]
  token_not_in: [String!]
  token_contains: String
  token_contains_nocase: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_: bnb_swap_LpToken_filter
  amount: bnb_swap_BigDecimal
  amount_not: bnb_swap_BigDecimal
  amount_gt: bnb_swap_BigDecimal
  amount_lt: bnb_swap_BigDecimal
  amount_gte: bnb_swap_BigDecimal
  amount_lte: bnb_swap_BigDecimal
  amount_in: [bnb_swap_BigDecimal!]
  amount_not_in: [bnb_swap_BigDecimal!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  modified: BigInt
  modified_not: BigInt
  modified_gt: BigInt
  modified_lt: BigInt
  modified_gte: BigInt
  modified_lte: BigInt
  modified_in: [BigInt!]
  modified_not_in: [BigInt!]
  transaction: bnb_swap_Bytes
  transaction_not: bnb_swap_Bytes
  transaction_gt: bnb_swap_Bytes
  transaction_lt: bnb_swap_Bytes
  transaction_gte: bnb_swap_Bytes
  transaction_lte: bnb_swap_Bytes
  transaction_in: [bnb_swap_Bytes!]
  transaction_not_in: [bnb_swap_Bytes!]
  transaction_contains: bnb_swap_Bytes
  transaction_not_contains: bnb_swap_Bytes
  """Filter for the block changed event."""
  _change_block: bnb_swap_BlockChangedFilter
  and: [bnb_swap_LpAccountBalance_filter]
  or: [bnb_swap_LpAccountBalance_filter]
}

enum bnb_swap_LpAccountBalance_orderBy {
  id
  account
  account__id
  account__address
  token
  token__id
  token__address
  token__decimals
  token__name
  token__symbol
  token__totalSupply
  amount
  block
  modified
  transaction
}

input bnb_swap_LpAccount_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  address: bnb_swap_Bytes
  address_not: bnb_swap_Bytes
  address_gt: bnb_swap_Bytes
  address_lt: bnb_swap_Bytes
  address_gte: bnb_swap_Bytes
  address_lte: bnb_swap_Bytes
  address_in: [bnb_swap_Bytes!]
  address_not_in: [bnb_swap_Bytes!]
  address_contains: bnb_swap_Bytes
  address_not_contains: bnb_swap_Bytes
  balances_: bnb_swap_LpAccountBalance_filter
  """Filter for the block changed event."""
  _change_block: bnb_swap_BlockChangedFilter
  and: [bnb_swap_LpAccount_filter]
  or: [bnb_swap_LpAccount_filter]
}

enum bnb_swap_LpAccount_orderBy {
  id
  address
  balances
}

type bnb_swap_LpToken {
  id: ID!
  address: bnb_swap_Bytes!
  stableSwap: bnb_swap_StableSwap!
  decimals: Int!
  name: String!
  symbol: String!
  totalSupply: bnb_swap_BigDecimal!
  events(skip: Int = 0, first: Int = 100, orderBy: bnb_swap_LpTokenEvent_orderBy, orderDirection: bnb_swap_OrderDirection, where: bnb_swap_LpTokenEvent_filter): [bnb_swap_LpTokenEvent!]!
}

interface bnb_swap_LpTokenEvent {
  id: ID!
  token: bnb_swap_LpToken!
  amount: bnb_swap_BigDecimal!
  block: BigInt!
  timestamp: BigInt!
  transaction: bnb_swap_Bytes!
  nonce: BigInt!
}

input bnb_swap_LpTokenEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  token: String
  token_not: String
  token_gt: String
  token_lt: String
  token_gte: String
  token_lte: String
  token_in: [String!]
  token_not_in: [String!]
  token_contains: String
  token_contains_nocase: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_: bnb_swap_LpToken_filter
  amount: bnb_swap_BigDecimal
  amount_not: bnb_swap_BigDecimal
  amount_gt: bnb_swap_BigDecimal
  amount_lt: bnb_swap_BigDecimal
  amount_gte: bnb_swap_BigDecimal
  amount_lte: bnb_swap_BigDecimal
  amount_in: [bnb_swap_BigDecimal!]
  amount_not_in: [bnb_swap_BigDecimal!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: bnb_swap_Bytes
  transaction_not: bnb_swap_Bytes
  transaction_gt: bnb_swap_Bytes
  transaction_lt: bnb_swap_Bytes
  transaction_gte: bnb_swap_Bytes
  transaction_lte: bnb_swap_Bytes
  transaction_in: [bnb_swap_Bytes!]
  transaction_not_in: [bnb_swap_Bytes!]
  transaction_contains: bnb_swap_Bytes
  transaction_not_contains: bnb_swap_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: bnb_swap_BlockChangedFilter
  and: [bnb_swap_LpTokenEvent_filter]
  or: [bnb_swap_LpTokenEvent_filter]
}

enum bnb_swap_LpTokenEvent_orderBy {
  id
  token
  token__id
  token__address
  token__decimals
  token__name
  token__symbol
  token__totalSupply
  amount
  block
  timestamp
  transaction
  nonce
}

input bnb_swap_LpToken_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  address: bnb_swap_Bytes
  address_not: bnb_swap_Bytes
  address_gt: bnb_swap_Bytes
  address_lt: bnb_swap_Bytes
  address_gte: bnb_swap_Bytes
  address_lte: bnb_swap_Bytes
  address_in: [bnb_swap_Bytes!]
  address_not_in: [bnb_swap_Bytes!]
  address_contains: bnb_swap_Bytes
  address_not_contains: bnb_swap_Bytes
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: bnb_swap_StableSwap_filter
  decimals: Int
  decimals_not: Int
  decimals_gt: Int
  decimals_lt: Int
  decimals_gte: Int
  decimals_lte: Int
  decimals_in: [Int!]
  decimals_not_in: [Int!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  symbol: String
  symbol_not: String
  symbol_gt: String
  symbol_lt: String
  symbol_gte: String
  symbol_lte: String
  symbol_in: [String!]
  symbol_not_in: [String!]
  symbol_contains: String
  symbol_contains_nocase: String
  symbol_not_contains: String
  symbol_not_contains_nocase: String
  symbol_starts_with: String
  symbol_starts_with_nocase: String
  symbol_not_starts_with: String
  symbol_not_starts_with_nocase: String
  symbol_ends_with: String
  symbol_ends_with_nocase: String
  symbol_not_ends_with: String
  symbol_not_ends_with_nocase: String
  totalSupply: bnb_swap_BigDecimal
  totalSupply_not: bnb_swap_BigDecimal
  totalSupply_gt: bnb_swap_BigDecimal
  totalSupply_lt: bnb_swap_BigDecimal
  totalSupply_gte: bnb_swap_BigDecimal
  totalSupply_lte: bnb_swap_BigDecimal
  totalSupply_in: [bnb_swap_BigDecimal!]
  totalSupply_not_in: [bnb_swap_BigDecimal!]
  events_: bnb_swap_LpTokenEvent_filter
  """Filter for the block changed event."""
  _change_block: bnb_swap_BlockChangedFilter
  and: [bnb_swap_LpToken_filter]
  or: [bnb_swap_LpToken_filter]
}

enum bnb_swap_LpToken_orderBy {
  id
  address
  stableSwap
  stableSwap__id
  stableSwap__isActive
  stableSwap__key
  stableSwap__canonicalId
  stableSwap__domain
  stableSwap__swapPool
  stableSwap__lpToken
  stableSwap__initialA
  stableSwap__futureA
  stableSwap__initialATime
  stableSwap__futureATime
  stableSwap__swapFee
  stableSwap__adminFee
  stableSwap__virtualPrice
  stableSwap__invariant
  stableSwap__lpTokenSupply
  decimals
  name
  symbol
  totalSupply
  events
}

type bnb_swap_LpTransferEvent implements bnb_swap_LpTokenEvent {
  id: ID!
  token: bnb_swap_LpToken!
  amount: bnb_swap_BigDecimal!
  from: bnb_swap_Bytes!
  to: bnb_swap_Bytes!
  fromBalance: bnb_swap_BigDecimal!
  toBalance: bnb_swap_BigDecimal!
  block: BigInt!
  timestamp: BigInt!
  transaction: bnb_swap_Bytes!
  nonce: BigInt!
}

input bnb_swap_LpTransferEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  token: String
  token_not: String
  token_gt: String
  token_lt: String
  token_gte: String
  token_lte: String
  token_in: [String!]
  token_not_in: [String!]
  token_contains: String
  token_contains_nocase: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_: bnb_swap_LpToken_filter
  amount: bnb_swap_BigDecimal
  amount_not: bnb_swap_BigDecimal
  amount_gt: bnb_swap_BigDecimal
  amount_lt: bnb_swap_BigDecimal
  amount_gte: bnb_swap_BigDecimal
  amount_lte: bnb_swap_BigDecimal
  amount_in: [bnb_swap_BigDecimal!]
  amount_not_in: [bnb_swap_BigDecimal!]
  from: bnb_swap_Bytes
  from_not: bnb_swap_Bytes
  from_gt: bnb_swap_Bytes
  from_lt: bnb_swap_Bytes
  from_gte: bnb_swap_Bytes
  from_lte: bnb_swap_Bytes
  from_in: [bnb_swap_Bytes!]
  from_not_in: [bnb_swap_Bytes!]
  from_contains: bnb_swap_Bytes
  from_not_contains: bnb_swap_Bytes
  to: bnb_swap_Bytes
  to_not: bnb_swap_Bytes
  to_gt: bnb_swap_Bytes
  to_lt: bnb_swap_Bytes
  to_gte: bnb_swap_Bytes
  to_lte: bnb_swap_Bytes
  to_in: [bnb_swap_Bytes!]
  to_not_in: [bnb_swap_Bytes!]
  to_contains: bnb_swap_Bytes
  to_not_contains: bnb_swap_Bytes
  fromBalance: bnb_swap_BigDecimal
  fromBalance_not: bnb_swap_BigDecimal
  fromBalance_gt: bnb_swap_BigDecimal
  fromBalance_lt: bnb_swap_BigDecimal
  fromBalance_gte: bnb_swap_BigDecimal
  fromBalance_lte: bnb_swap_BigDecimal
  fromBalance_in: [bnb_swap_BigDecimal!]
  fromBalance_not_in: [bnb_swap_BigDecimal!]
  toBalance: bnb_swap_BigDecimal
  toBalance_not: bnb_swap_BigDecimal
  toBalance_gt: bnb_swap_BigDecimal
  toBalance_lt: bnb_swap_BigDecimal
  toBalance_gte: bnb_swap_BigDecimal
  toBalance_lte: bnb_swap_BigDecimal
  toBalance_in: [bnb_swap_BigDecimal!]
  toBalance_not_in: [bnb_swap_BigDecimal!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: bnb_swap_Bytes
  transaction_not: bnb_swap_Bytes
  transaction_gt: bnb_swap_Bytes
  transaction_lt: bnb_swap_Bytes
  transaction_gte: bnb_swap_Bytes
  transaction_lte: bnb_swap_Bytes
  transaction_in: [bnb_swap_Bytes!]
  transaction_not_in: [bnb_swap_Bytes!]
  transaction_contains: bnb_swap_Bytes
  transaction_not_contains: bnb_swap_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: bnb_swap_BlockChangedFilter
  and: [bnb_swap_LpTransferEvent_filter]
  or: [bnb_swap_LpTransferEvent_filter]
}

enum bnb_swap_LpTransferEvent_orderBy {
  id
  token
  token__id
  token__address
  token__decimals
  token__name
  token__symbol
  token__totalSupply
  amount
  from
  to
  fromBalance
  toBalance
  block
  timestamp
  transaction
  nonce
}

"""Defines the order direction, either ascending or descending"""
enum bnb_swap_OrderDirection {
  asc
  desc
}

type bnb_swap_PooledToken {
  id: ID!
  asset: bnb_swap_Bytes!
}

input bnb_swap_PooledToken_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  asset: bnb_swap_Bytes
  asset_not: bnb_swap_Bytes
  asset_gt: bnb_swap_Bytes
  asset_lt: bnb_swap_Bytes
  asset_gte: bnb_swap_Bytes
  asset_lte: bnb_swap_Bytes
  asset_in: [bnb_swap_Bytes!]
  asset_not_in: [bnb_swap_Bytes!]
  asset_contains: bnb_swap_Bytes
  asset_not_contains: bnb_swap_Bytes
  """Filter for the block changed event."""
  _change_block: bnb_swap_BlockChangedFilter
  and: [bnb_swap_PooledToken_filter]
  or: [bnb_swap_PooledToken_filter]
}

enum bnb_swap_PooledToken_orderBy {
  id
  asset
}

type bnb_swap_StableSwap {
  id: ID!
  isActive: Boolean
  key: bnb_swap_Bytes!
  canonicalId: bnb_swap_Bytes
  domain: BigInt
  swapPool: bnb_swap_Bytes
  lpToken: bnb_swap_Bytes
  initialA: BigInt
  futureA: BigInt
  initialATime: BigInt
  futureATime: BigInt
  swapFee: BigInt
  adminFee: BigInt
  pooledTokens: [bnb_swap_Bytes!]!
  tokenPrecisionMultipliers: [BigInt!]!
  balances: [BigInt!]!
  adminFees: [BigInt!]!
  virtualPrice: BigInt!
  invariant: BigInt!
  lpTokenSupply: BigInt!
  events(skip: Int = 0, first: Int = 100, orderBy: bnb_swap_StableSwapEvent_orderBy, orderDirection: bnb_swap_OrderDirection, where: bnb_swap_StableSwapEvent_filter): [bnb_swap_StableSwapEvent!]
  exchanges(skip: Int = 0, first: Int = 100, orderBy: bnb_swap_StableSwapExchange_orderBy, orderDirection: bnb_swap_OrderDirection, where: bnb_swap_StableSwapExchange_filter): [bnb_swap_StableSwapExchange!]
  hourlyVolumes(skip: Int = 0, first: Int = 100, orderBy: bnb_swap_SwapHourlyVolume_orderBy, orderDirection: bnb_swap_OrderDirection, where: bnb_swap_SwapHourlyVolume_filter): [bnb_swap_SwapHourlyVolume!]
  dailyVolumes(skip: Int = 0, first: Int = 100, orderBy: bnb_swap_SwapDailyVolume_orderBy, orderDirection: bnb_swap_OrderDirection, where: bnb_swap_SwapDailyVolume_filter): [bnb_swap_SwapDailyVolume!]
  weeklyVolumes(skip: Int = 0, first: Int = 100, orderBy: bnb_swap_SwapWeeklyVolume_orderBy, orderDirection: bnb_swap_OrderDirection, where: bnb_swap_SwapWeeklyVolume_filter): [bnb_swap_SwapWeeklyVolume!]
}

type bnb_swap_StableSwapAddLiquidityEvent implements bnb_swap_StableSwapEvent {
  id: ID!
  stableSwap: bnb_swap_StableSwap!
  provider: bnb_swap_Bytes!
  tokenAmounts: [BigInt!]!
  fees: [BigInt!]!
  invariant: BigInt
  lpTokenSupply: BigInt!
  lpTokenAmount: BigInt!
  balances: [BigInt!]!
  block: BigInt!
  timestamp: BigInt!
  transaction: bnb_swap_Bytes!
  nonce: BigInt!
}

input bnb_swap_StableSwapAddLiquidityEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: bnb_swap_StableSwap_filter
  provider: bnb_swap_Bytes
  provider_not: bnb_swap_Bytes
  provider_gt: bnb_swap_Bytes
  provider_lt: bnb_swap_Bytes
  provider_gte: bnb_swap_Bytes
  provider_lte: bnb_swap_Bytes
  provider_in: [bnb_swap_Bytes!]
  provider_not_in: [bnb_swap_Bytes!]
  provider_contains: bnb_swap_Bytes
  provider_not_contains: bnb_swap_Bytes
  tokenAmounts: [BigInt!]
  tokenAmounts_not: [BigInt!]
  tokenAmounts_contains: [BigInt!]
  tokenAmounts_contains_nocase: [BigInt!]
  tokenAmounts_not_contains: [BigInt!]
  tokenAmounts_not_contains_nocase: [BigInt!]
  fees: [BigInt!]
  fees_not: [BigInt!]
  fees_contains: [BigInt!]
  fees_contains_nocase: [BigInt!]
  fees_not_contains: [BigInt!]
  fees_not_contains_nocase: [BigInt!]
  invariant: BigInt
  invariant_not: BigInt
  invariant_gt: BigInt
  invariant_lt: BigInt
  invariant_gte: BigInt
  invariant_lte: BigInt
  invariant_in: [BigInt!]
  invariant_not_in: [BigInt!]
  lpTokenSupply: BigInt
  lpTokenSupply_not: BigInt
  lpTokenSupply_gt: BigInt
  lpTokenSupply_lt: BigInt
  lpTokenSupply_gte: BigInt
  lpTokenSupply_lte: BigInt
  lpTokenSupply_in: [BigInt!]
  lpTokenSupply_not_in: [BigInt!]
  lpTokenAmount: BigInt
  lpTokenAmount_not: BigInt
  lpTokenAmount_gt: BigInt
  lpTokenAmount_lt: BigInt
  lpTokenAmount_gte: BigInt
  lpTokenAmount_lte: BigInt
  lpTokenAmount_in: [BigInt!]
  lpTokenAmount_not_in: [BigInt!]
  balances: [BigInt!]
  balances_not: [BigInt!]
  balances_contains: [BigInt!]
  balances_contains_nocase: [BigInt!]
  balances_not_contains: [BigInt!]
  balances_not_contains_nocase: [BigInt!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: bnb_swap_Bytes
  transaction_not: bnb_swap_Bytes
  transaction_gt: bnb_swap_Bytes
  transaction_lt: bnb_swap_Bytes
  transaction_gte: bnb_swap_Bytes
  transaction_lte: bnb_swap_Bytes
  transaction_in: [bnb_swap_Bytes!]
  transaction_not_in: [bnb_swap_Bytes!]
  transaction_contains: bnb_swap_Bytes
  transaction_not_contains: bnb_swap_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: bnb_swap_BlockChangedFilter
  and: [bnb_swap_StableSwapAddLiquidityEvent_filter]
  or: [bnb_swap_StableSwapAddLiquidityEvent_filter]
}

enum bnb_swap_StableSwapAddLiquidityEvent_orderBy {
  id
  stableSwap
  stableSwap__id
  stableSwap__isActive
  stableSwap__key
  stableSwap__canonicalId
  stableSwap__domain
  stableSwap__swapPool
  stableSwap__lpToken
  stableSwap__initialA
  stableSwap__futureA
  stableSwap__initialATime
  stableSwap__futureATime
  stableSwap__swapFee
  stableSwap__adminFee
  stableSwap__virtualPrice
  stableSwap__invariant
  stableSwap__lpTokenSupply
  provider
  tokenAmounts
  fees
  invariant
  lpTokenSupply
  lpTokenAmount
  balances
  block
  timestamp
  transaction
  nonce
}

interface bnb_swap_StableSwapEvent {
  id: ID!
  stableSwap: bnb_swap_StableSwap!
  block: BigInt!
  timestamp: BigInt!
  transaction: bnb_swap_Bytes!
  nonce: BigInt!
}

input bnb_swap_StableSwapEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: bnb_swap_StableSwap_filter
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: bnb_swap_Bytes
  transaction_not: bnb_swap_Bytes
  transaction_gt: bnb_swap_Bytes
  transaction_lt: bnb_swap_Bytes
  transaction_gte: bnb_swap_Bytes
  transaction_lte: bnb_swap_Bytes
  transaction_in: [bnb_swap_Bytes!]
  transaction_not_in: [bnb_swap_Bytes!]
  transaction_contains: bnb_swap_Bytes
  transaction_not_contains: bnb_swap_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: bnb_swap_BlockChangedFilter
  and: [bnb_swap_StableSwapEvent_filter]
  or: [bnb_swap_StableSwapEvent_filter]
}

enum bnb_swap_StableSwapEvent_orderBy {
  id
  stableSwap
  stableSwap__id
  stableSwap__isActive
  stableSwap__key
  stableSwap__canonicalId
  stableSwap__domain
  stableSwap__swapPool
  stableSwap__lpToken
  stableSwap__initialA
  stableSwap__futureA
  stableSwap__initialATime
  stableSwap__futureATime
  stableSwap__swapFee
  stableSwap__adminFee
  stableSwap__virtualPrice
  stableSwap__invariant
  stableSwap__lpTokenSupply
  block
  timestamp
  transaction
  nonce
}

type bnb_swap_StableSwapExchange {
  id: ID!
  stableSwap: bnb_swap_StableSwap!
  buyer: bnb_swap_Bytes!
  boughtId: BigInt!
  tokensBought: BigInt!
  soldId: BigInt!
  tokensSold: BigInt!
  balances: [BigInt!]!
  fee: BigInt!
  block: BigInt!
  timestamp: BigInt!
  transaction: bnb_swap_Bytes!
  nonce: BigInt!
}

input bnb_swap_StableSwapExchange_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: bnb_swap_StableSwap_filter
  buyer: bnb_swap_Bytes
  buyer_not: bnb_swap_Bytes
  buyer_gt: bnb_swap_Bytes
  buyer_lt: bnb_swap_Bytes
  buyer_gte: bnb_swap_Bytes
  buyer_lte: bnb_swap_Bytes
  buyer_in: [bnb_swap_Bytes!]
  buyer_not_in: [bnb_swap_Bytes!]
  buyer_contains: bnb_swap_Bytes
  buyer_not_contains: bnb_swap_Bytes
  boughtId: BigInt
  boughtId_not: BigInt
  boughtId_gt: BigInt
  boughtId_lt: BigInt
  boughtId_gte: BigInt
  boughtId_lte: BigInt
  boughtId_in: [BigInt!]
  boughtId_not_in: [BigInt!]
  tokensBought: BigInt
  tokensBought_not: BigInt
  tokensBought_gt: BigInt
  tokensBought_lt: BigInt
  tokensBought_gte: BigInt
  tokensBought_lte: BigInt
  tokensBought_in: [BigInt!]
  tokensBought_not_in: [BigInt!]
  soldId: BigInt
  soldId_not: BigInt
  soldId_gt: BigInt
  soldId_lt: BigInt
  soldId_gte: BigInt
  soldId_lte: BigInt
  soldId_in: [BigInt!]
  soldId_not_in: [BigInt!]
  tokensSold: BigInt
  tokensSold_not: BigInt
  tokensSold_gt: BigInt
  tokensSold_lt: BigInt
  tokensSold_gte: BigInt
  tokensSold_lte: BigInt
  tokensSold_in: [BigInt!]
  tokensSold_not_in: [BigInt!]
  balances: [BigInt!]
  balances_not: [BigInt!]
  balances_contains: [BigInt!]
  balances_contains_nocase: [BigInt!]
  balances_not_contains: [BigInt!]
  balances_not_contains_nocase: [BigInt!]
  fee: BigInt
  fee_not: BigInt
  fee_gt: BigInt
  fee_lt: BigInt
  fee_gte: BigInt
  fee_lte: BigInt
  fee_in: [BigInt!]
  fee_not_in: [BigInt!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: bnb_swap_Bytes
  transaction_not: bnb_swap_Bytes
  transaction_gt: bnb_swap_Bytes
  transaction_lt: bnb_swap_Bytes
  transaction_gte: bnb_swap_Bytes
  transaction_lte: bnb_swap_Bytes
  transaction_in: [bnb_swap_Bytes!]
  transaction_not_in: [bnb_swap_Bytes!]
  transaction_contains: bnb_swap_Bytes
  transaction_not_contains: bnb_swap_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: bnb_swap_BlockChangedFilter
  and: [bnb_swap_StableSwapExchange_filter]
  or: [bnb_swap_StableSwapExchange_filter]
}

enum bnb_swap_StableSwapExchange_orderBy {
  id
  stableSwap
  stableSwap__id
  stableSwap__isActive
  stableSwap__key
  stableSwap__canonicalId
  stableSwap__domain
  stableSwap__swapPool
  stableSwap__lpToken
  stableSwap__initialA
  stableSwap__futureA
  stableSwap__initialATime
  stableSwap__futureATime
  stableSwap__swapFee
  stableSwap__adminFee
  stableSwap__virtualPrice
  stableSwap__invariant
  stableSwap__lpTokenSupply
  buyer
  boughtId
  tokensBought
  soldId
  tokensSold
  balances
  fee
  block
  timestamp
  transaction
  nonce
}

type bnb_swap_StableSwapRemoveLiquidityEvent implements bnb_swap_StableSwapEvent {
  id: ID!
  stableSwap: bnb_swap_StableSwap!
  provider: bnb_swap_Bytes!
  tokenAmounts: [BigInt!]!
  fees: [BigInt!]
  invariant: BigInt
  lpTokenSupply: BigInt!
  lpTokenAmount: BigInt!
  balances: [BigInt!]!
  block: BigInt!
  timestamp: BigInt!
  transaction: bnb_swap_Bytes!
  nonce: BigInt!
}

input bnb_swap_StableSwapRemoveLiquidityEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: bnb_swap_StableSwap_filter
  provider: bnb_swap_Bytes
  provider_not: bnb_swap_Bytes
  provider_gt: bnb_swap_Bytes
  provider_lt: bnb_swap_Bytes
  provider_gte: bnb_swap_Bytes
  provider_lte: bnb_swap_Bytes
  provider_in: [bnb_swap_Bytes!]
  provider_not_in: [bnb_swap_Bytes!]
  provider_contains: bnb_swap_Bytes
  provider_not_contains: bnb_swap_Bytes
  tokenAmounts: [BigInt!]
  tokenAmounts_not: [BigInt!]
  tokenAmounts_contains: [BigInt!]
  tokenAmounts_contains_nocase: [BigInt!]
  tokenAmounts_not_contains: [BigInt!]
  tokenAmounts_not_contains_nocase: [BigInt!]
  fees: [BigInt!]
  fees_not: [BigInt!]
  fees_contains: [BigInt!]
  fees_contains_nocase: [BigInt!]
  fees_not_contains: [BigInt!]
  fees_not_contains_nocase: [BigInt!]
  invariant: BigInt
  invariant_not: BigInt
  invariant_gt: BigInt
  invariant_lt: BigInt
  invariant_gte: BigInt
  invariant_lte: BigInt
  invariant_in: [BigInt!]
  invariant_not_in: [BigInt!]
  lpTokenSupply: BigInt
  lpTokenSupply_not: BigInt
  lpTokenSupply_gt: BigInt
  lpTokenSupply_lt: BigInt
  lpTokenSupply_gte: BigInt
  lpTokenSupply_lte: BigInt
  lpTokenSupply_in: [BigInt!]
  lpTokenSupply_not_in: [BigInt!]
  lpTokenAmount: BigInt
  lpTokenAmount_not: BigInt
  lpTokenAmount_gt: BigInt
  lpTokenAmount_lt: BigInt
  lpTokenAmount_gte: BigInt
  lpTokenAmount_lte: BigInt
  lpTokenAmount_in: [BigInt!]
  lpTokenAmount_not_in: [BigInt!]
  balances: [BigInt!]
  balances_not: [BigInt!]
  balances_contains: [BigInt!]
  balances_contains_nocase: [BigInt!]
  balances_not_contains: [BigInt!]
  balances_not_contains_nocase: [BigInt!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: bnb_swap_Bytes
  transaction_not: bnb_swap_Bytes
  transaction_gt: bnb_swap_Bytes
  transaction_lt: bnb_swap_Bytes
  transaction_gte: bnb_swap_Bytes
  transaction_lte: bnb_swap_Bytes
  transaction_in: [bnb_swap_Bytes!]
  transaction_not_in: [bnb_swap_Bytes!]
  transaction_contains: bnb_swap_Bytes
  transaction_not_contains: bnb_swap_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: bnb_swap_BlockChangedFilter
  and: [bnb_swap_StableSwapRemoveLiquidityEvent_filter]
  or: [bnb_swap_StableSwapRemoveLiquidityEvent_filter]
}

enum bnb_swap_StableSwapRemoveLiquidityEvent_orderBy {
  id
  stableSwap
  stableSwap__id
  stableSwap__isActive
  stableSwap__key
  stableSwap__canonicalId
  stableSwap__domain
  stableSwap__swapPool
  stableSwap__lpToken
  stableSwap__initialA
  stableSwap__futureA
  stableSwap__initialATime
  stableSwap__futureATime
  stableSwap__swapFee
  stableSwap__adminFee
  stableSwap__virtualPrice
  stableSwap__invariant
  stableSwap__lpTokenSupply
  provider
  tokenAmounts
  fees
  invariant
  lpTokenSupply
  lpTokenAmount
  balances
  block
  timestamp
  transaction
  nonce
}

input bnb_swap_StableSwap_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  isActive: Boolean
  isActive_not: Boolean
  isActive_in: [Boolean!]
  isActive_not_in: [Boolean!]
  key: bnb_swap_Bytes
  key_not: bnb_swap_Bytes
  key_gt: bnb_swap_Bytes
  key_lt: bnb_swap_Bytes
  key_gte: bnb_swap_Bytes
  key_lte: bnb_swap_Bytes
  key_in: [bnb_swap_Bytes!]
  key_not_in: [bnb_swap_Bytes!]
  key_contains: bnb_swap_Bytes
  key_not_contains: bnb_swap_Bytes
  canonicalId: bnb_swap_Bytes
  canonicalId_not: bnb_swap_Bytes
  canonicalId_gt: bnb_swap_Bytes
  canonicalId_lt: bnb_swap_Bytes
  canonicalId_gte: bnb_swap_Bytes
  canonicalId_lte: bnb_swap_Bytes
  canonicalId_in: [bnb_swap_Bytes!]
  canonicalId_not_in: [bnb_swap_Bytes!]
  canonicalId_contains: bnb_swap_Bytes
  canonicalId_not_contains: bnb_swap_Bytes
  domain: BigInt
  domain_not: BigInt
  domain_gt: BigInt
  domain_lt: BigInt
  domain_gte: BigInt
  domain_lte: BigInt
  domain_in: [BigInt!]
  domain_not_in: [BigInt!]
  swapPool: bnb_swap_Bytes
  swapPool_not: bnb_swap_Bytes
  swapPool_gt: bnb_swap_Bytes
  swapPool_lt: bnb_swap_Bytes
  swapPool_gte: bnb_swap_Bytes
  swapPool_lte: bnb_swap_Bytes
  swapPool_in: [bnb_swap_Bytes!]
  swapPool_not_in: [bnb_swap_Bytes!]
  swapPool_contains: bnb_swap_Bytes
  swapPool_not_contains: bnb_swap_Bytes
  lpToken: bnb_swap_Bytes
  lpToken_not: bnb_swap_Bytes
  lpToken_gt: bnb_swap_Bytes
  lpToken_lt: bnb_swap_Bytes
  lpToken_gte: bnb_swap_Bytes
  lpToken_lte: bnb_swap_Bytes
  lpToken_in: [bnb_swap_Bytes!]
  lpToken_not_in: [bnb_swap_Bytes!]
  lpToken_contains: bnb_swap_Bytes
  lpToken_not_contains: bnb_swap_Bytes
  initialA: BigInt
  initialA_not: BigInt
  initialA_gt: BigInt
  initialA_lt: BigInt
  initialA_gte: BigInt
  initialA_lte: BigInt
  initialA_in: [BigInt!]
  initialA_not_in: [BigInt!]
  futureA: BigInt
  futureA_not: BigInt
  futureA_gt: BigInt
  futureA_lt: BigInt
  futureA_gte: BigInt
  futureA_lte: BigInt
  futureA_in: [BigInt!]
  futureA_not_in: [BigInt!]
  initialATime: BigInt
  initialATime_not: BigInt
  initialATime_gt: BigInt
  initialATime_lt: BigInt
  initialATime_gte: BigInt
  initialATime_lte: BigInt
  initialATime_in: [BigInt!]
  initialATime_not_in: [BigInt!]
  futureATime: BigInt
  futureATime_not: BigInt
  futureATime_gt: BigInt
  futureATime_lt: BigInt
  futureATime_gte: BigInt
  futureATime_lte: BigInt
  futureATime_in: [BigInt!]
  futureATime_not_in: [BigInt!]
  swapFee: BigInt
  swapFee_not: BigInt
  swapFee_gt: BigInt
  swapFee_lt: BigInt
  swapFee_gte: BigInt
  swapFee_lte: BigInt
  swapFee_in: [BigInt!]
  swapFee_not_in: [BigInt!]
  adminFee: BigInt
  adminFee_not: BigInt
  adminFee_gt: BigInt
  adminFee_lt: BigInt
  adminFee_gte: BigInt
  adminFee_lte: BigInt
  adminFee_in: [BigInt!]
  adminFee_not_in: [BigInt!]
  pooledTokens: [bnb_swap_Bytes!]
  pooledTokens_not: [bnb_swap_Bytes!]
  pooledTokens_contains: [bnb_swap_Bytes!]
  pooledTokens_contains_nocase: [bnb_swap_Bytes!]
  pooledTokens_not_contains: [bnb_swap_Bytes!]
  pooledTokens_not_contains_nocase: [bnb_swap_Bytes!]
  tokenPrecisionMultipliers: [BigInt!]
  tokenPrecisionMultipliers_not: [BigInt!]
  tokenPrecisionMultipliers_contains: [BigInt!]
  tokenPrecisionMultipliers_contains_nocase: [BigInt!]
  tokenPrecisionMultipliers_not_contains: [BigInt!]
  tokenPrecisionMultipliers_not_contains_nocase: [BigInt!]
  balances: [BigInt!]
  balances_not: [BigInt!]
  balances_contains: [BigInt!]
  balances_contains_nocase: [BigInt!]
  balances_not_contains: [BigInt!]
  balances_not_contains_nocase: [BigInt!]
  adminFees: [BigInt!]
  adminFees_not: [BigInt!]
  adminFees_contains: [BigInt!]
  adminFees_contains_nocase: [BigInt!]
  adminFees_not_contains: [BigInt!]
  adminFees_not_contains_nocase: [BigInt!]
  virtualPrice: BigInt
  virtualPrice_not: BigInt
  virtualPrice_gt: BigInt
  virtualPrice_lt: BigInt
  virtualPrice_gte: BigInt
  virtualPrice_lte: BigInt
  virtualPrice_in: [BigInt!]
  virtualPrice_not_in: [BigInt!]
  invariant: BigInt
  invariant_not: BigInt
  invariant_gt: BigInt
  invariant_lt: BigInt
  invariant_gte: BigInt
  invariant_lte: BigInt
  invariant_in: [BigInt!]
  invariant_not_in: [BigInt!]
  lpTokenSupply: BigInt
  lpTokenSupply_not: BigInt
  lpTokenSupply_gt: BigInt
  lpTokenSupply_lt: BigInt
  lpTokenSupply_gte: BigInt
  lpTokenSupply_lte: BigInt
  lpTokenSupply_in: [BigInt!]
  lpTokenSupply_not_in: [BigInt!]
  events_: bnb_swap_StableSwapEvent_filter
  exchanges_: bnb_swap_StableSwapExchange_filter
  hourlyVolumes_: bnb_swap_SwapHourlyVolume_filter
  dailyVolumes_: bnb_swap_SwapDailyVolume_filter
  weeklyVolumes_: bnb_swap_SwapWeeklyVolume_filter
  """Filter for the block changed event."""
  _change_block: bnb_swap_BlockChangedFilter
  and: [bnb_swap_StableSwap_filter]
  or: [bnb_swap_StableSwap_filter]
}

enum bnb_swap_StableSwap_orderBy {
  id
  isActive
  key
  canonicalId
  domain
  swapPool
  lpToken
  initialA
  futureA
  initialATime
  futureATime
  swapFee
  adminFee
  pooledTokens
  tokenPrecisionMultipliers
  balances
  adminFees
  virtualPrice
  invariant
  lpTokenSupply
  events
  exchanges
  hourlyVolumes
  dailyVolumes
  weeklyVolumes
}

type bnb_swap_SwapDailyVolume implements bnb_swap_SwapTradeVolume {
  id: ID!
  stableSwap: bnb_swap_StableSwap!
  timestamp: BigInt!
  volume: bnb_swap_BigDecimal!
}

input bnb_swap_SwapDailyVolume_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: bnb_swap_StableSwap_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  volume: bnb_swap_BigDecimal
  volume_not: bnb_swap_BigDecimal
  volume_gt: bnb_swap_BigDecimal
  volume_lt: bnb_swap_BigDecimal
  volume_gte: bnb_swap_BigDecimal
  volume_lte: bnb_swap_BigDecimal
  volume_in: [bnb_swap_BigDecimal!]
  volume_not_in: [bnb_swap_BigDecimal!]
  """Filter for the block changed event."""
  _change_block: bnb_swap_BlockChangedFilter
  and: [bnb_swap_SwapDailyVolume_filter]
  or: [bnb_swap_SwapDailyVolume_filter]
}

enum bnb_swap_SwapDailyVolume_orderBy {
  id
  stableSwap
  stableSwap__id
  stableSwap__isActive
  stableSwap__key
  stableSwap__canonicalId
  stableSwap__domain
  stableSwap__swapPool
  stableSwap__lpToken
  stableSwap__initialA
  stableSwap__futureA
  stableSwap__initialATime
  stableSwap__futureATime
  stableSwap__swapFee
  stableSwap__adminFee
  stableSwap__virtualPrice
  stableSwap__invariant
  stableSwap__lpTokenSupply
  timestamp
  volume
}

type bnb_swap_SwapHourlyVolume implements bnb_swap_SwapTradeVolume {
  id: ID!
  stableSwap: bnb_swap_StableSwap!
  timestamp: BigInt!
  volume: bnb_swap_BigDecimal!
}

input bnb_swap_SwapHourlyVolume_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: bnb_swap_StableSwap_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  volume: bnb_swap_BigDecimal
  volume_not: bnb_swap_BigDecimal
  volume_gt: bnb_swap_BigDecimal
  volume_lt: bnb_swap_BigDecimal
  volume_gte: bnb_swap_BigDecimal
  volume_lte: bnb_swap_BigDecimal
  volume_in: [bnb_swap_BigDecimal!]
  volume_not_in: [bnb_swap_BigDecimal!]
  """Filter for the block changed event."""
  _change_block: bnb_swap_BlockChangedFilter
  and: [bnb_swap_SwapHourlyVolume_filter]
  or: [bnb_swap_SwapHourlyVolume_filter]
}

enum bnb_swap_SwapHourlyVolume_orderBy {
  id
  stableSwap
  stableSwap__id
  stableSwap__isActive
  stableSwap__key
  stableSwap__canonicalId
  stableSwap__domain
  stableSwap__swapPool
  stableSwap__lpToken
  stableSwap__initialA
  stableSwap__futureA
  stableSwap__initialATime
  stableSwap__futureATime
  stableSwap__swapFee
  stableSwap__adminFee
  stableSwap__virtualPrice
  stableSwap__invariant
  stableSwap__lpTokenSupply
  timestamp
  volume
}

interface bnb_swap_SwapTradeVolume {
  stableSwap: bnb_swap_StableSwap!
  timestamp: BigInt!
  volume: bnb_swap_BigDecimal!
}

input bnb_swap_SwapTradeVolume_filter {
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: bnb_swap_StableSwap_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  volume: bnb_swap_BigDecimal
  volume_not: bnb_swap_BigDecimal
  volume_gt: bnb_swap_BigDecimal
  volume_lt: bnb_swap_BigDecimal
  volume_gte: bnb_swap_BigDecimal
  volume_lte: bnb_swap_BigDecimal
  volume_in: [bnb_swap_BigDecimal!]
  volume_not_in: [bnb_swap_BigDecimal!]
  """Filter for the block changed event."""
  _change_block: bnb_swap_BlockChangedFilter
  and: [bnb_swap_SwapTradeVolume_filter]
  or: [bnb_swap_SwapTradeVolume_filter]
}

enum bnb_swap_SwapTradeVolume_orderBy {
  stableSwap
  stableSwap__id
  stableSwap__isActive
  stableSwap__key
  stableSwap__canonicalId
  stableSwap__domain
  stableSwap__swapPool
  stableSwap__lpToken
  stableSwap__initialA
  stableSwap__futureA
  stableSwap__initialATime
  stableSwap__futureATime
  stableSwap__swapFee
  stableSwap__adminFee
  stableSwap__virtualPrice
  stableSwap__invariant
  stableSwap__lpTokenSupply
  timestamp
  volume
}

type bnb_swap_SwapWeeklyVolume implements bnb_swap_SwapTradeVolume {
  id: ID!
  stableSwap: bnb_swap_StableSwap!
  timestamp: BigInt!
  volume: bnb_swap_BigDecimal!
}

input bnb_swap_SwapWeeklyVolume_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: bnb_swap_StableSwap_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  volume: bnb_swap_BigDecimal
  volume_not: bnb_swap_BigDecimal
  volume_gt: bnb_swap_BigDecimal
  volume_lt: bnb_swap_BigDecimal
  volume_gte: bnb_swap_BigDecimal
  volume_lte: bnb_swap_BigDecimal
  volume_in: [bnb_swap_BigDecimal!]
  volume_not_in: [bnb_swap_BigDecimal!]
  """Filter for the block changed event."""
  _change_block: bnb_swap_BlockChangedFilter
  and: [bnb_swap_SwapWeeklyVolume_filter]
  or: [bnb_swap_SwapWeeklyVolume_filter]
}

enum bnb_swap_SwapWeeklyVolume_orderBy {
  id
  stableSwap
  stableSwap__id
  stableSwap__isActive
  stableSwap__key
  stableSwap__canonicalId
  stableSwap__domain
  stableSwap__swapPool
  stableSwap__lpToken
  stableSwap__initialA
  stableSwap__futureA
  stableSwap__initialATime
  stableSwap__futureATime
  stableSwap__swapFee
  stableSwap__adminFee
  stableSwap__virtualPrice
  stableSwap__invariant
  stableSwap__lpTokenSupply
  timestamp
  volume
}

type bnb_swap_SystemInfo {
  id: ID!
  exchangeCount: BigInt!
  swapCount: BigInt!
}

input bnb_swap_SystemInfo_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  exchangeCount: BigInt
  exchangeCount_not: BigInt
  exchangeCount_gt: BigInt
  exchangeCount_lt: BigInt
  exchangeCount_gte: BigInt
  exchangeCount_lte: BigInt
  exchangeCount_in: [BigInt!]
  exchangeCount_not_in: [BigInt!]
  swapCount: BigInt
  swapCount_not: BigInt
  swapCount_gt: BigInt
  swapCount_lt: BigInt
  swapCount_gte: BigInt
  swapCount_lte: BigInt
  swapCount_in: [BigInt!]
  swapCount_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: bnb_swap_BlockChangedFilter
  and: [bnb_swap_SystemInfo_filter]
  or: [bnb_swap_SystemInfo_filter]
}

enum bnb_swap_SystemInfo_orderBy {
  id
  exchangeCount
  swapCount
}

type bnb_swap__Block_ {
  """The hash of the block"""
  hash: bnb_swap_Bytes
  """The block number"""
  number: Int!
  """Integer representation of the timestamp stored in blocks for the chain"""
  timestamp: Int
  """The hash of the parent block"""
  parentHash: bnb_swap_Bytes
}

"""The type for the top-level _meta field"""
type bnb_swap__Meta_ {
  """
  Information about a specific subgraph block. The hash of the block
  will be null if the _meta field has a block constraint that asks for
  a block number. It will be filled if the _meta field has no block constraint
  and therefore asks for the latest  block
  
  """
  block: bnb_swap__Block_!
  """The deployment ID"""
  deployment: String!
  """If `true`, the subgraph encountered indexing errors at some past block"""
  hasIndexingErrors: Boolean!
}

enum xlayer_swap_Aggregation_interval {
  hour
  day
}

scalar xlayer_swap_BigDecimal

input xlayer_swap_BlockChangedFilter {
  number_gte: Int!
}

input xlayer_swap_Block_height {
  hash: xlayer_swap_Bytes
  number: Int
  number_gte: Int
}

scalar xlayer_swap_Bytes

"""
8 bytes signed integer

"""
scalar xlayer_swap_Int8

type xlayer_swap_LpAccount {
  id: ID!
  address: xlayer_swap_Bytes!
  balances(skip: Int = 0, first: Int = 100, orderBy: xlayer_swap_LpAccountBalance_orderBy, orderDirection: xlayer_swap_OrderDirection, where: xlayer_swap_LpAccountBalance_filter): [xlayer_swap_LpAccountBalance!]!
}

type xlayer_swap_LpAccountBalance {
  id: ID!
  account: xlayer_swap_LpAccount!
  token: xlayer_swap_LpToken!
  amount: xlayer_swap_BigDecimal!
  block: BigInt
  modified: BigInt
  transaction: xlayer_swap_Bytes
}

input xlayer_swap_LpAccountBalance_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  account: String
  account_not: String
  account_gt: String
  account_lt: String
  account_gte: String
  account_lte: String
  account_in: [String!]
  account_not_in: [String!]
  account_contains: String
  account_contains_nocase: String
  account_not_contains: String
  account_not_contains_nocase: String
  account_starts_with: String
  account_starts_with_nocase: String
  account_not_starts_with: String
  account_not_starts_with_nocase: String
  account_ends_with: String
  account_ends_with_nocase: String
  account_not_ends_with: String
  account_not_ends_with_nocase: String
  account_: xlayer_swap_LpAccount_filter
  token: String
  token_not: String
  token_gt: String
  token_lt: String
  token_gte: String
  token_lte: String
  token_in: [String!]
  token_not_in: [String!]
  token_contains: String
  token_contains_nocase: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_: xlayer_swap_LpToken_filter
  amount: xlayer_swap_BigDecimal
  amount_not: xlayer_swap_BigDecimal
  amount_gt: xlayer_swap_BigDecimal
  amount_lt: xlayer_swap_BigDecimal
  amount_gte: xlayer_swap_BigDecimal
  amount_lte: xlayer_swap_BigDecimal
  amount_in: [xlayer_swap_BigDecimal!]
  amount_not_in: [xlayer_swap_BigDecimal!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  modified: BigInt
  modified_not: BigInt
  modified_gt: BigInt
  modified_lt: BigInt
  modified_gte: BigInt
  modified_lte: BigInt
  modified_in: [BigInt!]
  modified_not_in: [BigInt!]
  transaction: xlayer_swap_Bytes
  transaction_not: xlayer_swap_Bytes
  transaction_gt: xlayer_swap_Bytes
  transaction_lt: xlayer_swap_Bytes
  transaction_gte: xlayer_swap_Bytes
  transaction_lte: xlayer_swap_Bytes
  transaction_in: [xlayer_swap_Bytes!]
  transaction_not_in: [xlayer_swap_Bytes!]
  transaction_contains: xlayer_swap_Bytes
  transaction_not_contains: xlayer_swap_Bytes
  """Filter for the block changed event."""
  _change_block: xlayer_swap_BlockChangedFilter
  and: [xlayer_swap_LpAccountBalance_filter]
  or: [xlayer_swap_LpAccountBalance_filter]
}

enum xlayer_swap_LpAccountBalance_orderBy {
  id
  account
  account__id
  account__address
  token
  token__id
  token__address
  token__decimals
  token__name
  token__symbol
  token__totalSupply
  amount
  block
  modified
  transaction
}

input xlayer_swap_LpAccount_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  address: xlayer_swap_Bytes
  address_not: xlayer_swap_Bytes
  address_gt: xlayer_swap_Bytes
  address_lt: xlayer_swap_Bytes
  address_gte: xlayer_swap_Bytes
  address_lte: xlayer_swap_Bytes
  address_in: [xlayer_swap_Bytes!]
  address_not_in: [xlayer_swap_Bytes!]
  address_contains: xlayer_swap_Bytes
  address_not_contains: xlayer_swap_Bytes
  balances_: xlayer_swap_LpAccountBalance_filter
  """Filter for the block changed event."""
  _change_block: xlayer_swap_BlockChangedFilter
  and: [xlayer_swap_LpAccount_filter]
  or: [xlayer_swap_LpAccount_filter]
}

enum xlayer_swap_LpAccount_orderBy {
  id
  address
  balances
}

type xlayer_swap_LpToken {
  id: ID!
  address: xlayer_swap_Bytes!
  stableSwap: xlayer_swap_StableSwap!
  decimals: Int!
  name: String!
  symbol: String!
  totalSupply: xlayer_swap_BigDecimal!
  events(skip: Int = 0, first: Int = 100, orderBy: xlayer_swap_LpTokenEvent_orderBy, orderDirection: xlayer_swap_OrderDirection, where: xlayer_swap_LpTokenEvent_filter): [xlayer_swap_LpTokenEvent!]!
}

interface xlayer_swap_LpTokenEvent {
  id: ID!
  token: xlayer_swap_LpToken!
  amount: xlayer_swap_BigDecimal!
  block: BigInt!
  timestamp: BigInt!
  transaction: xlayer_swap_Bytes!
  nonce: BigInt!
}

input xlayer_swap_LpTokenEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  token: String
  token_not: String
  token_gt: String
  token_lt: String
  token_gte: String
  token_lte: String
  token_in: [String!]
  token_not_in: [String!]
  token_contains: String
  token_contains_nocase: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_: xlayer_swap_LpToken_filter
  amount: xlayer_swap_BigDecimal
  amount_not: xlayer_swap_BigDecimal
  amount_gt: xlayer_swap_BigDecimal
  amount_lt: xlayer_swap_BigDecimal
  amount_gte: xlayer_swap_BigDecimal
  amount_lte: xlayer_swap_BigDecimal
  amount_in: [xlayer_swap_BigDecimal!]
  amount_not_in: [xlayer_swap_BigDecimal!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: xlayer_swap_Bytes
  transaction_not: xlayer_swap_Bytes
  transaction_gt: xlayer_swap_Bytes
  transaction_lt: xlayer_swap_Bytes
  transaction_gte: xlayer_swap_Bytes
  transaction_lte: xlayer_swap_Bytes
  transaction_in: [xlayer_swap_Bytes!]
  transaction_not_in: [xlayer_swap_Bytes!]
  transaction_contains: xlayer_swap_Bytes
  transaction_not_contains: xlayer_swap_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: xlayer_swap_BlockChangedFilter
  and: [xlayer_swap_LpTokenEvent_filter]
  or: [xlayer_swap_LpTokenEvent_filter]
}

enum xlayer_swap_LpTokenEvent_orderBy {
  id
  token
  token__id
  token__address
  token__decimals
  token__name
  token__symbol
  token__totalSupply
  amount
  block
  timestamp
  transaction
  nonce
}

input xlayer_swap_LpToken_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  address: xlayer_swap_Bytes
  address_not: xlayer_swap_Bytes
  address_gt: xlayer_swap_Bytes
  address_lt: xlayer_swap_Bytes
  address_gte: xlayer_swap_Bytes
  address_lte: xlayer_swap_Bytes
  address_in: [xlayer_swap_Bytes!]
  address_not_in: [xlayer_swap_Bytes!]
  address_contains: xlayer_swap_Bytes
  address_not_contains: xlayer_swap_Bytes
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: xlayer_swap_StableSwap_filter
  decimals: Int
  decimals_not: Int
  decimals_gt: Int
  decimals_lt: Int
  decimals_gte: Int
  decimals_lte: Int
  decimals_in: [Int!]
  decimals_not_in: [Int!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  symbol: String
  symbol_not: String
  symbol_gt: String
  symbol_lt: String
  symbol_gte: String
  symbol_lte: String
  symbol_in: [String!]
  symbol_not_in: [String!]
  symbol_contains: String
  symbol_contains_nocase: String
  symbol_not_contains: String
  symbol_not_contains_nocase: String
  symbol_starts_with: String
  symbol_starts_with_nocase: String
  symbol_not_starts_with: String
  symbol_not_starts_with_nocase: String
  symbol_ends_with: String
  symbol_ends_with_nocase: String
  symbol_not_ends_with: String
  symbol_not_ends_with_nocase: String
  totalSupply: xlayer_swap_BigDecimal
  totalSupply_not: xlayer_swap_BigDecimal
  totalSupply_gt: xlayer_swap_BigDecimal
  totalSupply_lt: xlayer_swap_BigDecimal
  totalSupply_gte: xlayer_swap_BigDecimal
  totalSupply_lte: xlayer_swap_BigDecimal
  totalSupply_in: [xlayer_swap_BigDecimal!]
  totalSupply_not_in: [xlayer_swap_BigDecimal!]
  events_: xlayer_swap_LpTokenEvent_filter
  """Filter for the block changed event."""
  _change_block: xlayer_swap_BlockChangedFilter
  and: [xlayer_swap_LpToken_filter]
  or: [xlayer_swap_LpToken_filter]
}

enum xlayer_swap_LpToken_orderBy {
  id
  address
  stableSwap
  stableSwap__id
  stableSwap__isActive
  stableSwap__key
  stableSwap__canonicalId
  stableSwap__domain
  stableSwap__swapPool
  stableSwap__lpToken
  stableSwap__initialA
  stableSwap__futureA
  stableSwap__initialATime
  stableSwap__futureATime
  stableSwap__swapFee
  stableSwap__adminFee
  stableSwap__virtualPrice
  stableSwap__invariant
  stableSwap__lpTokenSupply
  decimals
  name
  symbol
  totalSupply
  events
}

type xlayer_swap_LpTransferEvent implements xlayer_swap_LpTokenEvent {
  id: ID!
  token: xlayer_swap_LpToken!
  amount: xlayer_swap_BigDecimal!
  from: xlayer_swap_Bytes!
  to: xlayer_swap_Bytes!
  fromBalance: xlayer_swap_BigDecimal!
  toBalance: xlayer_swap_BigDecimal!
  block: BigInt!
  timestamp: BigInt!
  transaction: xlayer_swap_Bytes!
  nonce: BigInt!
}

input xlayer_swap_LpTransferEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  token: String
  token_not: String
  token_gt: String
  token_lt: String
  token_gte: String
  token_lte: String
  token_in: [String!]
  token_not_in: [String!]
  token_contains: String
  token_contains_nocase: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_: xlayer_swap_LpToken_filter
  amount: xlayer_swap_BigDecimal
  amount_not: xlayer_swap_BigDecimal
  amount_gt: xlayer_swap_BigDecimal
  amount_lt: xlayer_swap_BigDecimal
  amount_gte: xlayer_swap_BigDecimal
  amount_lte: xlayer_swap_BigDecimal
  amount_in: [xlayer_swap_BigDecimal!]
  amount_not_in: [xlayer_swap_BigDecimal!]
  from: xlayer_swap_Bytes
  from_not: xlayer_swap_Bytes
  from_gt: xlayer_swap_Bytes
  from_lt: xlayer_swap_Bytes
  from_gte: xlayer_swap_Bytes
  from_lte: xlayer_swap_Bytes
  from_in: [xlayer_swap_Bytes!]
  from_not_in: [xlayer_swap_Bytes!]
  from_contains: xlayer_swap_Bytes
  from_not_contains: xlayer_swap_Bytes
  to: xlayer_swap_Bytes
  to_not: xlayer_swap_Bytes
  to_gt: xlayer_swap_Bytes
  to_lt: xlayer_swap_Bytes
  to_gte: xlayer_swap_Bytes
  to_lte: xlayer_swap_Bytes
  to_in: [xlayer_swap_Bytes!]
  to_not_in: [xlayer_swap_Bytes!]
  to_contains: xlayer_swap_Bytes
  to_not_contains: xlayer_swap_Bytes
  fromBalance: xlayer_swap_BigDecimal
  fromBalance_not: xlayer_swap_BigDecimal
  fromBalance_gt: xlayer_swap_BigDecimal
  fromBalance_lt: xlayer_swap_BigDecimal
  fromBalance_gte: xlayer_swap_BigDecimal
  fromBalance_lte: xlayer_swap_BigDecimal
  fromBalance_in: [xlayer_swap_BigDecimal!]
  fromBalance_not_in: [xlayer_swap_BigDecimal!]
  toBalance: xlayer_swap_BigDecimal
  toBalance_not: xlayer_swap_BigDecimal
  toBalance_gt: xlayer_swap_BigDecimal
  toBalance_lt: xlayer_swap_BigDecimal
  toBalance_gte: xlayer_swap_BigDecimal
  toBalance_lte: xlayer_swap_BigDecimal
  toBalance_in: [xlayer_swap_BigDecimal!]
  toBalance_not_in: [xlayer_swap_BigDecimal!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: xlayer_swap_Bytes
  transaction_not: xlayer_swap_Bytes
  transaction_gt: xlayer_swap_Bytes
  transaction_lt: xlayer_swap_Bytes
  transaction_gte: xlayer_swap_Bytes
  transaction_lte: xlayer_swap_Bytes
  transaction_in: [xlayer_swap_Bytes!]
  transaction_not_in: [xlayer_swap_Bytes!]
  transaction_contains: xlayer_swap_Bytes
  transaction_not_contains: xlayer_swap_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: xlayer_swap_BlockChangedFilter
  and: [xlayer_swap_LpTransferEvent_filter]
  or: [xlayer_swap_LpTransferEvent_filter]
}

enum xlayer_swap_LpTransferEvent_orderBy {
  id
  token
  token__id
  token__address
  token__decimals
  token__name
  token__symbol
  token__totalSupply
  amount
  from
  to
  fromBalance
  toBalance
  block
  timestamp
  transaction
  nonce
}

"""Defines the order direction, either ascending or descending"""
enum xlayer_swap_OrderDirection {
  asc
  desc
}

type xlayer_swap_PooledToken {
  id: ID!
  asset: xlayer_swap_Bytes!
}

input xlayer_swap_PooledToken_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  asset: xlayer_swap_Bytes
  asset_not: xlayer_swap_Bytes
  asset_gt: xlayer_swap_Bytes
  asset_lt: xlayer_swap_Bytes
  asset_gte: xlayer_swap_Bytes
  asset_lte: xlayer_swap_Bytes
  asset_in: [xlayer_swap_Bytes!]
  asset_not_in: [xlayer_swap_Bytes!]
  asset_contains: xlayer_swap_Bytes
  asset_not_contains: xlayer_swap_Bytes
  """Filter for the block changed event."""
  _change_block: xlayer_swap_BlockChangedFilter
  and: [xlayer_swap_PooledToken_filter]
  or: [xlayer_swap_PooledToken_filter]
}

enum xlayer_swap_PooledToken_orderBy {
  id
  asset
}

type xlayer_swap_StableSwap {
  id: ID!
  isActive: Boolean
  key: xlayer_swap_Bytes!
  canonicalId: xlayer_swap_Bytes
  domain: BigInt
  swapPool: xlayer_swap_Bytes
  lpToken: xlayer_swap_Bytes
  initialA: BigInt
  futureA: BigInt
  initialATime: BigInt
  futureATime: BigInt
  swapFee: BigInt
  adminFee: BigInt
  pooledTokens: [xlayer_swap_Bytes!]!
  tokenPrecisionMultipliers: [BigInt!]!
  balances: [BigInt!]!
  adminFees: [BigInt!]!
  virtualPrice: BigInt!
  invariant: BigInt!
  lpTokenSupply: BigInt!
  events(skip: Int = 0, first: Int = 100, orderBy: xlayer_swap_StableSwapEvent_orderBy, orderDirection: xlayer_swap_OrderDirection, where: xlayer_swap_StableSwapEvent_filter): [xlayer_swap_StableSwapEvent!]
  exchanges(skip: Int = 0, first: Int = 100, orderBy: xlayer_swap_StableSwapExchange_orderBy, orderDirection: xlayer_swap_OrderDirection, where: xlayer_swap_StableSwapExchange_filter): [xlayer_swap_StableSwapExchange!]
  hourlyVolumes(skip: Int = 0, first: Int = 100, orderBy: xlayer_swap_SwapHourlyVolume_orderBy, orderDirection: xlayer_swap_OrderDirection, where: xlayer_swap_SwapHourlyVolume_filter): [xlayer_swap_SwapHourlyVolume!]
  dailyVolumes(skip: Int = 0, first: Int = 100, orderBy: xlayer_swap_SwapDailyVolume_orderBy, orderDirection: xlayer_swap_OrderDirection, where: xlayer_swap_SwapDailyVolume_filter): [xlayer_swap_SwapDailyVolume!]
  weeklyVolumes(skip: Int = 0, first: Int = 100, orderBy: xlayer_swap_SwapWeeklyVolume_orderBy, orderDirection: xlayer_swap_OrderDirection, where: xlayer_swap_SwapWeeklyVolume_filter): [xlayer_swap_SwapWeeklyVolume!]
}

type xlayer_swap_StableSwapAddLiquidityEvent implements xlayer_swap_StableSwapEvent {
  id: ID!
  stableSwap: xlayer_swap_StableSwap!
  provider: xlayer_swap_Bytes!
  tokenAmounts: [BigInt!]!
  fees: [BigInt!]!
  invariant: BigInt
  lpTokenSupply: BigInt!
  lpTokenAmount: BigInt!
  balances: [BigInt!]!
  block: BigInt!
  timestamp: BigInt!
  transaction: xlayer_swap_Bytes!
  nonce: BigInt!
}

input xlayer_swap_StableSwapAddLiquidityEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: xlayer_swap_StableSwap_filter
  provider: xlayer_swap_Bytes
  provider_not: xlayer_swap_Bytes
  provider_gt: xlayer_swap_Bytes
  provider_lt: xlayer_swap_Bytes
  provider_gte: xlayer_swap_Bytes
  provider_lte: xlayer_swap_Bytes
  provider_in: [xlayer_swap_Bytes!]
  provider_not_in: [xlayer_swap_Bytes!]
  provider_contains: xlayer_swap_Bytes
  provider_not_contains: xlayer_swap_Bytes
  tokenAmounts: [BigInt!]
  tokenAmounts_not: [BigInt!]
  tokenAmounts_contains: [BigInt!]
  tokenAmounts_contains_nocase: [BigInt!]
  tokenAmounts_not_contains: [BigInt!]
  tokenAmounts_not_contains_nocase: [BigInt!]
  fees: [BigInt!]
  fees_not: [BigInt!]
  fees_contains: [BigInt!]
  fees_contains_nocase: [BigInt!]
  fees_not_contains: [BigInt!]
  fees_not_contains_nocase: [BigInt!]
  invariant: BigInt
  invariant_not: BigInt
  invariant_gt: BigInt
  invariant_lt: BigInt
  invariant_gte: BigInt
  invariant_lte: BigInt
  invariant_in: [BigInt!]
  invariant_not_in: [BigInt!]
  lpTokenSupply: BigInt
  lpTokenSupply_not: BigInt
  lpTokenSupply_gt: BigInt
  lpTokenSupply_lt: BigInt
  lpTokenSupply_gte: BigInt
  lpTokenSupply_lte: BigInt
  lpTokenSupply_in: [BigInt!]
  lpTokenSupply_not_in: [BigInt!]
  lpTokenAmount: BigInt
  lpTokenAmount_not: BigInt
  lpTokenAmount_gt: BigInt
  lpTokenAmount_lt: BigInt
  lpTokenAmount_gte: BigInt
  lpTokenAmount_lte: BigInt
  lpTokenAmount_in: [BigInt!]
  lpTokenAmount_not_in: [BigInt!]
  balances: [BigInt!]
  balances_not: [BigInt!]
  balances_contains: [BigInt!]
  balances_contains_nocase: [BigInt!]
  balances_not_contains: [BigInt!]
  balances_not_contains_nocase: [BigInt!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: xlayer_swap_Bytes
  transaction_not: xlayer_swap_Bytes
  transaction_gt: xlayer_swap_Bytes
  transaction_lt: xlayer_swap_Bytes
  transaction_gte: xlayer_swap_Bytes
  transaction_lte: xlayer_swap_Bytes
  transaction_in: [xlayer_swap_Bytes!]
  transaction_not_in: [xlayer_swap_Bytes!]
  transaction_contains: xlayer_swap_Bytes
  transaction_not_contains: xlayer_swap_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: xlayer_swap_BlockChangedFilter
  and: [xlayer_swap_StableSwapAddLiquidityEvent_filter]
  or: [xlayer_swap_StableSwapAddLiquidityEvent_filter]
}

enum xlayer_swap_StableSwapAddLiquidityEvent_orderBy {
  id
  stableSwap
  stableSwap__id
  stableSwap__isActive
  stableSwap__key
  stableSwap__canonicalId
  stableSwap__domain
  stableSwap__swapPool
  stableSwap__lpToken
  stableSwap__initialA
  stableSwap__futureA
  stableSwap__initialATime
  stableSwap__futureATime
  stableSwap__swapFee
  stableSwap__adminFee
  stableSwap__virtualPrice
  stableSwap__invariant
  stableSwap__lpTokenSupply
  provider
  tokenAmounts
  fees
  invariant
  lpTokenSupply
  lpTokenAmount
  balances
  block
  timestamp
  transaction
  nonce
}

interface xlayer_swap_StableSwapEvent {
  id: ID!
  stableSwap: xlayer_swap_StableSwap!
  block: BigInt!
  timestamp: BigInt!
  transaction: xlayer_swap_Bytes!
  nonce: BigInt!
}

input xlayer_swap_StableSwapEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: xlayer_swap_StableSwap_filter
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: xlayer_swap_Bytes
  transaction_not: xlayer_swap_Bytes
  transaction_gt: xlayer_swap_Bytes
  transaction_lt: xlayer_swap_Bytes
  transaction_gte: xlayer_swap_Bytes
  transaction_lte: xlayer_swap_Bytes
  transaction_in: [xlayer_swap_Bytes!]
  transaction_not_in: [xlayer_swap_Bytes!]
  transaction_contains: xlayer_swap_Bytes
  transaction_not_contains: xlayer_swap_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: xlayer_swap_BlockChangedFilter
  and: [xlayer_swap_StableSwapEvent_filter]
  or: [xlayer_swap_StableSwapEvent_filter]
}

enum xlayer_swap_StableSwapEvent_orderBy {
  id
  stableSwap
  stableSwap__id
  stableSwap__isActive
  stableSwap__key
  stableSwap__canonicalId
  stableSwap__domain
  stableSwap__swapPool
  stableSwap__lpToken
  stableSwap__initialA
  stableSwap__futureA
  stableSwap__initialATime
  stableSwap__futureATime
  stableSwap__swapFee
  stableSwap__adminFee
  stableSwap__virtualPrice
  stableSwap__invariant
  stableSwap__lpTokenSupply
  block
  timestamp
  transaction
  nonce
}

type xlayer_swap_StableSwapExchange {
  id: ID!
  stableSwap: xlayer_swap_StableSwap!
  buyer: xlayer_swap_Bytes!
  boughtId: BigInt!
  tokensBought: BigInt!
  soldId: BigInt!
  tokensSold: BigInt!
  balances: [BigInt!]!
  fee: BigInt!
  block: BigInt!
  timestamp: BigInt!
  transaction: xlayer_swap_Bytes!
  nonce: BigInt!
}

input xlayer_swap_StableSwapExchange_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: xlayer_swap_StableSwap_filter
  buyer: xlayer_swap_Bytes
  buyer_not: xlayer_swap_Bytes
  buyer_gt: xlayer_swap_Bytes
  buyer_lt: xlayer_swap_Bytes
  buyer_gte: xlayer_swap_Bytes
  buyer_lte: xlayer_swap_Bytes
  buyer_in: [xlayer_swap_Bytes!]
  buyer_not_in: [xlayer_swap_Bytes!]
  buyer_contains: xlayer_swap_Bytes
  buyer_not_contains: xlayer_swap_Bytes
  boughtId: BigInt
  boughtId_not: BigInt
  boughtId_gt: BigInt
  boughtId_lt: BigInt
  boughtId_gte: BigInt
  boughtId_lte: BigInt
  boughtId_in: [BigInt!]
  boughtId_not_in: [BigInt!]
  tokensBought: BigInt
  tokensBought_not: BigInt
  tokensBought_gt: BigInt
  tokensBought_lt: BigInt
  tokensBought_gte: BigInt
  tokensBought_lte: BigInt
  tokensBought_in: [BigInt!]
  tokensBought_not_in: [BigInt!]
  soldId: BigInt
  soldId_not: BigInt
  soldId_gt: BigInt
  soldId_lt: BigInt
  soldId_gte: BigInt
  soldId_lte: BigInt
  soldId_in: [BigInt!]
  soldId_not_in: [BigInt!]
  tokensSold: BigInt
  tokensSold_not: BigInt
  tokensSold_gt: BigInt
  tokensSold_lt: BigInt
  tokensSold_gte: BigInt
  tokensSold_lte: BigInt
  tokensSold_in: [BigInt!]
  tokensSold_not_in: [BigInt!]
  balances: [BigInt!]
  balances_not: [BigInt!]
  balances_contains: [BigInt!]
  balances_contains_nocase: [BigInt!]
  balances_not_contains: [BigInt!]
  balances_not_contains_nocase: [BigInt!]
  fee: BigInt
  fee_not: BigInt
  fee_gt: BigInt
  fee_lt: BigInt
  fee_gte: BigInt
  fee_lte: BigInt
  fee_in: [BigInt!]
  fee_not_in: [BigInt!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: xlayer_swap_Bytes
  transaction_not: xlayer_swap_Bytes
  transaction_gt: xlayer_swap_Bytes
  transaction_lt: xlayer_swap_Bytes
  transaction_gte: xlayer_swap_Bytes
  transaction_lte: xlayer_swap_Bytes
  transaction_in: [xlayer_swap_Bytes!]
  transaction_not_in: [xlayer_swap_Bytes!]
  transaction_contains: xlayer_swap_Bytes
  transaction_not_contains: xlayer_swap_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: xlayer_swap_BlockChangedFilter
  and: [xlayer_swap_StableSwapExchange_filter]
  or: [xlayer_swap_StableSwapExchange_filter]
}

enum xlayer_swap_StableSwapExchange_orderBy {
  id
  stableSwap
  stableSwap__id
  stableSwap__isActive
  stableSwap__key
  stableSwap__canonicalId
  stableSwap__domain
  stableSwap__swapPool
  stableSwap__lpToken
  stableSwap__initialA
  stableSwap__futureA
  stableSwap__initialATime
  stableSwap__futureATime
  stableSwap__swapFee
  stableSwap__adminFee
  stableSwap__virtualPrice
  stableSwap__invariant
  stableSwap__lpTokenSupply
  buyer
  boughtId
  tokensBought
  soldId
  tokensSold
  balances
  fee
  block
  timestamp
  transaction
  nonce
}

type xlayer_swap_StableSwapRemoveLiquidityEvent implements xlayer_swap_StableSwapEvent {
  id: ID!
  stableSwap: xlayer_swap_StableSwap!
  provider: xlayer_swap_Bytes!
  tokenAmounts: [BigInt!]!
  fees: [BigInt!]
  invariant: BigInt
  lpTokenSupply: BigInt!
  lpTokenAmount: BigInt!
  balances: [BigInt!]!
  block: BigInt!
  timestamp: BigInt!
  transaction: xlayer_swap_Bytes!
  nonce: BigInt!
}

input xlayer_swap_StableSwapRemoveLiquidityEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: xlayer_swap_StableSwap_filter
  provider: xlayer_swap_Bytes
  provider_not: xlayer_swap_Bytes
  provider_gt: xlayer_swap_Bytes
  provider_lt: xlayer_swap_Bytes
  provider_gte: xlayer_swap_Bytes
  provider_lte: xlayer_swap_Bytes
  provider_in: [xlayer_swap_Bytes!]
  provider_not_in: [xlayer_swap_Bytes!]
  provider_contains: xlayer_swap_Bytes
  provider_not_contains: xlayer_swap_Bytes
  tokenAmounts: [BigInt!]
  tokenAmounts_not: [BigInt!]
  tokenAmounts_contains: [BigInt!]
  tokenAmounts_contains_nocase: [BigInt!]
  tokenAmounts_not_contains: [BigInt!]
  tokenAmounts_not_contains_nocase: [BigInt!]
  fees: [BigInt!]
  fees_not: [BigInt!]
  fees_contains: [BigInt!]
  fees_contains_nocase: [BigInt!]
  fees_not_contains: [BigInt!]
  fees_not_contains_nocase: [BigInt!]
  invariant: BigInt
  invariant_not: BigInt
  invariant_gt: BigInt
  invariant_lt: BigInt
  invariant_gte: BigInt
  invariant_lte: BigInt
  invariant_in: [BigInt!]
  invariant_not_in: [BigInt!]
  lpTokenSupply: BigInt
  lpTokenSupply_not: BigInt
  lpTokenSupply_gt: BigInt
  lpTokenSupply_lt: BigInt
  lpTokenSupply_gte: BigInt
  lpTokenSupply_lte: BigInt
  lpTokenSupply_in: [BigInt!]
  lpTokenSupply_not_in: [BigInt!]
  lpTokenAmount: BigInt
  lpTokenAmount_not: BigInt
  lpTokenAmount_gt: BigInt
  lpTokenAmount_lt: BigInt
  lpTokenAmount_gte: BigInt
  lpTokenAmount_lte: BigInt
  lpTokenAmount_in: [BigInt!]
  lpTokenAmount_not_in: [BigInt!]
  balances: [BigInt!]
  balances_not: [BigInt!]
  balances_contains: [BigInt!]
  balances_contains_nocase: [BigInt!]
  balances_not_contains: [BigInt!]
  balances_not_contains_nocase: [BigInt!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: xlayer_swap_Bytes
  transaction_not: xlayer_swap_Bytes
  transaction_gt: xlayer_swap_Bytes
  transaction_lt: xlayer_swap_Bytes
  transaction_gte: xlayer_swap_Bytes
  transaction_lte: xlayer_swap_Bytes
  transaction_in: [xlayer_swap_Bytes!]
  transaction_not_in: [xlayer_swap_Bytes!]
  transaction_contains: xlayer_swap_Bytes
  transaction_not_contains: xlayer_swap_Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: xlayer_swap_BlockChangedFilter
  and: [xlayer_swap_StableSwapRemoveLiquidityEvent_filter]
  or: [xlayer_swap_StableSwapRemoveLiquidityEvent_filter]
}

enum xlayer_swap_StableSwapRemoveLiquidityEvent_orderBy {
  id
  stableSwap
  stableSwap__id
  stableSwap__isActive
  stableSwap__key
  stableSwap__canonicalId
  stableSwap__domain
  stableSwap__swapPool
  stableSwap__lpToken
  stableSwap__initialA
  stableSwap__futureA
  stableSwap__initialATime
  stableSwap__futureATime
  stableSwap__swapFee
  stableSwap__adminFee
  stableSwap__virtualPrice
  stableSwap__invariant
  stableSwap__lpTokenSupply
  provider
  tokenAmounts
  fees
  invariant
  lpTokenSupply
  lpTokenAmount
  balances
  block
  timestamp
  transaction
  nonce
}

input xlayer_swap_StableSwap_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  isActive: Boolean
  isActive_not: Boolean
  isActive_in: [Boolean!]
  isActive_not_in: [Boolean!]
  key: xlayer_swap_Bytes
  key_not: xlayer_swap_Bytes
  key_gt: xlayer_swap_Bytes
  key_lt: xlayer_swap_Bytes
  key_gte: xlayer_swap_Bytes
  key_lte: xlayer_swap_Bytes
  key_in: [xlayer_swap_Bytes!]
  key_not_in: [xlayer_swap_Bytes!]
  key_contains: xlayer_swap_Bytes
  key_not_contains: xlayer_swap_Bytes
  canonicalId: xlayer_swap_Bytes
  canonicalId_not: xlayer_swap_Bytes
  canonicalId_gt: xlayer_swap_Bytes
  canonicalId_lt: xlayer_swap_Bytes
  canonicalId_gte: xlayer_swap_Bytes
  canonicalId_lte: xlayer_swap_Bytes
  canonicalId_in: [xlayer_swap_Bytes!]
  canonicalId_not_in: [xlayer_swap_Bytes!]
  canonicalId_contains: xlayer_swap_Bytes
  canonicalId_not_contains: xlayer_swap_Bytes
  domain: BigInt
  domain_not: BigInt
  domain_gt: BigInt
  domain_lt: BigInt
  domain_gte: BigInt
  domain_lte: BigInt
  domain_in: [BigInt!]
  domain_not_in: [BigInt!]
  swapPool: xlayer_swap_Bytes
  swapPool_not: xlayer_swap_Bytes
  swapPool_gt: xlayer_swap_Bytes
  swapPool_lt: xlayer_swap_Bytes
  swapPool_gte: xlayer_swap_Bytes
  swapPool_lte: xlayer_swap_Bytes
  swapPool_in: [xlayer_swap_Bytes!]
  swapPool_not_in: [xlayer_swap_Bytes!]
  swapPool_contains: xlayer_swap_Bytes
  swapPool_not_contains: xlayer_swap_Bytes
  lpToken: xlayer_swap_Bytes
  lpToken_not: xlayer_swap_Bytes
  lpToken_gt: xlayer_swap_Bytes
  lpToken_lt: xlayer_swap_Bytes
  lpToken_gte: xlayer_swap_Bytes
  lpToken_lte: xlayer_swap_Bytes
  lpToken_in: [xlayer_swap_Bytes!]
  lpToken_not_in: [xlayer_swap_Bytes!]
  lpToken_contains: xlayer_swap_Bytes
  lpToken_not_contains: xlayer_swap_Bytes
  initialA: BigInt
  initialA_not: BigInt
  initialA_gt: BigInt
  initialA_lt: BigInt
  initialA_gte: BigInt
  initialA_lte: BigInt
  initialA_in: [BigInt!]
  initialA_not_in: [BigInt!]
  futureA: BigInt
  futureA_not: BigInt
  futureA_gt: BigInt
  futureA_lt: BigInt
  futureA_gte: BigInt
  futureA_lte: BigInt
  futureA_in: [BigInt!]
  futureA_not_in: [BigInt!]
  initialATime: BigInt
  initialATime_not: BigInt
  initialATime_gt: BigInt
  initialATime_lt: BigInt
  initialATime_gte: BigInt
  initialATime_lte: BigInt
  initialATime_in: [BigInt!]
  initialATime_not_in: [BigInt!]
  futureATime: BigInt
  futureATime_not: BigInt
  futureATime_gt: BigInt
  futureATime_lt: BigInt
  futureATime_gte: BigInt
  futureATime_lte: BigInt
  futureATime_in: [BigInt!]
  futureATime_not_in: [BigInt!]
  swapFee: BigInt
  swapFee_not: BigInt
  swapFee_gt: BigInt
  swapFee_lt: BigInt
  swapFee_gte: BigInt
  swapFee_lte: BigInt
  swapFee_in: [BigInt!]
  swapFee_not_in: [BigInt!]
  adminFee: BigInt
  adminFee_not: BigInt
  adminFee_gt: BigInt
  adminFee_lt: BigInt
  adminFee_gte: BigInt
  adminFee_lte: BigInt
  adminFee_in: [BigInt!]
  adminFee_not_in: [BigInt!]
  pooledTokens: [xlayer_swap_Bytes!]
  pooledTokens_not: [xlayer_swap_Bytes!]
  pooledTokens_contains: [xlayer_swap_Bytes!]
  pooledTokens_contains_nocase: [xlayer_swap_Bytes!]
  pooledTokens_not_contains: [xlayer_swap_Bytes!]
  pooledTokens_not_contains_nocase: [xlayer_swap_Bytes!]
  tokenPrecisionMultipliers: [BigInt!]
  tokenPrecisionMultipliers_not: [BigInt!]
  tokenPrecisionMultipliers_contains: [BigInt!]
  tokenPrecisionMultipliers_contains_nocase: [BigInt!]
  tokenPrecisionMultipliers_not_contains: [BigInt!]
  tokenPrecisionMultipliers_not_contains_nocase: [BigInt!]
  balances: [BigInt!]
  balances_not: [BigInt!]
  balances_contains: [BigInt!]
  balances_contains_nocase: [BigInt!]
  balances_not_contains: [BigInt!]
  balances_not_contains_nocase: [BigInt!]
  adminFees: [BigInt!]
  adminFees_not: [BigInt!]
  adminFees_contains: [BigInt!]
  adminFees_contains_nocase: [BigInt!]
  adminFees_not_contains: [BigInt!]
  adminFees_not_contains_nocase: [BigInt!]
  virtualPrice: BigInt
  virtualPrice_not: BigInt
  virtualPrice_gt: BigInt
  virtualPrice_lt: BigInt
  virtualPrice_gte: BigInt
  virtualPrice_lte: BigInt
  virtualPrice_in: [BigInt!]
  virtualPrice_not_in: [BigInt!]
  invariant: BigInt
  invariant_not: BigInt
  invariant_gt: BigInt
  invariant_lt: BigInt
  invariant_gte: BigInt
  invariant_lte: BigInt
  invariant_in: [BigInt!]
  invariant_not_in: [BigInt!]
  lpTokenSupply: BigInt
  lpTokenSupply_not: BigInt
  lpTokenSupply_gt: BigInt
  lpTokenSupply_lt: BigInt
  lpTokenSupply_gte: BigInt
  lpTokenSupply_lte: BigInt
  lpTokenSupply_in: [BigInt!]
  lpTokenSupply_not_in: [BigInt!]
  events_: xlayer_swap_StableSwapEvent_filter
  exchanges_: xlayer_swap_StableSwapExchange_filter
  hourlyVolumes_: xlayer_swap_SwapHourlyVolume_filter
  dailyVolumes_: xlayer_swap_SwapDailyVolume_filter
  weeklyVolumes_: xlayer_swap_SwapWeeklyVolume_filter
  """Filter for the block changed event."""
  _change_block: xlayer_swap_BlockChangedFilter
  and: [xlayer_swap_StableSwap_filter]
  or: [xlayer_swap_StableSwap_filter]
}

enum xlayer_swap_StableSwap_orderBy {
  id
  isActive
  key
  canonicalId
  domain
  swapPool
  lpToken
  initialA
  futureA
  initialATime
  futureATime
  swapFee
  adminFee
  pooledTokens
  tokenPrecisionMultipliers
  balances
  adminFees
  virtualPrice
  invariant
  lpTokenSupply
  events
  exchanges
  hourlyVolumes
  dailyVolumes
  weeklyVolumes
}

type xlayer_swap_SwapDailyVolume implements xlayer_swap_SwapTradeVolume {
  id: ID!
  stableSwap: xlayer_swap_StableSwap!
  timestamp: BigInt!
  volume: xlayer_swap_BigDecimal!
}

input xlayer_swap_SwapDailyVolume_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: xlayer_swap_StableSwap_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  volume: xlayer_swap_BigDecimal
  volume_not: xlayer_swap_BigDecimal
  volume_gt: xlayer_swap_BigDecimal
  volume_lt: xlayer_swap_BigDecimal
  volume_gte: xlayer_swap_BigDecimal
  volume_lte: xlayer_swap_BigDecimal
  volume_in: [xlayer_swap_BigDecimal!]
  volume_not_in: [xlayer_swap_BigDecimal!]
  """Filter for the block changed event."""
  _change_block: xlayer_swap_BlockChangedFilter
  and: [xlayer_swap_SwapDailyVolume_filter]
  or: [xlayer_swap_SwapDailyVolume_filter]
}

enum xlayer_swap_SwapDailyVolume_orderBy {
  id
  stableSwap
  stableSwap__id
  stableSwap__isActive
  stableSwap__key
  stableSwap__canonicalId
  stableSwap__domain
  stableSwap__swapPool
  stableSwap__lpToken
  stableSwap__initialA
  stableSwap__futureA
  stableSwap__initialATime
  stableSwap__futureATime
  stableSwap__swapFee
  stableSwap__adminFee
  stableSwap__virtualPrice
  stableSwap__invariant
  stableSwap__lpTokenSupply
  timestamp
  volume
}

type xlayer_swap_SwapHourlyVolume implements xlayer_swap_SwapTradeVolume {
  id: ID!
  stableSwap: xlayer_swap_StableSwap!
  timestamp: BigInt!
  volume: xlayer_swap_BigDecimal!
}

input xlayer_swap_SwapHourlyVolume_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: xlayer_swap_StableSwap_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  volume: xlayer_swap_BigDecimal
  volume_not: xlayer_swap_BigDecimal
  volume_gt: xlayer_swap_BigDecimal
  volume_lt: xlayer_swap_BigDecimal
  volume_gte: xlayer_swap_BigDecimal
  volume_lte: xlayer_swap_BigDecimal
  volume_in: [xlayer_swap_BigDecimal!]
  volume_not_in: [xlayer_swap_BigDecimal!]
  """Filter for the block changed event."""
  _change_block: xlayer_swap_BlockChangedFilter
  and: [xlayer_swap_SwapHourlyVolume_filter]
  or: [xlayer_swap_SwapHourlyVolume_filter]
}

enum xlayer_swap_SwapHourlyVolume_orderBy {
  id
  stableSwap
  stableSwap__id
  stableSwap__isActive
  stableSwap__key
  stableSwap__canonicalId
  stableSwap__domain
  stableSwap__swapPool
  stableSwap__lpToken
  stableSwap__initialA
  stableSwap__futureA
  stableSwap__initialATime
  stableSwap__futureATime
  stableSwap__swapFee
  stableSwap__adminFee
  stableSwap__virtualPrice
  stableSwap__invariant
  stableSwap__lpTokenSupply
  timestamp
  volume
}

interface xlayer_swap_SwapTradeVolume {
  stableSwap: xlayer_swap_StableSwap!
  timestamp: BigInt!
  volume: xlayer_swap_BigDecimal!
}

input xlayer_swap_SwapTradeVolume_filter {
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: xlayer_swap_StableSwap_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  volume: xlayer_swap_BigDecimal
  volume_not: xlayer_swap_BigDecimal
  volume_gt: xlayer_swap_BigDecimal
  volume_lt: xlayer_swap_BigDecimal
  volume_gte: xlayer_swap_BigDecimal
  volume_lte: xlayer_swap_BigDecimal
  volume_in: [xlayer_swap_BigDecimal!]
  volume_not_in: [xlayer_swap_BigDecimal!]
  """Filter for the block changed event."""
  _change_block: xlayer_swap_BlockChangedFilter
  and: [xlayer_swap_SwapTradeVolume_filter]
  or: [xlayer_swap_SwapTradeVolume_filter]
}

enum xlayer_swap_SwapTradeVolume_orderBy {
  stableSwap
  stableSwap__id
  stableSwap__isActive
  stableSwap__key
  stableSwap__canonicalId
  stableSwap__domain
  stableSwap__swapPool
  stableSwap__lpToken
  stableSwap__initialA
  stableSwap__futureA
  stableSwap__initialATime
  stableSwap__futureATime
  stableSwap__swapFee
  stableSwap__adminFee
  stableSwap__virtualPrice
  stableSwap__invariant
  stableSwap__lpTokenSupply
  timestamp
  volume
}

type xlayer_swap_SwapWeeklyVolume implements xlayer_swap_SwapTradeVolume {
  id: ID!
  stableSwap: xlayer_swap_StableSwap!
  timestamp: BigInt!
  volume: xlayer_swap_BigDecimal!
}

input xlayer_swap_SwapWeeklyVolume_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stableSwap: String
  stableSwap_not: String
  stableSwap_gt: String
  stableSwap_lt: String
  stableSwap_gte: String
  stableSwap_lte: String
  stableSwap_in: [String!]
  stableSwap_not_in: [String!]
  stableSwap_contains: String
  stableSwap_contains_nocase: String
  stableSwap_not_contains: String
  stableSwap_not_contains_nocase: String
  stableSwap_starts_with: String
  stableSwap_starts_with_nocase: String
  stableSwap_not_starts_with: String
  stableSwap_not_starts_with_nocase: String
  stableSwap_ends_with: String
  stableSwap_ends_with_nocase: String
  stableSwap_not_ends_with: String
  stableSwap_not_ends_with_nocase: String
  stableSwap_: xlayer_swap_StableSwap_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  volume: xlayer_swap_BigDecimal
  volume_not: xlayer_swap_BigDecimal
  volume_gt: xlayer_swap_BigDecimal
  volume_lt: xlayer_swap_BigDecimal
  volume_gte: xlayer_swap_BigDecimal
  volume_lte: xlayer_swap_BigDecimal
  volume_in: [xlayer_swap_BigDecimal!]
  volume_not_in: [xlayer_swap_BigDecimal!]
  """Filter for the block changed event."""
  _change_block: xlayer_swap_BlockChangedFilter
  and: [xlayer_swap_SwapWeeklyVolume_filter]
  or: [xlayer_swap_SwapWeeklyVolume_filter]
}

enum xlayer_swap_SwapWeeklyVolume_orderBy {
  id
  stableSwap
  stableSwap__id
  stableSwap__isActive
  stableSwap__key
  stableSwap__canonicalId
  stableSwap__domain
  stableSwap__swapPool
  stableSwap__lpToken
  stableSwap__initialA
  stableSwap__futureA
  stableSwap__initialATime
  stableSwap__futureATime
  stableSwap__swapFee
  stableSwap__adminFee
  stableSwap__virtualPrice
  stableSwap__invariant
  stableSwap__lpTokenSupply
  timestamp
  volume
}

type xlayer_swap_SystemInfo {
  id: ID!
  exchangeCount: BigInt!
  swapCount: BigInt!
}

input xlayer_swap_SystemInfo_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  exchangeCount: BigInt
  exchangeCount_not: BigInt
  exchangeCount_gt: BigInt
  exchangeCount_lt: BigInt
  exchangeCount_gte: BigInt
  exchangeCount_lte: BigInt
  exchangeCount_in: [BigInt!]
  exchangeCount_not_in: [BigInt!]
  swapCount: BigInt
  swapCount_not: BigInt
  swapCount_gt: BigInt
  swapCount_lt: BigInt
  swapCount_gte: BigInt
  swapCount_lte: BigInt
  swapCount_in: [BigInt!]
  swapCount_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: xlayer_swap_BlockChangedFilter
  and: [xlayer_swap_SystemInfo_filter]
  or: [xlayer_swap_SystemInfo_filter]
}

enum xlayer_swap_SystemInfo_orderBy {
  id
  exchangeCount
  swapCount
}

type xlayer_swap__Block_ {
  """The hash of the block"""
  hash: xlayer_swap_Bytes
  """The block number"""
  number: Int!
  """Integer representation of the timestamp stored in blocks for the chain"""
  timestamp: Int
  """The hash of the parent block"""
  parentHash: xlayer_swap_Bytes
}

"""The type for the top-level _meta field"""
type xlayer_swap__Meta_ {
  """
  Information about a specific subgraph block. The hash of the block
  will be null if the _meta field has a block constraint that asks for
  a block number. It will be filled if the _meta field has no block constraint
  and therefore asks for the latest  block
  
  """
  block: xlayer_swap__Block_!
  """The deployment ID"""
  deployment: String!
  """If `true`, the subgraph encountered indexing errors at some past block"""
  hasIndexingErrors: Boolean!
}